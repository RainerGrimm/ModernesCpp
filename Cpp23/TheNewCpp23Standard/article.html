<p>C++23 will be the next C++ standard after C++20. This new standard significantly improves C++ but is less game-changing than C++98, C++11, or C++20. C++23 is more in the tradition of C++17.</p>
<hr id="system-readmore" />
<p>&nbsp;</p>
<p>&nbsp;<img src="https://www.modernescpp.com/images/blog/Cpp23/TheNewCStandard/TimelineCpp.png" alt="" width="650" height="220" style="display: block; margin-left: auto; margin-right: auto;" data-alt="TimelineCpp" /></p>
<p>To understand this next step in the evolution of C++, let me put the C++ standards into the historical context.</p>
<h3 id="h0-1-the-c-standards">The C++ Standards</h3>
<div>&nbsp;</div>
<div>C++ is more than 40 years old. What happened in the last years? Here is a simplified answer ending in C++23.<br />
<h3 id="h0-2-c-98">C++98</h3>
<p>At the end of the 80ths, Bjarne Stroustrup and <span data-ved="0ahUKEwj1rL2Us6XlAhXDZlAKHV4_B1UQ2koIywEoAjAM">Margaret A. Ellis </span>wrote their famous book <a href="http://www.stroustrup.com/arm.html">Annotated C++ Reference Manual </a>(ARM). These books served two purposes. First, there were many independent C++ implementations. ARM defined, therefore, the functionality of C++. Second, ARM was the base for the first C++ standard: C++98 (ISO/IEC&nbsp;14882). C++98 had a few essential features: templates, the standard template library (STL) with its containers and algorithms, strings, and IO streams.</p>
<h3 id="h0-3-c-03">C++03</h3>
<p>With C++03 (14882:2003), C++98 got a technical correction that is so small that there is no place on my timeline. In the community, C++03, which includes C++98, is called legacy C++.&nbsp;</p>
<h3 id="h0-4-tr1">TR1</h3>
<p>In 2005 something exciting happened. The so-called technical report 1 (TR1; ) was published. TR1 was a big step toward C++11 and, therefore, toward Modern C++. TR1 (TR 19768) is based on the <a href="https://www.boost.org/">boost project</a> founded by members of the C++ standardization committee. TR1 has 13 libraries that should become part of the next C++ standard. For example, the library to the regular expression library, the random number library, smart pointers such as <code>std::shared_ptr</code>, and hashtables. Only the so-called special mathematic functions had to wait until C++17.</p>
<p>{loadmoduleid 157}</p>
<h3 id="h0-5-c-11">C++11</h3>
<p>C++11 is the next C++ standard, but we call it Modern C++. This name also includes C++14 and C++17. C++11 has many features which fundamentally changed the way we program C++.&nbsp; For example, C++11 brought the components of the TR1, but also move-semantic, perfect forwarding, variadic templates, or <code>constexpr</code>. But this is not all. With C++11, we got a memory model as the fundamental threading base and a threading API. If you are curious, here are my general posts on the <a href="https://www.modernescpp.com/index.php/category/multithreading-memory-model">memory model</a> and <a href="https://www.modernescpp.com/index.php/category/multithreading">multithreading</a>.</p>
<h3 id="h0-6-c-14">C++14</h3>
<p>C++14 is a small C++ standard. It brought read-writer locks, generalized lambdas, and generalized <code>constexpr</code> functions.</p>
<h3 id="h0-7-c-17">C++17</h3>
<p>C++17 is neither big nor small. It has two outstanding features: the parallel STL and the standardized filesystem. About 80 algorithms of the STL can be executed with a so-called execution policy. This means a call <code>std::sort(std::execute::par, vec.begin(), vec.end())</code> is a hint for the C++ implementation to sort the container <code>vec</code> parallelly. Additionally, you can specify that the sort should be done sequentially (<code>std::execution::seq</code>) or vectorized (<code>std::execution::par_unseq</code>). As for C++11, boost was also highly influential for C++17. We got the filesystem from boost and the three new data types: <code>std::optional, std::variant</code>, and <code>std::any</code>. Here are my posts on <a href="https://www.modernescpp.com/index.php/category/c-17">C++17</a>.</p>
<h3 id="h0-8-c-20">C++20</h3>
<p>C++20 changed the way we program C++ as fundamentally as C++11. This holds, in particular, for the big four: Ranges, Coroutines, Concepts, and Modules.</p>
<p>The new ranges library enables it to express algorithms directly on the container, compose the algorithm with the pipe symbol and apply them to infinite data streams.&nbsp;</p>
<p>Thanks to Coroutines, asynchronous programming in C++ may become mainstream. Coroutines are the base for cooperative tasks, event loops, infinite data streams, or pipelines.</p>
<p>Concepts will change the way we think and program templates. They are semantic categories for valid template arguments. They enable you to express your intention directly in the type of system. If something goes wrong, you will get a short error message.</p>
<p>Modules will overcome the restrictions of header files. They promise a lot. For example, the preprocessor becomes obsolete. Ultimately, we will also have faster build times and an easier way to build packages.</p>
<p>My posts about <a href="https://www.modernescpp.com/index.php/tag/ranges-library">ranges</a>, <a href="https://www.modernescpp.com/index.php/tag/coroutines">coroutines</a>, <a href="https://www.modernescpp.com/index.php/tag/concepts">concepts</a>,&nbsp;<a href="https://www.modernescpp.com/index.php/tag/modules">modules</a>, and <a href="https://www.modernescpp.com/index.php/category/c-20">C++20</a>.</p>
<h3>C++23</h3>
Currently (July 2023), C++23 is done and out for the final ballot.</div>
<div><br />C++23 offers with deducing this a small but very impactful feature of the core language. Deducing this allows you, similar to Python, to make the implicitly passed this pointer in a member function definition explicit. Thanks to deducing this, a few complex techniques in C++, such as CRTP or the Overload Pattern, will become a piece of cake.</div>
<div><br />The C++23 library will get many impactful additions. You can directly import the standard library with<code> import std;,</code> or apply the C++20 format string in<code> std::print</code> and<code> std::println</code>. Additionally, we will get flat associative containers such as <code><span style="font-family: courier new, courier;">std::flat_map</span></code> for performance reasons.<code> std::flap_map</code> is a drop-in replacement for <code>std::map</code>. <code>std::optional</code> interface is extended with a monadic interface for composability. The new data type <code>std::expected</code> already has a composable interface and can store an expected or an unexpected value for error handling. Thanks to <code>std::mdspan</code>, we will get a multidimensional span. Finally,<code> std::generator</code> is the first concrete coroutine for creating a stream of numbers. <code>std::generator</code> is part of the ranges library, which will also be improved in C++23.<br />
<h2>What's Next?</h2>
<p>In my next post, I will start my journey through C++23 with deducing this. Deducing this is a small but significant improvement in C++.</p>
<p>&nbsp;</p>
<p>{loadmoduleid 153}</p>
<p>&nbsp;</p>
</div>