<div class="vorspann">Mein letzter Artikel "<a alt="%7B%22text%22%3A%22C%2B%2B20%3A%20Coroutinen%20mit%20cppcoro%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-20-Coroutinen-mit-cppcoro-4705161.html%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-20-Coroutinen-mit-cppcoro-4705161.html%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%7D" href="https://www.heise.de/developer/artikel/C-20-Coroutinen-mit-cppcoro-4705161.html" title="Link auf https://www.heise.de/developer/artikel/C-20-Coroutinen-mit-cppcoro-4705161.html" class="">C++20: Coroutinen mit cppcoro</a>" gab einen ersten Einblick in die Coroutinen-Bibliothek von Lewis Baker. Dieser Einblick stellt die elementaren Coroutinen Tasks und Generatoren vor. Heute erweitere ich Tasks um Threads. Das Ergebnis sind mächtige Coroutinen.</div>
<div class="text">Kannst du dich an den Artikel "<a href="https://heise.de/-4701396" alt="%7B%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C%2B%2B20%3A%20Thread-Synchronisation%20mit%20Coroutinen%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4701396%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4701396%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%7D" title="Link auf https://heise.de/-4701396" class="">C++20: Thread-Synchronisation mit Coroutinen</a>" erinnern? Falls nicht, ich habe in dem Artikel die Herausforderungen von Bedingungsvariablen vorgestellt. Bedingungsvariablen sind die klassische Strategie, um Thread-Synchronisation wie Sender/Empfänger- oder Producer/Consumer-Arbeitsabläufe umzusetzen. Sie besitzen aber eine große Design-Schwäche. Der Empfänger kann eine vermeintliche Benachrichtigung vom Sender erhalten (spuious wakeup) oder der Empfänger kann die Benachrichtigung vom Sender überhören (lost wakeup). In beiden Fällen lauert ein Deadlock. Mein anschließendes Beispiel zur Thread-Synchronisation mit Coroutinen hatte zwar nicht das inhärente Risiko der Bedingungsvariablen wie Spurious Wakeup und Lost Wakeup. Dafür besaß die Lösung eine neue Unzulänglichkeit: Sie war viel zu kompliziert. </div>
<div class="text">Dank cppcoro lässt sich das Beste aus beiden Welten vereinen: ein einfacher Benachrichtigungsmechanismus, der nicht die Design-Schwächen der Bedingungsvariablen besitzt.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/8/5/3/7/4/TN_192607794_f081b9dcc8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">single_consumer_event<br></div>
<div class="text">Laut der Dokumentation von <a alt="%7B%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Flewissbaker%2Fcppcoro%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Flewissbaker%2Fcppcoro%22%2C%22text%22%3A%22cppcoro%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%7D" href="https://github.com/lewissbaker/cppcoro" title="Link auf https://github.com/lewissbaker/cppcoro" class="">cppcoro</a> ist ein <span class="tx_code">single_consumer_event</span> "a simple manual-reset event type that supports only a single coroutine awaiting it at a time". Das ist genau das, was ich benötige:</div>
<div class="pre">// cppcororProducerConsumer.cpp<br><br>#include &lt;cppcoro/single_consumer_event.hpp&gt;<br>#include &lt;cppcoro/sync_wait.hpp&gt;<br>#include &lt;cppcoro/task.hpp&gt;<br><br>#include &lt;future&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;thread&gt;<br>#include &lt;chrono&gt;<br><br>cppcoro::single_consumer_event event;&nbsp; <br><br>cppcoro::task&lt;&gt; consumer() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto start = std::chrono::high_resolution_clock::now();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; co_await event;&nbsp; // suspended until some thread calls event.set()<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto end = std::chrono::high_resolution_clock::now();<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; elapsed = end - start;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Consumer waited " &lt;&lt; elapsed.count() &lt;&lt; " seconds." &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; co_return;<br>}<br><br>void producer() {<br><br>&nbsp;&nbsp;&nbsp; using namespace std::chrono_literals;<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(2s);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; event.set();&nbsp; // resumes the consumer&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto con = std::async([]{ cppcoro::sync_wait(consumer()); });&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; auto prod = std::async(producer);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; con.get(), res.prod();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Das Beispiel sollte sich fast selbst erklären. Der Empfänger (Zeile 1) und der Sender (Zeile 2) laufen in ihrem eigenen Thread. Der Aufruf <span class="tx_code">cppcoro::sync_wait(consumer())</span> (Zeile 1) dient als startender Top-Level Task, da die <span class="tx_code">main</span>-Funktion keine Coroutine sein kann. Der Aufruf wartet, bis die Coroutine <span class="tx_code">consumer</span> fertig ist. Die Coroutine <span class="tx_code">consumer</span> wartet in dem Ausdruck <span class="tx_code">call co_await</span>, bis <span class="tx_code">event.set()</span> aufgerufen wird. Nachdem die Funktion <span class="tx_code">producer</span> zwei Sekunden geschlafen hat, sendet sie das notwendige Event. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/8/5/3/7/4/TN_192607802_6e90724658.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Dank der cppcoro-Bibliothek lassen sich Threads auch beenden.</div>
<div class="ztitel">Threads beenden</div>
<div class="text">Der Aufrufer und der Aufgerufene können mithilfe des <span class="tx_code">cppcoro::cancellation_token</span> kommunizieren. Die aufgerufene Funktion, die die Aufforderung an ihre Beendigung erhält, kann auf zwei Weisen interagieren:</div>
<div class="text"><ol><li> Sie frägt in regelmäßigen Zeitabständen, ob sie die Aufforderung für ihre Beendigung erhalten hat. Für diesen Ablauf bietet das&nbsp; <span class="tx_code">cppcoro::cancellation_token </span>zwei Methoden an: <span class="tx_code">is_cancellation_requested()</span> und <span class="tx_code">throw_if_cancellation_requested()</span>.</li><li>Sie registriert einen Callback, der bei einer Anfrage zur Beendigung ausgeführt wird.</li></ol></div>
<div class="text">Das folgende Programm stellt den ersten Anwendungsfall vor:</div>
<div class="pre">// cppcoroCancellation.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br>#include &lt;future&gt;<br><br>#include &lt;cppcoro/cancellation_token.hpp&gt;<br>#include &lt;cppcoro/cancellation_source.hpp&gt;<br><br>using namespace std::chrono_literals; <br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; cppcoro::cancellation_source canSource;<br>&nbsp;&nbsp;&nbsp; cppcoro::cancellation_token canToken = canSource.token();&nbsp; // (1)<br><br>&nbsp;&nbsp;&nbsp; auto cancelSender = std::async([&amp;canSource] { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(2s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; canSource.request_cancellation();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "canSource.request_cancellation() " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto cancelReceiver = std::async([&amp;canToken] { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Wait for cancellation request" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(200ms);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (canToken.is_cancellation_requested()) return;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; });<br><br>&nbsp;&nbsp;&nbsp; cancelSender.get(), cancelReceiver.get();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Zeile (1) zeigt das <span class="tx_code">cancellation_token</span>, das durch die <span class="tx_code">cancellation_source</span> erzeugt wurde. Der Aufrufer <span class="tx_code">cancelSender</span> erhält die <span class="tx_code">cancellation_source</span> und der Aufgerufene <span class="tx_code">cancelReceiver</span> das <span class="tx_code">cancellation_token</span>. Der Aufgerufene fragt permanent nach der Aufforderung zu seiner Beendigung nach (Zeile 2). Diese sendet der Aufrufer mittels&nbsp; <span class="tx_code">call.request_cancellation()</span> (Zeile 3) nach zwei Sekunden.</div>
<div class="text">Zwei interessante Beobachtungen möchte ich noch ergänzen:<br></div>
<div class="text"><ol><li> Die Beendigung ist kooperativ. Falls der Aufgerufene die Anfrage zu seiner Beendigung ignoriert, passiert nichts.</li><li>Mit C++20 erhalten wir auch einen verbesserten <span class="tx_code">std::thread</span>: <span class="tx_code">std::jthread</span>. Er ruft automatisch [code]join[/code] in seinem Destruktor auf und kann mit einem Interrupt-Token beendet werden. Mein Artikel "<a class="" title="Link auf https://heise.de/-4197595" href="https://heise.de/-4197595" alt="%7B%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4197595%22%2C%22text%22%3A%22Ein%20neuer%20Thread%20mit%20C%2B%2B20%3A%20std%3A%3Ajthread%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4197595%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%7D">Ein neuer Thread mit C++20: std::jthread</a>" bietet mehr Details zum <span class="tx_code">std::jthread</span> an.</li></ol></div>
<div class="text">cppcore besitzt auch Mutexe.</div>
<div class="ztitel">asnyc_mutex</div>
<div class="text">Ein Mutex wie <span class="tx_code">cppcoro::async_mutex</span> ist ein Synchronisationswerkzeug, um geteilte Daten vor dem gleichzeitigen Zugriff mehrerer Threads zu schützen:<br></div>
<div class="pre">// cppcoroMutex.cpp<br><br>#include &lt;cppcoro/async_mutex.hpp&gt;<br>#include &lt;cppcoro/sync_wait.hpp&gt;<br>#include &lt;cppcoro/task.hpp&gt;<br><br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br>#include &lt;vector&gt;<br><br><br>cppcoro::async_mutex mutex;<br><br>int sum{};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>cppcoro::task&lt;&gt; addToSum(int num) {<br>&nbsp;&nbsp;&nbsp; cppcoro::async_mutex_lock lockSum = co_await mutex.scoped_lock_async(); // (3)&nbsp; <br>&nbsp;&nbsp;&nbsp; sum += num;<br>&nbsp; <br>} // (4)<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::thread&gt; vec(10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for(auto&amp; thr: vec) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thr = std::thread([]{ for(int n = 0; n &lt; 10; ++n) cppcoro::sync_wait(addToSum(n)); } );<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for(auto&amp; thr: vec) thr.join();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sum: " &lt;&lt; sum &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">In der Zeile (1) werden zehn Threads erzeugt. Jeder Thread fügt die Zahlen 0 bis 9 zu der geteilten Summationsvariable <span class="tx_code">sum</span> (Zeile 2) hinzu. Die Funktion <span class="tx_code">addToSum</span> stellt die Coroutine dar. Die Coroutine wartet in dem Ausdruck <span class="tx_code">co_await mutex.scoped_lock()</span> (Zeile 3), bis sie den Mutex erhält. Die Coroutine, die auf den Mutex wartet, wird nicht blockiert, sondern schlafen gelegt. Der vorherige Besitzer des Mutex weckte in seinem <span class="tx_code">unlock</span>-Aufruf die Coroutine wieder auf. Wie es der Name vermuten lässt, bleibt der Mutex bis zum Ende seines Bereichs (Zeile 4) gelockt. </div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/8/5/3/7/4/TN_192607812_2d605ff018.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Dank der Funktion <span class="tx_code">cppcoro::when_all</span> kann nicht nicht nur auf eine, sondern auf mehrere Coroutinen gewartet werden. Ich wende <span class="tx_code">cppcoro::when_al</span><span class="tx_code">l</span> zusammen mit <span class="tx_code">cppcoro::static_thread_pool</span> in meinem nächsten Artikel an, um mächtige Arbeitsabläufe zu modellieren.<br></div>
