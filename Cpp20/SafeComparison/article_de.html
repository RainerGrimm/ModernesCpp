<div class="vorspann">Wenn vorzeichenbehaftete und vorzeichenlose Integrale verglichen werden, führt das häufig nicht zum gewünschten Ergebnis. Dank der sechs<span class="tx_code"> std::cmp_</span> *-Funktionen gibt es eine Heilung mit C++20.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/0/6/9/8/3/TN_202747941_75ddbe67b6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Eventuell erinnerst du dich an die Regel "<a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-mix" alt="%7B%22text%22%3A%22ES.100%20Don%27t%20mix%20signed%20and%20unsigned%20arithmetic%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-mix%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-mix%22%2C%22custom%22%3A%7B%7D%7D" class="" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-mix">ES.100 Don't mix signed and unsigned arithmetic</a>" der C++ Core Guidelines. Ich habe in dem früheren Artikel "<a title="Link auf https://heise.de/-3997787" alt="%7B%22href%22%3A%22https%3A%2F%2Fheise.de%2F-3997787%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-3997787%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Regeln%20zu%20Anweisungen%20und%20Arithmetik%22%7D" class="" href="https://heise.de/-3997787">C++ Core Guidelines: Regeln zu Anweisungen und Arithmetik</a>" ein wenig darüber geschrieben. Heute möchte ich mich deutlich tiefer mit dem Problem beschäftigen, wenn vorzeichenbehaftete und vorzeichenlose Integrale verglichen werden. </div>
<div class="text">Los geht es mit einem unsicheren Vergleich.</div>
<div class="ztitel">Unsicherer Vergleich von Integralen</div>
<div class="text">Natürlich hat es einen Grund, dass das folgende Programm <span class="tx_code">unsafeComparison.cpp</span> heißt: <br></div>
<div class="pre">// unsafeComparison.cpp<br><br>#include &lt;iostream&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br><br>&nbsp;&nbsp;&nbsp; int x = -3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; unsigned int y = 7;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "-3 &lt; 7:&nbsp; " &lt;&lt; (x &lt; y) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "-3 &lt;= 7: " &lt;&lt; (x &lt;= y) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "-3 &gt; 7:&nbsp; " &lt;&lt; (x &gt; y) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "-3 =&gt; 7: " &lt;&lt; (x &gt;= y) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; &nbsp;<br>}<br></div>
<div class="text">Das Ausführen des Programms birgt ein großes Überraschungspotenzial.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/0/6/9/8/3/TN_202747954_c99c385a82.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">-3 soll größer als 7 sein! Eventuell kennst du bereits das Problem. Ich vergleiche <span class="tx_code">signed int x</span> (Zeile (1)) mit <span class="tx_code">unsingned int y</span> (Zeile (2)). Was passiert unter der Decke? Das folgende Programm gibt die Antwort:</div>
<div class="pre">// unsafeComparison2.cpp<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; int x = -3;<br>&nbsp;&nbsp;&nbsp; unsigned int y = 7;<br><br>&nbsp;&nbsp;&nbsp; bool val = x &lt; y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; static_assert(static_cast&lt;unsigned int&gt;(-3) == 4'294'967'293);<br>}<br></div>
<div class="text">Im Beispiel fokussiere ich mich auf den Kleiner-als-Operator. C++ Insights gibt mir die folgende Ausgabe:<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/0/6/9/8/3/TN_202747960_c2a574524a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die folgenden Schritte zeigen das Unheil: <br></div>
<div class="text"><ol><li>Der Compiler transformiert den Ausdruck <span class="tx_code">x &lt; </span>y (Zeile (1)) in <span class="tx_code">static_cast&lt;unsigned int&gt;(x) &lt; y</span>. Insbesondere wird <span class="tx_code">signed int</span> in ein <span class="tx_code">unsigned int</span> konvertiert.</li><li>Dank der Konvertierung wird -3 zu 4'294'967'293.&nbsp;</li><li> 4'294'967'293 entspricht (-3) modulo (2 hoch32).</li><li>32 ist die Anzahl der Bits eines <span class="tx_code">unsigned int</span> auf C++ Insights.</li></ol></div>
<div class="text">Dank C++20 können wir jetzt sichere Vergleiche einsetzen.</div>
<div class="ztitel">Sichere Vergleiche für Integrale<br></div>
<div class="text">C++20 bietet sechs Vergleichsfunktionen für Integrale an.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/0/6/9/8/3/TN_202747967_e3985a9514.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Sie lassen es zu, das vorherige Programm <span class="tx_code">unsafeComparison.cpp</span> in das Programm <span class="tx_code">safeComparison.cpp</span> zu refaktorieren. Die neuen Vergleichsfunktionen benötigen die Header-Datei <span class="tx_code">&lt;utility</span><span class="tx_code">&gt;</span>. <br></div>
<div class="pre">// safeComparison.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;utility&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br><br>&nbsp;&nbsp;&nbsp; int x = -3;<br>&nbsp;&nbsp;&nbsp; unsigned int y = 7;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "3 == 7:&nbsp; " &lt;&lt; std::cmp_equal(x, y) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "3 != 7:&nbsp; " &lt;&lt; std::cmp_not_equal(x, y) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "-3 &lt; 7:&nbsp; " &lt;&lt; std::cmp_less(x, y) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "-3 &lt;= 7: " &lt;&lt; std::cmp_less_equal(x, y) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "-3 &gt; 7:&nbsp; " &lt;&lt; std::cmp_greater(x, y) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "-3 =&gt; 7: " &lt;&lt; std::cmp_greater_equal(x, y) &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; &nbsp;<br>}<br></div>
<div class="text">Ich habe der Vollständigkeit halber in dem Programm auch den Gleichheits- und Ungleichsoperator verwendet. Nun erhalte ich die erwartete Ausgabe:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/0/6/9/8/3/TN_202747974_3066fe99af.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Werden die Vergleichsfunktionen mit einem Nicht-Integral aufgerufen, moniert das der Compiler.</div>
<div class="pre">// safeComparison2.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;utility&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; double x = -3.5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; unsigned int y = 7;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "-3.5 &lt; 7:&nbsp; " &lt;&lt; std::cmp_less(x, y) &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Der Versuch einen <span class="tx_code">double</span>-Wert (Zeile (1)) mit einen<span class="tx_code"> unsigned in</span>tWert (Zeile (2)) zu vergleichen, gibt mit dem GCC-10-Compiler eine längliche Fehlermeldung. Hier sind die entscheidenden Zeilen der Fehlermeldung: <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/0/6/9/8/3/TN_202747980_0e777f4a0f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das interne Type-Trait <span class="tx_code">__is_standard_integer</span> führt zur Fehlermeldung. Nun bin ich neugierig: Wie ist das Type-Trait definiert? Ich habe es in der <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/std/type_traits" alt="%7B%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fgcc-mirror%2Fgcc%2Fblob%2Fmaster%2Flibstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fgcc-mirror%2Fgcc%2Fblob%2Fmaster%2Flibstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits%22%2C%22version%22%3A1%2C%22text%22%3A%22GCC-Type-TraitsImplementierung%20auf%20GitHub%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%7D" class="" title="Link auf https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/std/type_traits">GCC-Type-TraitsImplementierung auf GitHub</a> gefunden. Dies sind die wichtigen Zeilen aus der Header-Datei <span class="tx_code">&lt;type_traits&gt;</span>:<br></div>
<div class="pre">// Check if a type is one of the signed or unsigned integer types.<br>&nbsp; template&lt;typename _Tp&gt;<br>&nbsp;&nbsp;&nbsp; using __is_standard_integer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = __or_&lt;__is_signed_integer&lt;_Tp&gt;, __is_unsigned_integer&lt;_Tp&gt;&gt;;<br><br>// Check if a type is one of the signed integer types.<br>&nbsp; template&lt;typename _Tp&gt;<br>&nbsp;&nbsp;&nbsp; using __is_signed_integer = __is_one_of&lt;__remove_cv_t&lt;_Tp&gt;,<br>&nbsp;&nbsp; &nbsp;&nbsp; signed char, signed short, signed int, signed long,<br>&nbsp;&nbsp; &nbsp;&nbsp; signed long long<br><br>// Check if a type is one of the unsigned integer types.<br>&nbsp; template&lt;typename _Tp&gt;<br>&nbsp;&nbsp;&nbsp; using __is_unsigned_integer = __is_one_of&lt;__remove_cv_t&lt;_Tp&gt;,<br>&nbsp;&nbsp; &nbsp;&nbsp; unsigned char, unsigned short, unsigned int, unsigned long,<br>&nbsp;&nbsp; &nbsp;&nbsp; unsigned long long<br></div>
<div class="text"><span class="tx_code">__remove_cv_</span>t ist eine weitere interne Funktion des GCC, um <span class="tx_code">const</span> oder <span class="tx_code">volatile</span> von einem Datentyp zu entfernen. Ich denke, du bist auch neugierig und willst wissen, was passiert, wenn ein <span class="tx_code">double</span>-Wert mit einem <span class="tx_code">unsigned int</span>-Wert auf klassische Art verglichen wird.<br></div>
<div class="text">Das Programm <span class="tx_code">classicalComparison.cpp</span> vergleicht Datentypen, die nicht zusammenpassen:</div>
<div class="pre">// classicalComparison.cpp<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; double x = -3.5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int y = 7;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; auto res = x &lt; y;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp;&nbsp; &nbsp;<br>}<br></div>
<div class="text">Der Vergleich funktioniert. Der entscheidende Wert vom Typ <span class="tx_code">unsigned in</span>t ist dank <span class="tx_code">floating-point-</span>Promotion zu einem <span class="tx_code">double-</span>Wert geworden. C++ Insights bringt die Wahrheit ans Licht:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/0/6/9/8/3/TN_202747984_bb13a13f7d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:8 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Nach so vielen Vergleichen möchte ich diesen Artikel mit neuen mathematischen Konstanten in C++20 beenden. </div>
<div class="ztitel">Mathematische Konstanten</div>
<div class="text">Zuerst einmal verlangen die mathematischen Konstanten die Header-Datei <span class="tx_code">&lt;numbers&gt;</span> und den Namensraum <span class="tx_code">std::numbers</span>. Die zwei Tabellen stellen alle mathematischen Konstanten vor: </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/0/6/9/8/3/TN_202747993_868fe7a6b6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:9 type=2>" style="max-height: 25px; max-width: 25px;"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/0/6/9/8/3/TN_202747997_efef828361.png" title="<ir_inline itemname=bilder_mvp_bild_var2:10 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das Programm <span class="tx_code">mathematicConstants.cpp</span> wendet die Konstanten an:</div>
<div class="pre">// mathematicConstants.cpp<br><br>#include &lt;iomanip&gt;<br>#include &lt;iostream&gt;<br>#include &lt;numbers&gt;<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt; std::setprecision(10);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::numbers::e: " &lt;&lt;&nbsp; std::numbers::e &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::numbers::log2e: " &lt;&lt;&nbsp; std::numbers::log2e &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::numbers::log10e: " &lt;&lt;&nbsp; std::numbers::log10e &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::numbers::pi: " &lt;&lt;&nbsp; std::numbers::pi &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::numbers::inv_pi: " &lt;&lt;&nbsp; std::numbers::inv_pi &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::numbers::inv_sqrtpi: " &lt;&lt;&nbsp; std::numbers::inv_sqrtpi &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::numbers::ln2: " &lt;&lt;&nbsp; std::numbers::ln2 &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::numbers::sqrt2: " &lt;&lt;&nbsp; std::numbers::sqrt2 &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::numbers::sqrt3: " &lt;&lt;&nbsp; std::numbers::sqrt3 &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::numbers::inv_sqrt3: " &lt;&lt;&nbsp; std::numbers::inv_sqrt3 &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::numbers::egamma: " &lt;&lt;&nbsp; std::numbers::egamma &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::numbers::phi: " &lt;&lt;&nbsp; std::numbers::phi &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Dies ist die Ausgabe mit dem MSVC Compiler 19.27:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/0/6/9/8/3/TN_202748005_b17c093d96.png" title="<ir_inline itemname=bilder_mvp_bild_var2:11 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die mathematischen Konstanten gibt es für die Datentypen <span class="tx_code">float</span>, <span class="tx_code">double</span> und <span class="tx_code">long</span> <span class="tx_code">double</span>. Per default wird <span class="tx_code">double</span> als Datentyp verwendet. Der Datentyp <span class="tx_code">float</span> oder <span class="tx_code">long</span> <span class="tx_code">double</span> muss explizit gesetzt werden: <span class="tx_code">std::numbers::pi_v&lt;float&gt;</span> oder <span class="tx_code">std::numbers::pi_v&lt;long double&gt;</span>.</div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">C++20 bietet noch mehr praktische Funktionen an. Zum Beispiel lässt sich der Compiler anfragen, welche C++20-Features er bereits anbietet. Darüber hinaus erlaubt <span class="tx_code">std::bind_front</span> es, auf einfache Art Funktionsobjekte zu erzeugen. Dank <span class="tx_code">std::is_constant_evaluated</span> ist es möglich unterschiedliche Zweige des Codes zu prozessieren. Die Entscheidung hängt davon ab, ob die Funktion&nbsp; zur Compilezeit oder Laufzeit ausgeführt wird.<br></div>