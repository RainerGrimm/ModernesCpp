<div class="vorspann">In meinem letzten Artikel "<a title="Link auf https://heise.de/-6002597" alt="%7B%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Jobs%20starten%20mit%20Coroutinen%20in%20C%2B%2B20%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6002597%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6002597%22%2C%22user_params%22%3A%22%22%7D" href="https://heise.de/-6002597" class="">Jobs starten mit Coroutinen in C++20</a>" führte ich das neue Schlüsselwort <span class="tx_code">co_await</span> ein, um einen Job zu starten. In diesem Artikel werde ich den Arbeitsablauf verbessern und den Job automatisch auf einem separaten Thread vollenden, falls das notwendig ist.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/8/5/7/2/3/TN_209213294_a27cbf922c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das ist der siebte Artikel meiner Miniserie zu den neuen Schlüsselwörtern <span class="tx_code">co_return</span>, <span class="tx_code">co_yield</span> und <span class="tx_code">co_await</span>. Um das meiste aus meiner praktischen Einführung zu Coroutinen herauszuholen, ist ein Grundverständnis der bisherigen Artikel notwendig.<br></div>
<div class="text"><b>co_return</b></div>
<div class="text"><ul><li> <a title="Link auf https://heise.de/-5066861" alt="%7B%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5066861%22%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5066861%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Einfache%20Futures%20mit%20Coroutinen%20implementieren%22%2C%22target%22%3A%22_blank%22%7D" href="https://heise.de/-5066861" class="">Einfache Futures mit Coroutinen implementieren</a> </li><li> <a title="Link auf https://heise.de/-5073590" alt="%7B%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5073590%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5073590%22%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Lazy%20Futures%20mit%20Coroutinen%20in%20C%2B%2B20%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" href="https://heise.de/-5073590" class="">Lazy Futures mit Coroutinen in C++20</a></li><li> <a title="Link auf https://heise.de/-5987297" alt="%7B%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5987297%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5987297%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Mit%20Coroutinen%20einen%20Future%20in%20einem%20eigenen%20Thread%20ausf%C3%BChren%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" href="https://heise.de/-5987297" class="">Mit Coroutinen einen Future in einem eigenen Thread ausführen</a></li></ul></div>
<div class="text"><b>co_yield</b><br></div>
<div class="text"><ul><li><a title="Link auf https://heise.de/-5991142" alt="%7B%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5991142%22%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5991142%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Ein%20unendlicher%20Datenstrom%20dank%20Coroutinen%20in%20C%2B%2B20%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" href="https://heise.de/-5991142" class="">Ein unendlicher Datenstrom dank Coroutinen in C++20</a></li><li> <a title="Link auf https://heise.de/-5996757" alt="%7B%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5996757%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5996757%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Ein%20generischer%20Datenstrom%20mit%20Coroutinen%20in%20C%2B%2B20%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%7D" href="https://heise.de/-5996757" class="">Ein generischer Datenstrom mit Coroutinen in C++20</a></li></ul></div>
<div class="text"><b><span class="tx_code">co_await</span></b><br></div>
<div class="text"><ul><li> <a title="Link auf https://heise.de/-6002597" alt="%7B%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Jobs%20starten%20mit%20Coroutinen%20in%20C%2B%2B20%22%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6002597%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6002597%22%7D" href="https://heise.de/-6002597" class="">Jobs starten mit Coroutinen in C++20</a> <br></li></ul></div>
<div class="ztitel">Automatisches Fortsetzen des Jobs<br></div>
<div class="text">Im vorherigen Arbeitsablauf (<a title="Link auf https://heise.de/-6002597" alt="%7B%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Jobs%20starten%20mit%20Coroutinen%20in%20C%2B%2B20%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6002597%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6002597%22%7D" href="https://heise.de/-6002597" class="">Jobs starten mit Coroutinen in C++20</a>) habe ich den Awaiter-Arbeitsablauf detailliert vorgestellt und den Job explizit gestartet:<br></div>
<div class="pre">int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt;&nbsp; "Before job" &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; auto job = prepareJob();<br>&nbsp;&nbsp;&nbsp; job.start();<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt;&nbsp; "After job" &lt;&lt;&nbsp; '\n';<br><br>}</div>
<div class="text">Das direkte Aufrufen von <span class="tx_code">job.start()</span> war notwendig, denn <span class="tx_code">await_ready</span> des Awaitable <span class="tx_code">MySuspendAlways</span> gibt immer <span class="tx_code">false</span> zurück. Nun möchte ich annehmen, dass <span class="tx_code">await_ready</span> entweder <span class="tx_code">true</span> oder <span class="tx_code">false</span> zurückgeben kann und der Arbeitsablauf nicht explizit gestartet wird. Zur Erinnerung: Wenn <span class="tx_code">await_ready</span> <span class="tx_code">true</span> zurückgibt, wird die Funktion <span class="tx_code">await_resume</span> direkt aufgerufen, die Funktion <span class="tx_code">await_suspend</span> aber nicht ausgeführt:<br></div>
<div class="pre">// startJobWithAutomaticResumption.cpp<br><br>#include &lt;coroutine&gt;<br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;random&gt;<br><br>std::random_device seed;<br>auto gen = std::bind_front(std::uniform_int_distribution&lt;&gt;(0,1), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::default_random_engine(seed()));<br><br>struct MySuspendAlways {<br>&nbsp;&nbsp;&nbsp; bool await_ready() const noexcept { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MySuspendAlways::await_ready"&nbsp; &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return gen();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; bool await_suspend(std::coroutine_handle&lt;&gt; handle) const noexcept {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MySuspendAlways::await_suspend"&nbsp; &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle.resume();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br><br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; void await_resume() const noexcept {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MySuspendAlways::await_resume"&nbsp; &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>};<br>&nbsp;<br>struct Job { <br>&nbsp;&nbsp;&nbsp; struct promise_type;<br>&nbsp;&nbsp;&nbsp; using handle_type = std::coroutine_handle&lt;promise_type&gt;;<br>&nbsp;&nbsp;&nbsp; handle_type coro;<br>&nbsp;&nbsp;&nbsp; Job(handle_type h): coro(h){}<br>&nbsp;&nbsp;&nbsp; ~Job() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( coro ) coro.destroy();<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; struct promise_type {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto get_return_object() { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Job{handle_type::from_promise(*this)};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MySuspendAlways initial_suspend() { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp; Job prepared" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {}; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_always final_suspend() noexcept {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp; Job finished" &lt;&lt; '\n'; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {}; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void return_void() {}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void unhandled_exception() {}<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; };<br>};<br>&nbsp;<br>Job performJob() {<br>&nbsp;&nbsp;&nbsp; co_await std::suspend_never();<br>}<br>&nbsp;<br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt;&nbsp; "Before jobs" &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; performJob();<br>&nbsp;&nbsp;&nbsp; performJob();<br>&nbsp;&nbsp;&nbsp; performJob();<br>&nbsp;&nbsp;&nbsp; performJob();<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt;&nbsp; "After jobs" &lt;&lt;&nbsp; '\n';<br><br>}</div>
<div class="text">Zuerst einmal besitzt die Coroutine den Namen <span class="tx_code">performJob</span> und startet automatisch. Der Generator <span class="tx_code">gen</span> (Zeile 1) erzeugt Zufallszahlen mit den Werten 0 oder 1. Er verwendet den Standardzufallsgenerator, der mit einem Seed initialisiert wird. Dank <span class="tx_code">std::bind_front</span> lässt sich der Generator mit <span class="tx_code">std::uniform_int_distribution</span> verknüpfen, sodass dieser eine aufrufbare Einheit erzeugt, die auf Anfrage Zufallszahlen zwischen 0 und 1 erzeugt. Eine aufrufbare Einheit verhält sich wie eine Funktion. Das können nicht nur Funktionen, sondern auch Funktionsobjekte oder Lambda-Ausdrücke sein. Mehr zu der neuen Funktion <span class="tx_code">std::bind_front</span> lässt sich im Artikel "<a title="Link auf https://heise.de/-4930612" alt="%7B%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4930612%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4930612%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Noch%20mehr%20praktische%20Werkzeuge%20in%20C%2B%2B20%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://heise.de/-4930612" class="">Noch mehr praktische Werkzeuge in C++20</a>" nachlesen.&nbsp; </div>
<div class="text">In dem Beispiel habe ich mit Ausnahme des Awaitable <span class="tx_code">MySuspendAlways</span> die im C++-Standard vordefinierten Awaitables verwendet. <span class="tx_code">MySuspendAlways</span> kommt als Rückgabewert der Methode <span class="tx_code">initial_suspend</span> (Zeile 2) zum Einsatz. <span class="tx_code">await_ready</span> (Zeile 3) gibt einen Wahrheitswert zurück. Wenn dieser Wert <span class="tx_code">true</span> besitzt, springt der Kontrollfluss direkt zur Methode <span class="tx_code">await_resume</span> (Zeile 4). Wenn die Funktion <span class="tx_code">false</span> zurückgibt, wird die Coroutine sofort pausiert. Damit wird die Funktion <span class="tx_code">await_suspend </span>(Zeile 5) ausgeführt. Die Funktion <span class="tx_code">await_suspend</span> erhält den Verweis auf die Coroutine und verwendet diesen, um die Coroutine (Zeile 6) wieder aufzuwecken. Anstelle des Werts <span class="tx_code">true</span> kann <span class="tx_code">await_suspend</span> auch <span class="tx_code">void</span> zurückgeben.</div>
<div class="text">Der folgende Screenhot bringt es auf den Punkt: Wenn <span class="tx_code">await_ready</span> <span class="tx_code">true</span> zurückgibt, wird die Funktion <span class="tx_code">await_resume</span> aufgerufen; wenn <span class="tx_code">await_ready</span> <span class="tx_code">false</span> zurückgibt, wird die Funktion <span class="tx_code">await_suspend</span> ausgeführt.</div>
<div class="text">Die Programmausführung lässt sich schön mit dem <a title="Link auf https://godbolt.org/z/8b1Y14" alt="%7B%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2F8b1Y14%22%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2F8b1Y14%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Compiler%20Explorer%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D" href="https://godbolt.org/z/8b1Y14" class="">Compiler Explorer</a> visualisieren. <br></div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/8/5/7/2/3/TN_209213301_b6bf2311a6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Nun steht die nächste Verbesserung an. Der Awaiter sollte auf einem anderen Thread aufgeweckt werden und seinen Arbeitsablauf fortführen. <br></div>
<div class="ztitel">Automatisches Fortsetzen des Jobs auf einem eigenen Thread<br></div>
<div class="text">Das folgende Programm baut auf dem vorherigen auf:<br></div>
<div class="pre">// startJobWithResumptionOnThread.cpp<br><br>#include &lt;coroutine&gt;<br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;random&gt;<br>#include &lt;thread&gt;<br>#include &lt;vector&gt;<br><br>std::random_device seed;<br>auto gen = std::bind_front(std::uniform_int_distribution&lt;&gt;(0,1), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::default_random_engine(seed()));<br>&nbsp;<br>struct MyAwaitable {<br>&nbsp;&nbsp;&nbsp; std::jthread&amp; outerThread;<br>&nbsp;&nbsp;&nbsp; bool await_ready() const noexcept {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto res = gen();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (res) std::cout &lt;&lt; " (executed)" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else std::cout &lt;&lt; " (suspended)" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; void await_suspend(std::coroutine_handle&lt;&gt; h) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outerThread = std::jthread([h] { h.resume(); });<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; void await_resume() {}<br>};<br><br>&nbsp;<br>struct Job{<br>&nbsp;&nbsp;&nbsp; static inline int JobCounter{1};<br>&nbsp;&nbsp;&nbsp; Job() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++JobCounter;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; struct promise_type {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int JobNumber{JobCounter};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Job get_return_object() { return {}; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_never initial_suspend() { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp; Job " &lt;&lt; JobNumber &lt;&lt; " prepared on thread " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::this_thread::get_id();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {}; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_never final_suspend() noexcept { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp; Job " &lt;&lt; JobNumber &lt;&lt; " finished on thread " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {}; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void return_void() {}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void unhandled_exception() { }<br>&nbsp;&nbsp;&nbsp; };<br>};<br>&nbsp;<br>Job performJob(std::jthread&amp; out) {<br>&nbsp;&nbsp;&nbsp; co_await MyAwaitable{out};<br>}<br>&nbsp;<br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::jthread&gt; threads(8);<br>&nbsp;&nbsp;&nbsp; for (auto&amp; thr: threads) performJob(thr);<br><br>}</div>
<div class="text">Der Hauptunterschied zum vorherigen Programm besteht darin, dass das neue Awaitable <span class="tx_code">MyAwaitable</span> in der Coroutine <span class="tx_code">performJob</span> (Zeile 1) zum Einsatz kommt. Im Gegensatz dazu ist das Coroutinen-Objekt, das die Coroutine <span class="tx_code">performJob</span> zurückgibt, einfach gehalten. Im Wesentlichen geben die Methoden <span class="tx_code">inital_suspend</span> (Zeile 2) und <span class="tx_code">final_suspend</span> (Zeile 3) das vordefinierte Awaitable<span class="tx_code"> std::suspend_never</span> zurück. Zusätzlich stellen beide Funktionen die Jobnummer des ausgeführten Jobs und die Thread-Id des ausführenden Threads dar. Der Screenshot zeigt deutlich, welche Coroutine sofort ausgeführt und welche pausiert wird. Dank der Thread-Id lässt sich schön visualisieren, dass die pausierten Coroutinen auf einem anderen Thread aufgeweckt werden. <br></div>
<div class="text">Die Programmausführung lässt sich mithilfe der <a title="Link auf https://wandbox.org/permlink/skHgWKF0SYAwp8Dm" alt="%7B%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwandbox.org%2Fpermlink%2FskHgWKF0SYAwp8Dm%22%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwandbox.org%2Fpermlink%2FskHgWKF0SYAwp8Dm%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Wandbox%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D" href="https://wandbox.org/permlink/skHgWKF0SYAwp8Dm" class="">Wandbox</a> visualisieren:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/8/5/7/2/3/TN_209213309_30604c6505.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Gerne möchte ich auf den interessanten Arbeitsablauf des Programms genauer eingehen. Zeile 4 erzeugt acht Default-konstruierte Threads, die die Coroutine <span class="tx_code">performJob</span> (Zeile 5) mittels Referenz annehmen. Darüber hinaus wird die Referenz als Argument für <span class="tx_code">MyAwaitable{out}</span> verwendet. Abhängig vom Wert von <span class="tx_code">res</span> (Zeile 6), und damit abhängig vom Rückgabewert der Methode <span class="tx_code">await_ready</span>, wird die Coroutine (<span class="tx_code">res</span> ist <span class="tx_code">true</span>) weiter ausgeführt oder pausiert (<span class="tx_code">res</span> ist <span class="tx_code">false</span>). Im Fall, dass <span class="tx_code">MyAwaitable</span> pausiert wird, wird die Funktion <span class="tx_code">await_suspend</span> (Zeile 7) ausgeführt. Dank der Zuweisung von <span class="tx_code">outerThread</span> (Zeile 8) wird dieser zum ausgeführten Thread. Die Lebenszeit des ausgeführten Threads muss länger sein als die der Coroutine. Aus diesem Grund werden die Threads im Gültigkeitsbereich der <span class="tx_code">main</span>-Funktion angelegt. <br></div>
<div class="ztitel">Wie geht's weiter?<br></div>
<div class="text">Geschafft: Beinahe 100 Artikel habe ich zu C++20 verfasst. In meinem nächsten Artikel möchte das Thema C++20 abschließen und die folgende Frage beantworten: Wie geht es weiter mit C++? <br></div>