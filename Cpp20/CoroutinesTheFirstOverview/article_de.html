<div class="vorspann">C++20 bietet vier Features an, die die Art und Weise ändern, wie wir über C++ denken und es einsetzen: Concepts, die Ranges-Bibliothek, Coroutinen und Module. Zu den <a href="https://www.grimm-jaud.de/index.php/blog/tag/concepts" alt="%7B%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fconcepts%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fconcepts%22%2C%22version%22%3A1%2C%22text%22%3A%22Concepts%22%7D" class="" title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/concepts">Concepts</a> und der&nbsp;<a class="" href="https://www.grimm-jaud.de/index.php/blog/tag/ranges-bibliothek" alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Franges-bibliothek%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22%20Ranges-Bibliothek%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Franges-bibliothek%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/ranges-bibliothek"> Ranges-Bibliothek</a> habe ich schon einige Artikel verfasst. Dieser Artikel dient als Startpunkt, um in weiteren tiefer in die Coroutinen einzutauchen.</div>
<div class="text">Coroutinen sind Funktionen, deren Ausführung sich anhalten und wieder aufnehmen lässt. Dabei behalten sie ihren Zustand. Die Evolution der Funktionen in C++ geht damit einen Schritt weiter. Was ich als neue Idee in C++20 "verkaufe", ist tatsächlich schon sehr angestaubt. Auf <a class="" href="https://en.wikipedia.org/wiki/Melvin_Conway" alt="%7B%22text%22%3A%22Melvin%20Conway%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FMelvin_Conway%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FMelvin_Conway%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf https://en.wikipedia.org/wiki/Melvin_Conway">Melvin Conway</a> geht der Name Coroutine zurück. Er verwendet ihn 1963 in seiner Veröffentlichung zur Konstruktion eines Compilers. <a href="https://en.wikipedia.org/wiki/Donald_Knuth" alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDonald_Knuth%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Donald%20Knuth%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDonald_Knuth%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%7D" class="" title="Link auf https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a> bezeichnete Funktionen als einen Spezialfall von Coroutinen. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/6/5/8/9/5/TN_190860066_b0a4ff6d05.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="text">Die zwei neuen Schlüsselworte <span class="tx_code">co_await</span> und <span class="tx_code">co_yield</span> erweitern die Ausführung von Funktionen um zwei neue Ideen:</div>
<div class="text"><ul><li> Dank <span class="tx_code">co_await expression</span> ist es möglich, die Ausführung einer Funktion anzuhalten und wieder aufzunehmen. Wenn du <span class="tx_code">co_await expression</span> in einer Funktion <span class="tx_code">func</span> verwendest, blockiert der Aufruf <span class="tx_code">getResult = func()</span> nicht, falls das Ergebnis noch nicht zur Verfügung steht. Damit wird ein ressourcenintensives Blocken zu einem ressourcenfreundlichen Warten. <br></li><li><span class="tx_code">co_yield expression</span> erlaubt es, eine Generatorfunktion zu schreiben. Diese gibt bei jedem Aufruf einen Wert zurück. Eine solche Funktion ist eine Art Datenstrom, von dem sich sukzessive Werte auslesen lassen. Dieser Datenstrom kann auch unendlich sein. Jetzt befinden wir uns mitten in der Bedarfsauswertung (lazy evaluation).</li></ul></div>
<div class="text">Bevor ich zum Einstieg eine Generatorfunktion vorstellen möchte, um die Unterschiede einer Funktion und Coroutine auf den Punkt zu bringen, möchte ich mit ein paar Worten auf die Evolution von Funktionen eingehen.</div>
<div class="utitel">Evolution von Funktionen<br></div>
<div class="text">Das folgende Programm zeigt in vereinfachender Form die verschiedenen Stufen in der Evolution einer Funktion:</div>
<div class="pre">// functionEvolution.cpp<br><br>int func1() {<br>&nbsp;&nbsp;&nbsp; return 1972;<br>}<br><br>int func2(int arg) {<br>&nbsp;&nbsp;&nbsp; return arg;<br>}<br><br>double func2(double arg) {<br>&nbsp;&nbsp;&nbsp; return arg;<br>}<br><br>template &lt;typename T&gt;<br>int func3(T arg) {<br>&nbsp;&nbsp;&nbsp; return arg;<br>}<br><br>struct FuncObject4 {<br>&nbsp;&nbsp;&nbsp; int operator()() { // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1998;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>auto func5 = [] {<br>&nbsp;&nbsp;&nbsp; return 2011;<br>};<br><br>auto func6 = [] (auto arg){<br>&nbsp;&nbsp;&nbsp; return arg;<br>};<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; func1();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1972<br><br>&nbsp;&nbsp;&nbsp; func2(1998);&nbsp;&nbsp;&nbsp; // 1998<br>&nbsp;&nbsp;&nbsp; func2(1998.0);&nbsp; // 1998.0<br>&nbsp;&nbsp;&nbsp; func3(1998);&nbsp;&nbsp;&nbsp; // 1998<br>&nbsp;&nbsp;&nbsp; func3(1998.0);&nbsp; // 1998.0<br>&nbsp;&nbsp;&nbsp; FuncObject4 func4;<br>&nbsp;&nbsp;&nbsp; func4();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1998<br><br>&nbsp;&nbsp;&nbsp; func5();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2011<br><br>&nbsp;&nbsp;&nbsp; func6(2014);&nbsp;&nbsp;&nbsp; // 2014<br>&nbsp;&nbsp;&nbsp; func6(2014.0);&nbsp; // 2014<br><br>}&nbsp;&nbsp; <br></div>
<div class="text"><ul><li>Seit dem ersten C-Standard (1972) kennen wir Funktionen: <span class="tx_code">func1</span>.</li><li>Mit dem ersten C++-Standard (1998) wurden Funktionen deutlich mächtiger:&nbsp; <ul><li>Überladen von Funktionen: <span class="tx_code">func2</span>.</li><li>Funktions-Templates: <span class="tx_code">func3</span>.</li><li>Funktionsobjekte: <span class="tx_code">func4</span>. Diese werden gerne fälschlicherweise Funktoren genannt. Sie sind dank des überladenen Aufrufoperators (<span class="tx_code">operator ()</span>) Objekte, die sich aufrufen lassen. Das zweite Paar runder Klammern in der Zeile (1) steht für die Funktionsparameter.</li></ul> </li><li>C++11 führte zur Erweiterung um Lambda-Funktionen: <span class="tx_code">func5</span>.</li><li>Mit C++14 können Lambda-Funktionen generisch sein: <span class="tx_code">func6</span>. <br></li></ul></div>
<div class="text">Jetzt geht die Evolution einen Schritt weiter. Generatoren sind spezielle Coroutinen.</div>
<div class="ztitel">Generatoren</div>
<div class="text">Im klassischem C++ lässt sich ein gieriger (greedy) Generator implementieren.</div>
<div class="ztitel_kleiner">Ein gieriger Generator</div>
<div class="text">Das folgende Programm ist so einfach wie möglich gehalten. Die Funktion <span class="tx_code">getNumbers</span> gibt alle Zahlen von <span class="tx_code">begin</span> bis <span class="tx_code">end</span> um <span class="tx_code">inc</span> inkrementiert zurück. <span class="tx_code">begin</span> muss kleiner als <span class="tx_code">end</span> und <span class="tx_code">inc</span> positiv sein:</div>
<div class="pre">// greedyGenerator.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>std::vector&lt;int&gt; getNumbers(int begin, int end, int inc = 1) {<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; numbers;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; for (int i = begin; i &lt; end; i += inc) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numbers.push_back(i);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; return numbers;<br>&nbsp; <br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; const auto numbers= getNumbers(-10, 11);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; for (auto n: numbers) std::cout &lt;&lt; n &lt;&lt; " ";<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp;&nbsp;&nbsp; for (auto n: getNumbers(0, 101, 5)) std::cout &lt;&lt; n &lt;&lt; " ";<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>}</div>
<div class="text">Ich muss zugeben, dass ich mit <span class="tx_code">getNumbers</span> das Rad nicht neu erfinde, denn die Funktion <span class="tx_code"><a alt="%7B%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Falgorithm%2Fiota%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Falgorithm%2Fiota%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22std%3A%3Aiota%22%7D" href="https://en.cppreference.com/w/cpp/algorithm/iota" class="" title="Link auf https://en.cppreference.com/w/cpp/algorithm/iota">std::iota</a></span> existiert genau für diese Aufgabe. Die Ausgabe des Programms sollte keine Überraschung bergen:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/6/5/8/9/5/TN_190860073_6e36a68e5e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Zwei Beobachtungen zum Programm sind entscheidend. Zum einen enthält der Vektor <span class="tx_code">numbers</span> in Zeile (1) immer alle Werte. Das gilt selbst dann, wenn ich nur an den ersten fünf Elementen eines Vektors mit 1000 Elementen interessiert bin. Zum anderen lässt sich die Funktion einfach in einen faulen (lazy) Generator transfomieren. </div>
<div class="ztitel_kleiner">Ein "lazy" Generator</div>
<div class="text">Dies ist bereits der Generator, der Bedarfsauswertung umsetzt:</div>
<div class="pre">// lazyGenerator.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>generator&lt;int&gt; generatorForNumbers(int begin, int inc = 1) {<br>&nbsp; <br>&nbsp; for (int i = begin;; i += inc) {<br>&nbsp;&nbsp;&nbsp; co_yield i;<br>&nbsp; }<br>&nbsp; <br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; const auto numbers= generatorForNumbers(-10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; for (int i= 1; i &lt;= 20; ++i) std::cout &lt;&lt; numbers &lt;&lt; " ";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (auto n: generatorForNumbers(0, 5)) std::cout &lt;&lt; n &lt;&lt; " ";&nbsp; // (3)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>}</div>
<div class="text">Während die Funktion <span class="tx_code">getNumbers</span> in der Datei <span class="tx_code">greedGenerator</span>.<span class="tx_code">cpp</span> einen <span class="tx_code">std::vector</span> zurückgibt, gibt die Coroutine <span class="tx_code">generatorForNumbers</span> in <span class="tx_code">lazyGeneraror</span>.<span class="tx_code">cpp</span> einen Generator zurück. Die Generatoren <span class="tx_code">numbers</span> in Zeile (2) oder <span class="tx_code">generatorForNumbers</span>(<span class="tx_code">0, 5)</span> in Zeile (3) geben wiederum auf Anfrage neue Werte zurück. Die range-basierte for-Schleife stößt diese Anfrage an. Um es genauer auszudrücken: Die Anfrage an die Coroutine gibt den Wert <span class="tx_code">i</span> mittels <span class="tx_code">co_yield i</span> zurück und legt sich dann schlafen. Falls ein neuer Wert angefordert wird, wird die Coroutine aufgeweckt und setzt ihre Ausführung genau an dieser Stelle fort.</div>
<div class="text">Der Ausdruck<span class="tx_code"> generatorForNumbers(0, 5)</span> in Zeile (3) stellt eine direkte Verwendung des Generators dar. Einen Punkt möchte ich explizit hervorheben. Die Coroutine <span class="tx_code">generatorForNumbers</span> erzeugt einen unendlichen Datenstrom, denn die [code]for[/code]-Schleife besitzt keine Endbedingung. Ein unendlicher Datenstrom ist sinnvoll, wenn ich nur endlich viele Elemente wie in Zeile (4) anfordere. Das gilt nicht für die Zeile (3), da sie keine Endbedingung besitzt. Konsequenterweise beendet sich diese Schleife nie.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Mit C++20 erhalten wir keine konkreten Coroutinen, sondern ein Framework für die Implementierung von Coroutinen. Du kannst dir denken, dass ich dazu einiges zu schreiben habe.</div>
<div class="ztitel">In eigener Sache: First Virtual Meetup</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/6/5/8/9/5/TN_190860078_fa2f0764b8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=1>" style="max-height: 25px; max-width: 25px;">Ich freue mich, dass wir es kurzfristig geschafft haben, meinen Vortrag für die Münchner C++ User Group zu virtualisieren. Hier ist die offizielle Einladung zu dem englischen Vortrag:<br></div>
<div class="text"><span class="css-901oao css-16my406 r-1qd0xha r-ad9z0x r-bcqeeo r-qvutc0">"Help us fight social isolation and join us next Thursday for our first-ever virtual meetup! <a class="" href="https://twitter.com/rainer_grimm" alt="%7B%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Ftwitter.com%2Frainer_grimm%22%2C%22text%22%3A%22%40rainer_grimm%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Ftwitter.com%2Frainer_grimm%22%2C%22alias%22%3A%22%22%7D" title="Link auf https://twitter.com/rainer_grimm">@rainer_grimm</a> will be talking about Concepts in C++20. March 26, 19:00 (CET).</span></div>
<div class="text"><span class="css-901oao css-16my406 r-1qd0xha r-ad9z0x r-bcqeeo r-qvutc0">Check out the full event description at <a title="Link auf https://www.meetup.com/de-DE/MUCplusplus/events/269530229/" alt="%7B%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.meetup.com%2Fde-DE%2FMUCplusplus%2Fevents%2F269530229%2F%22%2C%22text%22%3A%22meetup.com%2FMUCplusplus%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.meetup.com%2Fde-DE%2FMUCplusplus%2Fevents%2F269530229%2F%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%7D" href="https://www.meetup.com/de-DE/MUCplusplus/events/269530229/" class="">meetup.com/MUCplusplus</a>. The stream is open for everyone, you don't need to register on meetup for this one."</span></div>
