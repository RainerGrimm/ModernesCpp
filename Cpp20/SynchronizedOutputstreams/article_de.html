<div class="vorspann">Was passiert, wenn unsynchronisiert auf std::cout geschrieben wird? Ein vollkommenes Durcheinander. Das muss mit C++20 nicht mehr sein.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/6/0/4/2/2/TN_207151024_2c87fa86ba.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Bevor ich die synchronisierten Ausgabe-Streams in C++20 vorstelle, möchte auf die nicht synchronisierte Ausgabe in C++11 eingehen:</div>
<div class="pre">// coutUnsynchronized.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>class Worker{<br>public:<br>&nbsp; Worker(std::string n):name(n) {};<br>&nbsp;&nbsp;&nbsp; void operator() (){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 1; i &lt;= 3; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // begin work<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(200));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // end work<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; name &lt;&lt; ": " &lt;&lt; "Work " &lt;&lt; i &lt;&lt; " done !!!" &lt;&lt; '\n'; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp; std::string name;<br>};<br><br><br>int main() {<br><br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "Boss: Let's start working.\n\n";<br>&nbsp;<br>&nbsp; std::thread herb= std::thread(Worker("Herb"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; std::thread andrei= std::thread(Worker("&nbsp; Andrei"));<br>&nbsp; std::thread scott= std::thread(Worker("&nbsp;&nbsp;&nbsp; Scott"));<br>&nbsp; std::thread bjarne= std::thread(Worker("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bjarne"));<br>&nbsp; std::thread bart= std::thread(Worker("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bart"));<br>&nbsp; std::thread jenne= std::thread(Worker("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Jenne"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; <br>&nbsp; <br>&nbsp; herb.join();<br>&nbsp; andrei.join();<br>&nbsp; scott.join();<br>&nbsp; bjarne.join();<br>&nbsp; bart.join();<br>&nbsp; jenne.join();<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "\n" &lt;&lt; "Boss: Let's go home." &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>}<br></div>
<div class="text">Der Boss beschäftigt sechs Arbeiter (Zeile 1 bis 2). Jeder Arbeiter muss drei Arbeitspakete erledigen, die jeweils eine 1/5 Sekunde benötigen (Zeile 3). Nachdem ein Arbeiter mit einem Arbeitspaket fertig ist, schreit er seinen Namen laut heraus (Zeile 4). Wenn der Boss alle Benachrichtigungen von allen Arbeitern erhalten hat, schickt er seine Truppe (Zeile 5) nach Hause. Was für ein Durcheinander für solch einen einfachen Arbeitsablauf! Jeder Arbeiter schreit seine Nachricht heraus und ignoriert dabei seine Kollegen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/6/0/4/2/2/TN_207151028_486805d87c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text"><ul><li><span class="tx_code">std::cout</span><b> ist Thread-sicher</b>: Der C++11-Standard garantiert, dass du <span class="tx_code">std::cout</span> nicht schützen musst. Jeder Buchstaben wird atomar geschrieben. Mehrere Ausgabeoperationen wie im Beispiel können sich natürlich vermischen. Dieses Vermischen ist aber nur ein optisches Problem: Das Programm ist wohl definiert. Diese Aussage gilt für die globalen Stream-Objekte. Das Einfügen oder die Entnahme von den globalen Stream-Objekten (<span class="tx_code">std::cout</span>, <span class="tx_code">std::cin</span>, <span class="tx_code">std::cerr</span> und <span class="tx_code">std::clog</span>) ist Thread-sicher. Fomaler ausgedrückt: Schreiben auf <span class="tx_code">std::cout</span> stellt kein Data Race, sondern eine Race Condition dar. In meinem Artikel "<a title="Link auf https://www.heise.de/developer/artikel/Race-Conditions-versus-Data-Races-3717884.html" alt="%7B%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22text%22%3A%22Race%20Conditions%20versus%20Data%20Races%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FRace-Conditions-versus-Data-Races-3717884.html%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FRace-Conditions-versus-Data-Races-3717884.html%22%2C%22version%22%3A1%2C%22target%22%3A%22%22%7D" href="https://www.heise.de/developer/artikel/Race-Conditions-versus-Data-Races-3717884.html" class="">Race Conditions versus Data Races</a>" gehe ich genauer auf die beiden Begriffe ein. <br></li></ul></div>
<div class="text">Wie lässt sich das Problem beseitigen? Mit C++11 ist die Antwort einfach: Setze einen Lock wie <span class="tx_code">std::lock_guard</span> ein, um synchronisiert auf <span class="tx_code">std::cout</span> zu schreiben. Mehr Informationen zu Lock in C++11 bietet mein Artikel "<a title="Link auf https://www.grimm-jaud.de/index.php/blog/verklemmungen-loesen" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fverklemmungen-loesen%22%2C%22text%22%3A%22Locks%20statt%20Mutexe%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fverklemmungen-loesen%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%7D" href="https://www.grimm-jaud.de/index.php/blog/verklemmungen-loesen" class="">Locks statt Mutexe</a>". <br></div>
<div class="pre">// coutSynchronized.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br>#include &lt;mutex&gt;<br>#include &lt;thread&gt;<br><br>std::mutex coutMutex;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>class Worker{<br>public:<br>&nbsp; Worker(std::string n):name(n) {};<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; void operator() (){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 1; i &lt;= 3; ++i) { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // begin work<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(200));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // end work<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; coutLock(coutMutex);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; name &lt;&lt; ": " &lt;&lt; "Work " &lt;&lt; i &lt;&lt; " done !!!" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp; std::string name;<br>};<br><br><br>int main() {<br><br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "Boss: Let's start working." &lt;&lt; "\n\n";<br>&nbsp;<br>&nbsp; std::thread herb= std::thread(Worker("Herb"));<br>&nbsp; std::thread andrei= std::thread(Worker("&nbsp; Andrei"));<br>&nbsp; std::thread scott= std::thread(Worker("&nbsp;&nbsp;&nbsp; Scott"));<br>&nbsp; std::thread bjarne= std::thread(Worker("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bjarne"));<br>&nbsp; std::thread bart= std::thread(Worker("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bart"));<br>&nbsp; std::thread jenne= std::thread(Worker("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Jenne"));<br>&nbsp; <br>&nbsp; herb.join();<br>&nbsp; andrei.join();<br>&nbsp; scott.join();<br>&nbsp; bjarne.join();<br>&nbsp; bart.join();<br>&nbsp; jenne.join();<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "\n" &lt;&lt; "Boss: Let's go home." &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div>
<div class="text">Der <span class="tx_code">coutMutex</span> in Zeile 1 schützt das geteilte Objekt <span class="tx_code">std::cout</span>. Indem der <span class="tx_code">coutMutex</span> in einen <span class="tx_code">std::lock_guard</span> gesteckt wird, ist sichergestellt, dass der Mutex im Konstruktor (Zeile 2) gelockt und im Destruktor (Zeile 3) des <span class="tx_code">std::lock_guard</span> freigegeben wird. Dank des <span class="tx_code">coutMutex</span>, den <span class="tx_code">coutLock</span> verwaltet, löst sich das vollkommene Durcheinander in Harmonie auf. <br></div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/6/0/4/2/2/TN_207151036_3226df257d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Mit C++20 wird das synchronisierte Schreiben auf <span class="tx_code">std::cout</span> zum Kinderspiel.<span class="tx_code"> std::basic_syncbuf </span>ist ein Wrapper für <span class="tx_code">std::basic_streambuf</span>. Dieser Wrapper häuft seine Ausgabe in einem Puffer an und schreibt seinen Inhalt, wenn er destruiert wird. Konsequenterweise erscheint der Inhalt als kontinuierliche Sequenz von Buchstaben, sodass kein Durcheinander mehr möglich ist.</div>
<div class="text">Dank <span class="tx_code">std::basic_osyncstream</span> ist es möglich, direkt synchronisiert auf <span class="tx_code">std::cout</span> zu schreiben, indem ein synchronisierter Ausgabestream zum Einsatz kommt.</div>
<div class="text">Das folgende Programm basiert auf dem vorherigen Programm <span class="tx_code">coutUnsynchronized.cpp</span>. Zum jetzigen Zeitpunkt unterstützt lediglich GCC 11 synchronisierte Ausgabe-Streams:</div>
<div class="pre">// synchronizedOutput.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br>#include &lt;syncstream&gt;<br>#include &lt;thread&gt;<br><br>class Worker{<br>public:<br>&nbsp; Worker(std::string n): name(n) {};<br>&nbsp;&nbsp;&nbsp; void operator() (){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 1; i &lt;= 3; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // begin work<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(200));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // end work<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::osyncstream syncStream(std::cout);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syncStream &lt;&lt; name &lt;&lt; ": " &lt;&lt; "Work " &lt;&lt; i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; " done !!!" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp; std::string name;<br>};<br><br><br>int main() {<br><br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "Boss: Let's start working.\n\n";<br>&nbsp;<br>&nbsp; std::thread herb= std::thread(Worker("Herb"));<br>&nbsp; std::thread andrei= std::thread(Worker("&nbsp; Andrei"));<br>&nbsp; std::thread scott= std::thread(Worker("&nbsp;&nbsp;&nbsp; Scott"));<br>&nbsp; std::thread bjarne= std::thread(Worker("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bjarne"));<br>&nbsp; std::thread bart= std::thread(Worker("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bart"));<br>&nbsp; std::thread jenne= std::thread(Worker("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Jenne"));<br>&nbsp; <br>&nbsp; <br>&nbsp; herb.join();<br>&nbsp; andrei.join();<br>&nbsp; scott.join();<br>&nbsp; bjarne.join();<br>&nbsp; bart.join();<br>&nbsp; jenne.join();<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "\n" &lt;&lt; "Boss: Let's go home." &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>}</div>
<div class="text">Der einzige Unterschied zum vorherigen Programm <span class="tx_code">coutUnsynchronized.cpp</span> ist, dass <span class="tx_code">std::cout</span> in einem <span class="tx_code">std::osyncstream</span> (Zeile 1) enthalten ist. Wenn der <span class="tx_code">std::osyncstream</span> seinen Gültigkeitsbereich in Zeile (2) verlässt, werden seine Buchstaben übertragen und <span class="tx_code">std::cout</span> wird geleert. Ich möchte betonen, dass der Aufruf von <span class="tx_code">std::cout</span> im <span class="tx_code">main</span>-Program kein Data Race darstellt und damit nicht synchronisiert werden muss. Die Ausgaben finden vor oder nach der Ausgabe der Threads statt.</div>
<div class="text">Da ich den <span class="tx_code">syncStream</span> (Zeile 3) nur einmal verwende, ist ein temporäres Objekt in diesem Fall angebrachter. Das folgende Codebeispiel stellt den angepassten Aufruf-Operator vor:</div>
<div class="pre">void operator()() {<br>&nbsp; for (int i = 1; i &lt;= 3; ++i) { <br>&nbsp;&nbsp;&nbsp; // begin work<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(200));<br>&nbsp;&nbsp;&nbsp; // end work<br>&nbsp;&nbsp;&nbsp; std::osyncstream(std::cout) &lt;&lt; name &lt;&lt; ": " &lt;&lt; "Work " &lt;&lt; i &lt;&lt; " done !!!" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; '\n';<br>&nbsp; }<br>}</div>
<div class="text"><span class="tx_code">std::basic_osyncstream syncStream</span> bietet zwei interessante Methoden an: </div>
<div><ul><li><span class="tx_code">syncStream.emit()</span> gibt die gepufferte Ausgabe aus.</li><li><span class="tx_code">syncStream.get_wrapped()</span> gibt einen Zeiger auf den gewrappten Puffer zurück.</li></ul></div>
<div class="text"><a title="Link auf https://en.cppreference.com/w/cpp/io/basic_osyncstream/get_wrapped" alt="%7B%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fio%2Fbasic_osyncstream%2Fget_wrapped%22%2C%22text%22%3A%22cppreference.com%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fio%2Fbasic_osyncstream%2Fget_wrapped%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%7D" href="https://en.cppreference.com/w/cpp/io/basic_osyncstream/get_wrapped" class="">cppreference.com</a> zeigt, wie sich die Ausgabe verschiedener Ausgabe-Streams mit der <span class="tx_code">get_wrapped</span>-Methode sequenzieren lassen:</div>
<div class="pre">// sequenceOutput.cpp<br><br>#include &lt;syncstream&gt;<br>#include &lt;iostream&gt;<br>int main() {<br>&nbsp; <br>&nbsp; std::osyncstream bout1(std::cout);<br>&nbsp; bout1 &lt;&lt; "Hello, ";<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::osyncstream(bout1.get_wrapped()) &lt;&lt; "Goodbye, " &lt;&lt; "Planet!" &lt;&lt; '\n';<br>&nbsp; } // emits the contents of the temporary buffer<br>&nbsp; <br>&nbsp; bout1 &lt;&lt; "World!" &lt;&lt; '\n';<br>&nbsp; <br>} // emits the contents of bout1</div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/6/0/4/2/2/TN_207151039_94640fbe2d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Jetzt habe ich es vollbracht und C++20 in mehr als 70 Artikeln vollständig vorgestellt. Mehr Informationen zu C++ 20 gibt es nin meinem Buch: <a title="Link auf https://leanpub.com/c20" alt="%7B%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fleanpub.com%2Fc20%22%2C%22text%22%3A%22C%2B%2B20%3A%20Get%20the%20Details%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fleanpub.com%2Fc20%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%7D" href="https://leanpub.com/c20" class="">C++20: Get the Details</a>. </div>
<div class="text">Es gibt aber ein Feature, auf das ich nochmals genauer eingehen will: Coroutinen. In meinen nächsten Artikel werde ich mich mit den Schlüsselworten <span class="tx_code">co_return</span>, <span class="tx_code">co_yield</span> und <span class="tx_code">co_await</span> rein spielerisch beschäftigen.<br></div>

