<div class="vorspann">Mit diesem Artikel beende ich meine Ausführungen zu co_return in C++20 ab. Der erste Artikel beschäftigte sich mit einem Future, der sofort ausgeführt wurde. Es folgte ein Future, der nur bei Bedarf startete. Heute werde ich das Future dank Coroutinen in seinem eigenen Thread ausführen.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/7/1/8/1/8/TN_208088696_cbc03a1211.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Bevor ich diesen Artikel beginne, möchte ich meine Motivation zu dieser Miniserie über Coroutinen in C++20 nochmals zum Ausdruck bringen: Mir geht es darum, durch einfache Beispiele einen ersten Zugang zu den komplizierten Arbeitsabläufen von Coroutinen anzubieten. Diese aufeinander aufbauenden Artikel habe ich bereits in dieser Miniserie geschrieben:</div>
<div class="text"><ul><li> <a title="Link auf https://heise.de/-5066861" alt="%7B%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5066861%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5066861%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Einfache%20Futures%20mit%20Coroutinen%20implementieren%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%7D" href="https://heise.de/-5066861" class="">Einfache Futures mit Coroutinen implementieren</a> </li><li> <a title="Link auf https://heise.de/-5073590" alt="%7B%22alias%22%3A%22%22%2C%22text%22%3A%22Lazy%20Futures%20mit%20Coroutinen%20in%20C%2B%2B20%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5073590%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5073590%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%7D" href="https://heise.de/-5073590" class="">Lazy Futures mit Coroutinen in C++20</a> <br></li></ul></div>
<div class="text">Jetzt geht es darum, das Future in einem separaten Thread auszuführen.</div>
<div class="ztitel">Ausführung in einem separaten Thread<br></div>
<div class="text">Die Coroutine im ersten Artikel pausierte, bevor ihr Funktionskörper ausgeführt wurde:</div>
<div class="pre">MyFuture&lt;int&gt; createFuture() {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "createFuture" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; co_return 2021;<br>}<br></div>
<div class="text">Der Grund war, dass die Funktion <span class="tx_code">initial_suspend</span> den Promise <span class="tx_code">std::suspend_always</span> zurückgab. Das heißt, dass die Coroutine zuerst pausiert und dadurch auf einem separaten Thread ausgeführt werden kann: </div>
<div class="pre">// lazyFutureOnOtherThread.cpp<br><br>#include &lt;coroutine&gt;<br>#include &lt;iostream&gt;<br>#include &lt;memory&gt;<br>#include &lt;thread&gt;<br><br>template&lt;typename T&gt;<br>struct MyFuture {<br>&nbsp;&nbsp;&nbsp; struct promise_type;<br>&nbsp;&nbsp;&nbsp; using handle_type = std::coroutine_handle&lt;promise_type&gt;; <br>&nbsp;&nbsp;&nbsp; handle_type coro;<br><br>&nbsp;&nbsp;&nbsp; MyFuture(handle_type h): coro(h) {}<br>&nbsp;&nbsp;&nbsp; ~MyFuture() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( coro ) coro.destroy();<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; T get() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp; MyFuture::get:&nbsp; " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "std::this_thread::get_id(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::thread t([this] { coro.resume(); });&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.join();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return coro.promise().result;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; struct promise_type {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type(){ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::promise_type:&nbsp; " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "std::this_thread::get_id(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~promise_type(){ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::~promise_type:&nbsp; " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "std::this_thread::get_id(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T result;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto get_return_object() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyFuture{handle_type::from_promise(*this)};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void return_value(T v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::return_value:&nbsp; " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "std::this_thread::get_id(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; v &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = v;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_always initial_suspend() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_always final_suspend() noexcept {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::final_suspend:&nbsp; " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "std::this_thread::get_id(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void unhandled_exception() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::exit(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; };<br>};<br><br>MyFuture&lt;int&gt; createFuture() {<br>&nbsp;&nbsp;&nbsp; co_return 2021;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "main:&nbsp; " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "std::this_thread::get_id(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; auto fut = createFuture();<br>&nbsp;&nbsp;&nbsp; auto res = fut.get();<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "res: " &lt;&lt; res &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}<br></div>
<div class="text">Ich habe das Programm ein wenig kommentiert, sodass vor allem die ID des ausgeführten Threads dargestellt wird. Das Programm <span class="tx_code">lazyFutureOnOtherThread.cpp</span> ist dem vorherigen Programm <span class="tx_code">lazyFuture.cpp</span> des zweiten Artikels sehr ähnlich. Den größten Unterschied stellt die Funktion <span class="tx_code">get</span> (Zeile 1) dar. Der Aufruf <span class="tx_code">std::thread t([this] { coro.resume(); })</span> (Zeile 2) führt die Coroutine in einem anderen Thread fort. </div>
<div class="text">Auf dem <a title="Link auf https://wandbox.org/permlink/jFVVj80Gxu6bnNkc" alt="%7B%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwandbox.org%2Fpermlink%2FjFVVj80Gxu6bnNkc%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwandbox.org%2Fpermlink%2FjFVVj80Gxu6bnNkc%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Wandbox%20Online-Compiler%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%7D" href="https://wandbox.org/permlink/jFVVj80Gxu6bnNkc" class="">Wandbox Online-Compiler</a> lässt sich das Programm direkt ausprobieren:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/7/1/8/1/8/TN_208088708_6de083c654.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Ich möchte gerne noch ein paar Bemerkungen zur Funktion <span class="tx_code">get</span> hinzufügen. Es ist wichtig, dass der Promise, der in einem anderen Thread ausgeführt wird, fertig ist, bevor er sein Ergebnis mittels <span class="tx_code">coro.promise().result;</span> zurückgibt:<br></div>
<div class="pre">T get() {<br>&nbsp;&nbsp;&nbsp; std::thread t([this] { coro.resume(); });<br>&nbsp;&nbsp;&nbsp; t.join();<br>&nbsp;&nbsp;&nbsp; return coro.promise().result;<br>}</div>
<div class="text">Wird der Thread gejoinet, nachdem <span class="tx_code">coro.promise().result</span> aufgerufen wurde, ist dies undefiniertes Verhalten. In der folgenden Implementierung verwende ich <span class="tx_code">std::jthread</span>. Hierzu habe ich bereits einen Artikel geschrieben: "<a title="Link auf https://heise.de/-5054205" alt="%7B%22subject%22%3A%22%22%2C%22text%22%3A%22Ein%20verbesserter%20Thread%20mit%20std%3A%3Ajthread%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5054205%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5054205%22%2C%22mediasync_id%22%3A%22%22%7D" href="https://heise.de/-5054205" class="">Ein verbesserter Thread mit std::jthread</a>". Da <span class="tx_code">std::jthread</span> automatisch joint, falls er seinen Gültigkeitsbereich verlässt, ist dies zu spät: <br></div>
<div class="pre">T get() {&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::jthread t([this] { coro.resume(); });<br>&nbsp;&nbsp;&nbsp; return coro.promise().result;<br>}<br></div>
<div class="text">In diesem Fall ist es sehr wahrscheinlich, dass der Client das Ergebnis erhält, bevor der Promise seinen Aufruf<span class="tx_code"> return_value</span> abgeschlossen hat. Nun besitzt <span class="tx_code">value</span> und damit <span class="tx_code">res</span> einen zufälligen Wert.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/7/1/8/1/8/TN_208088712_e54c47088a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Natürlich gibt es mehr Möglichkeiten sicherzustellen, dass der Thread vor dem <span class="tx_code">return</span>-Aufruf fertig ist.</div>
<div class="text"><ul><li><span class="tx_code">std::jthread</span> erhält einen eigenen Gültigkeitsbereich:</li></ul></div>
<div class="pre">T get() {<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::jthread t([this] { coro.resume(); });<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return coro.promise().result;<br>}<br></div>
<div class="text"><ul><li><span class="tx_code">std::jthread</span> wird ein temporäres Objekt:</li></ul></div>
<div class="pre">T get() {<br>&nbsp;&nbsp;&nbsp; std::jthread([this] { coro.resume(); });<br>&nbsp;&nbsp;&nbsp; return coro.promise().result;<br>}<br></div>
<div class="text">Insbesondere die letzte Lösung finde ich problematisch, denn man benötigt wohl ein paar Sekunden, um zu erkennen, dass durch das temporäre Objekt der Konstruktor von <span class="tx_code">std::jthread</span> implizit aufgerufen wird.</div>
<div class="ztitel">promise_type</div>
<div class="text">Mancher mag sich wundern, dass eine Coroutine wie <span class="tx_code">MyFuture</span> immer einen inneren Typ <span class="tx_code">promise_type</span> besitzt. Dieser Name ist notwendig. Entsprechend lässt sich auch <a title="Link auf https://en.cppreference.com/w/cpp/coroutine/coroutine_traits" alt="%7B%22alias%22%3A%22%22%2C%22text%22%3A%22%5Bcode%5Dstd%3A%3Acoroutines_traits%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcoroutine%2Fcoroutine_traits%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcoroutine%2Fcoroutine_traits%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%7D" href="https://en.cppreference.com/w/cpp/coroutine/coroutine_traits" class="">[code]std::coroutines_traits</a>[/code] für <span class="tx_code">MyFuture</span> spezialisieren und in ihm einen öffentlichen <span class="tx_code">promise_type</span> erzeugen. Ich erwähne diesen Punkt, da ich weiß, dass viele Entwickler [--] auch ich [--] bereits in diese Falle getappt sind. </div>
<div class="text">Hier nun eine weitere Falle.<br></div>
<div class="ztitel">return_void and return_value</div>
<div class="text">Der Promise benötigt entweder die Funktion <span class="tx_code">return_void</span> oder <span class="tx_code">return_value.</span> Der erste Fall tritt ein, falls</div>
<div class="text"><ul><li>die Coroutine keine <span class="tx_code">co_return</span>-Anweisung besitzt.<br></li><li>die Coroutine eine <span class="tx_code">co_return</span>-Anweisung ohne Argument besitzt.<br></li><li>die Coroutine eine <span class="tx_code">co_return expression</span>-Anweisung besitzt, in der <span class="tx_code">expression</span> den Typ <span class="tx_code">void</span> hat.<br></li></ul></div>
<div class="text">Der Promise braucht die Funktion <span class="tx_code">return_value</span>, falls die Coroutine eine <span class="tx_code">co_return expression</span>-Anweisung besitzt, in der <span class="tx_code">expression</span> nicht den Typ <span class="tx_code">void</span> hat. </div>
<div class="text">Wird das Ende einer Coroutine erreicht, die <span class="tx_code">void</span> zurückgibt, aber keine <span class="tx_code">return_void</span>-Funktion besitzt, ist das undefiniertes Verhalten. Interessanterweise verlangt der Microsoft-Compiler, aber nicht der GCC eine Funktion <span class="tx_code">return_void</span>, wenn die Coroutine immer in ihrem letzten Haltepunkt pausiert und damit nie ihr Ende erreicht: <span class="tx_code">std::suspend_always final_suspend() noexcept.</span> Aus meiner Sicht ist der C++20-Standard in diesem Aspekt nicht eindeutig, und ich füge meinem Promise sicherheitshalber immer eine Funktion <span class="tx_code">void return_void() {}</span> hinzu.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Nach meinen Artikeln zu <span class="tx_code">co_return</span> geht es mit <span class="tx_code">co_yield</span> weiter. Dieses erlaubt es, unendliche Datenströme zu erzeugen. In meinem nächsten Artikel gehe ich darauf genauer ein.<br></div>