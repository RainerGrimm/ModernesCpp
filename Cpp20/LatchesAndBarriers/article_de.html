<div class="vorspann">Latches und Barriers sind Koordinationsdatentypen, die es Threads erlauben zu warten, bis ein Zähler den Wert Null besitzt. Ein <span class="tx_code">std::latch</span> lässt sich nur einmal, ein <span class="tx_code">std::barrier</span> hingegen mehrmals verwenden. Heute schaue ich mir Latches genauer an.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/4/4/0/5/8/TN_205841442_6e7df32792.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das gleichzeitige Aufrufen der Methoden eines <span class="tx_code">std::latch</span> oder einer <span class="tx_code">std::barrier</span> stellt kein Data Race dar. Ein Date Race ist ein solch elementarer Begriff in der Concurrency, dass ich ihn genauer vorstellen will. </div>
<div class="ztitel">Data Race<br></div>
<div class="text">Ein Data Race ist eine Situation, in der zumindest zwei Threads gleichzeitig auf eine Variable zugreifen und zumindest einer der zwei Threads versucht, diese zu verändern. Wenn ein Programm in ein Data Race läuft, besitzt es undefiniertes Verhalten. Das heißt, dass keine verbindlichen Aussagen über das Programm mehr möglich sind. Das folgende Programm ist ein Beispiel hierfür:</div>
<div class="pre">// addMoney.cpp<br><br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br>#include &lt;vector&gt;<br><br>struct Account{<br>&nbsp; int balance{100};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>};<br><br>void addMoney(Account&amp; to, int amount){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) <br>&nbsp; to.balance += amount;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>}<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp; Account account;<br>&nbsp; <br>&nbsp; std::vector&lt;std::thread&gt; vecThreads(100);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp; for (auto&amp; thr: vecThreads) thr = std::thread(addMoney, std::ref(account), 50); &nbsp;<br>&nbsp; <br>&nbsp; for (auto&amp; thr: vecThreads) thr.join();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp; std::cout &lt;&lt; "account.balance: " &lt;&lt; account.balance &lt;&lt; '\n';&nbsp; // (4)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br><br>}<br></div>
<div class="text">Im Programm addieren 100 Threads 50 Euro mithilfe der Funktion <span class="tx_code">addMoney</span> (2) auf dasselbe Konto (1). Der ursprüngliche Wert ist 100 (3). Die entscheidende Beobachtung ist es, dass die Modifikation des Kontos ohne Synchronisation stattfindet. Damit ist dies ein Data Race und das Programm besitzt undefiniertes Verhalten. Führe ich das Programm mehrfach aus, beträgt der Kontostand am Ende des Programms zwischen 5000 und 5100 Euro (4).</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/4/4/0/5/8/TN_205841449_7cbcfb75f2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Wie kann das passieren? Warum gehen ein paar 50 Euro Überweisungen verloren? Der Update-Prozess <span class="tx_code">to.balance += amount;</span> in Zeile (1) ist eine sogenannte Read-Modify-Write-Operation. Als solche wird zuerst der alte Wert von <span class="tx_code">to.balance</span> gelesen, dann aktualisiert und letztlich geschrieben. Nun ist die folgende Ausführung von Operationen möglich. Ich verwende der Anschaulichkeit halber in meiner Beschreibung konkrete Zahlen.</div>
<div class="text"><ul><li> Thread A liest lediglich den Wert 500 Euro und dann kommt Thread B zum Zuge.</li><li>Thread B liest auch den Wert 500 Euro, fügt 50 Euro hinzu und aktualisiert den Kontostand auf 550 Euro.</li><li>Nun vollendet Thread A seinen Job, in dem er auch 50 Euro zum Kontostand hinzufügt. Damit schreibt Thread A ebenfalls den Wert 550 Euro.</li><li>Letztlich wird der Wert 550 zweimal geschrieben und damit können wir anstelle zweier Überweisungen von 50 Euro nur eine wahrnehmen.<br></li><li>Das heißt, dass eine Überweisung verloren geht und wir einen zu niedrigen Kontostand erhalten.</li></ul></div>
<div class="text">Zuerst möchte ich zwei Fragen beantworten, bevor ich <span class="tx_code">std::latch</span> und <span class="tx_code">std::barrier</span> im Detail vorstelle.<br></div>
<div class="ztitel">Zwei Fragen<br></div>
<div class="text"><ol><li><b>Worin unterscheiden sich die beiden Mechanismen zur Koordination von Threads? </b>Ein <span class="tx_code">std::latch</span> lässt sich nur einmal verwenden, ein <span class="tx_code">std::barrier</span> hingegen mehrmals. Ein<span class="tx_code"> std::latch</span> wird gerne eingesetzt, um eine Aufgabe durch mehrere Threads ausführen zu lassen. Im Gegensatz dazu kommt ein <span class="tx_code">std::barrier</span> typischerweise zum Einsatz, wenn es darum geht, dass eine sich wiederholende Aufgabe durch mehrere Threads ausgeführt werden soll.</li><li><b>Welche neuen Anwendungsfälle lassen sich mit einem Latch und einer Barrier umsetzen, die sich in C++11 nicht schon mit Futures, Threads oder Bedingungsvariablen in Kombination mit einem Lock implementieren lassen? </b>Latches und Barrier bieten keine neuen Anwendungsfälle an. Sie sind aber deutlich einfacher zu verwenden. Darüber hinaus sind sie oft deutlich performanter, da bei ihnen typischerweise <a title="Link auf https://en.wikipedia.org/wiki/Non-blocking_algorithm" alt="%7B%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22lock-freie%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FNon-blocking_algorithm%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FNon-blocking_algorithm%22%2C%22mediasync_id%22%3A%22%22%7D" href="https://en.wikipedia.org/wiki/Non-blocking_algorithm" class="">lock-freie</a> Mechanismen zum Einsatz kommen. <br></li></ol></div>
<div class="text">Mit dem einfachen Datentyp <span class="tx_code">std::latch</span> möchte ich meinen Artikel fortführen.</div>
<div class="ztitel">std::latch<br></div>
<div class="text">Zuerst werfe ich einen genaueren Blick auf das Interface eines <span class="tx_code">std::latch</span>.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/4/4/0/5/8/TN_205841455_2334163bdf.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Der Default-Wert für <span class="tx_code">upd</span> ist 1. Falls <span class="tx_code">upd</span> größer als der Zähler oder negativ ist, stellt das undefiniertes Verhalten dar. Der Aufruf <span class="tx_code">lat.try_wait()</span> wartet nicht, wie es sein Name vermuten lässt. </div>
<div class="text">Das folgende Programm <span class="tx_code">bossWorkers.cpp</span> verwendet zwei Latches, um einen Boss-Worker-Ablauf umzusetzen. Ich synchronisiere das Schreiben auf <span class="tx_code">std::cout</span> mithilfe der Funktion <span class="tx_code">synchronizedOut</span> (1). Dadurch ist es einfacher, dem Ablauf zu folgen:</div>
<div class="pre">// bossWorkers.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;mutex&gt;<br>#include &lt;latch&gt;<br>#include &lt;thread&gt;<br><br>std::latch workDone(6);<br>std::latch goHome(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br><br>std::mutex coutMutex;<br><br>void synchronizedOut(const std::string s) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; lo(coutMutex);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; s;<br>}<br><br>class Worker {<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp;&nbsp; Worker(std::string n): name(n) { };<br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void operator() (){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // notify the boss when work is done<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronizedOut(name + ": " + "Work done!\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; workDone.count_down();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // waiting before going home<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goHome.wait();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronizedOut(name + ": " + "Good bye!\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; std::string name;<br>};<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "BOSS: START WORKING! " &lt;&lt; '\n';<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; Worker herb("&nbsp; Herb");<br>&nbsp;&nbsp;&nbsp; std::thread herbWork(herb);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; Worker scott("&nbsp;&nbsp;&nbsp; Scott");<br>&nbsp;&nbsp;&nbsp; std::thread scottWork(scott);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; Worker bjarne("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bjarne");<br>&nbsp;&nbsp;&nbsp; std::thread bjarneWork(bjarne);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; Worker andrei("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Andrei");<br>&nbsp;&nbsp;&nbsp; std::thread andreiWork(andrei);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; Worker andrew("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Andrew");<br>&nbsp;&nbsp;&nbsp; std::thread andrewWork(andrew);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; Worker david("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; David");<br>&nbsp;&nbsp;&nbsp; std::thread davidWork(david);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; workDone.wait();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; goHome.count_down();<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "BOSS: GO HOME!" &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; herbWork.join();<br>&nbsp;&nbsp;&nbsp; scottWork.join();<br>&nbsp;&nbsp;&nbsp; bjarneWork.join();<br>&nbsp;&nbsp;&nbsp; andreiWork.join();<br>&nbsp;&nbsp;&nbsp; andrewWork.join();<br>&nbsp;&nbsp;&nbsp; davidWork.join();<br>&nbsp; <br>}</div>
<div class="text">Das Programm setzt einen einfachen Ablauf um. Die sechs Arbeiter <span class="tx_code">herb</span>, <span class="tx_code">scott</span>, <span class="tx_code">bjarne</span>, <span class="tx_code">andrei, andrew</span> und <span class="tx_code">david</span> müssen ihre Arbeit erledigen. Wenn sie mit ihr fertig sind, dekrementiert sie den Latch: <span class="tx_code">workDone</span> (2). Der Boss (<span class="tx_code">main</span>-Thread) ist so lange in Zeile (3) blockiert, bis der Zähler den Wert 0 hat. Wenn der Zähler den Wert 0 hat, verwendet der Boss den zweiten <span class="tx_code">std::latch goHome</span>, um den Arbeitern zu signalisieren, dass sie nach Hause gehen dürfen. In diesem Fall ist der initiale Zähler 1 (4). Der Aufruf <span class="tx_code">goHome.wai</span>t (5) blockiert, bis der Zähler den Wert 0 besitzt. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/4/4/0/5/8/TN_205841462_6900d07118.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Es fällt vermutlich auf, dass sich der Ablauf auch ohne Boss umsetzen lässt. Hier ist die moderne Variante:</div>
<div class="pre">// workers.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;latch&gt;<br>#include &lt;mutex&gt;<br>#include &lt;thread&gt;<br><br>std::latch workDone(6);<br>std::mutex coutMutex;<br><br>void synchronizedOut(const std::string&amp; s) {<br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; lo(coutMutex);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; s;<br>}<br><br>class Worker {<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; Worker(std::string n): name(n) { };<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; void operator() () {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronizedOut(name + ": " + "Work done!\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; workDone.arrive_and_wait();&nbsp; // wait until all work is done&nbsp; (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronizedOut(name + ": " + "See you tomorrow!\n");<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; std::string name;<br>};<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; Worker herb("&nbsp; Herb");<br>&nbsp;&nbsp;&nbsp; std::thread herbWork(herb);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; Worker scott("&nbsp;&nbsp;&nbsp; Scott");<br>&nbsp;&nbsp;&nbsp; std::thread scottWork(scott);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; Worker bjarne("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bjarne");<br>&nbsp;&nbsp;&nbsp; std::thread bjarneWork(bjarne);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; Worker andrei("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Andrei");<br>&nbsp;&nbsp;&nbsp; std::thread andreiWork(andrei);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; Worker andrew("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Andrew");<br>&nbsp;&nbsp;&nbsp; std::thread andrewWork(andrew);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; Worker david("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; David");<br>&nbsp;&nbsp;&nbsp; std::thread davidWork(david);<br><br>&nbsp;&nbsp;&nbsp; herbWork.join();<br>&nbsp;&nbsp;&nbsp; scottWork.join();<br>&nbsp;&nbsp;&nbsp; bjarneWork.join();<br>&nbsp;&nbsp;&nbsp; andreiWork.join();<br>&nbsp;&nbsp;&nbsp; andrewWork.join();<br>&nbsp;&nbsp;&nbsp; davidWork.join();<br>&nbsp; <br>}</div>
<div class="text">Es gibt für mich nicht viel zu dem vereinfachten Ablauf hinzufügen. Der Aufruf <span class="tx_code">workDone.arrive_and_wait(1)</span> (1) ist äquivalent zu den Aufrufen <span class="tx_code">count_down(upd); wait();</span>. Das heißt, dass die Arbeiter sich selbst koordinieren können und der Boss im Gegensatz zum vorherigen Programm <span class="tx_code">bossWorkers.cpp</span> überflüssig ist.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/4/4/0/5/8/TN_205841465_c4ca0fdc1f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Wie geht's weiter? <br></div>
<div class="text">Eine <span class="tx_code">std::barrier</span> ist einer <span class="tx_code">std::latch</span> ähnlich. Ihre Stärke besteht aber darin, einen Job mehrmals auszuführen. Die <span class="tx_code">std::barrier</span> werde ich mir in meinem nächsten Artikel genauer anschauen. <br></div>