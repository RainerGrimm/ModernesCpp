<div class="vorspann">Mit diesem Artikel werde ich mir das letzte interessante Thema zu Concepts genauer anschauen: die Definition von Concepts. Außerdem beantworte ich in dem Zuge die Fragen, die meine vorherigen Artikel offen gelassen haben.&nbsp; <br></div>
<div class="text">Zuerst einmal sind die meisten von mir definierten Concepts bereits im C++20-Standard enthalten. Daher gibt es keinen Grund, diese nochmals zu implementieren. Um meine Concepts von denen des C++20-Standards zu unterscheiden, habe ich sie groß geschrieben. Zur Erinnerung: Mein vorheriger Artikel stellte die vordefinierten Concepts bereits dar: <a title="Link auf Beitrag 2822257" href="/exec/mainmenu.pl?sid=766f9a665f6d5efc6cd7b7d0d4105e35&amp;rm=open_article_id&amp;bid=2822257" alt="%7B%22text%22%3A%22C%2B%2B20%3A%20Vordefinierte%20Concepts%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D766f9a665f6d5efc6cd7b7d0d4105e35%26rm%3Dopen_article_id%26bid%3D2822257%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22destination%22%3A2822257%2C%22type%22%3A%22B%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" class="">C++20: Vordefinierte Concepts</a>. <br></div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/2/8/1/6/4/TN_187290209_61054faa5c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Concepts definieren<br></div>
<div class="text">Es gibt zwei typische Wege, Concepts zu definieren: die direkte Definition und die sogenannten requires-expressions lassen sich anwenden. <br></div>
<div class="text">Die Syntax der direkten Definition im Standard hat sich ein wenig zur Syntax des Concepts TS (Technical Specification) geändert.<br></div>
<div class="text"><ul><li><b>Concepts TS</b></li></ul></div>
<div class="pre">template&lt;typename T&gt;<br>concept bool Integral(){<br>&nbsp;&nbsp;&nbsp; return std::is_integral&lt;T&gt;::value;<br>}<br></div>
<div class="text"><ul><li><b>C++20-Standard</b></li></ul></div>
<div class="pre">template&lt;typename T&gt;<br>concept Integral = std::is_integral&lt;T&gt;::value; </div>
<div class="text">Die Syntax des C++20-Standards ist kompakter. Beide Implementierungen verwenden unter der Haube die Funktion<span class="tx_code"> std::is_integral&lt;T&gt;::value</span> aus der Typ-Traits-Bibliothek von C++11. <span class="tx_code">T</span> erfüllt das Concept genau dann, wenn das Compilezeit-Prädikat <span class="tx_code">std::is_integral&lt;T&gt;::value</span> zu <span class="tx_code">true </span>evaluiert. Compilezeit-Prädikat bedeutet, dass die Funktion zur Compilezeit ausgeführt wird und einen Wahrheitswert zurückgeben muss. Seit C++17 lässt sich der Ausdruck <span class="tx_code">std::is_integral&lt;T&gt;::value</span> einfacher schreiben: <span class="tx_code">std::is_integral_v&lt;T&gt;</span>.<br></div>
<div class="text">Ich bin mir nicht sicher, ob die zwei Begriffe <b>variable concept</b> für die direkte Definition und <b>function concept</b> für die requires-expressions noch verwendet werden. Beide Begriffe helfen aber, die direkte Definition von requires-expressions zu unterscheiden. </div>
<div class="text">Ich lasse das Beispiel zur Verwendung des Concepts <span class="tx_code">Integral</span> aus. Falls du neugierig bist, lies meinen vorherigen Artikel: <a href="/exec/mainmenu.pl?sid=766f9a665f6d5efc6cd7b7d0d4105e35&amp;rm=open_article_id&amp;bid=2803441" alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A2803441%2C%22type%22%3A%22B%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22text%22%3A%22C%2B%2B20%3A%20Concepts%20%5B--%5D%20die%20Placeholder-Syntax%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D766f9a665f6d5efc6cd7b7d0d4105e35%26rm%3Dopen_article_id%26bid%3D2803441%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf Beitrag 2803441" class="">C++20: Concepts [--] die Placeholder-Syntax</a>.<br></div>
<div class="ztitel_kleiner">requires-expressions<br></div>
<div class="text">Entsprechend der direkten Definition ändert sich die Syntax der requires-expressions von der Syntax des Concepts TS zu der des C++20-Standards.<br></div>
<div class="text"><ul><li><b>Concepts TS</b></li></ul></div>
<div class="pre">template&lt;typename T&gt;<br>concept bool Equal(){<br>&nbsp;&nbsp;&nbsp; return requires(T a, T b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a == b } -&gt; bool;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a != b } -&gt; bool;<br>&nbsp;&nbsp; };<br>}<br></div>
<div class="text"><ul><li><b>C++20-Standard</b></li></ul></div>
<div class="pre">template&lt;typename T&gt;<br>concept Equal =<br>&nbsp;&nbsp;&nbsp; requires(T a, T b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a == b } -&gt; bool;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a != b } -&gt; bool;<br>&nbsp;&nbsp;&nbsp; };<br></div>
<div class="text">Wie zuvor ist die Syntax des C++20-Standards kompakter. <span class="tx_code">T</span> erfüllt das Concept genau dann, wenn die Operatoren <span class="tx_code">== </span>und<span class="tx_code"> != </span>überladen sind und einen Wahrheitswert zurückgeben. Zusätzlich müssen die Datentypen von<span class="tx_code"> a </span>und <span class="tx_code">b</span> identisch sein. </div>
<div class="ztitel_kleiner">Das Concept <span class="tx_code">Equal</span><br></div>
<div class="text">Jetzt ist es an der Zeit, das Concept <span class="tx_code">Equal</span> anzuwenden: <br></div>
<div class="pre">// conceptsDefintionEqual.cpp<br><br>#include &lt;iostream&gt;<br><br>template&lt;typename T&gt;<br>concept Equal =<br>&nbsp;&nbsp;&nbsp; requires(T a, T b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a == b } -&gt; bool;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a != b } -&gt; bool;<br>};<br><br><br>bool areEqual(Equal auto a, Equal auto b) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; return a == b;<br>}<br><br>/*<br><br>struct WithoutEqual{<br>&nbsp; bool operator==(const WithoutEqual&amp; other) = delete;<br>};<br><br>struct WithoutUnequal{<br>&nbsp; bool operator!=(const WithoutUnequal&amp; other) = delete;<br>};<br><br>*/<br><br>int main() {<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "areEqual(1, 5): " &lt;&lt; areEqual(1, 5) &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; /*<br>&nbsp; <br>&nbsp; bool res = areEqual(WithoutEqual(),&nbsp; WithoutEqual());<br>&nbsp; <br>&nbsp; bool res2 = areEqual(WithoutUnequal(),&nbsp; WithoutUnequal());<br>&nbsp; <br>&nbsp; */<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>}<br></div>
<div class="text">Ich nutze das Concept <span class="tx_code">Equal</span> in der Funktion <span class="tx_code">areEqual</span> (Zeile 1). Zur Erinnerung, durch die Verwendung eines Concepts als Funktionsparameter erzeugt der Compiler ein Funktions-Template, für dessen Argumente die Einschränkungen des Concepts gelten. Mehr Informationen zu dieser einfachen Art, Concepts anzuwenden, gibt es wiederum in meinem vorherigen Artikel: <a title="Link auf Beitrag 2803441" alt="%7B%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A2803441%2C%22type%22%3A%22B%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C%2B%2B20%3A%20Concepts%20%5B--%5D%20die%20Placeholder-Syntax%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D766f9a665f6d5efc6cd7b7d0d4105e35%26rm%3Dopen_article_id%26bid%3D2803441%22%7D" href="/exec/mainmenu.pl?sid=766f9a665f6d5efc6cd7b7d0d4105e35&amp;rm=open_article_id&amp;bid=2803441" class="">C++20: Concepts [--] die Placeholder-Syntax</a>.</div>
<div class="text">Die Ausgabe des Programms ist unspektakulär:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/2/8/1/6/4/TN_187290217_ecce8526f4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Jetzt wird es aber spannender. Was passiert, wenn ich die Datentypen <span class="tx_code">WithoutEqual</span> und <span class="tx_code">WithoutUnequal</span> verwende? Natürlich habe ich absichtlich die Operatoren <span class="tx_code">== </span>und <span class="tx_code">!=</span> auf <span class="tx_code">delete </span>gesetzt. Der Compiler beschwert sich postwendend, dass beide Datentypen nicht das Concept <span class="tx_code">Equal</span> unterstützen. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/2/8/1/6/4/TN_187290225_9b16f5f1fb.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Wenn du die Fehlermeldung sorgfältig studierst, sollte der Grund klar sein<i>: (a == b) would be ill-formed </i>und<i> (a != b) would be ill-formed.</i><br></div>
<div class="text">Bevor ich den Artikel fortsetze, möchte ich einen kleinen Ausflug einlegen. Er ist notwendig, um den Sourcecode zu kompilieren.</div>
<div class="ztitel">Der Implementierungsstatus der Concepts</div>
<div class="text">Ich habe bei der Ausgabe des Programms<span class="tx_code"> conceptsDefinitionEqual.cpp</span> ein wenig geschummelt. Die Ausgabe stammt von der Concepts-TS-Implementierung des GCC. Zum jetzigen Zeitpunkt gibt es keine Implementierung, die standardkonform zur C++20-Syntax der Concepts ist. </div>
<div class="text"><ul><li> Der neueste Microsoft-Compiler setzt zwar die C++20-Syntax für Concepts um, kann aber noch nicht die Placeholer-Syntax, die ich für die Funktion <span class="tx_code">areEqual </span>verwendet habe.</li><li>Der GCC-Compiler unterstützt zwar die Placeholder-Syntax, hingegen nicht die C++20-Syntax,&nbsp; Concepts zu definieren. <br></li></ul> </div>
<div class="ztitel">From Equal to Ord<br></div>
<div class="text">Ich habe bereits in einem älteren Artikel geschrieben (<a class="" title="Link auf Beitrag 2794242" href="/exec/mainmenu.pl?sid=766f9a665f6d5efc6cd7b7d0d4105e35&amp;rm=open_article_id&amp;bid=2794242" alt="%7B%22custom%22%3A%7B%7D%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D766f9a665f6d5efc6cd7b7d0d4105e35%26rm%3Dopen_article_id%26bid%3D2794242%22%2C%22text%22%3A%22C%2B%2B20%3A%20Zwei%20Extreme%20und%20die%20Rettung%20dank%20Concepts%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22destination%22%3A2794242%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%7D">C++20: Zwei Extreme und die Rettung dank Concepts</a>), dass mich zu Anfang Concepts an Haskells Typklassen erinnerten. Typklassen in Haskell sind Interfaces für ähnliche Datentypen. Der Hauptunterschied zu Concepts ist aber, dass ein Datentyp wie <span class="tx_code">Int</span> in Haskell eine Instanz einer Typklasse sein und daher die Typklasse implementieren muss. Im Gegensatz dazu, prüft der Compiler bei Concepts, ob ein Datentyp ein Concept erfüllt. </div>
<div class="text">Dies ist ein Ausschnitt aus der Typklassen-Hierarchie Haskells:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/2/8/1/6/4/TN_187290228_cd006c024e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Hier ist meine entscheidende Beobachtung: Haskell unterstützt die Typklasse <span class="tx_code">Eq</span>. Wenn du die Definition der Typklasse <span class="tx_code">Eq</span> mit dem Concept <span class="tx_code">Equal</span> vergleichst, sind sie sehr ähnlich:</div>
<div class="ztitel_kleiner">Die Typklasse Eq</div>
<div class="pre">class Eq a where<br>&nbsp;&nbsp;&nbsp; (==) :: a -&gt; a -&gt; Bool<br>&nbsp;&nbsp;&nbsp; (/=) :: a -&gt; a -&gt; Bool</div>
<div class="ztitel_kleiner">Das Concept <span class="tx_code">Equal</span><br></div>
<div class="pre">template&lt;typename T&gt;<br>concept Equal =<br>&nbsp;&nbsp;&nbsp; requires(T a, T b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a == b } -&gt; bool;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a != b } -&gt; bool;<br>&nbsp;&nbsp;&nbsp; };</div>
<div class="text">Haskells Typklasse fordert von einer Instanz wie <span class="tx_code">Int</span>:<br></div>
<div class="text"><ul><li>Der gleich- (<span class="tx_code">==)</span> und ungleich-Operator (<span class="tx_code">/=)</span> muss unterstützt werden und dieser einen Wahrheitswert zurückgeben.<br></li><li>Die Operanden beider Operatoren müssen den gleichen Datentyp (<span class="tx_code">a -&gt; a</span>) besitzen.</li></ul></div>
<div class="text">Gerne möchte ich nochmals genauer die Typklassen-Hierarchie Haskells anschauen. Die Typklasse <span class="tx_code">Ord</span> ist eine Verfeinerung der Typklasse <span class="tx_code">Eq</span>. Dies geht auch aus der Definition der Typklasse <span class="tx_code">Ord</span> hervor:</div>
<div class="text"><span class="tx_code">class Eq a =&gt; Ord a where<br>&nbsp;&nbsp;&nbsp; compare :: a -&gt; a -&gt; Ordering<br>&nbsp;&nbsp;&nbsp; (&lt;) :: a -&gt; a -&gt; Bool<br>&nbsp;&nbsp;&nbsp; (&lt;=) :: a -&gt; a -&gt; Bool<br>&nbsp;&nbsp;&nbsp; (&gt;) :: a -&gt; a -&gt; Bool<br>&nbsp;&nbsp;&nbsp; (&gt;=) :: a -&gt; a -&gt; Bool<br>&nbsp;&nbsp;&nbsp; max :: a -&gt; a -&gt; a</span></div>
<div class="text">Der interessanteste Punkt der Definition der Typklasse <span class="tx_code">Ord</span> ist ihre erste Zeile. Eine Instanz der Typklasse <span class="tx_code">Ord</span> muss bereits eine Instanz der Typklasse <span class="tx_code">Eq</span> sein. <span class="tx_code">Ordering</span> ist eine Aufzählung mit den Werten <span class="tx_code">EQ</span>, <span class="tx_code">LT</span> und <span class="tx_code">GT</span>. Diese Verfeinerung einer bestehenden Typklasse in Haskell finde ich sehr elegant.</div>
<div class="text">Dies ist meine Herausforderung für meinen nächsten Artikel zu Concepts: Lassen sich Concepts ähnlich elegant verfeinern wie Typklassen in Haskell? </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">In meinem nächsten Artikel nehme ich die Herausforderung an, das Concept <span class="tx_code">Equal</span> zu verfeinern. Zusätzlich werde ich die zwei wichtigen Concepts <span class="tx_code">Regular</span> und <span class="tx_code">Semiregular</span> genauer vorstellen und implementieren.<br></div>
<div class="simple-translate-result-contents"><br> <br></div>