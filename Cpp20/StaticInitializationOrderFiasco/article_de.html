<div class="vorspann">Dem Wortlaut der <a class="" alt="%7B%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fisocpp.org%2Fwiki%2Ffaq%2Fctors%23static-init-order%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22FAQ%20von%20isocppp.org%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.org%2Fwiki%2Ffaq%2Fctors%23static-init-order%22%7D" href="https://isocpp.org/wiki/faq/ctors#static-init-order" title="Link auf https://isocpp.org/wiki/faq/ctors#static-init-order">FAQ von isocppp.org</a> folgend, ist das Static Initialization Order Fiasco "a subtle way to crash your program". Die FAQ geht noch weiter: "The static initialization order problem is a very subtle and commonly misunderstood aspect of C++." Genau mit diesem subtilen und missverstandenen Aspekt von C++ befasst sich mein heutiger Artikel.</div>
<div class="text">Bevor ich beginne, möchte ich einen kurzen Disclaimer loswerden. In diesem Artikel geht es um Variablen mit statischer Speicherdauer und ihren Abhängigkeiten. Sie können globale oder statische Variablen beziehungsweise statische Klassenmitglieder sein. Der Einfachheit halber werde ich sie statische Variablen nennen. Abhängigkeiten statischer Variablen in verschiedenen Übersetzungseinheiten sind im Allgemeinen ein Geschmäckle (code smell) und sollten die Grundlage für die Refaktorierung des Codes sein. Wenn du daher deinen Code refaktorierst, erübrigt sich für dich der Rest des Artikels.</div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/3/8/5/7/2/TN_197086906_917ca640b2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Static Initialization Order Fiasco</div>
<div class="text">Statische Variablen in einer Übersetzungseinheit werden in ihrer Definitionsreihenfolge initialisiert. Im Gegensatz dazu besitzt die Initialisierungsreihenfolge von statischen Variablen zwischen Übersetzungseinheiten ein großes Problem. Wenn eine statische Variable <span class="tx_code">staticA</span> in einer Übersetzungseinheit definiert wird, deren Initialisierung von der Initialisierung einer statischen Variable <span class="tx_code">staticB</span> in einer anderen Übersetzungseinheit abhängt, endet das im Static Initialization Order Fiasco. Das Programm ist <i>ill-formed,</i> denn es definiert nicht, welche statische Variable zuerst zur Laufzeit (dynamisch) initialisiert wird. </div>
<div class="text">Bevor ich mich der Lösung dieses Problems widme, möchte ich erst das Static Initialization Order Fiasco in Aktion vorstellen.</div>
<div class="ztitel_kleiner">Eine 50:50-Chance auf Korrektheit</div>
<div class="text">Warum ist die Initialisierung einer statischen Variable besonders? Sie besteht aus zwei Schritten: einem statischen und einem dynamischen Schritt. Wenn eine statische Variable nicht zur Compilezeit <a class="" alt="%7B%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fconstant_initialization%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fconstant_initialization%22%2C%22text%22%3A%22const-initialisiert%20%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://en.cppreference.com/w/cpp/language/constant_initialization" title="Link auf https://en.cppreference.com/w/cpp/language/constant_initialization">const-initialisiert </a>werden kann, wird sie vorerst <a href="https://en.cppreference.com/w/cpp/language/zero_initialization" alt="%7B%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fzero_initialization%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22null-initialisiert%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fzero_initialization%22%7D" title="Link auf https://en.cppreference.com/w/cpp/language/zero_initialization" class="">null-initialisiert</a>. Zur Laufzeit werden dann die statischen Variablen initialisiert, die zur Compilezeit <a alt="%7B%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fzero_initialization%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22null-initialisiert%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fzero_initialization%22%7D" href="https://en.cppreference.com/w/cpp/language/zero_initialization" title="Link auf https://en.cppreference.com/w/cpp/language/zero_initialization" class="">null-initialisiert</a> wurden:<br></div>
<div class="pre">// sourceSIOF2.cpp<br><br>int quad(int n) {<br>&nbsp;&nbsp;&nbsp; return n * n;<br>}<br><br>int&amp; staticA() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; static auto staticA&nbsp; = quad(5);&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; return staticA;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="pre">// mainSOIF2.cpp<br><br>#include &lt;iostream&gt;<br><br>int&amp; staticA();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>auto staticB = staticA(); // (3)<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "staticB: " &lt;&lt; staticB &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Zeile (1) erklärt eine statische Variable <span class="tx_code">staticA</span>. Die Initialisierung von <span class="tx_code">staticB</span> hängt von der Initialisierung von <span class="tx_code">staticA</span>. <span class="tx_code">staticB</span> wird zur Compilezeit null-initialisiert und zur Laufzeit dynamisch initialisiert. Das Problem ist, dass es keine Garantie gibt, ob zuerst <span class="tx_code">staticA</span> oder <span class="tx_code">staticB</span> initialisiert wird, da <span class="tx_code">staticA</span> und <span class="tx_code">staticB</span> zu verschiedenen Übersetzungseinheiten gehören. Nun hast du eine 50:50-Chance, dass <span class="tx_code">staticB</span> 0 oder 25 ist.</div>
<div class="text">Um meine Beobachtungen zu verdeutlichen, habe ich die Linkreihenfolge der Objektdateien geändert. Damit ändert sich auch der Wert von <span class="tx_code">staticB</span>!</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/3/8/5/7/2/TN_197086915_c82915b716.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Was für ein Fiasko! Das Ergebnis des Programms hängt von der Linkreihenfolge der Objektdateien ab. Wie lässt sich das Problem lösen, wenn wir nicht auf C++20 zurückgreifen können?</div>
<div class="ztitel">Verzögerte Initialisierung einer statischen Variable in einem lokalen Bereich</div>
<div class="text">Statische Variable in einem lokalen Bereich werden erst erzeugt, wenn sie benötigt werden. Der lokale Bereich meint im Wesentlichen, dass die statische Variable innerhalb geschweifter Klammern verwendet wird. Diese verzögerte Initialisierung (lazy initialization) ist eine Garantie von C++98. Mit C+11 werden statische Variable in einem lokalen Bereich darüber hinaus noch Thread-sicher initialisiert. Das Thread-sichere Meyers' Singleton basiert auf dieser Garantie. Ich habe bereits einen Artikel&nbsp; "<a class="" href="https://www.grimm-jaud.de/index.php/blog/threadsicheres-initialisieren-eines-singletons" alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fthreadsicheres-initialisieren-eines-singletons%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Thread-sicheres%20Initialisieren%20eines%20Singletons%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fthreadsicheres-initialisieren-eines-singletons%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/threadsicheres-initialisieren-eines-singletons">Thread-sicheres Initialisieren eines Singletons</a>" geschrieben.</div>
<div class="text">Die verzögerte Initialisierung kann als Lösung für das Static Initialization Order Fiasco verwendet werden:</div>
<div class="pre">// sourceSIOF2.cpp<br><br>int quad(int n) {<br>&nbsp;&nbsp;&nbsp; return n * n;<br>}<br><br>int&amp; staticA() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; static auto staticA&nbsp; = quad(5);&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; return staticA;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="pre">// mainSOIF2.cpp<br><br>#include &lt;iostream&gt;<br><br>int&amp; staticA();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>auto staticB = staticA(); // (3)<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "staticB: " &lt;&lt; staticB &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text"><span class="tx_code">staticA</span> ist eine statische Variable in einem lokalen Bereich (1). Die Zeile (2) erklärt die Funktion <span class="tx_code">staticA</span>, die zum Einsatz kommt, um die statische Variable <span class="tx_code">staticB</span> zu initialisieren. Der lokale Bereich von <span class="tx_code">staticA</span> sichert zu, dass <span class="tx_code">staticA</span> genau dann von der Laufzeit erzeugt und initialisiert wird, wenn diese das erste Mal genutzt wird. In diesem Fall besitzt die Linkreihenfolge keine Auswirkung auf den Wert von <span class="tx_code">staticB</span>.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/3/8/5/7/2/TN_197086920_a1626d7f8f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Zum Abschluss möchte ich noch das Static Initialization Order Fiasco mithilfe von C++20 lösen.</div>
<div class="ztitel">Compilezeit-Initialisierung einer statischen Variable</div>
<div class="text">Ich werde <span class="tx_code">constinit</span> auf <span class="tx_code">staticA</span> anwenden. <span class="tx_code"></span>Ersteres sichert zu, dass <span class="tx_code">staticA</span> zur Compilezeit initialisiert wird: </div>
<div class="pre">// sourceSIOF3.cpp<br><br>constexpr int quad(int n) {<br>&nbsp;&nbsp;&nbsp; return n * n;<br>}<br><br>constinit auto staticA&nbsp; = quad(5);&nbsp; // (2)</div>
<div class="pre">// mainSOIF3.cpp<br><br>#include &lt;iostream&gt;<br><br>extern constinit int staticA;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>auto staticB = staticA;<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "staticB: " &lt;&lt; staticB &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">(1) deklariert die Variable <span class="tx_code">staticA</span>. <span class="tx_code"></span>Diese (2) wird zur Compilezeit initialisiert. Eine kleine Beobachtung finde ich noch interessant. <span class="tx_code">constexpr</span> anstelle von <span class="tx_code">constinit</span> in (1) zu verwenden, ist nicht gültig, da <span class="tx_code">constexpr</span> eine Definition und nicht nur eine Deklaration benötigt.</div>
<div class="text">Dank des Clang-10-Compilers kann ich das Programm ausführen:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/3/8/5/7/2/TN_197086926_318f865629.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Wie im Fall der verzögerten Initialisierung durch statische Variablen in einem lokalen Bereich ist der Wert von <span class="tx_code">staticB</span> immer 25. </div>
<div class="ztitel">Wie geht' s weiter?</div>
<div class="text">C++20 besitzt einige kleine Verbesserungen rund um Templates und Lambdas. Genau darüber werde ich in meinem nächsten Artikel schreiben.<br></div>
