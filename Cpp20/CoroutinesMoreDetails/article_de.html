<div class="vorspann">Nachdem der letzte Artikel "<a class="" title="Link auf https://heise.de/-4687457" alt="%7B%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4687457%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4687457%22%2C%22text%22%3A%22C%2B%2B20%3A%20Coroutinen%20%5B--%5D%20ein%20erster%20%C3%9Cberblick%22%2C%22user_params%22%3A%22%22%7D" href="https://heise.de/-4687457">C++20: Coroutinen [--] ein erster Überblick</a>" in Coroutinen einführte, geht es heute um weitere Details. Gerne möchte ich wiederholen: Wir erhalten in C++20 keine Coroutinen, sondern ein Framework, um Coroutinen zu implementieren. <br></div>
<div class="text">Mein Ziel in diesem und weiteren Artikeln ist es, dieses Framework zum Implementieren eigener Coroutinen zu erklären. Am Ende kannst du Coroutinen erzeugen oder existierende Implementierungen von Couroutinen wie die exzellente <a class="" title="Link auf https://github.com/lewissbaker/cppcoro" href="https://github.com/lewissbaker/cppcoro" alt="%7B%22user_params%22%3A%22%22%2C%22text%22%3A%22cppcoro-%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Flewissbaker%2Fcppcoro%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Flewissbaker%2Fcppcoro%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%7D">cppcoro-</a>Umsetzung von Lewis Baker verwenden. </div>
<div class="text">Der heutige Artikel ist ein Weder-noch-Artikel. Weder stellt dieser Artikel einen Überblick dar, noch steigt er tief in das Coroutinen-Framework ein. </div>
<div class="text">Die erste Frage, die du zu Coroutinen hast, wird wohl sein: Wann sollten Coroutinen verwendet werden?</div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/7/0/5/5/5/TN_191266428_a072fd76bd.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="ztitel">Typische Anwendungsfälle<br></div>
<div class="text">Coroutinen werden gerne für <a class="" href="https://github.com/lewissbaker/cppcoro" alt="%7B%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Flewissbaker%2Fcppcoro%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Event-getriebene%20Applikationen%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Flewissbaker%2Fcppcoro%22%7D" title="Link auf https://github.com/lewissbaker/cppcoro">Event-getriebene Applikationen</a> verwendet. Diese können eine Simulation, ein Spiel, ein Server, ein Benutzerinterface oder auch ein Algorithmus sein. So schrieb ich zum Beispiel vor ein paar Jahren einen Simulator für einen Defibrillator. Der Defibrillator kam vor allem für die klinischen Usability-Tests zum Einsatz und ist eine Event-getriebenen Applikation. Daher setze ich ihn mithilfe des Event-getriebenen Frameworks <a title="Link auf https://twistedmatrix.com/trac/" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Ftwistedmatrix.com%2Ftrac%2F%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22twisted%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Ftwistedmatrix.com%2Ftrac%2F%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%7D" href="https://twistedmatrix.com/trac/" class="">twisted</a> in Python um. </div>
<div class="text">Coroutinen werden auch gerne für kooperatives Multitasking eingesetzt. Die zentrale Idee des kooperativen Multitaskings ist es, dass sich jeder Task so viel Zeit nimmt, wie er benötigt. Kooperatives Multitasking unterscheidet sich vom präemptiven Multitasking darin, dass ein Scheduler entscheidet, wie lange jeder Task die CPU erhält. Kooperatives Multitasking erlaubt es, Concurrency einfacher umzusetzen, da ein Task nicht in einem kritischen Bereich unterbrochen wird. Wenn du mehr Aufklärung zu den Begriffen kooperativ und präemptiv suchst, kann ich nur diesen exzellenten Überblickartikel empfehlen: "<a class="" title="Link auf https://medium.com/traveloka-engineering/cooperative-vs-preemptive-a-quest-to-maximize-concurrency-power-3b10c5a920fe" alt="%7B%22destination%22%3A%22https%3A%2F%2Fmedium.com%2Ftraveloka-engineering%2Fcooperative-vs-preemptive-a-quest-to-maximize-concurrency-power-3b10c5a920fe%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Cooperative%20vs.%20Preemptive%3A%20a%20quest%20to%20maximize%20concurrency%20power%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fmedium.com%2Ftraveloka-engineering%2Fcooperative-vs-preemptive-a-quest-to-maximize-concurrency-power-3b10c5a920fe%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%7D" href="https://medium.com/traveloka-engineering/cooperative-vs-preemptive-a-quest-to-maximize-concurrency-power-3b10c5a920fe">Cooperative vs. Preemptive: a quest to maximize concurrency power</a>".</div>
<div class="ztitel">Grundlegende Ideen</div>
<div class="text">Coroutinen in C++20 sind asymmetrisch, first-class und stackless: </div>
<div class="text"><ul><li> Der Arbeitsablauf einer <b>asymmetrischen</b> Coroutinen geht zum Aufrufer zurück.</li><li><b>First-class</b>-Coroutinen verhalten sich wie Daten. "Verhalten wie Daten" meint, das sich diese Coroutinen als Argument oder Rückgabewert einer Funktion verwenden lassen oder in einer Variable gespeichert werden können. <br></li><li>Eine <b>Stackless</b>-Coroutine erlaubt es, die Top-Level-Coroutinen zu pausieren und wieder zu starten. Die Ausführung der Coroutinen und deren Wert geht an den Aufrufer der Coroutine. Im Gegensatz dazu reserviert eine Stackful-Coroutine einen Stack von 1 MByte auf Windows und 2 MByte auf Linux. <br></li></ul></div>
<div class="ztitel">Designziele</div>
<div class="text">Gor Nishanov, der maßgeblich an der Standardisierung von Coroutinen in C++ beteiligt ist, stellt die Designziele von Coroutinen vor. Sie sollen</div>
<div class="text"><ul><li>be highly scalable (to billions of concurrent coroutines).</li><li>have highly efficient resume and suspend operations comparable in cost to the overhead of a&nbsp;function.</li><li>seamlessly interact with existing facilities with no overhead.</li><li>have open-ended coroutine machinery allowing library designers to develop coroutine libraries.</li><li>exposing various high-level semantics such as generators, goroutines, tasks and more.</li><li>usable in environments where exceptions are forbidden or not available.</li></ul></div>
<div class="ztitel">Zur Coroutinen werden</div>
<div class="text">Eine Funktion, die die Schlüsselworte <span class="tx_code">co_return</span>, <span class="tx_code">co_yield</span> oder <span class="tx_code">co_return</span> verwendet, wird automatisch zur Coroutine:<br></div>
<div class="text"><ul><li><span class="tx_code"><b>co_return</b></span>: Eine Coroutine verwendet <span class="tx_code">co_return</span> als Rückgabeanweisung.</li><li><b><span class="tx_code">co_yield</span></b>: Dank <span class="tx_code">co_yield</span> lässt sich ein unendlicher Datenstrom implementieren, von dem sukzessive der Wert angefragt werden kann. Der Rückgabetyp der Funktion <span class="tx_code">generatorForNumbers(int begin, int inc = 1)</span>, die ich in dem letzten Artikel ("<a class="" href="https://heise.de/-4687457" alt="%7B%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%3A%20Coroutinen%20%5B--%5D%20ein%20erster%20%C3%9Cberblick%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4687457%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4687457%22%7D" title="Link auf https://heise.de/-4687457">C++20: Coroutinen [--] ein erster Überblick</a>") vorgestellt habe, ist ein Generator. Ein Generator besitzt einen speziellen Promise <span class="tx_code">pro</span>, sodass ein Aufruf <span class="tx_code">co_yield i</span> äquivalent zu <span class="tx_code">pro.yield_value(i)</span> ist. Unmittelbar nach dem Aufruf wird die Coroutinte schlafen gelegt. <br></li><li><b><span class="tx_code">co_await</span></b>: <span class="tx_code">co_await</span> führt eventuell dazu, dass die Ausführung einer Coroutine angehalten oder wieder aufgenommen wird. Der Ausdruck <span class="tx_code">exp</span> in <span class="tx_code">co_await</span> <span class="tx_code">exp</span> ist ein sogenannter awaitable-Ausdruck sein. Dazu setzt <span class="tx_code">exp</span> ein spezifisches Interface um. Es besteht aus den Funktionen <span class="tx_code">await_ready</span>, <span class="tx_code">await_suspend</span> und <span class="tx_code">await_resume</span>. <br></li></ul></div>
<div class="ztitel_kleiner">Zwei Awaitables</div>
<div class="text">Der C++20-Standard definiert bereits zwei Awaitables als elementare Bausteine: <span class="tx_code">std::suspend_always </span>und <span class="tx_code">std::suspend_never</span>.</div>
<div class="text"><ul><li><b><span class="tx_code">std::suspend_always:</span></b></li></ul></div>
<div class="pre">struct suspend_always {<br>&nbsp;&nbsp;&nbsp; constexpr bool await_ready() const noexcept { return false; }<br>&nbsp;&nbsp;&nbsp; constexpr void await_suspend(coroutine_handle&lt;&gt;) const noexcept {}<br>&nbsp;&nbsp;&nbsp; constexpr void await_resume() const noexcept {}<br>};<br></div>
<div class="text"><span class="tx_code">std::suspend_always</span> pausiert immer, da <span class="tx_code">await_ready false</span> zurückgibt. Genau das Gegenteil gilt für das zweite Awaitable <span class="tx_code">std::suspend_never. </span></div>
<div class="text"><ul><li><span class="tx_code"><b>std::suspend_never:</b> </span><br></li></ul></div>
<div class="pre">struct suspend_never {<br>&nbsp;&nbsp;&nbsp; constexpr bool await_ready() const noexcept { return true; }<br>&nbsp;&nbsp;&nbsp; constexpr void await_suspend(coroutine_handle&lt;&gt;) const noexcept {}<br>&nbsp;&nbsp;&nbsp; constexpr void await_resume() const noexcept {}<br>};</div>
<div class="text">Ich hoffe, dass das folgende Beispiel es einfacher macht, diese Theorie zu verdauen. Ein Server ist das "hello world"-Beispiel für eine Coroutine.</div>
<div class="ztitel_kleiner">Ein blockierender und ein wartender Server</div>
<div class="text">Ein Server ist eine Event-getriebene Applikation. Er wartet typischerweise in einer Evenschleife auf Clientanfragen.Der folgende Codeschnipsel stellt die Struktur eines einfachen Servers vor:<br></div>
<div class="pre">Acceptor acceptor{443};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; <br>while (true){<br>&nbsp;&nbsp;&nbsp; Socket socket= acceptor.accept(); // blocking (2)<br>&nbsp;&nbsp;&nbsp; auto request= socket.read();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // blocking (3)<br>&nbsp;&nbsp;&nbsp; auto response= handleRequest(request);<br>&nbsp;&nbsp;&nbsp; socket.write(response);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // blocking (4)<br>}<br></div>
<div class="text">Der sequenzielle Server beantwortet jede Clientanfrage in demselben Thread. Der Server lauscht auf den Post 443 (Zeile 1), nimmt jede Verbindung an (Zeile 2), liest die ankommenden Daten von dem Client (Zeile 3) ein und schickt seine Antwort an den Client zurück (Zeile 4). Die Aufrufe in den Zeilen 2 bis 4 sind blockierend. </div>
<div class="text">Dank <span class="tx_code">co_await</span> lassen sich die blockierenden Aufrufe einfach pausieren und wieder aufnehmen. Der ressourcenintensive blockierende Server wird dadurch zum ressourcenschonenden wartenden Server:</div>
<div class="pre">Acceptor acceptor{443};<br><br>while (true){<br>&nbsp;&nbsp;&nbsp; Socket socket= co_await acceptor.accept();<br>&nbsp;&nbsp;&nbsp; auto request= co_await socket.read();<br>&nbsp;&nbsp;&nbsp; auto response= handleRequest(request);<br>&nbsp;&nbsp;&nbsp; co_await socket.write(response);<br>}</div>
<div class="text">Du vermutest es wohl schon. Der entscheidende Ausdruck, um Coroutinen zu verstehen, sind die awaitable-Ausdrücke <span class="tx_code">expr</span> in <span class="tx_code">co_await expr</span>. Sie müssen die Funktionen <span class="tx_code">await_ready</span>, <span class="tx_code">await_suspend</span> und <span class="tx_code">await_resume</span> umsetzen.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Das Framework für das Schreiben von Coroutinen besteht aus mehr als 20 Funktionen. Diese gilt es zumindest teilweise zu implementieren oder zur überladen. Mit meinem nächsten Artikel tauche ich tiefer in das Framework ein.</div>
<div class="ztitel">Online-C++-Schulungen und ein paar persönliche Worte<br></div>
<div class="text">Aufgrund des Coronavirus biete ich alle meine Schulungen jetzt auch online an. Ich halte bereits seit mehr als 10 Jahren Online-Seminare. Dank der modernen Webkonferenz-Werkzeuge ist ein Online-Seminar mehr als ein Ersatz für eine Präsenzschulung. Ein Online-Seminar bietet Mehrwert gegenüber einer Präsenzschulung an. </div>
<div class="text">Online-Seminare: </div>
<div class="text"><ul><li> <a href="https://www.modernescpp.de/index.php/c/2-c/25-c-11-und-c-14-online" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F25-c-11-und-c-14-online%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F25-c-11-und-c-14-online%22%2C%22text%22%3A%22C%2B%2B11%2F14%3A%2018.%20bis%2020.%20Mai%202020%20%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%7D" title="Link auf https://www.modernescpp.de/index.php/c/2-c/25-c-11-und-c-14-online" class="">C++11/14: 18. bis 20. Mai 2020 </a> <br></li><li> <a class="" href="https://www.modernescpp.de/index.php/c/2-c/26-embedded-programmierung-mit-modernem-c-online" alt="%7B%22text%22%3A%22Embedded-Programmierung%20mit%20modernem%20C%2B%2B%3A%207.%20bis%209.%20Juli%202020%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F26-embedded-programmierung-mit-modernem-c-online%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F26-embedded-programmierung-mit-modernem-c-online%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%7D" title="Link auf https://www.modernescpp.de/index.php/c/2-c/26-embedded-programmierung-mit-modernem-c-online">Embedded-Programmierung mit modernem C++: 7. bis 9. Juli 2020</a> <br></li></ul></div>
<div class="text">Wir sollten die aktuelle Krise als Chance sehen und nutzen, analoge Muster durch digitale Lösungen zu ersetzen und das Mehr an Zeit sinnvoll zu investieren. Eine Krise lässt sich nicht durch Aussitzen lösen. Ich habe die Preise für meine Online-Seminare während der Krise deutlich reduziert. Wem der Preis noch zu hoch ist, der kann direkt mit mir (<a class="" title="Link auf schulung@ModernesCpp.de" href="mailto:schulung@ModernesCpp.de" alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22%22%2C%22href%22%3A%22mailto%3Aschulung%40ModernesCpp.de%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22schulung%40ModernesCpp.de%22%2C%22destination%22%3A%22schulung%40ModernesCpp.de%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E_Mail%22%7D">schulung@ModernesCpp.de</a>) Kontakt aufnehmen.<br></div>
