<div class="vorspann">Das wohl am einflussreichste Schlüsselwort im modernem C++ ist constexpr. Mit C++20 erhalten wir einen constexpr <span class="tx_code">std::vector</span> und einen <span class="tx_code">constexpr std::string</span>. Zusätzlich lassen sich beide Container mit den constexpr-Algorithmen der Standard Template Library zur Compilezeit modifizieren<br></div>
<div class="text">In diesem Artikel möchte ich die Summe und das Produkt mehrerer Zahlen zur Compilezeit berechnen. Je nachdem, welchen C++-Standard ich dabei einsetze, ist die Aufgabe anspruchsvoll und aufwendig oder geht leicht von der Hand. Der Artikel startet mit C++11. </div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/7/1/5/9/6/TN_199626681_5215dd3fb6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Variadic Templates in C++11<br></div>
<div class="text">Ein Variadic Template ist ein Template, das sich mit einer beliebigen Anzahl von Argumenten aufrufen lässt. Durch die Verwendung der Ellipse (...) wird <span class="tx_code">tails</span> zu einem Parameter-Pack. Nur zwei Operationen lassen sich auf ein Parameter-Pack anwenden: packen und entpacken. Wenn die Ellipse links von <span class="tx_code">tails</span> steht, wird gepackt, wenn sie rechts von <span class="tx_code">tails</span> steht, entpackt:</div>
<div class="pre">// compiletimeVariadicTemplates.cpp<br><br>#include &lt;iostream&gt;<br><br>template&lt;int...&gt;<br>struct sum;<br><br>template&lt;&gt;<br>struct sum&lt;&gt; {<br>&nbsp; static constexpr int value = 0;<br>};<br><br>template&lt;int i, int... tail&gt;<br>struct sum&lt;i, tail...&gt; {<br>&nbsp; static constexpr int value = i + sum&lt;tail...&gt;::value;<br>};<br><br>template&lt;int...&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>struct product;<br><br>template&lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>struct product&lt;&gt; {<br>&nbsp; static constexpr int value = 1;<br>};<br><br>template&lt;int i, int... tail&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>struct product&lt;i, tail...&gt; {<br>&nbsp; static constexpr int value = i * product&lt;tail...&gt;::value;<br>};<br><br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sum&lt;1, 2, 3, 4, 5&gt;::value: " &lt;&lt; sum&lt;1, 2, 3, 4, 5&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "product&lt;1, 2, 3, 4, 5&gt;::value: " &lt;&lt; product&lt;1, 2, 3, 4, 5&gt;::value &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Das Programm berechnet die Summe und das Produkt der Zahlen 1 bis 5 zur Compilezeit. Im Fall des Funktions-Templates <span class="tx_code">product</span> erklärt die Zeile (1) das primäre Template, die Zeile (2) die vollständige Spezialisierung für kein Argument und die Zeile (3) die partielle Spezialisierung für zumindest ein Argument. Die Definition des primären Templates ist nicht notwendig, falls sie nicht verwendet wird. Die partielle Spezialisierung (3) startet die rekursive Instanziierung, die dann zum Ende kommt, wenn alle Argumente konsumiert sind. In diesem Fall wird die vollständige Spezialisierung für kein Argument als Endbedingung verwendet. Wenn du die Entpackung des Parameter-Packs genauer studieren möchtest, studiere das Beispiel <span class="tx_code">compileTimeVariadicTemplate.cpp</span> auf <a title="Link auf https://cppinsights.io/s/33f60630" href="https://cppinsights.io/s/33f60630" alt="%7B%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F33f60630%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F33f60630%22%2C%22text%22%3A%22C%2B%2B%20Insights%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%7D" class="">C++ Insights</a>:<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/7/1/5/9/6/TN_199626686_dabf8958d8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Dank Fold Expressions wird diese Berechnung deutlich einfacher.</div>
<div class="ztitel">Fold Expression in C++17<br></div>
<div class="text">Mit C++17 können wir Parameter-Packs direkt über einem binären Operator reduzieren:</div>
<div class="pre">// compiletimeFoldExpressions.cpp<br><br>#include &lt;iostream&gt;<br><br>template&lt;typename... Args&gt;<br>auto sum(const Args&amp;... args)<br>{<br>&nbsp; return (args + ...);<br>}<br><br>template&lt;typename... Args&gt;<br>auto product(const Args&amp;... args)<br>{<br>&nbsp; return (args * ...);<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sum(1, 2, 3, 4, 5): " &lt;&lt; sum(1, 2, 3, 4, 5) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "product(1, 2, 3, 4, 5): " &lt;&lt; product(1, 2, 3, 4, 5) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Das Programm <span class="tx_code">compileTimeFoldExpressions.cpp</span> liefert dieselben Ergebnisse wie das vorherige Programm <span class="tx_code">compileTimeVariadicTemplates.cpp</span>:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/7/1/5/9/6/TN_199626692_b84e7d1d70.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Natürlich gibt es mehr zu Fold Expressions in C++17 zu erzählen. Diese Details lassen sich in meinem früheren Artikel <a class="" title="Link auf https://www.grimm-jaud.de/index.php/44-blog/funktional/190-fold-expressions" href="https://www.grimm-jaud.de/index.php/44-blog/funktional/190-fold-expressions" alt="%7B%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22text%22%3A%22Fold%20Expressions%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2F44-blog%2Ffunktional%2F190-fold-expressions%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2F44-blog%2Ffunktional%2F190-fold-expressions%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%7D">Fold Expressions</a> nachlesen. </div>
<div class="text">Jetzt will ich mich aber endlich mit C++20 beschäftigen.</div>
<div class="ztitel"><span class="tx_code">constexper</span>-Container und -Algorithmen in C++20</div>
<div class="text">C++20 unterstützt die <span class="tx_code">constexpr</span>-Container <span class="tx_code">std::vector</span> und <span class="tx_code">std::string</span>. <span class="tx_code">constexpr</span> bedeutet in diesem Fall, dass die Methoden beider Container zur Compilezeit ausgeführt werden können. </div>
<div class="text">Bevor ich aber über beide Container schreibe, muss ich nochmals einen kleinen Abstecher zu C++17 machen. Der Grund ist einfach: Kein Compiler unterstützt zum gegenwärtigen Zeitpunkt einen <span class="tx_code">constexpr</span> <span class="tx_code">std::vector</span> oder<span class="tx_code"> constexpr std::string</span>. Im Gegensatz dazu unterstützen der GCC und der MS Compiler die <span class="tx_code">constexpr</span>-Algorithmen der STL. </div>
<div class="text">In meinem folgenden Beispiel verwende ich anstelle des <span class="tx_code">constexpr std::vector</span> das <span class="tx_code">constexpr std::array</span>. Seit C++17 lässt sich ein <span class="tx_code">std::array</span> als <span class="tx_code">constexpr</span> deklarieren: <span class="tx_code">constexpr std::array myArray{1, 2, 3}.</span></div>
<div class="text">Jetzt geht der Spaß los. Mit C++20 lässt sich ein <span class="tx_code">std::array</span> zur Compilezeit verwenden:</div>
<div class="pre">// constexprArray.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;numeric&gt;<br>#include &lt;array&gt;<br><br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr std::array myArray{1, 2, 3, 4, 5};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; constexpr auto sum = std::accumulate(myArray.begin(), myArray.end(), 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sum: "&nbsp; &lt;&lt; sum &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto product = std::accumulate(myArray.begin(), myArray.end(), 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::multiplies&lt;int&gt;());<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "product: "&nbsp; &lt;&lt; product &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto product2 = std::accumulate(myArray.begin(), myArray.end(), 1,&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](auto a, auto b) { return a * b;});<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "product2: "&nbsp; &lt;&lt; product2 &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Das <span class="tx_code">std::array</span> (1) und alle Ergebnisse der Berechnungen sind als <span class="tx_code">constexpr</span> deklariert. Zeile (2) berechnet die Summe aller Elemente und die Zeilen (3) und (4) das Produkt aller Elemente von <span class="tx_code">myArrray</span>. Die Zeile (2) ist gültig, da <span class="tx_code">myArray</span> ein <span class="tx_code">constexpr</span>-Container und der Algorithmus <span class="tx_code">std::accumulate</span> als <span class="tx_code">constexpr</span> deklariert ist. Die Zeilen (3) und (4) sind deutlich interessanter. Der Klammeroperator von <span class="tx_code"> <a class="" alt="%7B%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Ffunctional%2Fmultiplies%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22std%3A%3Amultiplies%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Ffunctional%2Fmultiplies%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%7D" title="Link auf https://en.cppreference.com/w/cpp/utility/functional/multiplies" href="https://en.cppreference.com/w/cpp/utility/functional/multiplies">std::multiplies</a></span> ist <span class="tx_code">constexpr</span> deklariert und seit C++17 können Lambda-Ausdrücke <span class="tx_code">constexpr</span> sein.</div>
<div class="text">Hier ist die Ausgabe des Programms:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/7/1/5/9/6/TN_199626701_dc90acd83e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Dank des <a alt="%7B%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2Fezv7Po%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2Fezv7Po%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22text%22%3A%22Compiler%20Explorer%22%7D" title="Link auf https://godbolt.org/z/ezv7Po" href="https://godbolt.org/z/ezv7Po" class="">Compiler Explorer</a> kann ich die Ergebnisse der Berechnung deutlich beeindruckender präsentieren. Dies sind die entscheidenden Assembler-Instruktionen mit dem GCC: </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/7/1/5/9/6/TN_199626708_3dc03bcb02.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Zeilen 19, 29 und 39 zeigen, dass die Ergebnisse der Array-Berechnungen Werte in den Assember-Instruktionen sind. Das heißt, dass <span class="tx_code">std::accumulate</span> zur Compilezeit ausgeführt und die Ergebnisse zur Laufzeit vorhanden sind.</div>
<div class="text">Wie ich bereits geschrieben habe, unterstützt zum jetzigen Zeitpunkt kein Compiler einen <span class="tx_code">constexpr std::vector</span> oder <span class="tx_code">std::string</span>. Daher muss ich jetzt ein wenig schummeln und annehmen, dass mein Compiler beide <span class="tx_code">constexpr</span>-Container vollständig unterstützt:<br></div>
<div class="pre">// constexprVectorString.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr std::vector myVec {15, -5, 0, 5, 10};<br>&nbsp;&nbsp;&nbsp; constexpr std::sort(myVec.begin(), myVec.end());<br>&nbsp;&nbsp;&nbsp; for (auto v: myVec) std::cout &lt;&lt; v &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp;&nbsp;&nbsp; using namespace std::string_literals;<br>&nbsp;&nbsp;&nbsp; constexpr std::vector&lt;std::string&gt; myStringVec{"Stroustrup"s, "Vandevoorde"s, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Sutter"s, "Josuttis"s, "Wong"s };<br>&nbsp;&nbsp;&nbsp; constexpr std::sort(myStringVec.begin(), myStringVec.end());<br>&nbsp;&nbsp;&nbsp; for (auto s: myStringVec) std::cout &lt;&lt; s &lt;&lt; " ";<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>}<br></div>
<div class="text">Mit C++20 lässt sich ein <span class="tx_code">std::vector</span> oder ein <span class="tx_code">std::string</span> zur Compilezeit sortieren:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/7/1/5/9/6/TN_199626714_1cbbfe3f0e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">C++20 bietet zusätzlich viele Funktionen an, die den Umgang mit Containern der Standard Template Library deutlich angenehmer machen. Dank den Funktionen <span class="tx_code">std::erase</span>&nbsp;und&nbsp;<span class="tx_code">std::erase_if</span> geht das Löschen der Elemente eines Containers deutlich leichter von der Hand. Mit der Funktion <span class="tx_code">contains</span> ist es einfach zu bestimmen, ob ein bestimmtes Element in einem assoziativen Container enthalten ist.<br></div>