<div class="vorspann">Heute werde ich weitere praktische Werkzeuge in C++20 vorstellen. Mit diesen Werkzeugen lässt sich einfach der Mittelpunkt zweier Werte berechnen, prüfen, ob ein String mit einem gegebenen String anfängt oder endet, und einfach eine aufrufbare Einheit erzeugen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/8/6/5/8/9/TN_201168175_bc8024e1a3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Mein Artikel beginnt arithmetisch.</div>
<div class="ztitel">Mittelpunkt und lineare Interpolation<br></div>
<div class="text"><ul><li><span class="tx_code">std::midpoint(a, b)</span> berechnet den Mittelpunkt <span class="tx_code">(a + (b - a) / 2)</span> zweier Integrale, zweier Gleitkommazahlen oder zweier Zeiger. Wenn <span class="tx_code">a</span> und <span class="tx_code">b</span> Zeiger sind, müssen sie auf dasselbe Array verweisen.</li><li><span class="tx_code">std::lerp(a, b, t)</span> berechnet die lineare Interpolation <span class="tx_code">(a + t(b - a))</span>. Falls <span class="tx_code">t</span> außerhalb des Bereichs <span class="tx_code">[0, 1]</span> ist, berechnet die Funktion die lineare Extrapolation.<br></li></ul></div>
<div class="text">Das folgende einfache Programm wendet beide arithmetische Funktionen an:</div>
<div class="pre">// midpointLerp.cpp<br><br>#include &lt;cmath&gt;&nbsp;&nbsp;&nbsp;&nbsp; // std::lerp<br>#include &lt;numeric&gt;&nbsp;&nbsp; // std::midpoint<br>#include &lt;iostream&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::midpoint(10, 20): " &lt;&lt; std::midpoint(10, 20) &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; for (auto v: {0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0}) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::lerp(10, 20, " &lt;&lt; v &lt;&lt; "): " &lt;&lt; std::lerp(10, 20, v) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br><br>}<br></div>
<div class="text">Die Ausgabe des Programms sollte selbsterklärend sein. Falls nicht, habe ich das Programm auf dem <a class="" title="Link auf https://godbolt.org/z/Y8qsbz" alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FY8qsbz%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FY8qsbz%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Compiler%20Explorer%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%7D" href="https://godbolt.org/z/Y8qsbz">Compiler Explorer</a> hinterlegt. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/8/6/5/8/9/TN_201168176_8da462b1a4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">C++20 bietet einfache Funktionen an, um Arrays zu kreieren.</div>
<div class="ztitel">Arrays erzeugen</div>
<div class="text">Mit den Funktionen <span class="tx_code">std::to_array</span> und <span class="tx_code">std::make_shared</span> bietet C++20 neue Wege an, ein <span class="tx_code">std::array</span> und ein <span class="tx_code">std::shared_ptr</span> von C-Arrays zu erzeugen.</div>
<div class="ztitel">std::to_array<br></div>
<div>Dank der Funktion<span class="tx_code"> std::to_array</span> ist das Erzeugen eines <span class="tx_code">std::array</span> aus einem C-Array eine einfache Aufgabe:<br></div>
<div class="pre">// toArray.cpp<br><br>#include &lt;type_traits&gt;<br>#include &lt;utility&gt;<br>#include &lt;array&gt;<br>&nbsp;<br>int main(){<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; auto arr1 = std::to_array("C-String Literal");<br>&nbsp;&nbsp;&nbsp; static_assert(arr1.size() == 17);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; auto arr2 = std::to_array({ 0, 2, 1, 3 });&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; static_assert(std::is_same&lt;decltype(arr2), std::array&lt;int, 4&gt;&gt;::value); // (2)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; auto arr3 = std::to_array&lt;long&gt;({ 0, 1, 3 });&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; static_assert(std::is_same&lt;decltype(arr3), std::array&lt;long, 3&gt;&gt;::value); // (3)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; auto arr4 = std::to_array&lt;std::pair&lt;int, float&gt;&gt;( { { 3, .0f }, { 4, .1f }, { 4, .1e23f } });<br>&nbsp;&nbsp;&nbsp; static_assert(arr4.size() == 3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; static_assert(std::is_same&lt;decltype(arr4), std::array&lt;std::pair&lt;int, float&gt;, 3&gt;&gt;::value);<br>&nbsp;&nbsp; &nbsp;<br>}<br></div>
<div class="text">Die Zeilen (1), (2), (3) und (4) sichern zu, dass das erzeugte <span class="tx_code">std::array</span> den richtigen Typ und die richtige Länge besitzt.</div>
<div class="text">Per Design ist ein <span class="tx_code">std::array</span> so billig und so schnell wie ein C-Array. Falls du mehr Hintergrundinformation zu <span class="tx_code">std::array</span> benötigst und wissen willst, warum du ein C-Array nicht verwenden sollst, kann ich meinen Artikel empfehlen: <span class="tx_code"><a title="Link auf https://www.grimm-jaud.de/index.php/blog/keine-dynamische-speicherallokation-mit-std-array" class="" alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fkeine-dynamische-speicherallokation-mit-std-array%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fkeine-dynamische-speicherallokation-mit-std-array%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22text%22%3A%22std%3A%3Aarray%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%7D" href="https://www.grimm-jaud.de/index.php/blog/keine-dynamische-speicherallokation-mit-std-array">std::array</a></span><a alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fkeine-dynamische-speicherallokation-mit-std-array%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fkeine-dynamische-speicherallokation-mit-std-array%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22text%22%3A%22%20%5B-%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%7D" href="https://www.grimm-jaud.de/index.php/blog/keine-dynamische-speicherallokation-mit-std-array" title="Link auf https://www.grimm-jaud.de/index.php/blog/keine-dynamische-speicherallokation-mit-std-array" class=""> [-</a><a href="https://www.grimm-jaud.de/index.php/blog/keine-dynamische-speicherallokation-mit-std-array" alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fkeine-dynamische-speicherallokation-mit-std-array%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fkeine-dynamische-speicherallokation-mit-std-array%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22-%5D%20Keine%20dynamische%20Speicherallokation%20notwendig%22%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/keine-dynamische-speicherallokation-mit-std-array" class="">-] Keine dynamische Speicherallokation notwendig</a>.</div>
<div class="text">Darüber hinaus kennt <span class="tx_code">std::array</span> seine Größe und bietet das typische Interface eines Containers der Standard Template Library wie <span class="tx_code">std::vector</span> an.<br></div>
<div class="text">Zum jetzigen Zeitpunkt unterstützen bereits der MSVC, Clang und GCC Compiler diese komfortable Art, ein <span class="tx_code">std::array</span> zu erzeugen. Diese Unterstützung gilt aber nicht für das nächste Feature.</div>
<div class="ztitel">Ein std::shared_ptr aus einem C-Array erzeugen</div>
<div class="text">Seit C++11 besitzt C++ die Fabrikfunktion <span class="tx_code">std::make_shared</span>, um einen <span class="tx_code">std::shard_ptr</span> zu erzeugen. Mit C++20 unterstützt <span class="tx_code">std::make_shared</span> auch C-Arrays, mit denen sich <span class="tx_code">std::shared_ptr</span> von C-Arrays erzeugen lassen:</div>
<div class="pre">auto s1 = std::make_shared&lt;double[]&gt;(1024);<br>auto s2 = std::make_shared&lt;double[]&gt;(1024, 1.0);</div>
<div class="text"><span class="tx_code">s1</span> ist ein <span class="tx_code">std::shared_ptr</span> eines C-Arrays. Alle seine Mitglieder werden default-initialisiert. <span class="tx_code">s2</span> ist ein <span class="tx_code">std::shared_ptr</span> eines C-Arrays. Jedes Mitglied erhält den Wert 1.0.</div>
<div class="text">Im Gegensatz zu <span class="tx_code">std::make_shared</span> unterstützen aktuelle MSVC, Clang oder auch GCC die nächsten zwei neue Funktionen des <span class="tx_code">std::string</span>. <br></div>
<div class="ztitel">Prüfen, ob ein String mit einem Präfix beginnt oder einem Suffix endet<br></div>
<div class="text"><span class="tx_code">std::string</span> erhält die neuen Funktionen <span class="tx_code">starts_with</span> und <span class="tx_code">ends_with</span>. Diese Funktionen prüfen, ob ein<span class="tx_code"> std::string</span> mit einem vorgegebenen String beginnt oder endet:</div>
<div class="pre">// stringStartsWithEndsWith.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string_view&gt;<br>#include &lt;string&gt;<br>&nbsp;<br>template &lt;typename PrefixType&gt;<br>void startsWith(const std::string&amp; str, PrefixType prefix) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; starts with " &lt;&lt; prefix &lt;&lt; ": " <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; str.starts_with(prefix) &lt;&lt; '\n';&nbsp;&nbsp;&nbsp; // (1)<br>}<br><br>template &lt;typename SuffixType&gt;<br>void endsWith(const std::string&amp; str, SuffixType suffix) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ends with " &lt;&lt; suffix &lt;&lt; ": " <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; str.ends_with(suffix) &lt;&lt; '\n';<br>}<br>&nbsp;<br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::string helloWorld("Hello World");<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; helloWorld &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; startsWith(helloWorld, helloWorld);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; startsWith(helloWorld, std::string_view("Hello"));&nbsp; // (3)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; startsWith(helloWorld, 'H');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n"; <br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; helloWorld &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; endsWith(helloWorld, helloWorld);<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; endsWith(helloWorld, std::string_view("World"));<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; endsWith(helloWorld, 'd');<br>&nbsp;<br>}</div>
<div class="text">Beide Funktionen <span class="tx_code">starts_with</span> und <span class="tx_code">ends_with</span> sind Prädikate. Das heißt, dass sie einen Wahrheitswert zurückgeben. Die Funktion <span class="tx_code">starts_with</span> (Zeile 1) kann mit einem <span class="tx_code">std::string</span> (Zeile 2), einem <span class="tx_code">std::string_view</span> (Zeile 3) und einem <span class="tx_code">char</span> (Zeile 4) aufgerufen werden.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/8/6/5/8/9/TN_201168182_058574078a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Das nächste praktische Werkzeug in C++20 mag dich verwundern.</div>
<div class="ztitel">std::bind_front</div>
<div class="text"><span class="tx_code">std::bind_front (Func&amp;&amp; func, Args&amp;&amp; ... args)</span> erzeugt einen aufrufbaren Wrapper für eine aufrufbare Einheit <span class="tx_code">func.</span> <span class="tx_code">std::bind_front</span> kann beliebige viele Argumente annehmen und bindet diese vorne.</div>
<div class="text">Nun möchte ich über den verwunderlichen Punkt schreiben. Mit C++11 besitzt C++ <span class="tx_code">std::bind</span> und Lambda-Ausdrücke. Um ganz pedantisch zu sein, <span class="tx_code">std::bind</span> gibt es bereits seit dem <a class="" title="Link auf https://en.wikipedia.org/wiki/C++_Technical_Report_1" alt="%7B%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Technical%20Report%201%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FC%2B%2B_Technical_Report_1%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FC%2B%2B_Technical_Report_1%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%7D" href="https://en.wikipedia.org/wiki/C++_Technical_Report_1">Technical Report 1</a> (TR1). Beide können als Ersatz für <span class="tx_code">std::bind</span><span class="tx_code">_front </span>verwendet werden. Es geht noch weiter, <span class="tx_code">std::bind_front</span> lässt sich als kleiner Bruder von <span class="tx_code">std::bind </span>auffassen, den nur <span class="tx_code">std::bind</span> unterstützt das Umordnen der Argumente. Natürlich gibt es einen Grund in der Zukunft, <span class="tx_code">std::bind_front</span><span class="tx_code"> std::bind</span> vorzuziehen: <span class="tx_code">std::bind_front</span> propagiert Ausnahmespezifikationen des zugrunde liegenden Aufrufoperators.</div>
<div class="text">Das folgende Programm bringt auf den Punkt, dass sich mit <span class="tx_code">std::bind</span> oder Lambda-Ausdrücke ähnliche Anwendungsfälle wie mit <span class="tx_code">std::bind_front</span> umsetzen lassen:<br></div>
<div class="pre">// bindFront.cpp<br><br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br><br>int plusFunction(int a, int b) {<br>&nbsp;&nbsp;&nbsp; return a + b;<br>}<br><br>auto plusLambda = [](int a, int b) {<br>&nbsp;&nbsp;&nbsp; return a + b;<br>};<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; auto twoThousandPlus1 = std::bind_front(plusFunction, 2000);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "twoThousandPlus1(20): " &lt;&lt; twoThousandPlus1(20) &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; auto twoThousandPlus2 = std::bind_front(plusLambda, 2000);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "twoThousandPlus2(20): " &lt;&lt; twoThousandPlus2(20) &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; auto twoThousandPlus3 = std::bind_front(std::plus&lt;int&gt;(), 2000);&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "twoThousandPlus3(20): " &lt;&lt; twoThousandPlus3(20) &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; using namespace std::placeholders;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; auto twoThousandPlus4 = std::bind(plusFunction, 2000, _1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "twoThousandPlus4(20): " &lt;&lt; twoThousandPlus4(20) &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; auto twoThousandPlus5 =&nbsp; [](int b) { return plusLambda(2000, b); };&nbsp; // (5) <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "twoThousandPlus5(20): " &lt;&lt; twoThousandPlus5(20) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Jeder Aufruf (Zeilen 1 bis 5) erhält eine aufrufbare Einheit, die zwei Argumente annimmt und gibt eine aufrufbare Einheit zurück, die nur noch ein Argument benötigt, da das erste Argument bereits auf 2000 gesetzt ist. Die aufrufbare Einheit ist eine Funktion (Zeile 1), ein Lambda-Ausdruck (Zeile 2) oder ein vordefiniertes Funktionsobjekt (Zeile 3). <span class="tx_code">_1</span> ist ein sogenannter Platzhalter (Zeile 4), der in diesem Fall für das fehlende Argument steht. Mit einem Lambda-Ausdruck (Zeile 5) lässt sich direkt das erste Argument setzen und <span class="tx_code">b</span> für den fehlenden Parameter verwenden. Vom Standpunkt der Lesbarkeit betrachtet, sollte <span class="tx_code">std::bind_front</span> deutlich eingehender als <span class="tx_code">std::bind</span> oder der Lambda-Ausdruck sein.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/8/6/5/8/9/TN_201168192_92be8105d7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">In bekannter Manier lässt sich das Beispiel auf dem <a alt="%7B%22text%22%3A%22Compiler%20Explorer%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FbhY3MW%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FbhY3MW%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="https://godbolt.org/z/bhY3MW" class="" title="Link auf https://godbolt.org/z/bhY3MW">Compiler Explorer</a> verwenden.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">In meinem nächsten Artikel stelle ich die Erweiterungen der <a alt="%7B%22text%22%3A%22chrono%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fchrono%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fchrono%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="https://en.cppreference.com/w/cpp/chrono" title="Link auf https://en.cppreference.com/w/cpp/chrono" class="">chrono</a>-Bibliothek in C++20 vor: Tageszeit, Kalender und Zeitzonen.<br></div>