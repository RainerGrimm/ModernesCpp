<div class="vorspann">Zugegeben, ich stelle in dem heutigen Artikel ein paar kleine Verbesserungen zu Templates und zu C++20 im Allgemeinen vor. Obwohl diese Verbesserungen nicht so beeindruckend wirken, wird durch sie C++20 konsistenter und damit auch weniger fehleranfällig, wenn es um das generische Programmieren geht.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/4/2/3/6/2/TN_197393068_d4254ecb77.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Der heutige Artikel befasst sich mit dem bedingt expliziten Konstruktor und neuen Nichttyp (non-type) Template-Parameter.<br></div>
<div class="ztitel">Bedingt expliziter Konstruktor<br></div>
<div class="text">Häufig soll eine Klasse mehrere Konstruktoren besitzen, die verschiedene Datentypen annehmen kann. Zum Beispiel gilt dies für die Klasse <span class="tx_code">VariantWrapper</span>, die eine <span class="tx_code">std::variant</span> enthält.<br></div>
<div class="pre">class VariantWrapper {<br><br>&nbsp;&nbsp;&nbsp; std::variant&lt;bool, char, int, double, float, std::string&gt; myVariant;<br><br>};<br></div>
<div class="text">Um <span class="tx_code">myVariant</span> mit<span class="tx_code"> bool, char, int, double, float </span>oder<span class="tx_code"> std::string </span>zu initialisieren, benötigt die Klasse <span class="tx_code">VariantWrapper</span> Konstruktoren für jeden der aufgezählten Datentypen. Faulheit ist eine Tugend - zumindest für Programmierer. Daher bietet sich in diesem Fall ein generischer Konstruktor an.<br></div>
<div class="text">Die Klasse <span class="tx_code">Implicit</span> stellt einen generischen Konstruktor vor. <br></div>
<div class="pre">// explicitBool.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;type_traits&gt;<br><br>struct Implicit {<br>&nbsp;&nbsp;&nbsp; template &lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; Implicit(T t) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; t &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>struct Explicit {<br>&nbsp;&nbsp;&nbsp; template &lt;typename T&gt;<br>&nbsp;&nbsp;&nbsp; explicit Explicit(T t) {&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; t &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Implicit imp1 = "implicit";<br>&nbsp;&nbsp;&nbsp; Implicit imp2("explicit");<br>&nbsp;&nbsp;&nbsp; Implicit imp3 = 1998;<br>&nbsp;&nbsp;&nbsp; Implicit imp4(1998);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; // Explicit exp1 = "implicit";&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; Explicit exp2{"explicit"};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; // Explicit exp3 = 2011;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; Explicit exp4{2011};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;&nbsp; <br><br>} </div>
<div class="text">Diese Umsetzung besitzt ein Problem. Ein generischer Konstruktor (1) ist ein Catch-all-Konstruktor, da er mit jedem beliebigen Datentyp verwendet werden kann. Der Konstruktor ist viel zu gierig. Durch die Verwendung des Schlüsselworts <span class="tx_code">explicit</span> (1) vor dem Konstruktor wird dieser explizit. Das heißt, das er keine impliziten Konvertierungen (3) ausführt. Lediglich explizite Aufrufe (4) sind gültig. </div>
<div class="text">Dank dem Clang 10 Compiler ist hier die Ausgabe des Programms:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/4/2/3/6/2/TN_197393071_735d42a850.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Dies ist aber noch nicht das Ende der Geschichte. Eventuell möchte man einen Datentyp <span class="tx_code">MyBool</span> implementieren, der lediglich die implizite Konvertierung von <span class="tx_code">bool</span> erlaubt. Alle anderen impliziten Konvertierung sollen aber nicht zulässig sein. In diesem Fall lässt sich <span class="tx_code">explicit</span> auch bedingt verwenden.</div>
<div class="pre">// myBool.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br>#include &lt;typeinfo&gt;<br><br>struct MyBool {<br>&nbsp;&nbsp;&nbsp; template &lt;typename T&gt;<br>&nbsp;&nbsp;&nbsp; explicit(!std::is_same&lt;T, bool&gt;::value) MyBool(T t) {&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(t).name() &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>void needBool(MyBool b){ }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; MyBool myBool1(true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MyBool myBool2 = false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; needBool(myBool1);<br>&nbsp;&nbsp;&nbsp; needBool(true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; // needBool(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; // needBool("true");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Der <span class="tx_code">explicit(!std::is_same&lt;T,&nbsp; bool&gt;::value</span>) Ausdruck sichert zu, dass <span class="tx_code">MyBool</span> nur implizit von einem <span class="tx_code">bool</span>-Wert erzeugt werden kann. Die Funktion <span class="tx_code">std::is_same</span> ist ein Compile-Zeit-Prädikat der <a title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22Type-Traits%20Bibliothek%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%7D" href="https://en.cppreference.com/w/cpp/header/type_traits" class="">Type-Traits Bibliothek</a>. Compilezeit-Prädikat bedeutet, dass <span class="tx_code">std::is_same</span> beim Kompilieren ausgeführt wird und einen Wahrheitswert zurückgibt. Konsequenterweise sind die impliziten Konvertierung von <span class="tx_code">bool</span> in (3) und (4) zulässig. Diese implizite Konvertierung für einen <span class="tx_code">int</span>- und einen C-String-Wert ist aber nicht in Zeile (5) zulässig. </div>
<div class="text">Nun könnte man einwenden, dass der bedingt explizite Konstruktor sich auch mit <a class="" href="https://en.cppreference.com/w/cpp/language/sfinae" title="Link auf https://en.cppreference.com/w/cpp/language/sfinae" alt="%7B%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fsfinae%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22SFINAE%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fsfinae%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D">SFINAE</a> umsetzen ließe. Ehrlich gesagt bin ich kein Freund des entsprechenden Konstruktors, der SFINAE verwendet. Zum einen benötige ich mehrere Sätze, um ihn zu erklären, zum anderen habe ich ihn erst nach dem dritten Versuch richtig implementiert.</div>
<div class="pre">template &lt;typename T, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool&gt;, bool&gt; = true&gt;<br>MyBool(T&amp;&amp; t) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(t).name() &lt;&lt; std::endl;<br>}<br></div>
<div class="text">Ich denke, jetzt sind ein paar erklärende Worte notwendig. SFINAE steht für Substitution Failure Is Not An Error und wird während der Überladung von Funktions-Templates angewandt. Es bedeutet: Wenn bei der Ersetzung der Template-Parameter ein Fehler auftritt, ist dies kein Fehler. Diese Instantiierung der Template-Parameter wird aus der Menge aller Funktionsüberladungen entfernt. Genau das passiert in dem konkreten Fall. Die Spezialisierung wird entfernt, wenn <span class="tx_code">std::is_same_v&lt;std::decay_t&lt;T&gt;, bool&gt;</span> zu <span class="tx_code">false</span> evaluiert. <span class="tx_code">std::decay&lt;T&gt;</span> wendet Konvertierung auf <span class="tx_code">T </span>wie das Entfernen von <span class="tx_code">const</span>, <span class="tx_code">volatile</span> oder das Entfernen einer Referenz von <span class="tx_code">T</span> an. <span class="tx_code">std::decay_t&lt;T&gt;</span> ist eine angenehme Schreibeweise für <span class="tx_code">std::decay&lt;T&gt;::type</span>. Dasselbe gilt für <span class="tx_code">std::is_same_v&lt;T, bool&gt;</span> als Kurzform für <span class="tx_code">std::is_same&lt;T, bool&gt;::value</span>.</div>
<div class="text">Neben meiner länglichen Erklärung gibt es ein weiteres Argument, das gegen SFINAE und für den bedingten expliziten Konstruktor spricht: Performanz. Simon Brand hat in seinem Artikel "<a alt="%7B%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fdevblogs.microsoft.com%2Fcppblog%2Fc20s-conditionally-explicit-constructors%2F%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%27s%20Conditionally%20Explicit%20Constructors%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fdevblogs.microsoft.com%2Fcppblog%2Fc20s-conditionally-explicit-constructors%2F%22%7D" title="Link auf https://devblogs.microsoft.com/cppblog/c20s-conditionally-explicit-constructors/" class="" href="https://devblogs.microsoft.com/cppblog/c20s-conditionally-explicit-constructors/">C++20's Conditionally Explicit Constructors</a>"&nbsp; dargestellt, dass Template Instanziierung mit <span class="tx_code">explicit(bool)</span> im Falle von Visual Studio 2019 um 15% schneller ist als die Template Instanziierung mit SFINAE.</div>
<div class="text">Mit C++20 werden auch weitere Nichttyp (non-type) Template-Parameter unterstützt.</div>
<div class="ztitel">Neue Nichttyp Template-Parameter</div>
<div class="text">Mit C++20 werden Fließkommazahlen und Klassen mit <span class="tx_code">constexpr</span> Konstruktor als Nichttypen unterstützt.</div>
<div class="text">C++ unterstützt bereits Nichttypen als Template-Parameter. Im Wesentlichen sind Nichttypen</div>
<div class="text"><ul><li>Ganzzahlen oder Aufzähler<br></li><li>Zeiger oder Referenzen auf Objekte, Funktionen oder Mitglieder einer Klasse</li><li><span class="tx_code">std::nullptr_t</span><br></li></ul></div>
<div class="text">Wenn ich die Teilnehmer meiner Schulung frage, ob sie bereits Nichttypen als Template-Parameter verwendet haben, ist die einheitliche Antwort: Nein! Natürlich beantworte ich direkt meine knifflige Frage und stelle ein oft verwendetes Beispiel für Nichttyp Template-Parameter vor.</div>
<div class="pre">std::array&lt;int, 5&gt; myVec;</div>
<div class="text">5 ist ein Nichttyp und wird als Template-Argument verwendet. Seit dem ersten Standard C++98 gibt es die Diskussion in der C++-Community, dass Fließkommazahlen auch als Template-Parameter unterstützt werden sollten. Mit C++20 stehen sie zur Verfügung.</div>
<div class="pre">// nonTypeTemplateParameter.cpp<br><br>struct ClassType {<br>&nbsp;&nbsp;&nbsp; constexpr ClassType(int) {}&nbsp; // (1)<br>};<br><br>template &lt;ClassType cl&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>auto getClassType() {<br>&nbsp;&nbsp;&nbsp; return cl;<br>}<br><br>template &lt;double d&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>auto getDouble() {<br>&nbsp;&nbsp;&nbsp; return d;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; auto c1 = getClassType&lt;ClassType(2020)&gt;();<br><br>&nbsp;&nbsp;&nbsp; auto d1 = getDouble&lt;5.5&gt;();&nbsp; // (4) <br>&nbsp;&nbsp;&nbsp; auto d2 = getDouble&lt;6.5&gt;();&nbsp; // (4) <br><br>}<br></div>
<div class="text"><span class="tx_code">ClassType</span> besitzt einen <span class="tx_code">constexpr</span> Konstruktor (1) und kann daher als Template-Argument verwendet werden (2). Dieselbe Beobachtung gilt für das Funktions-Template <span class="tx_code">getDouble </span>(3), das nur <span class="tx_code">double</span>-Werte annimmt. Ich möchte es explizt betonen, dass jeder Aufruf des Funktions-Templates <span class="tx_code">getDouble</span> (4) mit einem neuen Argument die Instanziierung einer Funktion <span class="tx_code">getDouble</span> bewirkt. Das bedeutet, dass zwei Instanziierung für die <span class="tx_code">double</span>-Werte 5.5 und 6.5 erzeugt werden. </div>
<div class="text">Wenn der Clang-Compiler dieses Feature bereits unterstützen würde, könnte ich schön mit C++ Insights zeigen, dass jede Instanziierung für 5.5 und 6.5 ein vollständig spezialisiertes Funktions-Template erzeugen würde. Zumindest kann ich aber dank des GCC-Compilers und dem <a alt="%7B%22text%22%3A%22Compiler%20Explorer%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf https://godbolt.org/" href="https://godbolt.org/" class="">Compiler Explorer</a> die entscheidenden Assemblerbefehle vorstellen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/4/2/3/6/2/TN_197393079_f474cbe3bf.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Der Screenshot zeigt, dass der Compiler für jedes Template-Argument eine Funktion erzeugt.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Ähnlich wie Templates erfahren Lambdas auch einige Verbesserungen in C++20. In meinem nächsten Artikel gehe ich auf diese Verbesserungen ein.<br></div>
