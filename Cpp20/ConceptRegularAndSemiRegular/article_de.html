<div class="vorspann">Ein konkreter Datentyp, der sich intuitiv im C++-Ökosystem verwenden lässt, sollte sich wie ein <span class="tx_code">int</span> verhalten. Formaler ausgedrückt, sollte der konkrete Datentyp das Concept <span class="tx_code">Regular </span>unterstützen. In diesem Artikel werde ich die Concepts <span class="tx_code">SemiRegular</span> und <span class="tx_code">Regular</span> definieren.</div>
<div class="text"><span class="tx_code">Regular</span> und <span class="tx_code">SemiRegular</span> sind wichtige Ideen in C++. Sorry, ich sollte Concepts sagen. Zum Beispiel lautet die Regel T.46 der C++ Core Guidelines: <a alt="%7B%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22T.46%3A%20Require%20template%20arguments%20to%20be%20at%20least%20Regular%20or%20%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-regular%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-regular%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-regular" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-regular" class="">T.46: Require template arguments to be at least Regular or </a><span class="tx_code"><a class="" alt="%7B%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-regular%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-regular%22%2C%22text%22%3A%22SemiRegular%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-regular" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-regular">SemiRegular</a></span>. Jetzt muss ich nur noch eine Frage beantworten. Was sind <span class="tx_code">Regular</span>- und <span class="tx_code">SemiRegula</span><span class="tx_code">r</span>-Datentypen? Bevor ich in die Details eintauche, ist das die informelle Antwort: </div>
<div class="text">Ein <span class="tx_code">Regular</span>-Datentyp "behaves like an <span class="tx_code">int</span>". Er kann kopiert werden und das Ergebnis des Kopierens ist unabhängig vom Original. Beide haben nach dem Kopieren den gleichen Wert.</div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/3/5/6/7/3/TN_187934168_a704ce3dd9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Jetzt wird es formaler. Ein <span class="tx_code">Regular-</span>Datentyp ist ein <span class="tx_code">SemiRegula</span><span class="tx_code">r</span>-Datentyp. Konsequenterweise starte ich mit einem <span class="tx_code">SemiRegular</span>-Datentyp.</div>
<div class="ztitel">SemiRegular</div>
<div class="text">Ein <span class="tx_code">SemiRegular</span>-Datentyp muss die <a class="" href="https://heise.de/-3813435" alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-3813435%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-3813435%22%2C%22text%22%3A%22Sechserregel%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf https://heise.de/-3813435">Sechserregel</a> umsetzen und zusätzlich <span class="tx_code">swap</span> unterstützen.<br></div>
<div class="text"><ul><li>Default-Konstruktor: <span class="tx_code">X()</span></li><li>Copy-Konstruktor:&nbsp;<span class="tx_code">X(const X&amp;)</span></li><li>Copy-Zuweisungsoperator:&nbsp;<span class="tx_code">operator=(const X&amp;)</span></li><li>Move-Konstruktor:&nbsp;<span class="tx_code">X(X&amp;&amp;)</span></li><li>Move-Zuweisungsoperator:&nbsp;<span class="tx_code">operator=(X&amp;&amp;)</span></li><li>Destruktor:&nbsp;<span class="tx_code">~X()</span></li><li>swap: <span class="tx_code">swap(X&amp;, Y&amp;)</span></li></ul></div>
<div class="text">Das war einfach. Dank der Typ-Traits-Bibliothek ist die Definition des entsprechendes Concepts reine Fingerarbeit. Erst werde ich das Typ-Trait <span class="tx_code">isSemiRegular</span> definieren und mit diesem das Concept <span class="tx_code">SemiRegular</span> umsetzen:<br></div>
<div class="pre">template&lt;typename T&gt;<br>struct isSemiRegular: std::integral_constant&lt;bool,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_default_constructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_copy_constructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_copy_assignable&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_move_constructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_move_assignable&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_destructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_swappable&lt;T&gt;::value &gt;{};<br><br><br>template&lt;typename T&gt;<br>concept SemiRegular = isSemiRegular&lt;T&gt;::value;</div>
<div class="text">Jetzt geht es weiter mit dem Concept <span class="tx_code">Regular</span>.<br></div>
<div class="ztitel">Regular<br></div>
<div class="text">Ein kleiner Schritt fehlt noch, und ich kann das Concept <span class="tx_code">Regular</span> definieren. Zusätzlich zum Concept <span class="tx_code">SemiRegular</span> verlangt das Concept <span class="tx_code">Regular</span> von seinen Datentypen, dass sie auch Gleichheit unterstützen. Ich habe bereits in meinem <a href="https://heise.de/-4641098" title="Link auf https://heise.de/-4641098" alt="%7B%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4641098%22%2C%22text%22%3A%22letzten%20Artikel%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4641098%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%7D" class="">letzten Artikel</a> das Concept <span class="tx_code">Equal</span> implementiert:<br></div>
<div class="pre">template&lt;typename T&gt;<br>concept Equal =<br>&nbsp;&nbsp;&nbsp; requires(T a, T b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a == b } -&gt; std::convertible_to&lt;bool&gt;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a != b } -&gt; std::convertible_to&lt;bool&gt;;<br>};<br></div>
<div class="text">Nun muss ich nur noch das Concept<span class="tx_code"> Equal </span>für das Concept <span class="tx_code">Regular</span> wiederverwenden:<br></div>
<div class="pre">template&lt;typename T&gt;<br>concept Regular = Equal&lt;T&gt; &amp;&amp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SemiRegular&lt;T&gt;;<br></div>
<div class="text">Jetzt bin ich neugierig. Wie sind die beiden Concepts <span class="tx_code">SemiRegular</span> und <span class="tx_code">Regular</span> im C++20-Standard definiert? <br></div>
<div class="ztitel_kleiner">regular und semiregular in C++20</div>
<div class="pre">template&lt;class T&gt;<br>concept movable = is_object_v&lt;T&gt; &amp;&amp; move_constructible&lt;T&gt; &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assignable_from&lt;T&amp;, T&gt; &amp;&amp; swappable&lt;T&gt;;<br><br>template&lt;class T&gt;<br>concept copyable = copy_constructible&lt;T&gt; &amp;&amp; movable&lt;T&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; assignable_from&lt;T&amp;, const T&amp;&gt;;<br><br>template&lt;class T&gt;<br>concept semiregular = copyable&lt;T&gt; &amp;&amp; default_constructible&lt;T&gt;;<br><br>template&lt;class T&gt;<br>concept regular = semiregular&lt;T&gt; &amp;&amp; equality_comparable&lt;T&gt;;<br></div>
<div class="text">Nebenbei gesagt, es gibt außer didaktischen Gründen keinen Grund, die Concepts <span class="tx_code">Regular</span> und <span class="tx_code">SemiRegular</span> selbst zu definieren. </div>
<div class="text">Interessanterweise ist das Concept <span class="tx_code">regular</span> meinem Concept<span class="tx_code"> Regular</span> sehr ähnlich. Diese Beobachtung gilt nicht für das Concept <span class="tx_code">semiregular</span>, das aus elementaren Concepts wie<span class="tx_code"> copyable</span> und <span class="tx_code">moveable</span> komponiert ist. Das Concept <span class="tx_code">movable</span> basiert auf der Funktion <a href="https://en.cppreference.com/w/cpp/types/is_object" title="Link auf https://en.cppreference.com/w/cpp/types/is_object" alt="%7B%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_object%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22%5Bcode%5Dis_object%5B%2Fcode%5D%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_object%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" class="">[code]is_object[/code]</a> aus der Typ-Traits-Bibliothek. Auf der referenzierten Seite findet sich auch eine mögliche Implementierung des Typ-Traits<span class="tx_code"> is_object</span>.</div>
<div class="text">Jetzt fehlt noch der letzte Schritt in meinem Artikel: die Concepts anwenden.<br></div>
<div class="ztitel">Anwendung der Concepts regular und regular</div>
<div class="text">Um es einfach zu machen, prüfen die Funktions-Template <span class="tx_code">behavesLikeAnInt</span> und <span class="tx_code">behavesLikeAnInt2</span>, ob die Argumente sich wie <span class="tx_code">int</span>'s verhalten. Das heißt, dass ich mein Concept <span class="tx_code">Regular</span> und das Concept <span class="tx_code">regula</span><span class="tx_code">r</span> des C++20-Standards verwende, um die Typanforderung zu prüfen:</div>
<div class="pre">// regularSemiRegular.cpp<br><br>#include &lt;concepts&gt;<br>#include &lt;vector&gt;<br>#include &lt;utility&gt;<br><br>template&lt;typename T&gt;<br>struct isSemiRegular: std::integral_constant&lt;bool,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_default_constructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_copy_constructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_copy_assignable&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_move_constructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_move_assignable&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_destructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_swappable&lt;T&gt;::value &gt;{};<br><br><br>template&lt;typename T&gt;<br>concept SemiRegular = isSemiRegular&lt;T&gt;::value;<br><br>template&lt;typename T&gt;<br>concept Equal =<br>&nbsp;&nbsp;&nbsp; requires(T a, T b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a == b } -&gt; std::convertible_to&lt;bool&gt;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a != b } -&gt; std::convertible_to&lt;bool&gt;;<br>};<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>concept Regular = Equal&lt;T&gt; &amp;&amp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SemiRegular&lt;T&gt;;<br><br>template &lt;Regular T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>void behavesLikeAnInt(T) {<br>&nbsp;&nbsp;&nbsp; // ...<br>}<br><br>template &lt;std::regular T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>void behavesLikeAnInt2(T) {<br>&nbsp;&nbsp;&nbsp; // ...<br>}<br><br>struct EqualityComparable { };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>bool operator == (EqualityComparable const&amp;, EqualityComparable const&amp;) { <br>&nbsp;&nbsp;&nbsp; return true; <br>}<br><br>struct NotEqualityComparable { };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; int myInt{};<br>&nbsp;&nbsp;&nbsp; behavesLikeAnInt(myInt);<br>&nbsp;&nbsp;&nbsp; behavesLikeAnInt2(myInt);<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; myVec{};<br>&nbsp;&nbsp;&nbsp; behavesLikeAnInt(myVec);<br>&nbsp;&nbsp;&nbsp; behavesLikeAnInt2(myVec);<br><br>&nbsp;&nbsp;&nbsp; EqualityComparable equComp;<br>&nbsp;&nbsp;&nbsp; behavesLikeAnInt(equComp);<br>&nbsp;&nbsp;&nbsp; behavesLikeAnInt2(equComp);<br><br>&nbsp;&nbsp;&nbsp; NotEqualityComparable notEquComp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; behavesLikeAnInt(notEquComp);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp; behavesLikeAnInt2(notEquComp);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Ich habe einfach alle Bausteinchen der vorherigen Codebeispiel zusammengestellt und damit das Concept <span class="tx_code">Regular</span> (Zeile 1) definiert. Die Funktionen <span class="tx_code">behavesLikeAnInt </span>(Zeile 2) und <span class="tx_code">behavesLikeAnIn</span><span class="tx_code">t2</span> (Zeile 3) verwenden die Concepts. Wie es der Name verspricht, unterstützt der Datentyp <span class="tx_code">EqualityCompareable </span>(Zeile 4) Gleichheit. Dies gilt aber nicht für den Datentyp <span class="tx_code">NotEqualityComarable</span> (Zeile 5). Am Interessantesten ist die Anwendung des Datentyps <span class="tx_code">NotEqualityComparable</span> in den Zeilen&nbsp; 6 und 7.</div>
<div class="ztitel_kleiner">GCC</div>
<div class="text">Wenn du das Programm in Aktion sehen willst, verwende den Link auf den Compiler Explorer: <a class="" href="https://godbolt.org/z/XAJ2w3" alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FXAJ2w3%22%2C%22text%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FXAJ2w3%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FXAJ2w3%22%7D" title="Link auf https://godbolt.org/z/XAJ2w3">https://godbolt.org/z/XAJ2w3</a>. Die Fehlermeldung im Compiler Explorer mit dem GCC ist sehr genau, aber ein wenig unübersichtlich. Dies ist wohl der Tatsache geschuldet, dass beide Concepts fehlgeschlagen sind, Concepts sich noch in einem frühen Implementierungsstadium befinden und Online-Werkzeuge nicht so komfortabel wie eine Konsole sind.</div>
<div class="text"><ul><li><b> Das Concept <span class="tx_code">Regular</span></b></li></ul></div>
<div class="text">Dies sind die entscheidenden Zeilen, die mein Concept <span class="tx_code">Regular</span> (Zeile 6) mithilfe des Compiler Explorer ausgibt:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/3/5/6/7/3/TN_187934171_f960142fc7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text"><ul><li><b>Das Concept </b><span class="tx_code">regular</span></li></ul></div>
<div class="text">Das C++20-Concept <span class="tx_code">regular</span> besitzt eine ausgefeiltere Implementierung. Daher erzeugt sich auch eine ausgefeiltere Fehlermeldung: </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/3/5/6/7/3/TN_187934180_34b866e84b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="ztitel_kleiner">MSVC</div>
<div class="text">Die Fehlermeldung des Windows-Compilers ist mir zu unspezifisch:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/3/5/6/7/3/TN_187934183_5a86d867d0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Mit diesem Artikel habe ich meine Miniserie zu Concepts abgeschlossen. Natürlich bin ich jetzt an deiner Meinung interessiert: <b>Sind Concepts eine Evolution oder eine Revolution in C++? </b>Schicke mir doch deine Meinung oder schreibe einen Kommentar, bis einschließlich Donnerstag, den 6. Februar. Gerne möchte ich das Stimmungsbild in meinem nächsten Artikel zusammenfassen. Falls ich dich namentlich nennen soll, schreibe mir dies explizit und nenne deinen Namen.<br></div>
