<div class="vorspann">In den letzten Wochen habe ich etwas Neues zu Modulen in C++20 gelernt: <span class="tx_code">private</span> Module Fragment und Header Units. Deshalb mache ich in diesem Beitrag einen kleinen Umweg über Module und stelle deren neue Funktionalität vor.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/6/3/3/4/2/TN_216363933_da4838855a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Du fragst dich vielleicht, warum ich meinen angekündigten Beitrag über Variadic Templates verschiebe? Der Grund ist einfach. Mein kommendes <a title="Link auf https://www.modernescpp.com/index.php/what-pdf-bundle-do-you-want-make-your-choice" alt="%7B%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22pdf-Bundle%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fwhat-pdf-bundle-do-you-want-make-your-choice%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fwhat-pdf-bundle-do-you-want-make-your-choice%22%2C%22mediasync_id%22%3A%22%22%7D" href="https://www.modernescpp.com/index.php/what-pdf-bundle-do-you-want-make-your-choice">pdf-Bundle</a>, das ich nächste Woche veröffentliche, beinhaltet die C++20-Module und ich möchte diesen Beitrag in das Bundle einbinden, daher ziehe ich dessen Veröffentlichung vor.<br></div><div class="text">Ein <span class="tx_code">private</span> Module Fragment und Header Units machen den Umgang mit Modulen in C++20 deutlich komfortabler.<br></div><div class="text">Ich verwende in diesem Beitrag absichtlich den neuesten Visual Studio Compiler, denn er unterstützt C++20-Module fast vollständig. Die neuesten GCC und Clang Compiler unterstützen Module hingegen nur teilweise.<br></div><div class="ztitel"><span class="tx_code">private</span> Module Fragment<br></div><div class="text">Ich bin mir nicht sicher, ob du die Fakten über die Module Interface Unit und die Module Implementation Unit parat hast? Deshalb möchte ich die wichtigsten wiederholen.<br></div><div class="text">Wenn du das Modul in ein Interface und dessen Implementierung separieren willst, bietet es sich an, es in eine Module Interface Unit und eine oder mehrere Module Implementation Units zu unterteilen.</div><div class="ztitel_kleiner">Module Interface Unit<br></div><div class="pre">// mathInterfaceUnit2.ixx<br><br>module;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>#include &lt;vector&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>export module math;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>export namespace math {<br><br>&nbsp;&nbsp;&nbsp; int add(int fir, int sec);<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; int getProduct(const std::vector&lt;int&gt;&amp; vec);<br><br>}</div><div class="text"><ul><li>Die Module Interface Unit enthält die exportierende Moduldeklaration:<span class="tx_code"> export module math</span>.</li><li>Die Namen <span class="tx_code">add</span> und <span class="tx_code">getProduct</span> werden exportiert.</li><li>Ein Modul kann nur eine Module Interface Unit besitzen.</li></ul></div><div class="ztitel_kleiner">Modul Implementation Unit</div><div class="pre">// mathImplementationUnit2.cpp<br><br>module math;<br><br>#include &lt;numeric&gt;<br><br>namespace math {<br><br>&nbsp;&nbsp;&nbsp; int add(int fir, int sec){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir + sec;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; int getProduct(const std::vector&lt;int&gt;&amp; vec) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::accumulate(vec.begin(), vec.end(), 1, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::multiplies&lt;int&gt;());<br>&nbsp;&nbsp; }<br>}</div><div class="text"><ul><li>Die Module Implementation Unit enthält nicht-exportierende Moduldeklarationen: <span class="tx_code">module math;.</span></li><li>Ein Modul kann mehr als eine Module Implementation Unit besitzen.</li></ul></div><div class="text">Das <span class="tx_code">main</span>-Programm</div><div class="pre">// client4.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>import math;<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';&nbsp; &nbsp;<br>&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "math::add(2000, 20): " &lt;&lt; math::add(2000, 20) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; myVec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "math::getProduct(myVec): " &lt;&lt; math::getProduct(myVec) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; &nbsp;<br>}&nbsp;&nbsp;&nbsp;&nbsp; </div><div class="text">Aus der Sicht des Benutzers wurde nur der Namensraum <span class="tx_code">math</span> hinzugefügt. <br></div><div class="ztitel_kleiner">Erstellen der ausführbaren Datei<br></div><div class="text">Das manuelle Erstellen der ausführbaren Datei umfasst folgende Schritte.<br></div><div class="pre">cl.exe /std:c++latest /c mathInterfaceUnit2.ixx /EHsc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>cl.exe /std:c++latest /c mathImplementationUnit2.cpp /EHsc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>cl.exe /std:c++latest /c client4.cpp /EHsc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>cl.exe client4.obj mathInterfaceUnit2.obj mathImplementationUnit2.obj // (4)<br></div><div class="text"><ol><li>Erzeugt die Objektdatei <span class="tx_code">mathInterfaceUnit2.obj </span>und die Modulschnittstellendatei <span class="tx_code">math.ifc</span>.</li><li>Erzeugt die Objektdatei <span class="tx_code">mathImplementationUnit2.obj</span>.</li><li>Erzeugt die Objektdatei <span class="tx_code">client4.obj</span>.</li><li>Erzeugt die ausführbare Datei<span class="tx_code"> client4.exe</span>.<br></li></ol></div><div class="text">Für den Microsoft-Compiler muss das Modell für die Ausnahmebehandlung (<span class="tx_code">/EHsc</span>) zusätzlich angeben werden. Verwende außerdem das Flag<span class="tx_code"> /std:c++latest</span>.<br></div><div class="text">Zum Abschluss liefert das Programm dann diese Ausgabe:<br></div><div class="text">&nbsp;<img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/6/3/3/4/2/TN_216363941_99249d9449.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Einer der großen Vorteile der Strukturierung von Modulen in eine Module Interface Unit und eine oder mehrere Module Implementation Units ist, dass sich Änderungen in den Module Implementation Units nicht auf die Module Interface Unit auswirken und daher keine Neukompilierung erforderlich ist.</div><div class="ztitel_kleiner"><span class="tx_code">private</span> Module Fragment<br> </div><div class="text">Dank eines <span class="tx_code">private</span> Module Fragment kannst du ein Modul in einer Datei implementieren und seinen letzten Teil mit <span class="tx_code">module :private;</span> als seine Implementierung deklarieren. Folglich führt eine Änderung des privaten Modulfragments nicht zu einer Neukompilierung des Moduls. Die folgende Moduldeklarationsdatei <span class="tx_code">mathInterfaceUnit3.ixx </span>fasst die Module Interface Unit<span class="tx_code"> mathInterfaceUnit2.ixx</span> und die Module Implementation Unit <span class="tx_code">mathImplementationUnit2.cpp</span> in einer Datei zusammen.<br> </div><div class="pre">// mathInterfaceUnit3.ixx<br><br>module;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>#include &lt;numeric&gt;<br>#include &lt;vector&gt;<br><br>export module math;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>export namespace math {<br><br>&nbsp;&nbsp; int add(int fir, int sec);<br><br>&nbsp;&nbsp; int getProduct(const std::vector&lt;int&gt;&amp; vec);<br><br>}<br><br>module :private; // (1)<br><br>int add(int fir, int sec) {<br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>}<br><br>int getProduct(const std::vector&lt;int&gt;&amp; vec) {<br>&nbsp;&nbsp;&nbsp; return std::accumulate(vec.begin(), vec.end(), 1, std::multiplies&lt;int&gt;());<br>}<br></div><div class="text"><span class="tx_code">module: private;</span> (Zeile 1) kennzeichnet den Beginn des <span class="tx_code">private</span> Module Fragments. Eine Änderung in diesem optionalen letzten Teil einer Moduldeklarationsdatei führt nicht dazu, dass sie neu kompiliert wird.<br> </div><div class="text">Ich habe die Header Units bereits in einem früheren Beitrag vorgestellt. Jetzt kann ich sie einsetzen.<br> </div><div class="ztitel">Header-Units<br> </div><div class="text">Header Units sind ein einfacher Weg, um von Headern auf Module umzustellen. Du musst lediglich die <span class="tx_code">#include</span>-Direktive durch die neue <span class="tx_code">import</span>-Anweisung ersetzen.<br> </div><div class="pre">#include &lt;vector&gt; =&gt; import &lt;vector&gt;;<br>#include "myHead.h" =&gt; import "myHead.h"; <br> </div><div class="text">Erstens wendet <span class="tx_code">import</span> die gleichen Regeln wie <span class="tx_code">include</span> an, um Namen aufzulösen. Das bedeutet im Fall der Anführungszeichen ("<span class="tx_code">myHeader.h</span>"), dass das Lookup zuerst im lokalen Verzeichnis sucht, bevor es mit dem Systemsuchpfad fortfährt.<br> </div><div class="text">Zweitens ist dies weit mehr als eine Textersetzung. In diesem Fall erzeugt der Compiler aus der <span class="tx_code">import</span>-Anweisung etwas Modul-ähnliches und behandelt das Ergebnis so, als ob es ein Modul wäre. Die importierende Modulanweisung erhält alle exportierbaren Namen des Headers. Zu den exportierbaren Namen gehören auch Makros. Der Import dieser synthetischen Header-Einheiten ist schneller und in der Geschwindigkeit mit vorkompilierten Headern vergleichbar.<br> </div><div class="ztitel_kleiner">Module sind keine vorkompilierten Header<br> </div><div class="text">Vorkompilierte Header sind eine nicht standardisierte Methode, um Header in einer Zwischenform zu kompilieren, die vom Compiler schneller verarbeitet werden kann. Der Microsoft-Compiler verwendet die Erweiterung <span class="tx_code">.pch</span> und der GCC-Compiler <span class="tx_code">.gch </span>für vorkompilierte Header. Der Hauptunterschied zwischen vorkompilierten Headern und Modulen ist, dass Module selektiv Namen exportieren können. Nur in einem Modul exportierte Namen sind außerhalb des Moduls sichtbar.</div><div class="text">Nach dieser kurzen Auffrischung möchte ich Header Units gerne einsetzen.<br> </div><div class="ztitel_kleiner">Verwenden von Header Units<br> </div><div class="text">Das folgende Beispiel besteht aus drei Dateien. Die Header-Datei<span class="tx_code"> head.h</span>, in der die Funktion <span class="tx_code">hello</span> deklariert wird, ihre Implementierungsdatei <span class="tx_code">head.cpp</span> und die Client-Datei<span class="tx_code"> helloWorld3.cpp</span>, die die Funktion <span class="tx_code">hello</span> verwendet.<br> </div><div class="pre">// head.h<br><br>#include &lt;iostream&gt;<br><br>void hello();<br> </div><div class="text">Nur die Implementierungsdatei<span class="tx_code"> head.cpp</span> und die Client-Datei <span class="tx_code">helloWorld3.cpp</span> sind besonders. Sie importieren die Header-Datei <span class="tx_code">head.h: import "head.h";</span>.<br> </div><div class="pre">// head.cpp<br><br>import "head.h";<br><br>void hello() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Hello World: header units\n";<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="pre">// helloWorld3.cpp<br><br>import "head.h";<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; hello();<br><br>}<br></div><div class="text">Die nachfolgenden Schritte sind notwendig, um Header Units zu verwenden. <br> </div><div class="pre">cl.exe /std:c++latest /EHsc /exportHeader head.h <br>cl.exe /c /std:c++latest /EHsc /headerUnit head.h=head.h.ifc head.cpp<br>cl.exe /std:c++latest /EHsc /headerUnit head.h=head.h.ifc helloWorld3.cpp head.obj &nbsp;&nbsp;&nbsp;&nbsp; </div><div class="text"><ul><li>Das Flag <span class="tx_code">/exporHeader</span> (erste Zeile) bewirkt, dass die ifc-Datei <span class="tx_code">head.h.ifc</span> aus der Header-Datei<span class="tx_code"> head.h</span> erstellt wird. Die ifc-Datei enthält die Metadatenbeschreibung der Modulschnittstelle.</li><li>Die Implementierungsdatei<span class="tx_code"> head.cpp</span> (zweite Zeile) und die Client-Datei<span class="tx_code"> helloWordl3.cpp</span> (dritte Zeile) verwenden die Header-Unit. Das Flag<span class="tx_code"> /headerUnit head.h=head.h.ifc</span> importiert den Header und teilt dem Compiler oder Linker den Namen der ifc-Datei für den angegebenen Header mit.<br></li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/6/3/3/4/2/TN_216363946_63218ec3e5.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br> </div><div class="text">Einen Nachteil haben Header Units aber doch: Nicht alle Header sind importierbar. Welche Header importierbar sind, hängt von der Implementierung ab. Der C++-Standard garantiert, dass alle Header der Standardbibliothek importierbar sind. Die Möglichkeit zu importieren, schließt C-Header aus.<br> </div><div class="ztitel">Wie geht's weiter?<br> </div><div class="text">In meinem nächsten Beitrag verwende ich Variadic Templates, um das C++-Idiom für eine vollständig generische Fabrik zu implementieren. Eine Implementierung dieses wichtigen C++-Idioms ist <span class="tx_code">std::make_unique</span>.<br></div>