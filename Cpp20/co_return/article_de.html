<div class="vorspann">Anstelle von <span class="tx_code">return</span> verwendet eine Coroutine <span class="tx_code">co_return</span>, um ihren Wert zurückzugeben. In diesem Artikel werde ich eine einfache Coroutine implementieren, die <span class="tx_code">co_return</span> verwendet.</div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/6/4/5/3/9/TN_207479111_4d973afe40.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Warum schreibe ich nochmals über Coroutinen in C++20, obwohl ich deren Theorie bereits in mehreren Artikeln zu<a title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/coroutinen" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fcoroutinen%22%2C%22text%22%3A%22%20Coroutinen%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fcoroutinen%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/tag/coroutinen" class=""> Coroutinen</a> vorgestellt habe? Das liegt an meinen Erfahrungen mit Coroutinen. C++20 bietet keine konkrete Coroutinen, sondern ein Framework für das Implementieren von Coroutinen an. Dieses Framework besteht aus mehr als 20 Funktionen, die teilweise implementiert werden müssen oder können. Basierend auf diesen Funktionen erzeugt der Compiler zwei Arbeitsabläufe, die das Verhalten einer Coroutine definieren. Um es kurz zu machen: Coroutinen sind ein zweischneidiges Schwert. Einerseits sind sie sehr mächtig, andererseits sind sie sehr anspruchsvoll, um sie zu verstehen. In meinem Buch "<a title="Link auf https://leanpub.com/c20" alt="%7B%22destination%22%3A%22https%3A%2F%2Fleanpub.com%2Fc20%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C%2B%2B20%3A%20Get%20the%20Details%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fleanpub.com%2Fc20%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%7D" href="https://leanpub.com/c20" class="">C++20: Get the Details</a>" habe ich ihnen mehr als 80 Seiten gewidmet und dabei immer noch nicht alle Details erklärt.<br></div>
<div class="text">Aus meiner Perspektive besteht der einfachste [--] und vielleicht einzige [--] Weg, Coroutinen zu verstehen, darin, einfache Coroutinen zu modifizieren und ihr Verhalten zu studieren. Dies ist genau die Strategie, die ich in den folgenden Artikeln verwende. Um ihren Arbeitsablauf offenzulegen, werde ich viele Kommentare einsetzen und nur so viel Theorie hinzufügen, wie für das Verständnis der Interna notwendig sind. Meine Erklärungen erheben gar nicht den Anspruch, vollständig zu sein, und sind nur als Startpunkt gedacht, um das Wissen zu Coroutinen zu vertiefen. </div>
<div class="ztitel">Ein kleiner Auffrischer<br></div>
<div class="text"><ul><li>Eine <b>Funktion</b> wird aufgerufen und wieder verlassen. <br></li><li>Eine <b>Coroutine</b> wird aufgerufen, ihre Ausführung kann aber pausiert und wieder fortgesetzt werden. Eine pausierende Coroutine lässt sich darüber hinaus zerstören.</li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/6/4/5/3/9/TN_207479118_cfb3ac5ee9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Mit den neuen Schlüsselwörtern <span class="tx_code">co_await</span> und <span class="tx_code">co_yield</span> unterstützt C++20 zwei neue Konzepte, um Funktionen auszuführen.</div>
<div class="text">Dank des Ausdrucks <span class="tx_code">co_await expression</span> ist es möglich, die Ausführung des Ausdrucks <span class="tx_code">expression</span> zu pausieren und wieder aufzunehmen. Wenn <span class="tx_code">co_await expression</span> in einer Funktion <span class="tx_code">func</span> verwendet wird, muss der Aufruf <span class="tx_code">auto getResult = func()</span> nicht automatisch blockieren, wenn das Ergebnis des Funktionsaufrufs <span class="tx_code">func()</span> noch nicht zur Verfügung steht. Ein ressourcenintensives Blockieren lässt sich durch ein ressourcenfreundliches Warten ersetzen.&nbsp;</div>
<div class="text">Der <span class="tx_code">co_yield</span>-Ausdruck erlaubt Generatoren das Implementiren. Generatoren geben jedes Mal einen neuen Wert zurück, wenn sie danach gefragt werden. Ein Generator ist ein Datenstrom, von dem sich Werte herausnehmen lassen. Dieser Datenstrom kann unendlich sein. Damit sind wir mitten in der Bedarfsauswertung in C++. </div>
<div class="text">Zusätzlich gibt eine Coroutine ihr Ergebnis nicht mit <span class="tx_code">return</span>, sondern mit <span class="tx_code">co_return</span> zurück: </div>
<div class="pre">// ...<br><br>MyFuture&lt;int&gt; createFuture() {<br>&nbsp;&nbsp;&nbsp; co_return 2021;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; auto fut = createFuture();<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "fut.get(): " &lt;&lt; fut.get() &lt;&lt; '\n';<br><br>}&nbsp; </div>
<div class="text">In diesem einfachen Beispiel ist <span class="tx_code">createFuture</span> eine Coroutine, da sie eines der drei Schlüsselworte <span class="tx_code">co_return</span>, <span class="tx_code">co_yield</span> oder <span class="tx_code">co_await</span> verwendet. Darüber hinaus gibt die Funktion <span class="tx_code">createFuture</span> eine Coroutine <span class="tx_code">MyFuture&lt;int</span><span class="tx_code">&gt;</span> zurück. Was? Das hat mich oft verwirrt. Der Name Coroutine wird für zwei Einheiten verwendet. Daher will ich zwei Begriffe einführen. <span class="tx_code">createFuture</span> ist eine Coroutinen-Fabrik, die ein Coroutinen-Objekt <span class="tx_code">fut</span> zurückgibt, das verwendet werden kann, um nach dem seinem Ergebnis zu fragen: <span class="tx_code">fut.get()</span>.</div>
<div class="text">Nun schließe ich die Theorie vorerst ab und gehe auf <span class="tx_code">co_return</span> genauer ein. </div>
<div class="ztitel">co_return</div>
<div class="text">Zugegeben, die Coroutine in dem folgenden Programm <span class="tx_code">eagerFuture.cpp</span> ist die einfachste Coroutine, die ich mir vorstellen kann, die einen Mehrwert liefert: Sie speichert das Ergebnis ihres Aufrufs:</div>
<div class="pre">// eagerFuture.cpp<br><br>#include &lt;coroutine&gt;<br>#include &lt;iostream&gt;<br>#include &lt;memory&gt;<br><br>template&lt;typename T&gt;<br>struct MyFuture {<br>&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;T&gt; value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; MyFuture(std::shared_ptr&lt;T&gt; p): value(p) {}<br>&nbsp;&nbsp;&nbsp; ~MyFuture() { }<br>&nbsp;&nbsp;&nbsp; T get() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (10)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *value;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; struct promise_type {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;T&gt; ptr = std::make_shared&lt;T&gt;(); // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~promise_type() { }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyFuture&lt;T&gt; get_return_object() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; // (7)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ptr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void return_value(T v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ptr = v;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_never initial_suspend() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_never final_suspend() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void unhandled_exception() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::exit(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; };<br>};<br><br>MyFuture&lt;int&gt; createFuture() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; co_return 2021;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (9)<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; auto fut = createFuture();<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "fut.get(): " &lt;&lt; fut.get() &lt;&lt; '\n';&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}<br></div>
<div class="text"><span class="tx_code">MyFuture</span> verhält sich wie ein Future, der sofort ausgeführt wird (siehe "<a title="Link auf https://www.grimm-jaud.de/index.php/blog/asynchrone-funktionsaufrufe" alt="%7B%22type%22%3A%22E%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fasynchrone-funktionsaufrufe%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Asynchrone%20Funktionsaufrufe%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fasynchrone-funktionsaufrufe%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%7D" href="https://www.grimm-jaud.de/index.php/blog/asynchrone-funktionsaufrufe" class="">Asynchrone Funktionsaufrufe</a>"). Der Aufruf der Coroutine <span class="tx_code">createFuture</span> (Zeile 1) gibt den Future zurück, sodass der Aufruf <span class="tx_code">fut.get() </span>(Zeile 2) das Ergebnis vom assoziierten Promise anfordern kann. </div>
<div class="text">Es gibt einen kleinen Unterschied zu einem Future: Der Rückgabewert der Coroutine <span class="tx_code">createFuture</span> ist sofort nach ihrem Aufruf verfügbar. Wegen der Lebenszeit und den Anforderungen der Coroutinen werden diese von einem <span class="tx_code">std::shared_ptr</span> (Zeile 3 und 4) gemanagt. Die Coroutinen verwenden immer<span class="tx_code"> std::suspend_never</span> (Zeile 5 und 6) und pausieren damit weder vor oder noch nach ihrer Ausführung. Das heißt, dass die Coroutine sofort ausgeführt wird, wenn die Funktion <span class="tx_code">createFuture</span><span class="tx_code">()</span> aufgerufen wird. Die Methode <span class="tx_code">get_return_object</span> (Zeile 7) gibt den Handle auf die Coroutine zurück und speichert diesen in einer lokalen Variablen. <span class="tx_code">return_value</span> (Zeile 8) speichert das Ergebnis der Coroutine, das durch <span class="tx_code">co_return 2021</span> (Zeile 9) erzeugt wird. Der Klient ruft <span class="tx_code">fut.get()</span> (Zeile 2) auf und verwendet den Future als Handle auf den Promise. Die Methode <span class="tx_code">get()</span> liefert zum Abschluss das Ergebnis an den Client (Zeile 10). <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/6/4/5/3/9/TN_207479125_95daafdedd.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Ist der Aufwand gerechtfertigt, eine Coroutine zu verwenden, wenn sich diese wie eine gewöhnliche Funktion verhält? Dem kann ich nichts erwidern. Jedoch ist diese Coroutine ein idealer Startpunkt für weitere Implementierung von Coroutinen.</div>
<div class="text">Jetzt sollte ich ein wenig Theorie hinzufügen.</div>
<div class="ztitel">Der Promise-Workflow<br></div>
<div class="text">Wenn <span class="tx_code">co_yield</span>, <span class="tx_code">co_await</span> oder <span class="tx_code">co_return</span> in einer Funktion zum Einsatz kommen, wird diese Funktion zur Coroutine und der Compiler transformiert ihren Funktionskörper zu folgendem, äquivalenten Code:</div>
<div class="pre">{<br>&nbsp; Promise prom;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; co_await prom.initial_suspend();&nbsp;&nbsp; // (2)<br>&nbsp; try {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; &lt;function body&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; }<br>&nbsp; catch (...) {<br>&nbsp;&nbsp;&nbsp; prom.unhandled_exception();<br>&nbsp; }<br>FinalSuspend:<br>&nbsp; co_await prom.final_suspend();&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>}</div>
<div class="text">Wirken die Funktionsnamen vielleicht vertraut? Klar! Dies sind die Methoden der inneren Klasse <span class="tx_code">promise_type</span>. Hier sind die Schritte, die der Compiler ausführt, wenn er das Coroutinen-Objekt als Rückgabewert der Coroutinen-Fabrik <span class="tx_code">createFuture</span> vollzieht. Zuerst erzeugt er das Promise-Objekt (Zeile 1), ruft dann die Funktion <span class="tx_code">inital_suspend</span> (Zeile 2) auf, führt den Funktionskörper (Zeile 3) aus und ruft zum Abschluss die Methode <span class="tx_code">final_suspend</span> (Zeile 4). Beide Methoden <span class="tx_code">inital_suspend</span> und <span class="tx_code">final_suspend</span> des Programms <span class="tx_code">eagerFuture.cpp</span> geben das vordefinierte Awaitable<span class="tx_code"> std::suspend_never</span> zurück. Wie es der Name verspricht, pausiert dieses Awaitable nie und damit pausiert auch die Coroutine nie und verhält sich wie eine gewöhnliche Funktion. Ein Awaitable ist eine Einheit, auf die sich warten lässt. Genau das benötigt <span class="tx_code">co_await</span> als Argument. Ich werde in zukünftigen Artikeln noch genauer auf Awaitables und den zweiten Awaiter-Workflow eingehen.<br></div>
<div class="text">Aus dem vereinfachten Arbeitsablauf lässt sich einfach schließen, welche Methoden der Promise (<span class="tx_code">promise_type</span>) mindestens benötigt:</div>
<div class="text"><ul><li> Default-Konstruktor</li><li><span class="tx_code">initial_suspend</span></li><li><span class="tx_code">final_suspend</span></li><li><span class="tx_code">unhandled_exception</span><br></li></ul></div>
<div class="text">Zugegeben, dies war nicht die vollständige Erklärung. Die Erklärung sollte aber eine erste Intuition zum Ablauf von Coroutinen vermitteln.<br></div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Nun ist es wohl ersichtlich, womit sich mein nächster Artikel befasst. Zuerst dekoriere ich die Coroutine mit Kommentaren, damit sich ihr Arbeitsablauf transparent darstellen lässt, dann werde ich die Coroutine lazy implementieren und auf einem anderen Thread wieder starten.<br></div>