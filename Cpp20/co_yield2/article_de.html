<div class="vorspann">In meinem letzten Artikel "<a title="Link auf https://heise.de/-5991142" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Ein%20unendlicher%20Datenstrom%20dank%20Coroutinen%20in%20C%2B%2B20%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5991142%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5991142%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%7D" href="https://heise.de/-5991142" class="">Ein unendlicher Datenstrom dank Coroutinen in C++20</a>" dieser Miniserie zur Anwendung von Coroutinen stellte ich den Arbeitsablauf vor. Heute nutze ich das generische Potenzial des Datenstroms.</div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/7/9/0/9/8/TN_208661691_0da66d2721.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Voraussetzung zum Verständnis ist die Lektüre des vorherigen Artikels "<a title="Link auf https://heise.de/-5991142" alt="%7B%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5991142%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5991142%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22Ein%20unendlicher%20Datenstrom%20dank%20Coroutinen%20in%20C%2B%2B20%22%7D" href="https://heise.de/-5991142" class="">Ein unendlicher Datenstrom dank Coroutinen in C++20</a>". Er erklärt detailliert den Arbeitsablauf des unendlichen Generators, basierend auf dem neuen Schlüsselwort <span class="tx_code">co_yield</span>. Bisher hat sich diese Miniserie mit den neuen Schlüsselwörtern <span class="tx_code">co_return</span> und <span class="tx_code">co_yield</span> beschäftigt, die eine normale Funktion in eine Coroutine transformieren. Nun werde ich auf das anspruchsvollste Schlüsselwort <span class="tx_code">co_await</span> genauer eingehen. </div>
<div class="text"><b><span class="tx_code">co_return</span></b></div>
<div class="text"><ul><li> <a title="Link auf https://heise.de/-5066861" alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22Einfache%20Futures%20mit%20Coroutinen%20implementieren%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5066861%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5066861%22%7D" href="https://heise.de/-5066861" class="">Einfache Futures mit Coroutinen implementieren</a> </li><li> <a title="Link auf https://heise.de/-5073590" alt="%7B%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5073590%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5073590%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Lazy%20Futures%20mit%20Coroutinen%20in%20C%2B%2B20%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D" href="https://heise.de/-5073590" class="">Lazy Futures mit Coroutinen in C++20</a></li><li> <a title="Link auf https://heise.de/-5987297" alt="%7B%22text%22%3A%22Mit%20Coroutinen%20einen%20Future%20in%20einem%20eigenen%20Thread%20ausf%C3%BChren%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5987297%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5987297%22%7D" href="https://heise.de/-5987297" class="">Mit Coroutinen einen Future in einem eigenen Thread ausführen</a></li></ul></div>
<div class="text"><b><span class="tx_code">co_yield</span></b><br></div>
<div class="text"><ul><li><a title="Link auf https://heise.de/-5991142" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Ein%20unendlicher%20Datenstrom%20dank%20Coroutinen%20in%20C%2B%2B20%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5991142%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5991142%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%7D" href="https://heise.de/-5991142" class="">Ein unendlicher Datenstrom dank Coroutinen in C++20</a></li></ul></div>
<div class="ztitel">Verallgemeinerung des Generators</div>
<div class="text">Verwunderlich ist vielleicht für manche, dass ich das volle generische Potenzial des Generators in meinem letzten Artikel nicht ausgenutzt habe. Im folgenden Beispiel passe ich die Implementierung des Generators an, sodass er die Elemente eines beliebigen Containers der Standard Template Library sukzessiv ausgeben kann: <br></div>
<div class="pre">// coroutineGetElements.cpp<br><br>#include &lt;coroutine&gt;<br>#include &lt;memory&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>template&lt;typename T&gt;<br>struct Generator {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; struct promise_type;<br>&nbsp;&nbsp;&nbsp; using handle_type = std::coroutine_handle&lt;promise_type&gt;;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; Generator(handle_type h): coro(h) {}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; handle_type coro;<br>&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;T&gt; value;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; ~Generator() { &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( coro ) coro.destroy();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; Generator(const Generator&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; Generator&amp; operator = (const Generator&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; Generator(Generator&amp;&amp; oth): coro(oth.coro) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oth.coro = nullptr;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; Generator&amp; operator = (Generator&amp;&amp; oth) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coro = oth.coro;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oth.coro = nullptr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; T getNextValue() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coro.resume();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return coro.promise().current_value;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; struct promise_type {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type() {}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~promise_type() {}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_always initial_suspend() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_always final_suspend() noexcept {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto get_return_object() {&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Generator{handle_type::from_promise(*this)};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_always yield_value(const T value) {&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_value = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void return_void() {}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void unhandled_exception() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::exit(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T current_value;<br>&nbsp;&nbsp;&nbsp; };<br><br>};<br><br>template &lt;typename Cont&gt;<br>Generator&lt;typename Cont::value_type&gt; getNext(Cont cont) {<br>&nbsp;&nbsp;&nbsp; for (auto c: cont) co_yield c;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::string helloWorld = "Hello world";<br>&nbsp;&nbsp;&nbsp; auto gen = getNext(helloWorld);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; helloWorld.size(); ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; gen.getNextValue() &lt;&lt; " ";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp;&nbsp;&nbsp; auto gen2 = getNext(helloWorld);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 5 ; ++i) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; gen2.getNextValue() &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp;&nbsp;&nbsp; std::vector myVec{1, 2, 3, 4 ,5};<br>&nbsp;&nbsp;&nbsp; auto gen3 = getNext(myVec);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; myVec.size() ; ++i) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; gen3.getNextValue() &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}<br></div>
<div class="text">In diesem Beispiel wird der Generator dreimal instanziiert und verwendet. In den ersten zwei Fällen werden <span class="tx_code">gen1</span> (Zeile 1) und <span class="tx_code">gen2</span> (Zeile 2) mit <span class="tx_code">std::string helloWorld</span> initialisiert, während <span class="tx_code">gen3</span> einen <span class="tx_code">std::vector&lt;int&gt;</span> (Zeile 3) einsetzt. Die Ausgabe des Programms verhält sich wie erwartet. Zeile 4 gibt alle Buchstaben des Strings <span class="tx_code">helloWorld</span> sukzessive zurück, hingegen Zeile 5 nur die ersten fünf Buchstaben und Zeile 6 alle Element von <span class="tx_code">std::vector&lt;int&gt;</span>.</div>
<div class="text">Dank des <a title="Link auf https://godbolt.org/z/j9znva" alt="%7B%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2Fj9znva%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2Fj9znva%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Compiler%20Explorer%22%2C%22ir_link%22%3A1%7D" href="https://godbolt.org/z/j9znva" class="">Compiler Explorer</a> lässt sich das Programm in Aktion bewundern:<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/7/9/0/9/8/TN_208661699_ef91b13d0a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die Implementierung des <span class="tx_code">Generator&lt;T&gt;</span> ist beinahe identisch zu seiner vorherigen im Artikel "<a title="Link auf https://heise.de/-5991142" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22text%22%3A%22Ein%20unendlicher%20Datenstrom%20dank%20Coroutinen%20in%20C%2B%2B20%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5991142%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5991142%22%2C%22subject%22%3A%22%22%7D" href="https://heise.de/-5991142" class="">Ein unendlicher Datenstrom dank Coroutinen in C++20</a>". Den entscheidenden Unterschied stellt die Coroutine <span class="tx_code">getNext</span> dar: </div>
<div class="pre">template &lt;typename Cont&gt;<br>Generator&lt;typename Cont::value_type&gt; getNext(Cont cont) {<br>&nbsp;&nbsp;&nbsp; for (auto c: cont) co_yield c;<br>}</div>
<div class="text"><span class="tx_code">getNext</span> ist ein Funktions-Template, das einen Container als Argument annimmt und anschließend mittels einer Range-basierten <span class="tx_code">for</span>-Schleife durch all seine Elemente iteriert. Nach jeder Iteration pausiert das Funktions-Template. Der Rückgabetyp <span class="tx_code">Generator&lt;typename Cont::value_type&gt;</span> mag befremdlich wirken. <span class="tx_code">Cont::value_type</span> ist ein abhängiger Template-Parameter (dependend template parameter), für den der Parser einen Hinweis benötigt. Per Default nimmt der Compiler an, dass dies ein Nicht-Typ ist, obwohl das Argument auch als ein Typ interpretiert werden kann. Genau aus dem Grund muss ich <span class="tx_code">typename Con::value_type</span> voranstellen. <br></div>
<div class="ztitel">Die Arbeitsabläufe<br></div>
<div class="text">Der Compiler transformiert die Coroutine und führt zwei Arbeitsabläufe aus: den äußeren <b>Promise-Arbeitsablauf </b>und den inneren<b> Awaiter-Arbeitsablauf</b>. Bisher habe ich nur den äußeren Arbeitsablauf vorgestellt, der auf den Methoden des <span class="tx_code">promise_type</span> basiert: </div>
<div class="pre">{<br>&nbsp;&nbsp;&nbsp; Promise prom;<br>&nbsp;&nbsp;&nbsp; co_await prom.initial_suspend();<br>&nbsp;&nbsp;&nbsp; try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;function body having co_return, co_yield, or co_wait&gt;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; catch (...) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prom.unhandled_exception();<br>&nbsp;&nbsp;&nbsp; }<br>FinalSuspend:<br>&nbsp;&nbsp;&nbsp; co_await prom.final_suspend();<br>}</div>
<div class="text">Der Arbeitsablauf sollte vertraut wirken. Die Komponenten des Arbeitsablaufs sind die Methode <span class="tx_code">prom.initial_suspend()</span>, der Funktionskörper der Coroutine und die Methode<span class="tx_code"> prom.final_suspend()</span>.&nbsp; </div>
<div class="text">Der innere Arbeitsablauf basiert auf den Awaitables, die Awaiters zurückgeben. Ich habe meine Erklärung absichtlich deutlich vereinfacht. Zwei vordefinierte Awaitables habe ich bereits häufig verwendet: </div>
<div class="text"><ul><li> <span class="tx_code">std::suspend_always</span></li></ul></div>
<div class="pre">struct suspend_always {<br>&nbsp;&nbsp;&nbsp; constexpr bool await_ready() const noexcept { return false; }<br>&nbsp;&nbsp;&nbsp; constexpr void await_suspend(std::coroutine_handle&lt;&gt;) const noexcept {}<br>&nbsp;&nbsp;&nbsp; constexpr void await_resume() const noexcept {}<br>};</div>
<div class="text"><ul><li> <span class="tx_code">std::suspend_never</span></li></ul></div>
<div class="pre">struct suspend_never {<br>&nbsp;&nbsp;&nbsp; constexpr bool await_ready() const noexcept { return true; }<br>&nbsp;&nbsp;&nbsp; constexpr void await_suspend(std::coroutine_handle&lt;&gt;) const noexcept {}<br>&nbsp;&nbsp;&nbsp; constexpr void await_resume() const noexcept {}<br>};</div>
<div class="text">Nun ist es offensichtlich, auf welchen Komponenten der Awaiter-Arbeitsablauf basiert, nämlich auf den Methoden <span class="tx_code">await_ready()</span>, <span class="tx_code">await_suspend()</span> und <span class="tx_code">await_resume()</span> des Awaitable.</div>
<div class="pre">awaitable.await_ready() returns false:<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; suspend coroutine<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; awaitable.await_suspend(coroutineHandle) returns: <br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; awaitable.await_suspend(coroutineHandle);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coroutine keeps suspended<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return to caller<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool result = awaitable.await_suspend(coroutineHandle);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if result: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coroutine keep suspended<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return to caller<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; go to resumptionPoint<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; another coroutine handle:&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto anotherCoroutineHandle = awaitable.await_suspend(coroutineHandle);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; anotherCoroutineHandle.resume();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return to caller<br>&nbsp;&nbsp; &nbsp;<br>resumptionPoint:<br><br>return awaitable.await_resume();</div>
<div class="text">Ich habe den Awaiter-Arbeitsablauf in einer Pseudosprache dargestellt. Das Verständnis dieses Arbeitsablaufs ist das entscheidende Puzzlestück für das Verständnis von Coroutinen.</div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">In meinem nächsten Artikel werde ich tiefer in den Awaiter-Arbeitsablauf abtauchen, der auf dem Awaitable basiert. Sei auf ein zweischneidiges Schwert gefasst: Einerseits sind benutzerdefinierte Awaitables sehr mächtige Werkzeuge, andererseits sind sie nicht einfach zu verstehen.</div>
<div class="ztitel">C++ Schulung für Kurzentschlossene<br></div>
<div class="text">Meine Schulung <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/30-embedded-programmierung-mit-modernem-c20210126195655" alt="%7B%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F30-embedded-programmierung-mit-modernem-c20210126195655%22%2C%22mediasync_id%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F30-embedded-programmierung-mit-modernem-c20210126195655%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Embedded-Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/30-embedded-programmierung-mit-modernem-c20210126195655" class="">Embedded-Programmierung mit modernem C++</a> (12. bis 14. April 2022) findet bereits in zwei Wochen statt. <br></div>