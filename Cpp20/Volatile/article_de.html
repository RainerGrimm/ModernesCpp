<div class="vorspann">Die Tour durch die C++20-Kernsprache geht nun zu Ende. Eine interessante der kleineren Verbesserungen ist, dass die Semantik von volatile deutlich eingeschränkt wird. <br></div>
<div class="text">Das Abstrakt im Proposal P1152R0 umreißt kurz und bündig, welche Veränderungen das Schlüsselwort <span class="tx_code">volatile</span> erfährt: "The proposed deprecation preserves the useful parts of&nbsp;volatile, and removes the dubious / already broken ones. This paper aims at breaking at compile-time code which is today subtly broken at runtime or through a compiler update."</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/5/5/5/1/2/TN_198482392_7a2a2c4b02.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Bevor ich auf die Feature von <span class="tx_code">volatile</span> eingehe, die in C++20 erhalten bleiben, möchte ich zuerst die Features vorstellen, die in C++20 verworfen werden. </div>
<div class="text"><ol><li> Zusammengesetze <span class="tx_code">volatile</span>-Zuweisungen und Pre/Post-Inkrement/Dekrement-Operationen<br></li><li><span class="tx_code">volatile</span>-Funktionsparameter oder Rückgabetypen</li><li><span class="tx_code">volatile</span>-Auszeichnung in Structural Binding</li></ol></div>
<div class="text">Wenn du an allen anspruchsvollen Details zu den Änderungen interessiert bist, kann ich sehr die Präsentation "<a class="" title="Link auf https://www.youtube.com/watch?v=KJW_DLaVXIY" alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DKJW_DLaVXIY%22%2C%22text%22%3A%22Deprecating%20volatile%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DKJW_DLaVXIY%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%7D" href="https://www.youtube.com/watch?v=KJW_DLaVXIY">Deprecating volatile</a>" (CppCon 2019) von JF Bastien empfehlen. Hier sind ein paar Beispiele aus der Präsentation, die sich auf die Punkte (1) bis (3) beziehen:</div>
<div class="pre">(1)<br>int neck, tail;<br>volatile int brachiosaur;<br>brachiosaur = neck;&nbsp;&nbsp; // OK, a volatile store<br>tail = brachiosaur;&nbsp;&nbsp;&nbsp; // OK, a volatile load<br><br>// deprecated: does this access brachiosaur once or twice<br>tail = brachiosaur = neck;<br><br>// deprecated: does this access brachiosaur once or twice<br>brachiosaur += neck;<br><br>// OK, a volatile load, an addition, a volatile store<br>brachiosau = brachiosaur + neck;<br><br>#########################################<br>(2)<br>// deprecated: a volatile return type has no meaning<br>volatile struct amber jurassic();<br><br>// deprecated: volatile parameters aren't meaningful to the<br>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; caller, volatile only applies within the function<br>void trex(volatile short left_arm, volatile short right_arm);<br><br>// OK, the pointer isn't volatile, the data is opints to is<br>void fly(volatile struct pterosaur* pterandon);<br><br>########################################<br>(3)<br>struct linhenykus { volatile short forelimb; };<br>void park(linhenykus alvarezsauroid) {<br>&nbsp;&nbsp;&nbsp; // deprecated: doe the binding copy the foreelimbs?<br>&nbsp;&nbsp;&nbsp; auto [what_is_this] = alvarezsauroid;<br>&nbsp;&nbsp;&nbsp; // ...<br>}<br></div>
<div class="text">Damit habe ich aber noch nicht die entscheidende Frage beantwortet: Wann sollte <span class="tx_code">volatile</span> eingesetzt werden? Dazu möchte ich gerne eine Bemerkung aus dem C++-Standard zitieren: "volatile is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might be changed by means undetectable by an implementation." Also für die Ausführungseinheit (thread of execution), dass der Compiler so oft Lade- und Speicher-Operationen ausführen muss, wie sie in dem Sourcecode verwendet werden. <span class="tx_code">volatile</span>-Operationen können somit weder entfernt noch umsortiert werden. Konsequenterweise lässt sich <span class="tx_code">volatile</span> für die Kommunikation mit Signal-Handlern, aber nicht für die Kommunikation mit einer anderen Ausführungseinheit verwenden. </div>
<div class="text">Um es kurz zu machen: <b><span class="tx_code">volatile</span> verhindert aggressive Optimierung und besitzt keine Multithreading-Semantik.</b></div>
<div class="text">Die folgenden kleinen, aber feinen Verbesserungen stelle ich mit einem Beispiel vor, das direkt im Compiler Explorer ausgeführt werden kann. </div>
<div class="ztitel">Range-basierte For-Schleife mit Initialisierer</div>
<div class="text">Mit C++20 lässt sich die Range-basierte For-Schleife direkt mit einem Initalisierer verwenden:</div>
<div class="pre">// rangeBasedForLoopInitializer.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; for (auto vec = std::vector{1, 2, 3}; auto v : vec) {&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; v &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (auto initList = {1, 2, 3}; auto e : initList) {&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e *= e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; e &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; using namespace std::string_literals;<br>&nbsp;&nbsp;&nbsp; for (auto str = "Hello World"s; auto c: str) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; c &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Die Range-basierte For-Schleife in Zeile (1) verwendet einen <span class="tx_code">std::vec</span><span class="tx_code">tor</span>, die in Zeile (2) eine <span class="tx_code">std::initalizer_list</span> und die in Zeile (3) einen<span class="tx_code"> std::string</span>. Zusätzlich habe ich in den Zeilen (1) und (2) die automatische Bestimmung der Typparameter für Klassen-Templates angewandt. Das ist seit C++17 möglich. Sonst hätte ich <span class="tx_code">std::vector&lt;int&gt;</span> und <span class="tx_code">std::initializer_list&lt;int&gt;</span> anstelle von <span class="tx_code">std::vector </span>und <span class="tx_code">std::initializer_list</span> schreiben müssen. </div>
<div class="text">Mit dem GCC 10.2 und dem <a href="https://godbolt.org/z/9c3rGs" alt="%7B%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2F9c3rGs%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2F9c3rGs%22%2C%22text%22%3A%22Compiler%20Explorer%22%7D" class="" title="Link auf https://godbolt.org/z/9c3rGs">Compiler Explorer</a> lässt sich das Programm ausführen.<br></div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/5/5/5/1/2/TN_198482397_84e6e11d0f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel"><span class="tx_code">virtual constexpr</span>-Funktionen</div>
<div class="text">Eine <span class="tx_code">constexpr-</span>Funktion hat das Potenzial zur Compilezeit, kann aber auch zur Laufzeit ausgeführt werden. Konsequenterweise können mit C++20 <span class="tx_code">constexpr</span>-Funktionen als <span class="tx_code">virtual</span> deklariert werden. Alle Kombinationen sind möglich. Eine virtuelle <span class="tx_code">constexpr</span>-Funktion kann eine Nicht-<span class="tx_code">constexpr</span>-Funktion und eine virtuelle Nicht-<span class="tx_code">constexpr</span>-Funktion kann eine virtuelle <span class="tx_code">constexpr</span>.Funktion überschreiben. Ich möchte betonen, dass Überschreiben impliziert, dass die entsprechende Methode einer Basisklasse virtuell ist:<br></div>
<div class="pre">// virtualConstexpr.cpp<br><br>#include &lt;iostream&gt;<br><br>struct X1 {<br>&nbsp;&nbsp;&nbsp; virtual int f() const = 0;<br>};<br><br>struct X2: public X1 {<br>&nbsp;&nbsp;&nbsp; constexpr int f() const override { return 2; }<br>};<br><br>struct X3: public X2 {<br>&nbsp;&nbsp;&nbsp; int f() const override { return 3; }<br>};<br><br>struct X4: public X3 {<br>&nbsp;&nbsp;&nbsp; constexpr int f() const override { return 4; }<br>};<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; X1* x1 = new X4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "x1-&gt;f(): " &lt;&lt; x1-&gt;f() &lt;&lt; std::endl; <br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; X4 x4;<br>&nbsp;&nbsp;&nbsp; X1&amp; x2 = x4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "x2.f(): " &lt;&lt; x2.f() &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Zeile (1) verwendet den virtuellen Dispatch (späte Bindung) mithilfe eines Zeigers, Zeile (2) nutzt für den virtuellen Dispatch eine Referenz. Nochmals leisten mir der GCC 10.2 und der <a alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2F5qvdvz%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2F5qvdvz%22%2C%22text%22%3A%22Compiler%20Explorer%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%7D" href="https://godbolt.org/z/5qvdvz" class="" title="Link auf https://godbolt.org/z/5qvdvz">Compiler Explorer</a> wertvolle Hilfe.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/5/5/5/1/2/TN_198482403_74d60b4e43.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Der neue Zeichentyp für UTF-8 Strings: char8_t<br></div>
<div class="text">Zusätzlich zu den C++11 Zeichentypen <span class="tx_code">char16_t</span> und <span class="tx_code">char32_t</span> erhält C++20 den neuen Zeichentyp <span class="tx_code">char8_t</span>. Er ist groß genug, um UTF-8 (8 Bits) zu repräsentieren. Er besitzt dieselbe Größe, dasselbe Vorzeichen und dasselbe Alignment wie<span class="tx_code"> unsigned char</span>, ist aber ein neuer Datentyp.</div>
<div class="text">In bekannter Manier erhält C++20 den neuen Typalias für den Zeichentyp <span class="tx_code">char8_t</span> (1) und einen neuen UTF-8 String Literal (2): </div>
<div class="pre">std::u8string: std::basic_string&lt;char8_t&gt; (1)<br>u8"Hello World"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)<br></div>
<div class="text">Das folgende Programm zeigt die Verwendung des neuen Zeichentyps <span class="tx_code">char8_t:</span></div>
<div class="pre">// char8Str.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; const char8_t* char8Str = u8"Hello world";<br>&nbsp;&nbsp;&nbsp; std::basic_string&lt;char8_t&gt; char8String = u8"helloWorld";<br>&nbsp;&nbsp;&nbsp; std::u8string char8String2 = u8"helloWorld";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; char8String2 += u8".";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "char8String.size(): " &lt;&lt; char8String.size() &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "char8String2.size(): " &lt;&lt; char8String2.size() &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; char8String2.replace(0, 5, u8"Hello ");<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "char8String2.size(): " &lt;&lt; char8String2.size() &lt;&lt; std::endl;<br>&nbsp;<br>}<br></div>
<div class="text">Ohne viele Worte folgt hier bereits die Ausgabe des Programms mit dem <a class="" title="Link auf https://godbolt.org/z/1fYfen" href="https://godbolt.org/z/1fYfen" alt="%7B%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2F1fYfen%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2F1fYfen%22%2C%22text%22%3A%22Compiler%20Explorer%22%7D">Compiler Explorer</a>.</div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/5/5/5/1/2/TN_198482410_1c0247088d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">using enum in lokalen Bereichen</div>
<div class="text">Eine <span class="tx_code">using enum-</span>Deklaration führt die Aufzähler in der benamsten Aufzählung in den lokalen Bereich ein:</div>
<div class="pre">// enumUsing.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string_view&gt;<br><br>enum class Color {<br>&nbsp;&nbsp;&nbsp; red,<br>&nbsp;&nbsp;&nbsp; green, <br>&nbsp;&nbsp;&nbsp; blue<br>};<br><br>std::string_view toString(Color col) {<br>&nbsp; switch (col) {<br>&nbsp;&nbsp;&nbsp; using enum Color;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) <br>&nbsp;&nbsp;&nbsp; case red:&nbsp;&nbsp; return "red";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) <br>&nbsp;&nbsp;&nbsp; case green: return "green";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) <br>&nbsp;&nbsp;&nbsp; case blue:&nbsp; return "blue";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) <br>&nbsp; }<br>&nbsp; return "unknown";<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "toString(Color::red): " &lt;&lt; toString(Color::red) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; using enum Color;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "toString(green): " &lt;&lt; toString(green) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp; // (2) <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}&nbsp; <br></div>
<div class="text">Die <span class="tx_code">using enum</span>-Deklaration (1) führt die Aufzähler mit Gültigkeitsbereich <span class="tx_code">Color</span> in den lokalen Bereich ein. Von diesem Punkt an lassen sich die Aufzähler ohne den Gültigkeitsbereich verwenden (2). Zum jetzigen Zeitpunkt ist der Microsoft-Compiler 19.24 der einzige Compiler, der <span class="tx_code">using enum</span> unterstützt. </div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/5/5/5/1/2/TN_198482414_ed9f0e4e28.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Default-Initialisierung der Mitglieder eines Bitfelds</div>
<div class="text">Zuerst einmal, stellt sich die Frage: Was ist ein Bitfeld? In diesem Fall hilft <a class="" title="Link auf https://de.wikipedia.org/wiki/Bitfeld" alt="%7B%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FBitfeld%22%2C%22text%22%3A%22Wikipedia%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FBitfeld%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%7D" href="https://de.wikipedia.org/wiki/Bitfeld">Wikipedia</a>: "In der&nbsp;Informationstechnik&nbsp;und&nbsp;Programmierung&nbsp;bezeichnet ein&nbsp;<b>Bitfeld</b>&nbsp;ein vorzeichenloses&nbsp;Integer, in dem einzelne&nbsp;Bits&nbsp;oder Gruppen von Bits aneinandergereiht werden. Es stellt eine Art&nbsp;Verbunddatentyp&nbsp;auf Bit-Ebene dar. Im Gegensatz dazu steht der&nbsp;primitive Datentyp, bei dem der Wert aus allen Stellen gemeinsam gebildet wird."</div>
<div class="text">Mit C++20 lassen sich die Mitglieder eines Bitfelds mit Default-Initialisierung nutzen:<i><br></i></div>
<div class="pre">// bitField.cpp<br><br>#include &lt;iostream&gt;<br><br>struct Class11 {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; int i = 1;<br>&nbsp;&nbsp;&nbsp; int j = 2;<br>&nbsp;&nbsp;&nbsp; int k = 3;<br>&nbsp;&nbsp;&nbsp; int l = 4;<br>&nbsp;&nbsp;&nbsp; int m = 5;<br>&nbsp;&nbsp;&nbsp; int n = 6;<br>};<br><br>struct BitField20 {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; int i : 3 = 1;<br>&nbsp;&nbsp;&nbsp; int j : 4 = 2;<br>&nbsp;&nbsp;&nbsp; int k : 5 = 3;<br>&nbsp;&nbsp;&nbsp; int l : 6 = 4;<br>&nbsp;&nbsp;&nbsp; int m : 7 = 5;<br>&nbsp;&nbsp;&nbsp; int n : 7 = 6;<br>};<br><br>int main () {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sizeof(Class11): " &lt;&lt; sizeof(Class11) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sizeof(BitField20): " &lt;&lt; sizeof(BitField20) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Und zwar entsprechend der Mitglieder einer Klasse (1) mit C++11, so lassen sich mit C++20 die Mitglieder eines Bitfelds Default-initialisieren (2). Zum Abschluss ist hier die Ausgabe des Programms mit dem Clang 10.0 Compiler:<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/5/5/5/1/2/TN_198482422_d3eba15426.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Eine kurze Schreibpause</div>
<div class="text">In den nächsten vierzehn Tagen werde ich in Italien sein und daher keinen Artikel schreiben.</div>
<div class="text">Im Falle, dass du in der Zwischenzeit einen meiner mehr als 300 Artikel zu modernem C++ lesen möchtest, habe ich eine visuelle Tour durch meinen Blog aufgenommen. Diese Sie erklärt das Inhaltsverzeichnis, die Kategorien, die Tags, das Archiv und das Suche-System. Damit sollte es möglich sein, den gewünschten Artikel zu finden:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/image/rte/youtube.svg" title="<ir_inline itemname=video_mvp_id:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Nach der kurzen Schreibpause, setze ich meine Reise durch C++20 mit der Bibliothek fort. Insbesondere werde ich mir <span class="tx_code">std::span </span>genauer anschauen. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/image/rte/textbox.svg" title="<ir_inline itemname=textboxen_mvp_text:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>