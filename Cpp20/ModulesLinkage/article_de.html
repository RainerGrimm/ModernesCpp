<div class="vorspann">Die bisherigen vier Artikel zu Modulen gingen auf deren Grundlagen ein. Daher gibt es nur noch wenige Fragen zu Modulen zu beantworten. Genau diese Fragen adressiere ich in dem heutigen Artikel: Templates und Module, das Linkage von Modulen und Header Units.</div>
<div class="text">In diesem Artikel mache ich es mir einfach. Ich nehme an, dass du meine vorherigen Artikel zu Modulen kennst. Falls nicht, habe ich sie hier aufgelistet:</div>
<div class="text"><ul><li> <a alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4717856%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22%20C%2B%2B20%3A%20Die%20Vorteile%20von%20Modulen%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4717856%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%7D" href="https://heise.de/-4717856" class="" title="Link auf https://heise.de/-4717856"> C++20: Die Vorteile von Modulen</a> </li><li> <a alt="%7B%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4722629%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4722629%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22C%2B%2B20%3A%20Ein%20einfaches%20math-Modul%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://heise.de/-4722629" class="" title="Link auf https://heise.de/-4722629">C++20: Ein einfaches math-Modul</a> </li><li> <a href="https://heise.de/-4727382" alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4727382%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%3A%20Module%20Interface%20Unit%20und%20Module%20Implementation%20Unit%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4727382%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%7D" title="Link auf https://heise.de/-4727382" class="">C++20: Module Interface Unit und Module Implementation Unit</a> </li><li> <a title="Link auf https://heise.de/-4770234" class="" href="https://heise.de/-4770234" alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4770234%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%3A%20Module%20strukturieren%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4770234%22%7D">C++20: Module strukturieren</a> <br></li></ul></div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/0/7/2/2/6/TN_194471206_57aba394c4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Templates und Module<br></div>
<div class="text">Ich höre recht häufig die Frage: Wie werden Templates durch Module exportiert? Wenn du ein Template instanziierst, muss seine Definition verfügbar sein. Das ist der Grund, warum Template-Definitionen in Header-Dateien verpackt werden. Konzeptionell besitzt die Verwendung von Templates die folgende Struktur.<br></div>
<div class="text"><ul><li><span class="tx_code">templateSum.h</span></li></ul></div>
<div class="pre">// templateSum.h<br>&nbsp; <br>template &lt;typename T, typename T2&gt;<br>auto sum(T fir, T2 sec) { <br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>}</div>
<div class="pre"><ul><li><span class="tx_code">sumMain.cpp</span></li></ul></div>
<div class="pre">// sumMain.cpp<br><br>#include &lt;templateSum.h&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; sum(1, 1.5);<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Die Datei <span class="tx_code">sumMain.cpp</span> inkludiert direkt die Header-Datei <span class="tx_code">templatSum</span><span class="tx_code">.h</span>. Der Aufruf <span class="tx_code">sum(1, 1.5)</span> stößt die Template-Instanziierung an. In diesem Fall erzeugt der Compiler aus dem Funktions-Template <span class="tx_code">sum</span> die konkrete Funktion <span class="tx_code">sum</span>, die ein <span class="tx_code">int</span> und ein <span class="tx_code">double</span> erwartet. Dieser Prozess lässt sich schön mit <a class="" title="Link auf https://cppinsights.io/s/cee41fd8" alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Insights%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2Fcee41fd8%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2Fcee41fd8%22%7D" href="https://cppinsights.io/s/cee41fd8">C++ Insights</a> visualisieren.</div>
<div class="text">Templates können und sollten mit C++20 in Modulen definiert werden. Module habe eine eindeutige interne Repräsentation, die weder Sourcecode noch Assembler entspricht. Diese Repräsentation ist eine Art <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" alt="%7B%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAbstract_syntax_tree%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAbstract_syntax_tree%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Abstract%20Syntax%20Tree%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%7D" title="Link auf https://en.wikipedia.org/wiki/Abstract_syntax_tree" class="">Abstract Syntax Tree</a> (AST). Dank ihr steht die Template-Definition während der Template-Instanziierung zur Verfügung. </div>
<div>Im folgenden Beispiel definiere ich das Funktions-Template <span class="tx_code">sum</span> in dem Modul <span class="tx_code">math</span>.</div>
<div><ul><li><span class="tx_code">mathModuleTemplate.ixx</span></li></ul></div>
<div class="pre">// mathModuleTemplate.ixx<br><br>export module math;&nbsp;&nbsp;&nbsp; <br><br>export namespace math {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; template &lt;typename T, typename T2&gt;<br>&nbsp;&nbsp;&nbsp; auto sum(T fir, T2 sec) { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir + sec;<br>&nbsp;&nbsp;&nbsp; }<br><br>}<br></div>
<div class="text"><ul><li><span class="tx_code">clientTemplate.cpp</span></li></ul></div>
<div class="pre">// clientTemplate.cpp<br><br>#include &lt;iostream&gt;<br>import math;<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "math::sum(2000, 11): " &lt;&lt; math::sum(2000, 11) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "math::sum(2013.5, 0.5): " &lt;&lt; math::sum(2013.5, 0.5) &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "math::sum(2017, false): " &lt;&lt; math::sum(2017, false) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Die Kommendozeile zum Übersetzen des Programms unterscheidet sich nicht von der des letzten Artikels "<a class="" title="Link auf https://heise.de/-4770234" alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4770234%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%3A%20Module%20strukturieren%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4770234%22%7D" href="https://heise.de/-4770234">C++20: Module strukturieren</a>". Daher verzichte ich auf diese und zeige direkt die Ausgabe des Programms.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/0/7/2/2/6/TN_194471214_8538e35b02.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Mit Modulen erhalten wir eine neue Art von Linkage.</div>
<div class="ztitel">Modul Linkage</div>
<div class="text">Bisher besitzt C++ zwei Arten von Linkage: Internal Linkage und External Linkage.</div>
<div class="text"><ul><li> <b>Internal Linkage: </b>Namen mit Interal Linkage lassen sich nicht außerhalb der Übersetzungseinheit verwenden. Es schließt im Wesentlichen globale Namen (namespace scope) ein, die als <span class="tx_code">static</span> deklariert sind, und Mitglieder anonymer Unions.</li><li><b>External Linkage</b>: Namen mit External Linkage lassen sich außerhalb der Übersetzungseinheit verwenden. Es schließt im Wesentlichen globale Namen ein, die nicht <span class="tx_code">static</span> deklariert, aber auch Klassen und ihre Mitglieder, Variablen und Templates. <br></li></ul></div>
<div class="text">Mit Modulen erhalten wir Module Linkage.</div>
<div class="text"><ul><li> <b>Module Linkage</b>: Namen mit Module Linkage lassen sich nur innerhalb des Moduls verwenden. Damit Namen Module Linkage besitzen, sind zwei Bedingungen notwendig. Einerseits dürfen die Namen keine Internal Linkage haben und damit nur in der Übersetzungseinheit sichtbar sein und andererseits dürfen die Namen nicht exportiert werden. </li></ul></div>
<div class="text">Die kleine Variation des vorherigen Moduls <span class="tx_code">math</span> soll Module Linkage verdeutlichen. Ich möchte Anwendern meines Funktions-Templates <span class="tx_code">sum</span> zusätzlich zurückgeben, welchen Rückgabetyp der Compiler deduziert hat. </div>
<div class="text"><ul><li><span class="tx_code">mathModuleTemplate1.ixx</span></li></ul></div>
<div class="pre">// mathModuleTemplate1.ixx<br><br>module;<br><br>#include &lt;iostream&gt;<br>#include &lt;typeinfo&gt;<br>#include &lt;utility&gt;<br><br>export module math;&nbsp;&nbsp; <br><br>template &lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) &nbsp;<br>auto showType(T&amp;&amp; t) {<br>&nbsp;&nbsp;&nbsp; return typeid(std::forward&lt;T&gt;(t)).name();<br>}<br><br>export namespace math {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3) <br><br>&nbsp;&nbsp;&nbsp; template &lt;typename T, typename T2&gt;<br>&nbsp;&nbsp;&nbsp; auto sum(T fir, T2 sec) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto res = fir + sec;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::make_pair(res, showType(res));&nbsp; // (1) <br>&nbsp;&nbsp;&nbsp; }<br><br>}<br></div>
<div class="text">Anstelle der Summe der Zahlen gibt das Funktions-Template <span class="tx_code">sum</span> ein<span class="tx_code"> std::pair</span> (1) zurück, das aus der Summe und der String-Repräsentation des Datentyps <span class="tx_code">res</span> besteht. Ich habe das Funktions-Template <span class="tx_code">showType</span> (2) nicht im exportierten Namensraum <span class="tx_code">math</span> (3) verwendet. Konsequenterweise kann auf <span class="tx_code">showType</span> nicht außerhalb des Moduls <span class="tx_code">math</span> zugegriffen werden. <span class="tx_code">showType</span> nutzt <a href="https://www.grimm-jaud.de/index.php/blog/perfect-forwarding" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fperfect-forwarding%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fperfect-forwarding%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Perfect%20Forwarding%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/perfect-forwarding" class="">Perfect Forwarding</a>, um die Wertkategorie des Funktionsarguments <span class="tx_code">t</span> zu erhalten. Die Funktion <span class="tx_code">typeid</span> ermittelt die Information zum Datentyp zur Laufzeit (<a title="Link auf https://en.cppreference.com/w/cpp/types" class="" href="https://en.cppreference.com/w/cpp/types" alt="%7B%22text%22%3A%22runtime%20type%20identification%20%28RTTI%29%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%22%7D">runtime type identification (RTTI)</a>). </div>
<div class="text"><ul><li><span class="tx_code">clientTemplate1.cpp</span></li></ul></div>
<div class="pre">// clientTemplate1.cpp<br><br>#include &lt;iostream&gt;<br>import math;<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto [val, message] = math::sum(2000, 11);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "math::sum(2000, 11): " &lt;&lt; val &lt;&lt; "; type: " &lt;&lt; message &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto [val1, message1] =&nbsp; math::sum(2013.5, 0.5);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "math::sum(2013.5, 0.5): " &lt;&lt; val1 &lt;&lt; "; type: " &lt;&lt; message1 &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto [val2, message2] =&nbsp; math::sum(2017, false);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "math::sum(2017, false): " &lt;&lt; val2 &lt;&lt; "; type: " &lt;&lt; message2 &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Jetzt stellt das Programm das Ergebnis der Summation und die String-Repräsentation des automatisch ermittelten Rückgabetyps dar.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/0/7/2/2/6/TN_194471218_9321f117e9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Weder der GCC noch der Clang oder der Microsoft Compiler unterstützen zum jetzigen Zeitpunkt das nächste Feature von Modulen. Es wird wohl sehr gerne eingesetzt werden.</div>
<div class="ztitel">Header Units</div>
<div class="text">Header Units stellen eine sehr angenehme Art dar, den Übergang von Header-Dateien und Modulen zu vollziehen. Du musst dazu lediglich die <span class="tx_code">#include</span>-Direktive durch die neue <span class="tx_code">import</span>-Direktive ersetzen. </div>
<div class="pre">#include &lt;vector&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; import &lt;vector&gt;;<br>#include "myHeader.h"&nbsp; =&gt; import "myHeader.h"; </div>
<div class="text">Zuerst einmal respektiert <span class="tx_code">import</span> dieselben Lookup-Regeln wie <span class="tx_code">include</span>. Das bedeutet in dem konkreten Fall der Anführungszeichen ("<span class="tx_code">myHeaders.h</span>"), dass der Lookup zuerst das lokale Verzeichnis und dann den Systempfad berücksichtigt.</div>
<div class="text">Darüber hinaus stellt die Ersetzung von <span class="tx_code">#includ</span>e mit <span class="tx_code">import</span> mehr als eine Textersetzung dar. Im Fall von <span class="tx_code">import</span> erzeugt der Compiler eine Einheit, die modulähnlich ist, und behandelt diese wie ein Modul. Der <span class="tx_code">import</span>-Aufruf importiert alle Namen der Header-Datei, die exportierbar sind. Dies umfasst alle Makros. Das Importieren der erzeugten Header Unit ist schneller und aus Performanzsicht vergleichbar zum Importieren <a title="Link auf https://en.wikipedia.org/wiki/Precompiled_header" class="" href="https://en.wikipedia.org/wiki/Precompiled_header" alt="%7B%22text%22%3A%22vorkompilierter%20Header-Dateien%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPrecompiled_header%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPrecompiled_header%22%2C%22ir_link%22%3A1%7D">vorkompilierter Header-Dateien</a>. <br></div>
<div class="ztitel">Ein Wermutstropfen</div>
<div class="text">Header Units besitzen einen Wermutstropfen: Nicht alle Header-Dateien sind importierbar. Welche Header-Dateien das sind, hängt vom Compiler ab. Der C++20-Standard garantiert aber, dass alle Header-Dateien des Standards importierbar sind. Das schließt die C-Header-Dateien aus, die nur durch den Namensraum <span class="tx_code">std</span> dekoriert werden. So ist zum Beispiel die Header-Datei <span class="tx_code">&lt;</span><span class="tx_code">cstring</span><span class="tx_code">&gt;</span> der C++-Wrapper für <span class="tx_code">&lt;</span><span class="tx_code">string.h</span><span class="tx_code">&gt;</span>. Du kannst die C-Header-Dateien einfach identifizieren, denn aus C-Header-Datei <b><span class="tx_code">xxx.h</span></b> wird <span class="tx_code"><b>cxxx.</b></span></div>
<div class="ztitel">Wie geht's weiter</div>
<div class="text">Mit diesem Artikel schließe ich meine Geschichte zu Modulen und insbesondere zu den großen Vier in C++20 ab. Der Link <a class="" title="Link auf https://www.grimm-jaud.de/index.php/blog/category/c-20" alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fc-20%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fc-20%22%7D" href="https://www.grimm-jaud.de/index.php/blog/category/c-20">C++20</a> verweist auf alle existierenden und noch erscheinenden Artikel zu C++20. Als Nächstes nehme ich die Features der Kernsprache genauer unter die Lupe, die nicht so prominent sind wie Concepts oder Module. Der nächste Artikel beschäftigt sich mit dem Drei-Weg-Vergleichsoperator.<br></div>
