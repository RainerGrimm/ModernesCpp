<div class="vorspann">Module sind neben Concepts, Ranges und Coroutinen eines der vier großen Features von C++20 und sie versprechen viel: Sie sollen die Compilezeit verkürzen, Makros isolieren, Header-Dateien und hässliche Workarounds überflüssig werden lassen.</div>
<div class="text">Warum benötigen wir Module? Zur Beantwortung dieser Frage möchte ich gerne ein paar Schritte zurücktreten und vereinfachend darstellen, wie eine ausführbare Datei in C++ erzeugt wird.</div>
<div class="ztitel">Eine einfache ausführbare Datei<br></div>
<div class="text">Klar, jede Einführung beginnt mit "Hello World": </div>
<div class="pre">// helloWorld.cpp<br><br>#include &lt;iostream&gt;<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;<br>}<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/2/2/7/5/TN_193241327_0856a2e517.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="text">Die ausführbare Datei <span class="tx_code">helloWorl</span><span class="tx_code">d</span> ist um den Faktor 130 größer als die Quellcodedatei <span class="tx_code">helloWorld.cpp</span>. <br></div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/2/2/7/5/TN_193241336_6f753a5fe7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Zahlen 100 und 12928 in dem Screenshot stehen für die Anzahl der Bytes.</div>
<div class="text">Es ist natürlich sinnvoll zu wissen, was unter der Decke passiert.</div>
<div class="ztitel">Der klassische Erstellungsprozess</div>
<div class="text">Der Erstellungsprozess lastet auf drei Schultern: Präprozessor, Compiler und Linker.</div>
<div class="ztitel_kleiner">Präprozessor</div>
<div class="text">Der Präprozessor kümmert sich um Präprozessor-Direktiven wie <span class="tx_code">#include</span> und <span class="tx_code">#define</span>. Der Präprozessor ersetzt die <span class="tx_code">#include</span>-Direktiven mit den Header-Dateien und die Makros (<span class="tx_code">#define</span>) mit dem entsprechenden Text. Dank weiterer Direktiven wie <span class="tx_code">#if</span>, <span class="tx_code">#else</span>, <span class="tx_code">#elif</span>, <span class="tx_code">#ifdef</span>, <span class="tx_code">#ifndef </span>und <span class="tx_code">#endif </span>lassen sich Teile des Sourcecodes inkludieren oder exkludieren.</div>
<div class="text">Diese einfache Textersetzung lässt sich mit dem Compiler-Flag <span class="tx_code">-E</span> beim GCC-/Clang- oder <span class="tx_code">/E</span> beim Windows-Compiler schön darstellen. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/2/2/7/5/TN_193241342_271fe0e667.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Der Präprozessor produziert tatsächlich eine Textdatei mit mehr als einer halben Million Bytes. Ich will hier nicht GCC tadeln, denn alle anderen Compiler sind ähnlich geschwätzig: <a title="Link auf https://godbolt.org/z/rtXGFQ" class="" href="https://godbolt.org/z/rtXGFQ" alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FrtXGFQ%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FrtXGFQ%22%2C%22text%22%3A%22Compiler%20Explorer%22%7D">Compiler Explorer</a>. </div>
<div class="text">Die Ausgabe des Präprozessors stellt die Eingabe für den Compiler dar.<br></div>
<div class="ztitel_kleiner">Compiler</div>
<div class="text">Die Kompilierung findet separat auf allen Dateien statt, die der Präprozessor erzeugt. Der Compiler parst den C++-Sourcecode und konvertiert ihn zu Assemblercode. Die dabei erzeugte Datei wird Objektdatei genannt. Sie enthält den kompilierten Code im Binärformat. Die Objektdatei kann Symbole referenzieren, die keine Definition besitzen. Die Objektdatei lässt sich in ein Archiv für die einfache Wiederverwendung packen. Diese Archive werden statische Bibliotheken genannt. </div>
<div class="text">Die Objektdateien oder auch Übersetzungseinheiten, die der Compiler erzeugt, stellen die Eingabe für den Linker dar.</div>
<div class="ztitel_kleiner">Linker</div>
<div class="text">Der Linker kann eine ausführbare Datei oder auch eine statische oder geteilte Bibliothek (shared library) erzeugen. Es ist die Aufgabe des Linkers, die Referenzen zu undefinierten Symbolen aufzulösen. Die Symbole sind in den Objektdateien oder Bibliotheken definiert. Der typische Fehler in diesem Prozess ist es, dass die Symbole entweder gar nicht oder mehrfach definiert sind. </div>
<div class="text">Diesen klassischen Erstellungsprozess aus drei Schritten hat C++ von C geerbt. Er funktioniert ausreichend gut, wenn es eine Übersetzungseinheit gibt. Wenn du aber mehr als eine Übersetzungseinheit besitzt, hat er viele Schwächen.</div>
<div class="ztitel">Schwächen des klassischen Erstellungsprozesses<br></div>
<div class="text">Ohne einen Anspruch auf Vollständigkeit möchte ich ein paar Schwächen des klassischen Erstellungsprozesses vorstellen. Module überwinden diese Schwächen. <br></div>
<div class="ztitel_kleiner">Wiederholte Ersetzung der Header-Dateien<br></div>
<div class="text">Der Präprozessor ersetzt jede <span class="tx_code">#include</span>-Direktive mit der entsprechenden Header-Datei. Lass mich zur Verdeutlichung mein am Anfang des Artikels vorgestelltes <span class="tx_code">helloWord.cpp</span>-Programm ein wenig modifizieren. Ich habe es refaktorisiert und zwei Quelldateien (<span class="tx_code">hello.cpp</span> und <span class="tx_code">world.cpp</span>) hinzugefügt. Die Datei <span class="tx_code">hello.cpp</span> bietet die Funktion <span class="tx_code">hello</span>; die Datei <span class="tx_code">word.cpp</span> bietet die Funktion <span class="tx_code">world</span> an. Beide Quelldateien besitzen die entsprechenden Header-Dateien. Refaktorisierung bedeutet, dass sich das neue Programm <span class="tx_code">helloWorld2.cpp</span> wie das Programm <span class="tx_code">helloWorld.cpp</span> verhält. Lediglich die interne Struktur hat sich verändert. Hier sind die neuen Dateien:<br></div>
<div class="text"><ul><li><span class="tx_code">hello.cpp</span> und <span class="tx_code">hello.h</span></li></ul></div>
<div class="pre">// hello.cpp<br><br>#include "hello.h"<br><br>void hello() {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "hello ";<br>}<br><br>// hello.h<br><br>#include &lt;iostream&gt;<br><br>void hello();<br></div>
<div class="text"><ul><li><span class="tx_code">world.cpp</span> und <span class="tx_code">world.h</span><br></li></ul></div>
<div class="pre">// world.cpp<br><br>#include "world.h"<br><br>void world() {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "world";<br>}<br><br>// world.h<br><br>#include &lt;iostream&gt;<br><br>void world();<br></div>
<div class="text"><ul><li><span class="tx_code">helloWorld2.cpp</span></li></ul></div>
<div class="pre">// helloWorld2.cpp<br><br>#include &lt;iostream&gt;<br><br>#include "hello.h"<br>#include "world.h"<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; hello(); <br>&nbsp;&nbsp;&nbsp; world(); <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Das Erzeugen und Ausführen des Programms verhält sich erwartungsgemäß.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/2/2/7/5/TN_193241345_437292db6e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Es gibt aber eine Schwäche. Der Präprozessor vollzieht seine Ersetzung auf jeder Quelldatei. Das heißt, dass die Header-Datei &lt;<span class="tx_code">iostream</span>&gt; Mal in jeder Übersetzungseinheit inkludiert wird. Konsequenterweise wird jede Quelldatei damit auf mehr als eine halbe Million Bytes aufgeblasen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/2/2/7/5/TN_193241355_ab6c3d9253.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Dieser Aufwand ist eine Vergeudung von Übersetzungszeit.<br></div>
<div class="vorspann">Im Gegensatz dazu wird ein Modul nur einmal importiert. Dieser Prozess ist buchstäblich umsonst.<br></div>
<div class="ztitel_kleiner">Isolation von Präprozessor-Makros</div>
<div class="text">Falls es einen Konsens in der C++-Community gibt, dann diesen: Wir sollten die Präprozessor-Makros loswerden. Warum? Die Verwendung eines Makros stellt lediglich Textersetzung ohne C++-Semantik dar. Diese naive Ersetzung besitzt viele Schwächen: Zum Beispiel kann der Wert eines Makros davon abhängen, in welcher Reihenfolge du Makros inkludierst. Darüber hinaus können Makros mit bereits bestehenden oder Bezeichnern in deiner Applikation kollidieren.</div>
<div class="text">Stelle dir vor, du hast die zwei Header-Dateien <span class="tx_code">webcolor.h </span>und <span class="tx_code">productinfo.h</span>:<br></div>
<div class="pre">// webcolors.h<br><br>#define RED&nbsp;&nbsp; 0xFF0000</div>
<div class="pre">// productinfo.h<br><br>#define RED&nbsp;&nbsp; 0<br> </div>
<div class="text">Wenn nun eine Quelldatei <span class="tx_code">client.cpp</span> beide Header-Dateien inkludiert, hängt der Wert vom Makro <span class="tx_code">RED</span> davon ab, in welcher Reihenfolge die Header-Dateien inkludiert wurden. Diese Abhängigkeit ist sehr fehleranfällig.<br></div>
<div class="vorspann">Im Gegensatz dazu stellt es keinen Unterschied dar, in welcher Reihenfolge Module importiert werden.<br></div>
<div class="ztitel_kleiner">Mehrfache Definition von Symbolen<br></div>
<div class="text">ODR steht für One Definition Rule und sagt im Falle einer Funktion aus:</div>
<div class="text"><ul><li>Eine Funktion kann nicht mehr als eine Definition pro Übersetzungseinheit besitzen.</li><li>Eine Funktion kann nicht mehr als eine Definition pro Programm besitzen.</li><li>Eine Inline-Funktion mit externer Bindung kann in mehr als einer Übersetzungseinheit definiert werden. Für jede Definition muss aber gelten, dass sie identisch ist.</li></ul></div>
<div class="text">Lass mich testen, ob sich mein Linker beschwert, wenn ich versuche ein Programm zu linken und dabei die One Definition Rule verletze. Das folgende Codebeispiel besitzt zwei Header-Dateien <span class="tx_code">header.h</span>&nbsp;und <span class="tx_code">header2.h</span>. Das <span class="tx_code">main-</span>Programm inkludiert zweimal die Header-Datei [code]header.h[/code] und bricht damit die One Definition Rule, da die Funktion&nbsp;<span class="tx_code">func</span>&nbsp;dadurch doppelt inkludiert wird.<br></div>
<div class="pre">// header.h<br><br>void func() {}<br> </div>
<div class="pre">// header2.h<br><br>#include "header.h"<br> </div>
<div class="pre">// main.cpp<br><br>#include "header.h"<br>#include "header2.h"<br><br>int main() {}<br> <br></div>
<div class="text">Der Linker beschwert sich sofort über die doppelte Definition von <span class="tx_code">func</span>:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/2/2/7/5/TN_193241361_cde99a99d4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Sicherlich haben wir uns an hässliche Workarounds wie einen Inklude-Guard für Header-Dateien gewöhnt. Das Hinzufügen des Inklude-Guard [code]FUNC_H[/code] zu der Header-Datei löst das Problem.</div>
<div class="pre">// header.h<br><br>#ifndef FUNC_H<br>#define FUNC_H<br><br>void func(){}<br><br>#endif<br></div>
<div class="text"><b>Im Gegensatz dazu sind identische Namen mit Modulen sehr unwahrscheinlich.</b></div>
<div class="text">Bevor ich diesen Artikel abschließe, möchte ich noch die Vorteile von Modulen zusammenfassen.</div>
<div class="ztitel">Vorteile von Modulen</div>
<div class="text"><ul><li>Ein Modul wird nur einmal importiert. Dieser Prozess ist buchstäblich umsonst.</li><li>Es stellt keinen Unterschied dar, in welcher Reihenfolge Module importiert werden.</li><li>Identische Namen mit Modulen sind sehr unwahrscheinlich.</li><li>Module erlauben es dir, die logische Struktur deines Codes auszudrücken. Du kannst explizit angeben, welche Namen exportiert werden sollen oder nicht. Zusätzlich lassen sich Module einfach in neue Module verpacken und damit dem Kunden als logisches Paket anbieten.</li><li>Dank Modulen besteht nicht mehr die Notwendigkeit, den Sourcecode in das Interface und die Implementierung zu separieren.</li></ul></div>
<div class="ztitel">Wie geht's weiter? <br></div>
<div class="text">Module versprechen viel. In meinen nächsten Artikel werde ich mein erstes Modul definieren und einsetzen.<br></div>
