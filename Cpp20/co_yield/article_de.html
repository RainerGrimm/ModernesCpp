<div class="vorspann">In diesem Artikel wird das Schlüsselwort [code]co_yield[/code] genauer unter die Lupe genommen. Dank ihm ist es möglich, einen unendlichen Datenstrom zu erzeugen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/7/5/4/3/7/TN_208375234_ff1c4dfaa6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die folgenden Artikel habe ich bereits auf meiner pragmatischen Reise durch die drei neuen Schlüsselwörter <span class="tx_code">co_return</span>, <span class="tx_code">co_yield</span> und <span class="tx_code">co_await</span> verfasst:</div>
<div class="text"><ul><li> <a title="Link auf https://heise.de/-5066861" alt="%7B%22text%22%3A%22Einfache%20Futures%20mit%20Coroutinen%20implementieren%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5066861%22%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5066861%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%7D" href="https://heise.de/-5066861" class="">Einfache Futures mit Coroutinen implementieren</a> </li><li> <a title="Link auf https://heise.de/-5073590" alt="%7B%22alias%22%3A%22%22%2C%22text%22%3A%22Lazy%20Futures%20mit%20Coroutinen%20in%20C%2B%2B20%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5073590%22%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5073590%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%7D" href="https://heise.de/-5073590" class="">Lazy Futures mit Coroutinen in C++20</a></li><li> <a title="Link auf https://heise.de/-5987297" alt="%7B%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5987297%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Mit%20Coroutinen%20einen%20Future%20in%20einem%20eigenen%20Thread%20ausf%C3%BChren%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5987297%22%2C%22mediasync_id%22%3A%22%22%7D" href="https://heise.de/-5987297" class="">Mit Coroutinen einen Future in einem eigenen Thread ausführen</a> <br></li></ul></div>
<div class="ztitel">Ein Generator<br></div>
<div class="text">Als Startpunkt meiner Variationen stelle ich einen Generator vor, der nur nach drei Werten fragt. Diese Vereinfachung und seine Visualisierung sollen helfen, den Arbeitsablauf des Generators besser zu verstehen:</div>
<div class="pre">// infiniteDataStreamComments.cpp<br><br>#include &lt;coroutine&gt;<br>#include &lt;memory&gt;<br>#include &lt;iostream&gt;<br><br>template&lt;typename T&gt;<br>struct Generator {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; struct promise_type;<br>&nbsp;&nbsp;&nbsp; using handle_type = std::coroutine_handle&lt;promise_type&gt;;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; Generator(handle_type h): coro(h) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Generator::Generator" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; handle_type coro;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; ~Generator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Generator::~Generator" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( coro ) coro.destroy();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; Generator(const Generator&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; Generator&amp; operator = (const Generator&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; Generator(Generator&amp;&amp; oth): coro(oth.coro) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oth.coro = nullptr;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; Generator&amp; operator = (Generator&amp;&amp; oth) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coro = oth.coro;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oth.coro = nullptr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; T getNextValue() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Generator::getNextValue" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coro.resume();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (13) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return coro.promise().current_value;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; struct promise_type {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::promise_type" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~promise_type() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::~promise_type" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_always initial_suspend() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::initial_suspend" &lt;&lt; '\n'; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_always final_suspend() noexcept {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::final_suspend" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto get_return_object() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::get_return_object" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Generator{handle_type::from_promise(*this)};&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_always yield_value(int value) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (8)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::yield_value" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_value = value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (9)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (10)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void return_void() {}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void unhandled_exception() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::exit(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T current_value;<br>&nbsp;&nbsp;&nbsp; };<br><br>};<br><br>Generator&lt;int&gt; getNext(int start = 10, int step = 10) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp; getNext: start" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; auto value = start;<br>&nbsp;&nbsp;&nbsp; for (true&nbsp;&nbsp;&nbsp;) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (11)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp; getNext: before co_yield" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; co_yield value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp; getNext: after co_yield" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value += step;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>int main() {<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; auto gen = getNext();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt;= 2; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto val = gen.getNextValue();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (12)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "main: " &lt;&lt; val &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (14)<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Wird das Programm auf dem <a title="Link auf https://godbolt.org/z/cTW9Gq" alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Compiler%20Explorer%20%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FcTW9Gq%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FcTW9Gq%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%7D" href="https://godbolt.org/z/cTW9Gq" class="">Compiler Explorer </a>ausgeführt, legt es seinen Arbeitsablauf offen. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/7/5/4/3/7/TN_208375241_2e34567760.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Nun widme ich mich der Analyse des Arbeitsablaufs.</div>
<div class="text">Der Aufruf <span class="tx_code">getNext()</span> (Zeile 1) stößt das Erzeugen des <span class="tx_code">Generator&lt;int&gt;</span> an. Zuerst wird der <span class="tx_code">promise_type</span> (Zeile 2) generiert. Dann kreiert der Aufruf <span class="tx_code">get_return_object</span> (Zeile 3) den Generator (Zeile 4) und speichert ihn in einer lokalen Variable. Das Ergebnis dieses Ausrufs wird dem Aufrufer zurückgegeben, wenn diese Coroutine das erste Mal pausiert. Das initiale Pausieren findet sofort statt (Zeile 5). Da die Methode <span class="tx_code">initial_suspend</span> einen Awaitable <span class="tx_code">std::suspend_always</span> (Zeile 6) als Rückgabewert besitzt, geht der Kontrollfluss der Coroutine <span class="tx_code">getNext</span> weiter, bis der Aufruf <span class="tx_code">co_yield value</span> in Zeile 7 ausgeführt wird. Dieser Aufruf wird auf die Funktion <span class="tx_code">yield_value(int value)</span> (Zeile 8) abgebildet, und der aktuelle Wert wird hinterlegt: <span class="tx_code">current_value = value</span> (Zeile 9). </div>
<div class="text">Die Methode <span class="tx_code">yield_value(int value</span>) gibt den Awaitable <span class="tx_code">std::suspend_always</span> (Zeile 10) zurück. Konsequenterweise wird die Ausführung der Coroutine pausiert, der Kontrollfluss geht an die <span class="tx_code">main</span>-Funktion zurück, und die <span class="tx_code">for</span>-Schleife beginnt (Zeile 11). Der Aufruf <span class="tx_code">gen.getNextValue()</span> (Zeile 12) stößt die Ausführung der Coroutine an, indem er diese dank <span class="tx_code">coro.resume()</span> (Zeile 13) wieder aufweckt. </div>
<div class="text">Darüber hinaus gibt die Funktion <span class="tx_code">getNextValue()</span> den aktuellen Wert zurück, den der bereits erfolgte Aufruf der Methode <span class="tx_code">yield_value(int value)</span> (Zeile 8) vorbereitet hat. Zuletzt werden die erzeugte Zahl in Zeile 14 dargestellt und die <span class="tx_code">for</span>-Schleife weiter ausgeführt. Zum Abschluss werden Generator und Promise zerstört.</div>
<div class="ztitel">Modifikationen<br></div>
<div class="text">Nach dieser detaillierten Analyse des Arbeitsablaufs möchte ich ihn leicht modifizieren. Mein Code-Schnipsel und die Zeilennummer basieren alle auf dem vorherigen Programm <span class="tx_code">infiniteDataStreamComments.cpp</span>. Der Einfachheit halber stelle ich nur die Veränderungen dar.</div>
<div class="text"><b>Die Coroutine wird nicht aufgeweckt</b></div>
<div class="text">Wenn ich das Aufwecken der Coroutine (Zeile 12) und das Darstellen des Werts (Zeile 14) auskommentiere, pausiert die Coroutine sofort:</div>
<div class="pre">int main() {<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; auto gen = getNext();<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt;= 2; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // auto val = gen.getNextValue();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // std::cout &lt;&lt; "main: " &lt;&lt; val &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Die Coroutine wird in diesem Fall nie ausgeführt, und der Generator und sein Promise werden erzeugt und gleich wieder zerstört.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/7/5/4/3/7/TN_208375249_9ec17dfea3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text"><b>initial_suspend pausiert nicht</b></div>
<div class="text">Im Programm gibt die Methode <span class="tx_code">initial_suspend</span> den Awaitable <span class="tx_code">std::suspend_always</span> (Zeile 5) zurück. Wie es der Name andeutet, führt das Awaitable <span class="tx_code">std::suspends_always</span> dazu, dass die Coroutine sofort pausiert. Nun ersetze ich <span class="tx_code">std::suspend_always</span> mit <span class="tx_code">std::suspend_never</span>:</div>
<div class="pre">std::suspend_never initial_suspend() {&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::initial_suspend" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; return {};<br>}</div>
<div class="text">Jetzt wird die Coroutine sofort ausgeführt und pausiert erst, wenn die Funktion <span class="tx_code">yield_value</span> (Zeile 8) prozessiert wird. Der darauffolgende Aufruf <span class="tx_code">gen.getNextValue()</span> (Zeile 12) weckt die Coroutine wieder auf und stößt die Ausführung der Funktion <span class="tx_code">yield_value</span> nochmals an. Das Ergebnis ist, dass der Startwert 10 ignoriert wird und die Coroutine die Werte 20, 30 und 40 zurückgibt. <br></div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/7/5/4/3/7/TN_208375253_80165fd54c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><b>yield_value pausiert nicht</b></div>
<div class="text">Die Methode <span class="tx_code">yield_value</span> (Zeile 8) wird durch den Aufruf <span class="tx_code">co_yield value</span> aufgerufen und bereitet den <span class="tx_code">current_value</span> (Zeile 9) vor. Die Funktion gibt den Awaitable <span class="tx_code">std::suspend_always</span> (Zeile 10) zurück und pausiert damit konsequenterweise. Ein anschließender Aufruf von <span class="tx_code">gen.getNextValue</span> (Zeile 12) muss daher die Corutine wieder aufwecken. Was passiert nun, wenn ich den Rückgabewert der Methode <span class="tx_code">yield_value</span> auf <span class="tx_code">std::suspend_never</span> ändere? <br></div>
<div class="pre">std::suspend_never yield_value(int value) {&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::yield_value" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; current_value = value;<br>&nbsp;&nbsp;&nbsp; return {};<br>}</div>
<div class="text">Die<span class="tx_code"> while-</span>Schleife (Zeile 1) läuft für immer und die Coroutine liefert keinen Wert. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/7/5/4/3/7/TN_208375260_8f279ae41b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">@<a title="Link auf https://github.com/mattgodbolt" alt="%7B%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fmattgodbolt%22%2C%22text%22%3A%22Matt%20Godbolt%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fmattgodbolt%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%7D" href="https://github.com/mattgodbolt" class="">Matt Godbolt</a>: Dies war kein "Denial of Service"-Angriff.</div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">In diesem Artikel habe ich nicht ausgenutzt, dass die Coroutine ein Klassen-Template ist. In meinem nächsten Artikel werde ich die Coroutine so verallgemeinern, sodass sie eine endliche Anzahl beliebiger Werte zurückgeben kann.<br></div>