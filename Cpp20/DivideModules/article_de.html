<div class="vorspann">Wenn das Modul größer wird, sollte es in handliche Komponenten aufgeteilt werden. C++20 bietet dafür zwei Möglichkeiten an: Submodule und Partitionen. In diesem Artikel schaue ich mir beide Optionen genauer an.</div>
<div class="text">Diesem Artikel möchte ich noch eine kurze Anmerkung vorausschicken. Der Einfachheit halber werde ich die Trennung von Module Interface Unit und Module Implementation Unit ignorieren. Das heißt, meine Module werden aus einer Datei bestehen. Zusätzlich werde ich keine Namensräume verwenden. Ich habe beide Features bereits in dem vorherigen Artikel: "<a class="" title="Link auf https://heise.de/-4727382" alt="%7B%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4727382%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4727382%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%3A%20Module%20Interface%20Unit%20und%20Module%20Implemenation%20Unit%22%7D" href="https://heise.de/-4727382">C++20: Module Interface Unit und Module Implemenation Unit</a>" vorgestellt. </div>
<div class="text">Submodule sind einfach umzusetzen. Daher werde ich mit ihnen beginnen.</div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/0/3/6/9/5/TN_194186233_6575b52d27.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Submodule<br></div>
<div class="text">Ein Modul kann Module importieren und diese wieder zurückexportieren. Im folgenden Beispiel importiert das Modul <span class="tx_code">math</span> die Submodule <span class="tx_code">math.math</span>1 und <span class="tx_code">math.math2</span>.</div>
<div class="text"><ul><li>Modul <span class="tx_code">math</span><br></li></ul></div>
<div class="pre">// mathModule.ixx<br><br>export module math;<br><br>export import math.math1;<br>export import math.math2;<br></div>
<div class="text">Der Ausdruck <span class="tx_code">export import math.math1</span> importiert das Modul <span class="tx_code">math.math1</span> und exportiert es als Bestandteil des Moduls <span class="tx_code">math</span> zurück.</div>
<div class="text">Der Vollständigkeit halber sind hier die Module <span class="tx_code">math.math1</span> und <span class="tx_code">math.math2</span>. Ich verwende einen Punkt, um das Modul von seinen Submodulen zu trennen. Er ist aber nicht notwendig.</div>
<div class="text"><ul><li>Submodul <span class="tx_code">math.math1</span></li></ul></div>
<div class="pre">// mathModule1.ixx<br><br>export module math.math1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)&nbsp;&nbsp; <br><br>export int add(int fir, int sec) { // (2)<br>&nbsp;&nbsp;&nbsp; return fir * sec;<br>}<br></div>
<div class="text"><ul><li>Submodul<span class="tx_code"> math.math2</span></li></ul></div>
<div class="pre">// mathModule2.ixx<br><br>export module math.math2;&nbsp;&nbsp;&nbsp;&nbsp; // (1)&nbsp;&nbsp; <br><br>export {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; int mul(int fir, int sec) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir * sec;<br>&nbsp;&nbsp;&nbsp; }<br>}<br></div>
<div class="text">Wenn du die Submodule sorgfältig studierst, wirst du einen kleinen Unterschied zwischen der <span class="tx_code">export</span>-Anweisung (2) in den Modulen <span class="tx_code">math.math1</span> und <span class="tx_code">math.math2</span> feststellen. <span class="tx_code">math.math1</span> verwendet einen <span class="tx_code">export</span>-Spezifizierer und <span class="tx_code">math.math2</span> ein sogenannte <span class="tx_code">export</span>-Gruppe oder <span class="tx_code">export</span>-Block.</div>
<div class="text">Aus der Sicht der Anwender ist die Verwendung des Moduls <span class="tx_code">math</span> einfach.</div>
<div class="text"><ul><li>Client-Programm</li></ul></div>
<div class="pre">// mathModuleClient.cpp<br><br>import std.core;<br>import math;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "add(3, 4): " &lt;&lt; add(3, 4) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "mul(3, 4): " &lt;&lt; mul(3, 4) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Das Kompilieren, Linken und Ausführen des Programms lässt sich mit der Microsoft-Implementierung von Modulen wie gewohnt umsetzen:</div>
<div class="pre">cl.exe /std:c++latest /c /experimental:module mathModule1.ixx /EHsc /MD&nbsp; // (3)<br>cl.exe /std:c++latest /c /experimental:module mathModule2.ixx /EHsc /MD&nbsp; // (3)<br>cl.exe /std:c++latest /c /experimental:module mathModule.ixx /EHsc /MD&nbsp;&nbsp; // (3)<br>cl.exe /std:c++latest /experimental:module mathModuleClient.cpp mathModule1.obj mathModule2.obj mathModule.obj /EHsc /MD // (4)</div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/0/3/6/9/5/TN_194186243_783c81e367.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Jeder Kompilierschritt (3) erzeugt zwei Artefakte: Die IFC-Datei (interface file) <span class="tx_code">*.ifc</span>, die implizit in (4) verwendet wird, und die <span class="tx_code">*.obj</span>-Datei, die explizit in (4) eingesetzt wird.</div>
<div class="text">Ich habe bereits geschrieben, dass ein Submodul lediglich ein Modul ist. Jedes Submodul besitzt eine Modul-Deklaration (1). Konsequenterweise kann ich ein zweites Client-Programm implementieren, das nur das Modul <span class="tx_code">math.math1</span> benötigt.</div>
<div class="text"><ul><li> Zweites Client-Programm</li></ul></div>
<div class="pre">// mathModuleClient1.cpp<br><br>import std.core;<br>import math.math1;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "add(3, 4): " &lt;&lt; add(3, 4) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Für dieses Programm ist es ausreichend, das neue Client-Programm zu kompilieren und zu linken. Das existierende Modul <span class="tx_code">math.math1</span> lässt sich direkt dafür verwenden:</div>
<div class="pre">cl.exe /std:c++latest /experimental:module mathModuleClient1.cpp mathModule1.obj /EHsc /MD</div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/0/3/6/9/5/TN_194186247_f3fa3946dc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Trennung von Modulen in Module und Submodule ist ein einfaches Mittel für Moduldesigner, Anwendern die Möglichkeit zu geben, die Module feingranular zu importieren. Diese Beobachtung gilt aber nicht für Modul-Partitionen.</div>
<div class="ztitel">Modul-Partitionen</div>
<div class="text">Ein Modul lässt sich in Partitionen aufteilen. Jede Partition besteht aus einem Module Interface Unit (partition interface file) und keiner oder mehrerer Module Implementation Units (<a class="" title="Link auf https://heise.de/-4727382" alt="%7B%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4727382%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4727382%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%3A%20Module%20Interface%20Unit%20und%20Module%20Implementation%20Unit%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%7D" href="https://heise.de/-4727382">C++20: Module Interface Unit und Module Implementation Unit</a>). Die Namen, die die Partitionen exportieren, werden durch das primäre Module Interface (primary modul interface oder primare interface file) importiert und zurückexportiert. Der Name einer Partition muss mit dem Namen des Moduls beginnen. Eine Partition kann nicht selbstständig existieren. </div>
<div class="text">Leider ist die Beschreibung einer Modul-Partition deutlich komplizierter als ihre Umsetzung. In den folgenden Zeilen werde ich das Modul [code]math[/code] und seine Submodule [code]math.math1[/code] und [code]math.math2[/code] in Modul-Partitionen transformieren. Bei diesem einfachen Vorgang verwende ich die soeben eingeführten Begriffe der Modul-Partition.</div>
<div class="text"><ul><li>Das primäre Module Interface <span class="tx_code">mathPartition.ixx</span></li></ul></div>
<div class="pre">// mathPartition.ixx<br><br>export module math;&nbsp;&nbsp; // (1)<br><br>export import :math1; // (2)<br>export import :math2; // (2)<br></div>
<div class="text">Das primäre Module Interface besteht aus der Modul-Deklaration (1). Es importiert und exportiert die Paritionen <span class="tx_code">math1</span> und <span class="tx_code">math2</span> mithilfe der Doppelpunkte zurück. Der Name der Partition muss mit dem Namen des Moduls beginnen. Konsequenterweise ist dieser daher im Ausdruck (2) nicht anzugeben. </div>
<div class="text"><ul><li>Modul-Partionen (<span class="tx_code">mathPartition1.ixx</span> und <span class="tx_code">mathPartition2.ixx</span>)</li></ul></div>
<div class="pre">export module math:math1;&nbsp;&nbsp;&nbsp;&nbsp; // (1)&nbsp;&nbsp; <br><br>export int add(int fir, int sec) {<br>&nbsp;&nbsp;&nbsp; return fir * sec;<br>}</div>
<div class="pre">// mathPartition2.ixx<br><br>export module math:math2;&nbsp;&nbsp;&nbsp;&nbsp; // (1)&nbsp;&nbsp; <br><br>export { <br>&nbsp;&nbsp;&nbsp; int mul(int fir, int sec) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir * sec;<br>&nbsp;&nbsp;&nbsp; }<br>}</div>
<div class="text">Analog zur Modul-Deklaration erklärt (1) eine sogenannte Module Interface Partition. Sie ist auch eine Module Interface Unit. Der Name <span class="tx_code">math</span> steht für den Namen des Moduls und die Namen <span class="tx_code">math1</span> und <span class="tx_code">math2</span> stehen für die der Partition. </div>
<div class="text"><ul><li>Client-Programm</li></ul></div>
<div class="pre">// mathModuleClient.cpp<br><br>import std.core;<br>import math;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "add(3, 4): " &lt;&lt; add(3, 4) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "mul(3, 4): " &lt;&lt; mul(3, 4) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Das Client-Programm ist identisch mit dem, das ich für Submodule verwendet habe. Die gleiche Aussage gilt für die Erzeugung des ausführbaren Programms:</div>
<div class="pre">cl.exe /std:c++latest /c /experimental:module mathPartition1.ixx /EHsc /MD<br>cl.exe /std:c++latest /c /experimental:module mathPartition2.ixx /EHsc /MD<br>cl.exe /std:c++latest /c /experimental:module mathPartition.ixx /EHsc /MD<br>cl.exe /std:c++latest /experimental:module mathModuleClient.cpp mathPartition1.obj mathPartition2.obj mathPartition.obj /EHsc /MD<br></div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/0/3/6/9/5/TN_194186256_19e9157f0c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Wie geht's weiter?<br></div>
<div class="text">Module in C++20 haben noch mehr zu bieten. So führen sie zum Beispiel "Header Units" ein und unterscheiden zwischen dem globalen und privaten Modul-Fragment. Zuletzt möchte ich auf das Linken des Programms eingehen.</div>
<div><img class="rteInlinetag" src="https://heise-cms.de/image/rte/textbox.svg" title="<ir_inline itemname=textboxen_mvp_text:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
