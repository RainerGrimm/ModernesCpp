<div class="vorspann">Dank Module Interface Unit und Module Implementation Unit lässt sich die Definition eines Moduls in sein Interface und seine Implementierung aufteilen. Der heutige Artikel zeigt, wie sich das umsetzen lässt.</div>
<div class="text">Wie ich in meinem letzten Artikel "<a href="https://heise.de/-4722629" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4722629%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%3A%20Ein%20einfaches%20math-Modul%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4722629%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%7D" title="Link auf https://heise.de/-4722629" class="">C++20: Ein einfaches math-Modul</a>" angekündigt habe, werde ich diesen Artikel mit meiner Clang-Odyssee beginnen. Mein kleiner Umweg ist zugleich eine kompakte Wiederholung meines letzten Artikels.<br></div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/9/5/7/3/TN_193865748_a583053466.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Meine Clang-Odyssee<br></div>
<div class="text">Aufgrund der Vorträge von Boris Kolpackov "<a href="https://github.com/CppCon/CppCon2017/blob/master/Presentations/Building%20C%2B%2B%20Modules/Building%20C%2B%2B%20Modules%20-%20Boris%20Kolpackov%20-%20CppCon%202017.pdf" title="Link auf https://github.com/CppCon/CppCon2017/blob/master/Presentations/Building%20C%2B%2B%20Modules/Building%20C%2B%2B%20Modules%20-%20Boris%20Kolpackov%20-%20CppCon%202017.pdf" alt="%7B%22href%22%3A%22https%3A%2F%2Fgithub.com%2FCppCon%2FCppCon2017%2Fblob%2Fmaster%2FPresentations%2FBuilding%2520C%252B%252B%2520Modules%2FBuilding%2520C%252B%252B%2520Modules%2520-%2520Boris%2520Kolpackov%2520-%2520CppCon%25202017.pdf%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Building%20C%2B%2B%20Modules%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2FCppCon%2FCppCon2017%2Fblob%2Fmaster%2FPresentations%2FBuilding%2520C%252B%252B%2520Modules%2FBuilding%2520C%252B%252B%2520Modules%2520-%2520Boris%2520Kolpackov%2520-%2520CppCon%25202017.pdf%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%7D" class="">Building C++ Modules</a>" auf der CppCon 2017 oder Corentin Jabot "<a href="https://cor3ntin.github.io/posts/modules/" alt="%7B%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fcor3ntin.github.io%2Fposts%2Fmodules%2F%22%2C%22text%22%3A%22Modules%20are%20not%20a%20tooling%20opportunity%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fcor3ntin.github.io%2Fposts%2Fmodules%2F%22%7D" title="Link auf https://cor3ntin.github.io/posts/modules/" class="">Modules are not a tooling opportunity</a>" hatte ich geglaubt, dass die Compiler-Hersteller die folgenden Suffixe für Module vorschlagen:<br></div>
<div class="text"><ul><li>Windows: cppm</li><li>Clang: ixx</li><li>GCC: kein Suffix<br></li></ul></div>
<div class="text">Im Fall des Clang-Compilers lag ich daneben. Das ist das einfache <span class="tx_code">math</span>-Modul, das ich mit dem Clang-Compiler übersetzen wollte:</div>
<div class="pre">// math.cppm<br><br>export module math;<br><br>export int add(int fir, int sec){<br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>} <br></div>
<div class="text">Ich verwendete zum Übersetzen den Clang-9- und den Clang-10-Compiler auf Microsoft und Linux. Darüber hinaus baute ich den aktuellen Clang 11 direkt aus den Quellen und setzte ihn ein. Alle meine Versuche, das Modul zu erzeugen, endeten mit einer ähnlichen Fehlermeldung: </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/9/5/7/3/TN_193865757_e6bcdedef3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Kommandozeile sollte das Modul <span class="tx_code">math.pcm</span> erzeugen. Ich verwendete die Kommandozeile<span class="tx_code"> -std=c++20 -fmodules-ts</span>, aber die Fehlermeldung ergab: <span class="tx_code">module interface compilation requires <b>'-std=c++20' or '-fmodules-ts'</b></span>. Ich spielte alle Variationen der beiden Flags durch, fügte das globale Modul-Fragment der Modul-Definition hinzu und versuchte es noch mit weiteren Flags. Das Ergebnis war immer dasselbe.</div>
<div class="text">Dann bat ich Arthur O'Dwyer und Roland Bock um ihre Hilfe. Arthur hatte bereits Module mit dem Clang erzeugt: "<a title="Link auf https://quuxplusone.github.io/blog/2019/11/07/modular-hello-world/" alt="%7B%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Hello%20World%20with%20C%2B%2B2a%20modules%22%2C%22destination%22%3A%22https%3A%2F%2Fquuxplusone.github.io%2Fblog%2F2019%2F11%2F07%2Fmodular-hello-world%2F%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fquuxplusone.github.io%2Fblog%2F2019%2F11%2F07%2Fmodular-hello-world%2F%22%7D" class="" href="https://quuxplusone.github.io/blog/2019/11/07/modular-hello-world/">Hello World with C++2a modules</a>". Roland hatte wie ich den Clang 11 direkt aus den Quellen gebaut und mein <span class="tx_code">math</span>-Modul direkt erzeugen können. Wir beiden hatten buchstäblich denselben Clang-Compiler und dieselbe Moduldefinition verwendet. Buchstabe für Buchstabe verglich ich seine Kommandozeile mit meiner. Da fiel mir der entscheidende Unterschied auf:</div>
<div class="pre">Mine:&nbsp;&nbsp; clang++ -std=c++20 - -fmodules-ts -stdlib=libc++ -c math.cppm - Xclang -emit-module-interface -o math.pcm<br>Roland: clang++ -std=c++20 - -fmodules-ts -stdlib=libc++ -c math.cpp - Xclang -emit-module-interface -o math.pcm</div>
<div class="text">Roland nannte seine Moduldefinition <span class="tx_code">math.cpp</span>. <span class="tx_code">cpp</span> war genau das Suffix, das auch Arthur eingesetzt hatte. <b>Gib deinem Modul nicht das Suffix cppm</b>.</div>
<div class="text">Jetzt waren das Erzeugen und das Verwenden des Moduls ein Kinderspiel:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/9/5/7/3/TN_193865762_3c7076f590.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Um diesen Exkurs zu beenden, stelle ich kurz noch die <span class="tx_code">client.cpp</span>-Datei vor und sage noch ein paar Worte zu den Flags für den Clang-Compiler:<br></div>
<div class="pre">// client.cpp<br><br>import math;<br><br>int main() {<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; add(2000, 20);<br>&nbsp;&nbsp; <br>}</div>
<div class="pre">clang++ -std=c++2a -stdlib=libc++ -c math.cppm - Xclang -emit-module-interface -o math.pcm // (1)<br>clang++ -std=c++2a -stdlib=libc++ -fprebuilt-module-path=. client.cpp math.pcm -o client&nbsp;&nbsp; // (2)<br></div>
<div class="text"><ol><li>Erzeugt das Modul<span class="tx_code"> math.pcm</span>. Das Suffix <span class="tx_code">pcm</span> steht für ein vorkompiliertes Modul (precompiled modul). Die Kombination der Flags <span class="tx_code">-Xclang -emit-module-interface</span> ist für die Erzeugung des vorkompilierten Moduls notwendig.</li><li>Erzeugt die ausführbare Datei <span class="tx_code">client</span>, die das Modul <span class="tx_code">math.pcm</span> verwendet. Dazu musst du den Pfad zu dem Modul mit dem Flag <span class="tx_code">-fprebuilt-module-path</span> angeben.<br></li></ol></div>
<div class="text">Das Modul <span class="tx_code">math</span> war sehr einfach gestrickt. Das nächste Modul soll ein wenig anspruchsvoller werden.</div>
<div class="ztitel">Regel für die Struktur eines Moduls<br></div>
<div class="text">Hier ist die erste Regel für die Struktur eines Moduls:</div>
<div class="pre">module;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // global module fragment<br><br>#include &lt;headers for libraries not modularized so far&gt;<br><br>export module math;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // module declartion <br><br>import &lt;importing of other modules&gt; &nbsp;<br><br>&lt;non-exported declarations&gt;&nbsp; // names with only visibiliy inside the module<br><br>export namespace math {<br><br>&nbsp;&nbsp;&nbsp; &lt;exported declarations&gt;&nbsp; // exported names <br><br>}</div>
<div class="text">Diese Regel hilft in doppelter Hinsicht. Sie gibt dir eine einfache Struktur für ein Modul vor und eine Idee, worüber ich noch schreiben werde. Was ist daher neu in der Struktur des Moduls?</div>
<div class="text"><ul><li> In Module lassen sich andere Module importieren. Sie haben Modulbindung und sind nicht außerhalb des Moduls sichtbar. Diese Beobachtung gilt auch für die nichtexportierten Deklarationen (non-exported declarations).</li><li>Ich habe die exportierten Namen in einen Namensraum <span class="tx_code">math</span> verpackt. Er besitzt denselben Namen wie das Modul.</li><li>Die Namen in dem Modul sind lediglich deklariert und nicht definiert. Nun möchte ich auf die Trennung des Interfaces und der Implementierung eines Moduls eingehen. <br></li></ul></div>
<div class="ztitel">Module Interface Unit und Module Implementation Unit<br></div>
<div class="text">Entsprechend der Regel zum Aufbau eines Moduls möchte ich das Modul <span class="tx_code">math</span> des letzten Artikels "<a href="https://heise.de/-4722629" class="" alt="%7B%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4722629%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4722629%22%2C%22text%22%3A%22C%2B%2B20%3A%20Ein%20einfaches%20math-Modul%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D" title="Link auf https://heise.de/-4722629">C++20: Ein einfaches math-Modul</a>" refaktorieren.</div>
<div class="ztitel_kleiner">Module Interface Unit<br></div>
<div class="pre">// mathInterfaceUnit.ixx<br><br>module;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>import std.core;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>export module math;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>export namespace math {<br><br>&nbsp;&nbsp;&nbsp; int add(int fir, int sec);<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; int getProduct(const std::vector&lt;int&gt;&amp; vec);<br><br>}</div>
<div class="text"><ul><li> Die Module Interface Unit enthält die exportierte Modul-Deklaration: <span class="tx_code">export module math</span>.</li><li>Die Namen <span class="tx_code">add</span> und <span class="tx_code">getProduct</span> werden exportiert.</li><li>Ein Modul kann nur eine Module Interface Unit besitzen.</li></ul></div>
<div class="ztitel_kleiner">Module Implementation Unit</div>
<div class="pre">// mathImplementationUnit.cpp<br><br>module math;<br><br>import std.core;<br><br>int add(int fir, int sec){<br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>}<br><br>int getProduct(const std::vector&lt;int&gt;&amp; vec) {<br>&nbsp;&nbsp;&nbsp; return std::accumulate(vec.begin(), vec.end(), 1, std::multiplies&lt;int&gt;());<br>}</div>
<div class="text"><ul><li> Die Module Implementation Unit enthält die nicht exportierte Moduldeklaration: <span class="tx_code">module math</span>.</li><li>Ein Modul kann mehrere Module Implementation Units besitzen. <br></li></ul> </div>
<div class="ztitel_kleiner">Das<span class="tx_code"> main</span>-Programm</div>
<div class="pre">// client3.cpp<br><br>import std.core;<br><br>import math;<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;&nbsp;&nbsp; <br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "math::add(2000, 20): " &lt;&lt; math::add(2000, 20) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; myVec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "math::getProduct(myVec): " &lt;&lt; math::getProduct(myVec) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; <br>}</div>
<div class="text"><ul><li>Für Anwender ändert sich nicht viel. Sie müssen lediglich den Namensraum <span class="tx_code">math</span> verwenden.<br></li></ul></div>
<div class="ztitel_kleiner">Bauen der ausführbaren Datei<br></div>
<div class="text">Das händische Bauen der ausführbaren Datei besteht aus ein paar Schritten:</div>
<div class="pre">cl.exe /std:c++latest /c /experimental:module mathInterface.ixx /EHsc /MD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>cl.exe /std:c++latest /c /experimental:module mathImplementationUnit.cpp /EHsc /MD // (2)<br>cl.exe /std:c++latest /c /experimental:module client3.cpp /EHsc /MD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>cl.exe client3.obj mathInterfaceUnit.obj mathImplementationUnit.obj&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)</div>
<div class="text"><ol><li>Erzeugt die Objektdatei <span class="tx_code">mathInterfaceUnit.obj</span> und die Module-Interface-Datei <span class="tx_code">math.ifc.</span></li><li>Erzeugt die Objektdatei <span class="tx_code">mathImplementationUnit.obj.</span></li><li>Erzeugt die Objektdatei <span class="tx_code">client3.obj.</span></li><li>Erzeugt die Objektdatei <span class="tx_code">client3.exe.</span></li></ol></div>
<div class="text">Für den Microsoft-Compiler müssen das Exception Handling (<a class="" alt="%7B%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fbuild%2Freference%2Feh-exception-handling-model%3Fview%3Dvs-2019%22%2C%22text%22%3A%22%2FEHsc%22%2C%22href%22%3A%22https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fbuild%2Freference%2Feh-exception-handling-model%3Fview%3Dvs-2019%22%7D" title="Link auf https://docs.microsoft.com/en-us/cpp/build/reference/eh-exception-handling-model?view=vs-2019" href="https://docs.microsoft.com/en-us/cpp/build/reference/eh-exception-handling-model?view=vs-2019">/EHsc</a>) und die Multithreading-Bibliothek (<span class="tx_code"><a href="https://docs.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library?view=vs-2019" title="Link auf https://docs.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library?view=vs-2019" alt="%7B%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fbuild%2Freference%2Fmd-mt-ld-use-run-time-library%3Fview%3Dvs-2019%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fbuild%2Freference%2Fmd-mt-ld-use-run-time-library%3Fview%3Dvs-2019%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22%2FMD%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D" class="">/MD</a></span>) verwendet werden. Darüber hinaus ist das Flag <span class="tx_code"> <a title="Link auf https://docs.microsoft.com/en-us/cpp/build/reference/std-specify-language-standard-version?view=vs-2019" alt="%7B%22anchor%22%3A%22%22%2C%22text%22%3A%22%2Fstd%3Ac%2B%2Blatest%22%2C%22destination%22%3A%22https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fbuild%2Freference%2Fstd-specify-language-standard-version%3Fview%3Dvs-2019%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fbuild%2Freference%2Fstd-specify-language-standard-version%3Fview%3Dvs-2019%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%7D" class="" href="https://docs.microsoft.com/en-us/cpp/build/reference/std-specify-language-standard-version?view=vs-2019">/std:c++latest</a> </span> notwendig. </div>
<div class="text">Zu guter Letzt ist hier die Ausgabe des Programms: <br></div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/9/5/7/3/TN_193865765_92f12b0afe.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">In meinem nächsten Artikel werde ich das Modul <span class="tx_code">math</span> um weitere Features erweitern. Zuerst werde ich Module in ein Modul importieren und die importierten Module als Bestandteil eines neuen Moduls anbieten; darüber hinaus wird das nächste Modul Namen enthalten, die nur innerhalb des Moduls sichtbar sind. <br></div>
<div class="simple-translate-result-contents"><br> <br></div>
