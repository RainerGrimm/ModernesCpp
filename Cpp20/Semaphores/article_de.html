<div class="vorspann">Semaphoren bieten sich an, um den gemeinsamen Zugriff auf geteilte Ressourcen zu koordinieren. Zusätzlich lässt sich mit ihnen Ping-Pong spielen. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/3/9/9/9/4/TN_205506934_ef0b975bd4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Eine zählende Semaphore ist eine spezielle Semaphore, die einen Zähler größer Null besitzt. Dieser Zähler wird im Konstruktor initialisiert. Das Anfordern der Semaphore dekrementiert und das ihr Freigeben&nbsp; inkrementiert den Zähler. Wenn ein Thread versucht, die Semaphore anzufordern, falls der Zähler den Wert Null besitzt, wird dieser Thread blockiert, bis ein anderer Thread die Semaphore freigibt, indem er den Zähler inkrementiert.</div>
<div class="ztitel">Wer hat's erfunden? <br></div>
<div class="text">Der dänische Informatiker <a title="Link auf https://de.wikipedia.org/wiki/Edsger_W._Dijkstra" alt="%7B%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FEdsger_W._Dijkstra%22%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FEdsger_W._Dijkstra%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Edsger%20W.%20Dijkstra%20%22%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" href="https://de.wikipedia.org/wiki/Edsger_W._Dijkstra" class="">Edsger W. Dijkstra </a>stellte 1965 das Konzept einer Semaphore vor. Eine Semaphore ist eine Datenstruktur mit einer Queue und einem Zähler. Der Zähler wird auf einen Wert größer oder gleich Null initialisiert. Sie unterstützt die zwei Operationen <span class="tx_code">wait</span> und <span class="tx_code">signal</span>. <span class="tx_code"></span>Erstere fordert die Semaphore an und dekrementiert den Zähler. In diesem Fall wird der ausführende Thread blockiert, falls die Semaphore den Wert Null besitzt. <span class="tx_code">signal</span> gibt die Semaphore frei und inkrementiert den Zähler. Blockierte Threads werden zur Queue hinzugefügt, um <a title="Link auf https://en.wikipedia.org/wiki/Starvation_(computer_science)" alt="%7B%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FStarvation_%28computer_science%29%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FStarvation_%28computer_science%29%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Starvation%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D" href="https://en.wikipedia.org/wiki/Starvation_(computer_science)" class="">Starvation</a> zu vermeiden. </div>
<div class="text">Der&nbsp; Begriff Semaphore steht ursprünglich für ein Eisenbahnsignal.</div>
<div class="ztitel">Zählende Semaphoren in C++20</div>
<div class="text">C++20 unterstützt eine <span class="tx_code">std::binary_semaphore</span>, die ein Alias auf eine <span class="tx_code">std::counting_semaphore&lt;1&gt;</span> ist. In diesem Fall ist der maximale Wert für den Zähler 1. Eine <span class="tx_code">std::binary_semaphore</span> kann dazu verwendet werden, einen <a title="Link auf https://en.cppreference.com/w/cpp/named_req/BasicLockable" alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22text%22%3A%22Lock%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FBasicLockable%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FBasicLockable%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%7D" href="https://en.cppreference.com/w/cpp/named_req/BasicLockable" class="">Lock</a> zu implementieren:<br></div>
<div class="pre">using binary_semaphore = std::counting_semaphore&lt;1&gt;;</div>
<div class="text">Im Gegensatz zu einem <span class="tx_code">std::mutex</span> ist eine <span class="tx_code">std::counting_semaphore</span> nicht an einen Thread gebunden. Das heißt, dass das Anfordern und Freigeben der Semaphore in verschiedenen Threads stattfinden kann. Die folgende Tabelle stellt das Interface einer<span class="tx_code"> std::counting_semaphore</span> vor: <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/3/9/9/9/4/TN_205506941_c958527243.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Der Aufruf des Konstruktors <span class="tx_code">std::counting_semaphore&lt;10&gt; sem(5)</span> erzeugt die Semaphore <span class="tx_code">sem</span>, die maximal den Wert 10 annehmen kann. Der Zähler besitzt den Wert 5. <span class="tx_code">sem.max()</span> gibt den maximalen Wert für den Zähler zurück<span class="tx_code">.try_aquire_for(relTime)</span> benötigt eine Zeitdauer, die Funktion <span class="tx_code">sem.try_acquire_until(absTime)</span> einen Zeitpunkt. In meinen Artikeln zur Zeitbibliothek lassen sich die Details zu Zeitdauern und Zeitpunkten genauer nachlesen: <a title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/time" alt="%7B%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Ftime%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Ftime%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22time%22%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%7D" href="https://www.grimm-jaud.de/index.php/blog/tag/time" class="">time</a>. Die drei Aufrufe <span class="tx_code">sem.try_acquire</span>, <span class="tx_code">sem.try_acquire_for</span> und <span class="tx_code">sem.try_acquire_until</span> geben einen Wahrheitswert zurück, der den Erfolg der Operation anzeigt. </div>
<div class="text">Semaphoren werden typischerweise in Sender-Empfänger-Abläufen verwendet. Wird zum Beispiel eine Semaphore auf 0 initialisiert, blockiert der Empfänger-Aufruf <span class="tx_code">sem.acquire()</span>, bis der Sender <span class="tx_code">sem.release()</span> ausführt. Damit wartet der Empfänger auf die Benachrichtigung des Senders. Die einmalige Synchronisation von Threads lässt sich einfach mit Semaphoren umsetzen: <br></div>
<div class="pre">// threadSynchronizationSemaphore.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;semaphore&gt;<br>#include &lt;thread&gt;<br>#include &lt;vector&gt;<br><br>std::vector&lt;int&gt; myVec{};<br><br>std::counting_semaphore&lt;1&gt; prepareSignal(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>void prepareWork() {<br><br>&nbsp;&nbsp;&nbsp; myVec.insert(myVec.end(), {0, 1, 0, 3});<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Sender: Data prepared."&nbsp; &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; prepareSignal.release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>}<br><br>void completeWork() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Waiter: Waiting for data." &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; prepareSignal.acquire();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; myVec[2] = 2;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Waiter: Complete the work." &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; for (auto i: myVec) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::thread t1(prepareWork);<br>&nbsp;&nbsp;&nbsp; std::thread t2(completeWork);<br><br>&nbsp;&nbsp;&nbsp; t1.join();<br>&nbsp;&nbsp;&nbsp; t2.join();<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>}</div>
<div class="text">Die <span class="tx_code">std::counting_semaphore prepareSignal</span> (Zeile 1) kann die Werte 0 oder 1 besitzen. Im konkreten Anwendungsfall wird sie auf <span class="tx_code">0</span> (Zeile 1) initialisiert. Das heißt, dass der Aufruf <span class="tx_code">prepareSignal.release() </span>den Wert auf <span class="tx_code">1</span> (Zeile 2) setzt und den Aufruf <span class="tx_code">prepareSignal.acquire()</span> entblockt (Zeile 3). </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/3/9/9/9/4/TN_205506948_c7ace79ecb.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=1>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Nun möchte ich einen Performanztest mit einem Ping-Pong-Spiel durchführen.</div>
<div class="ztitel">Ein Ping-Pong-Spiel</div>
<div class="text">In meinem letzten Artikel "<a title="Link auf https://heise.de/-5019237" alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22Performanzvergleich%20von%20Bedingungsvariablen%20und%20Atomics%20in%20C%2B%2B20%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5019237%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5019237%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%7D" href="https://heise.de/-5019237" class="">Performanzvergleich von Bedingungsvariablen und Atomics in C++20</a>"&nbsp; implementierte ich ein Ping-Pong-Spiel. Das war die zentrale Idee des Spiels:&nbsp; Ein Thread führt eine <span class="tx_code">ping</span>- und ein anderer eine&nbsp;<span class="tx_code">pong</span>-Funktion aus. Der Ping-Thread wartet bei dem Spiel auf die Benachrichtigung des Pong-Threads. Der Pong-Thread schickt wiederum die Benachrichtigung zurück. Das Spiel soll nach 1.000.000 Ballwechseln beendet sein. Jedes Spiel führe ich fünfmal aus, um vergleichbare Performanzzahlen zu erhalten. Los geht das Spiel:</div>
<div class="pre">// pingPongSemaphore.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;semaphore&gt;<br>#include &lt;thread&gt;<br><br>std::counting_semaphore&lt;1&gt; signal2Ping(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>std::counting_semaphore&lt;1&gt; signal2Pong(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>std::atomic&lt;int&gt; counter{};<br>constexpr int countlimit = 1'000'000;<br><br>void ping() {<br>&nbsp;&nbsp;&nbsp; while(counter &lt;= countlimit) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal2Ping.acquire();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++counter;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal2Pong.release();<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>void pong() {<br>&nbsp;&nbsp;&nbsp; while(counter &lt; countlimit) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal2Pong.acquire();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal2Ping.release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; auto start = std::chrono::system_clock::now();<br><br>&nbsp;&nbsp;&nbsp; signal2Ping.release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::thread t1(ping);<br>&nbsp;&nbsp;&nbsp; std::thread t2(pong);<br><br>&nbsp;&nbsp;&nbsp; t1.join();<br>&nbsp;&nbsp;&nbsp; t2.join();<br><br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; dur = std::chrono::system_clock::now() - start;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Duration: " &lt;&lt; dur.count() &lt;&lt; " seconds" &lt;&lt; '\n';<br><br>}</div>
<div class="text">Das Programm <span class="tx_code">pingPongsemaphore.cpp</span> verwendet zwei Semaphoren: <span class="tx_code">signal2Ping </span>und <span class="tx_code">signal2Pong</span> (1 und 2). Beide können die Werte 0 und 1 annehmen und werden auf 0 initialisiert. Das bedeutet, wenn der Wert des Zählers von <span class="tx_code">signal2Ping</span> <span class="tx_code">0</span> ist, dass der Aufruf <span class="tx_code">signal2Ping.release()</span> (3 und 4) den Zähler auf 1 setzt und damit eine Benachrichtigung darstellt. Der Aufruf <span class="tx_code">signal2Ping.acquire()</span> (5) blockiert, bis der Zähler den Wert 1 hat. Die entsprechende Argumentation gilt für die zweite Semaphore <span class="tx_code">signal2Pong</span>. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/3/9/9/9/4/TN_205506957_882839ca20.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Im Durchschnitt benötigt die Ausführung des Spiels 0,33 Sekunden.</div>
<div class="text">Gerne möchte ich die Performanzzahlen aus meinem letzten Artikel "<a title="Link auf https://heise.de/-5019237" alt="%7B%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22text%22%3A%22Performanzvergleich%20von%20Bedingungsvariablen%20und%20Atomics%20in%20C%2B%2B20%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5019237%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5019237%22%7D" href="https://heise.de/-5019237" class="">Performanzvergleich von Bedingungsvariablen und Atomics in C++20</a>" ins Spiel bringen.</div>
<div class="ztitel">Alle Zahlen</div>
<div class="text"><span class="tx_code">std::condition_variable</span> stellt die langsamste und <span class="tx_code">std::atomic_flag</span> die schnellste Art dar, Threads zu synchronisieren. Die Performanz von <span class="tx_code">std::atomic</span> liegt dazwischen. <span class="tx_code">std::atomic</span> besitzt einen großen Nachteil. Der Standard sichert nicht zu, dass diese lock-frei implementiert sind. <span class="tx_code">std::atomic_flag</span> ist die einzige, garantiert lock-freie atomare Variable. Semaphoren haben mich am meisten beeindruckt, denn sie sind fast so schnell wie <span class="tx_code">std::atomic_flag</span>.</div>
<div class="ztitel">Mein C++20 Buch<br></div>
<div class="text">Dieser Artikel basiert auf Auszügen meines englischen Buchs zu C++20. Es ist mittlerweile zu 70 Prozent abgeschlossen und auf <a title="Link auf https://leanpub.com/c20" alt="%7B%22mediasync_id%22%3A%22%22%2C%22text%22%3A%22LeanPub%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fleanpub.com%2Fc20%22%2C%22destination%22%3A%22https%3A%2F%2Fleanpub.com%2Fc20%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%7D" href="https://leanpub.com/c20" class="">LeanPub</a> in mehreren digitalen Formaten erhältlich. Natürlich erhältst du automatisch jedes Update des Buchs. <br></div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/3/9/9/9/4/TN_205506966_fbd7b20a7b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Mit Latches und Barriers erhalten wir mehr Koordinationsdatentypen in C++20. In meinem nächsten Artikel schaue ich mir diese genauer an.<br></div>