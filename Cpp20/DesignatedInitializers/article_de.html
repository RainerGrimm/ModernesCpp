<div class="vorspann">Designated Initialization ist eine Erweiterung von Aggregate Initialization und ermöglicht es, die Mitglieder einer Klasse direkt mithilfe ihres Namens zu initialisieren</div>
<div class="text">Desingated Initialization ist ein Spezialfall der Aggregate Initialization. Daher wird dieser Artikel mit Letzerer beginnen.<br></div>
<div class="ztitel">Aggregate Initialization</div>
<div class="text">Zuerst gilt es zu klären, was Aggregate sind. Aggregate sind Arrays und Klassentypen. Ein Klassentyp ist eine <span class="tx_code">class</span>, <span class="tx_code">struct</span> oder <span class="tx_code">union</span>. <br></div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/3/1/9/5/2/TN_196558495_61f2b8dc20.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Mit C++20 muss ein Klassentyp die folgenden Bedingungen erfüllen:</div>
<div class="text"><ul><li>keine <span class="tx_code">private</span>- oder <span class="tx_code">protected</span>-nichtstatischen Mitglieder</li><li>kein benutzerdefinierter oder geerbter Konstruktor</li><li>keine <span class="tx_code">virtual</span>-, <span class="tx_code">private</span>- oder <span class="tx_code">protected</span>-Basisklasse</li><li>keine virtuellen Memberfunktionen</li></ul></div>
<div class="text">Das nächste Programm stellt Aggregate genauer vor:<br></div>
<div class="pre">// aggregateInitialization.cpp<br><br>#include &lt;iostream&gt;<br><br>struct Point2D{<br>&nbsp;&nbsp;&nbsp; int x; <br>&nbsp;&nbsp;&nbsp; int y;<br>};<br><br>class Point3D{<br>public:<br>&nbsp;&nbsp;&nbsp; int x;<br>&nbsp;&nbsp;&nbsp; int y;<br>&nbsp;&nbsp;&nbsp; int z;<br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Point2D point2D{1, 2};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; Point3D point3D{1, 2, 3};&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "point2D: " &lt;&lt; point2D.x &lt;&lt; " " &lt;&lt; point2D.y &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "point3D: " &lt;&lt; point3D.x &lt;&lt; " " &lt;&lt; point3D.y &lt;&lt; " " &lt;&lt; point3D.z &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">(1) und (2) initialisieren die Aggregate direkt durch Einsatz geschweifter Klammern. Die Reihenfolge der Initialisierer in den geschweiften Klammern muss der Deklarationsreihenfolge der Mitglieder entsprechen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/3/1/9/5/2/TN_196558500_d7aa6b66ea.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Basierend auf der Aggregat Initiaization in C++11 erhalten wir mit C++20 Designed Initializers. Bisher unterstützt nur der Microsoft-Compiler diese neuen Feature vollständig. <br></div>
<div class="ztitel">Designated Initializers</div>
<div class="text">Dank Designated Initalizers ist es möglich, Mitglieder der Klasse direkt mithilfe ihres Namens zu initialisieren. Für eine <span class="tx_code">union</span> darf nur ein Initializer verwendet werden. Wie es bereits für Aggregate Initialization gilt, so muss die Reihenfolge der Initialisierer der Deklarationsreihenfolge der Mitglieder entsprechen:</div>
<div class="pre">// designatedInitializer.cpp<br><br>#include &lt;iostream&gt;<br><br>struct Point2D{<br>&nbsp;&nbsp;&nbsp; int x;<br>&nbsp;&nbsp;&nbsp; int y;<br>};<br><br>class Point3D{<br>public:<br>&nbsp;&nbsp;&nbsp; int x;<br>&nbsp;&nbsp;&nbsp; int y;<br>&nbsp;&nbsp;&nbsp; int z;<br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Point2D point2D{.x = 1, .y = 2};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; Point3D point3D{.x = 1, .y = 2, .z = 3};&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "point2D: " &lt;&lt; point2D.x &lt;&lt; " " &lt;&lt; point2D.y &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "point3D: " &lt;&lt; point3D.x &lt;&lt; " " &lt;&lt; point3D.y &lt;&lt; " " &lt;&lt; point3D.z &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">(1) und (2) verwenden Designated Initializers zum Initialisieren der Mitglieder. Initialisierer wie <span class="tx_code">.x</span> und <span class="tx_code">.y</span> werden auch gerne Designatoren (designators) genannt. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/3/1/9/5/2/TN_196558508_57632db931.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die Mitglieder des Aggregates können bereits einen Defaultwert besitzen. Dieser wird dann verwendet, wenn der Initialisierer nicht angegeben wird. Diese Regel gilt nicht für Unions.</div>
<div class="pre">// designatedInitializersDefaults.cpp<br><br>#include &lt;iostream&gt;<br><br>class Point3D{<br>public:<br>&nbsp;&nbsp;&nbsp; int x;<br>&nbsp;&nbsp;&nbsp; int y = 1; <br>&nbsp;&nbsp;&nbsp; int z = 2;<br>};<br><br>void needPoint(Point3D p) {<br>&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "p: " &lt;&lt; p.x &lt;&lt; " " &lt;&lt; p.y &lt;&lt; " " &lt;&lt; p.z &lt;&lt; std::endl;<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Point3D point1{.x = 0, .y = 1, .z = 2};&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "point1: " &lt;&lt; point1.x &lt;&lt; " " &lt;&lt; point1.y &lt;&lt; " " &lt;&lt; point1.z &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Point3D point2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "point2: " &lt;&lt; point2.x &lt;&lt; " " &lt;&lt; point2.y &lt;&lt; " " &lt;&lt; point2.z &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Point3D point3{.x = 0, .z = 20};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "point3: " &lt;&lt; point3.x &lt;&lt; " " &lt;&lt; point3.y &lt;&lt; " " &lt;&lt; point3.z &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; // Point3D point4{.z = 20, .y = 1}; ERROR&nbsp;&nbsp; // (4) <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; needPoint({.x = 0});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">(1) initialisiert alle Mitglieder. Das gilt aber nicht für (2), das keinen Initialisierer für <span class="tx_code">x</span> besitzt. Konsequenterweise wird <span class="tx_code">x</span> nicht initialisiert. Es ist zulässig, wenn du nur die Mitglieder initialisierst, die wie (3) oder (5) keinen Defaultwert besitzen. Der Ausdruck (4) lässt sich nicht übersetzen, denn <span class="tx_code">z</span> und <span class="tx_code">y</span> besitzen die falsche Reihenfolge.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/3/1/9/5/2/TN_196558511_d4a2271267.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=1>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Designated Initialisierer erkennen Narrowing Conversion. Dies ist die Konvertierung eines Werts mit dem einhergehenden Verlust der Datengenauigkeit:<br></div>
<div class="pre">// designatedInitializerNarrowingConversion.cpp<br><br>#include &lt;iostream&gt;<br><br>struct Point2D{<br>&nbsp;&nbsp;&nbsp; int x;<br>&nbsp;&nbsp;&nbsp; int y;<br>};<br><br>class Point3D{<br>public:<br>&nbsp;&nbsp;&nbsp; int x;<br>&nbsp;&nbsp;&nbsp; int y;<br>&nbsp;&nbsp;&nbsp; int z;<br>};<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; Point2D point2D{.x = 1, .y = 2.5};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; Point3D point3D{.x = 1, .y = 2, .z = 3.5f};&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "point2D: " &lt;&lt; point2D.x &lt;&lt; " " &lt;&lt; point2D.y &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "point3D: " &lt;&lt; point3D.x &lt;&lt; " " &lt;&lt; point3D.y &lt;&lt; " " &lt;&lt; point3D.z &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">(1) und (2) verursachen einen Fehler zur Compile-Zeit, da die Initialisierung <span class="tx_code">.y = 2.5</span> und <span class="tx_code">.z = 3.5f</span> Narrowing Conversion verursachen. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/3/1/9/5/2/TN_196558519_9ccadb2016.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Interessanterweise verhalten sich Designated Initializers in C++ anders als in C.</div>
<div class="ztitel_kleiner">Unterschiede zwischen C++ und C</div>
<div class="text">C unterstützt Anwendungsfälle mit Designated Initialisers, die C++ nicht anbietet. So erlaubt C,<br></div>
<div class="text"><ul><li>die Mitglieder des Aggregates in einer anderen Reihenfolge als der Deklarationsreihenfolge zu initialisieren.</li><li>die Mitglieder eines verschachtelten Aggregates zu initialisieren.</li><li>Designated Initializers und reguläre Initialisierer zu vermischen.</li><li>die Designated Initializations eines Arrays.</li></ul></div>
<div class="text">Das Proposal <a class="" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2017%2Fp0329r4.pdf%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22P0329R4%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2017%2Fp0329r4.pdf%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%7D" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0329r4.pdf" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0329r4.pdf">P0329R4</a> bietet ein selbsterklärendes Beispiel für diese Anwendungsfälle an:<br></div>
<div class="pre">struct A { int x, y; };<br>struct B { struct A a; };<br>struct A a = {.y = 1, .x = 2}; // valid C, invalid C++ (out of order)<br>int arr[3] = {[1] = 5};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // valid C, invalid C++ (array)<br>struct B b = {.a.x = 0};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // valid C, invalid C++ (nested)<br>struct A a = {.x = 1, 2};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // valid C, invalid C++ (mixed)</div>
<div class="text">Die Begründung für den Unterschied zwischen C und C++ ist Teil des Proposals: "In C++, members are destroyed in reverse construction order and the elements of an initializer list are evaluated in lexical order, so field initializers must be specified in order. Array designators conflict with ​lambda-expression​ syntax. Nested designators are seldom used." Das Dokument argumentiert weiter, dass nur eines der ausschließlich in C unterstützten Feature gerne zum Einsatz kommt: das Initialisieren der AggregateMmitglieder in einer Reihenfolge, die nicht der Deklarationsreihenfolge entspricht.</div>
<div class="ztitel">Wie geh't weiter?</div>
<div class="text">Seit C++98 besitzen wir <span class="tx_code">const</span>, mit C++11 <span class="tx_code">constexpr</span> und mit C++20 <span class="tx_code">consteval</span> und <span class="tx_code">constinit</span>. In meinem nächsten Artikel werde ich einerseits auf die neuen C++20-Spezifizier <span class="tx_code">consteval</span> und <span class="tx_code">constinit</span> genauer eingehen und andererseits deren Unterschiede zu <span class="tx_code">const</span> und <span class="tx_code">constexpr</span> analysieren.<br></div>
