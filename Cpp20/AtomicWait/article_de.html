<div class="vorspann">Sender/Empfänger Arbeitsabläufe sind typisch für Threads. In solch einem Arbeitsablauf wartet der Empfänger auf die Benachrichtigung des Senders bevor er seine Arbeit fortsetzt. Es gibt einige Möglichkeiten diesen Arbeitsablauf umzusetzen. Mit C++11 bieten sich Bedingungsvariablen oder Promise/Future-Paare an, mit C++20 atomare Variablen.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/2/3/9/6/6/TN_204063414_f9936b4368.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Es gibt mehrere Möglichkeiten, Thread zu synchronisieren, und jede besitzt ihre Vor- und Nachteile. Daher möchte ich die verschiedene Möglichkeiten gegenüberstellen. Wem die Details zur Bedingungsvariablen und Promises und Futures bekannt sind, der kann die zwei nächsten Abschnitte überspringen. Falls nicht, folgt ein kleiner Auffrischer.</div>
<div class="ztitel">Bedingungsvariablen<br></div>
<div class="text">Eine Bedingungsvariable kann sowohl die Rolle es Senders als auch die des Empfängers annehmen. Als Sender kann sie eine oder alle Empfänger benachrichtigen.</div>
<div class="pre">// threadSynchronisationConditionVariable.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;condition_variable&gt;<br>#include &lt;mutex&gt;<br>#include &lt;thread&gt;<br>#include &lt;vector&gt;<br><br>std::mutex mutex_;<br>std::condition_variable condVar;<br><br>std::vector&lt;int&gt; myVec{};<br><br>void prepareWork() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myVec.insert(myVec.end(), {0, 1, 0, 3});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Sender: Data prepared."&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; condVar.notify_one();<br>}<br><br>void completeWork() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Worker: Waiting for data." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp; condVar.wait(lck, [] { return not myVec.empty(); });<br>&nbsp;&nbsp;&nbsp; myVec[2] = 2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Waiter: Complete the work." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; for (auto i: myVec) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::thread t1(prepareWork);<br>&nbsp;&nbsp;&nbsp; std::thread t2(completeWork);<br><br>&nbsp;&nbsp;&nbsp; t1.join();<br>&nbsp;&nbsp;&nbsp; t2.join();<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>}<br></div>
<div class="text">Das Programm besitzt zwei Threads<span class="tx_code"> t1</span> und <span class="tx_code">t2</span>. Sie erhalten ihre Arbeitspakete <span class="tx_code">prepareWork</span> und <span class="tx_code">completeWork</span>&nbsp;in Zeile (1) und (3). Die Funktion <span class="tx_code">prepareWork</span> schickt eine Benachrichtigung, wenn sie mit ihrer Arbeitsvorbereitung fertig ist: <span class="tx_code">condVar.notify_one()</span>. Während <span class="tx_code">t2 </span>auf die Benachrichtigung wartet, hält er das Lock: <span class="tx_code">condVar.wait(lck, []{ return not myVec.empty(); })</span>. Der wartende Thread führt immer die gleichen Schritte aus. Wenn er aufgeweckt wird, prüft er das Prädikat während er das Lock hält (<span class="tx_code">[]{ return not myVec.empty();</span>). Falls das Prädikat nicht <span class="tx_code">true</span> ergibt, legt er sich wieder schlafen. Wenn das Prädikat <span class="tx_code">true</span> ergibt, setzte er seine Arbeit fort. In dem konkreten Arbeitsablauf initialisiert der Sender den<span class="tx_code"> std::vector</span>(3),&nbsp; während der Empfänger die Arbeit fertigstellt (4).</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/2/3/9/6/6/TN_204063422_96222cbdd0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Bedingungsvariablen habe viele inhärent Probleme. Zum Beispiel kann der Empfänger aufwachen, obwohl keine Benachrichtigung geschickt wurde oder die Benachrichtigung kann verloren gehen. Das erste Phänomen nennt sich "spurious wakeup" und das Zweite "lost wakeup". Das Prädikat ist der Schutz gegen beide Phänomene. Die Benachrichtigung würde verloren gehen, wenn der Sender die Benachrichtigung schickt, bevor der Empfänger im Wartezustand ist und kein Prädikat verwendet. Konsequenterweise wartet in diesem Fall der Empfänger auf ein Ereignis, das nicht auftritt. Dies ist eine Deadlock. Die Ausgabe des Programms zeigt, dass jede zweite Ausführung zum einem Deadlock geführt hätte, wenn ich kein Prädikat eingesetzt hätte. Natürlich ist es möglich, Bedingungsvariablen ohne Prädikat zu verwenden.</div>
<div class="text">Wer mehr zu den Details zu dem Sender/Empfänger-Arbeitsauflauf und den Gefahren mit Bedingungsvariablen wissen möchte, sei auf meinen Artikel: "<a title="Link auf https://heise.de/-406382" alt="%7B%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-406382%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Sei%20dir%20der%20Fallen%20von%20Bedingungsvariablen%20bewusst%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-406382%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%7D" href="https://heise.de/-406382" class="">C++ Core Guidelines: Sei dir der Fallen von Bedingungsvariablen bewusst</a>" verwiesen<br></div>
<div class="text">Wenn lediglich eine einmalige Benachrichtigung wie in dem vorherigen Programm benötigt wird, sind Promise und Futures Bedingungsvariablen vorzuziehen. Promise und Future können keine Opfer von spurious oder lost wakeups werden. <br></div>
<div class="ztitel">Promise und Futures<br></div>
<div class="text">Ein Promise kann einen Wert, eine Ausnahme oder eine Benachrichtigung an den assoziierten Future schicken. Daher werde ich das vorherige Programm auf Promise und Futures umstellen. </div>
<div class="pre">// threadSynchronisationPromiseFuture.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;future&gt;<br>#include &lt;thread&gt;<br>#include &lt;vector&gt;<br><br>std::vector&lt;int&gt; myVec{};<br><br>void prepareWork(std::promise&lt;void&gt; prom) {<br><br>&nbsp;&nbsp;&nbsp; myVec.insert(myVec.end(), {0, 1, 0, 3});<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Sender: Data prepared."&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; prom.set_value();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>}<br><br>void completeWork(std::future&lt;void&gt; fut){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Worker: Waiting for data." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; fut.wait();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; myVec[2] = 2;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Waiter: Complete the work." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; for (auto i: myVec) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::promise&lt;void&gt; sendNotification;<br>&nbsp;&nbsp;&nbsp; auto waitForNotification = sendNotification.get_future();<br><br>&nbsp;&nbsp;&nbsp; std::thread t1(prepareWork, std::move(sendNotification));<br>&nbsp;&nbsp;&nbsp; std::thread t2(completeWork, std::move(waitForNotification));<br><br>&nbsp;&nbsp;&nbsp; t1.join();<br>&nbsp;&nbsp;&nbsp; t2.join();<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>}</div>
<div class="text">Beim genaueren Blick auf den Programmfluss fällt auf, dass die Synchronisation auf ihre wesentlichen Komponenten reduziert ist: <span class="tx_code">prom.set_value() </span>(1) und<span class="tx_code"> fut.wait()</span> (2). Weder ist es notwendig, Locks oder Mutexe einzusetzen, noch ein Prädikat zum Schutz den spurious und lost wakeups zu verwenden. Die Ausgabe des Programms ignoriere ich, da sie sich von der vorherigen Ausgabe nicht unterscheidet. </div>
<div class="text">Promise und Futures besitzen aber einen Nachteil: Sie lassen sich nur einmal verwenden. Hier sind meine bestehenden Artikel zu <a title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/tasks" alt="%7B%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Ftasks%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22text%22%3A%22Promisen%20und%20Futures%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Ftasks%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%7D" href="https://www.grimm-jaud.de/index.php/blog/tag/tasks" class="">Promisen und Futures</a>.</div>
<div class="text">Um mehr als einmal zu kommunizieren, müssen Bedingungsvariablen oder atomare Variablen eingesetzt werden. </div>
<div class="ztitel"><span class="tx_code">std::atomic_flag</span><br></div>
<div class="text"><span class="tx_code">std::atomic_flag</span> in C++11 besitzt ein einfaches Interface. Seine Funktion <span class="tx_code">clear</span> erlaubt es, seinen Wert auf&nbsp; <span class="tx_code">false</span> zu setzen. Dank der Funktion <span class="tx_code">test_and_set </span>ist es möglich, ihn wieder auf <span class="tx_code">true</span> zu setzen. Die Funktion<span class="tx_code"> test_and_set</span> gibt dabei den alten Wert zurück. Dank <span class="tx_code">ATOMIC_FLAG_INIT</span> kann <span class="tx_code">std::atomic_flag</span> auf <span class="tx_code">false</span> initialisiert werden. <span class="tx_code">std::atomic_flag </span>besitzt zwei sehr interessante Eigenschaften.</div>
<div class="text"><b><span class="tx_code">std::atomic_flag</span> </b><b>ist<span class="tx_code"><br></span></b></div>
<div class="text"><ul><li>die einzige lock-freie atomare Variable.</li><li>der Baustein für höhere Thread-Abstraktionen.</li></ul></div>
<div class="text">Die anderen atomaren Variablen können ihre Funktionalität anbieten, indem sie intern einen Mutex verwenden. Dies entsprecht dem C++-Standard. Daher besitzen diese atomaren Variablen eine Funktion<span class="tx_code"> is_lock_free</span>. Auf den populären Plattformen erhält man in der Regel immer<span class="tx_code"> false</span>. Hier sind noch ein paar Hintergrundinformationen zu <a title="Link auf https://www.grimm-jaud.de/index.php/41-blog/multithreading/speichermodell/84-das-atomare-flag" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2F41-blog%2Fmultithreading%2Fspeichermodell%2F84-das-atomare-flag%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2F41-blog%2Fmultithreading%2Fspeichermodell%2F84-das-atomare-flag%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22std%3A%3Aatomic_flag%22%7D" href="https://www.grimm-jaud.de/index.php/41-blog/multithreading/speichermodell/84-das-atomare-flag" class="">std::atomic_flag</a>. </div>
<div class="text">Jetzt springe ich direkt von C++11 nach C++20. Mit C++20 bietet <span class="tx_code">std::atomic_flag </span>neue Funktionen an:<span class="tx_code"> atomicFlag.wait()</span>,<span class="tx_code"> atomicFlag.notify_one()</span> und <span class="tx_code">atomicFlag.notify_all()</span>. Die Funktionen <span class="tx_code">notify_one</span>&nbsp;oder <span class="tx_code">notify_all</span> benachrichtigen einen oder alle wartetenden Threads. <span class="tx_code">atomicFlag.wait(boo)</span> benötigt eine Wahrheitswert <span class="tx_code">boo</span>. Der Aufruf <span class="tx_code">atomicFlag.wait(boo)</span> blockiert bis zur nächsten Benachrichtigung oder spurious wakup. Dann prüft er, ob der Wert des atomaren Flags den Wert <span class="tx_code">boo</span> besitzt. Falls ja, blockiert der Aufruf weiter. Der Wert von <span class="tx_code">boo</span> dient als eine Art Prädikat.</div>
<div class="text">Zusätzlich zu C++11, erhält eine <span class="tx_code">std::atomic_flag</span> den Wert <span class="tx_code">false</span>, wenn er default-konstruiert wird. Darüber hinaus lässt sich sein Wert mit der Funktion<span class="tx_code"> atomicFlag.test()</span> abfragen. Mit diesem Wissen ist es relativ einfach, dass vorherige Programm auf <span class="tx_code">std::atomic_flag</span> umzustellen. <br></div>
<div class="pre">// threadSynchronisationAtomicFlag.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;atomic&gt;<br>#include &lt;thread&gt;<br>#include &lt;vector&gt;<br><br>std::vector&lt;int&gt; myVec{};<br><br>std::atomic_flag atomicFlag{};<br><br>void prepareWork() {<br><br>&nbsp;&nbsp;&nbsp; myVec.insert(myVec.end(), {0, 1, 0, 3});<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Sender: Data prepared."&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; atomicFlag.test_and_set();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; atomicFlag.notify_one();&nbsp; &nbsp;<br><br>}<br><br>void completeWork() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Worker: Waiting for data." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; atomicFlag.wait(false);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; myVec[2] = 2;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Waiter: Complete the work." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; for (auto i: myVec) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::thread t1(prepareWork);<br>&nbsp;&nbsp;&nbsp; std::thread t2(completeWork);<br><br>&nbsp;&nbsp;&nbsp; t1.join();<br>&nbsp;&nbsp;&nbsp; t2.join();<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>}<br></div>
<div class="text">Der Thread <span class="tx_code">t1</span> (1), der die Arbeit vorbereitet, setzt <span class="tx_code">atomicFlag</span> auf <span class="tx_code">true</span> und schickt dann seine Benachrichtigung. Der Thread, der die Arbeit vollendet, wartet auf die Benachrichtigung (2) und wird freigegeben, wenn <span class="tx_code">atomicFlag</span> den Wert <span class="tx_code">true</span> besitzt.</div>
<div class="text">Hier sind ein paar Ausführungen des Programms mit dem Microsoft Compiler.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/2/3/9/6/6/TN_204063431_f66298bcbb.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Ich bin mir nicht sicher, ob ich eine einfache Thread-Synchronisation mit einem Promise/Future-Paar oder einem<span class="tx_code"> std::atomic_flag </span>umsetzen würde. Beide sind per Design Thread-sicher und verlangen keine Schutzmechanismen. Promise und Futures sind zwar einfacher zu verwenden, aber <span class="tx_code">std::atomic_flag</span> ist wohl schneller. Ich bin mir nur sicher, dass ich Bedingungsvariablen vermeide, wenn es möglich ist. </div>
<div class="ztitel">Wie geht`s weiter?</div>
<div class="text">Wenn es gilt, einen deutlich anspruchsvolleren Arbeitsablauf wie ein Ping-Pong-Spiel mit 1'000'000 Ballwechsel umzusetzen, sind Futures und Promise keine Option. In meinem nächsten Artikel werde ich ein Ping-Pong-Spiel mit Bedingungsvariablen und atomaren Variablen implementieren und mir die Performanz genauer anschauen. </div>
<div class="ztitel">Ein kurze Pause</div>
<div class="text">In den nächsten zwei Wochen lege ich eine kleine Weihnachtspause ein. Mein nächster Artikel wird am 11.01 erscheinen. Für mehr Informationen zu C++20 möchte ich mein neues Buch auf <a title="Link auf https://leanpub.com/c20" alt="%7B%22text%22%3A%22LeanPub%20zu%20C%2B%2B20%20%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fleanpub.com%2Fc20%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fleanpub.com%2Fc20%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D" href="https://leanpub.com/c20" class="">LeanPub zu C++20 </a>empfehlen.<br></div>