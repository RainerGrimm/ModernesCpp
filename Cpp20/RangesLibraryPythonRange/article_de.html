<div class="vorspann">Im letzten Artikel "<a alt="%7B%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Df3277c8fb3cf52899ddc3b4ace35051b%26rm%3Dopen_article_id%26bid%3D2852803%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%3A%20Pythonisch%20mit%20der%20Ranges-Bibliothek%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A2852803%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%7D" href="/exec/mainmenu.pl?sid=f3277c8fb3cf52899ddc3b4ace35051b&amp;rm=open_article_id&amp;bid=2852803" title="Link auf Beitrag 2852803" class="">C++20: Pythonisch mit der Ranges-Bibliothek</a>" begann mein Experiment, die beliebten Python-Funktionen <span class="tx_code">range</span> und <span class="tx_code">filter</span> mit der Ranges-Bibliothek zu implementieren. Aufgrund zweier interessanter Kommentare möchte ich mir die Funktion <span class="tx_code">range</span> nochmals genauer anschauen. </div>
<div class="text">Zugegeben, es hat einige Zeit gedauert, bis ich mit der Ranges-Bibliothek vertraut wurde. Die investierte Zeit war aber gut angelegt. Zuerst gibt es eine kleine Erinnerungshilfe. Der Aufruf <span class="tx_code">range(begin, end, step)</span> erzeugt in Python 2 alle Ganzzahlen von <span class="tx_code">begin</span> bis <span class="tx_code">end</span> in <span class="tx_code">step</span> Schrittweite. <span class="tx_code">begin</span> ist inklusive und <span class="tx_code">end</span> ist exklusive. <span class="tx_code">step</span> ist per Default 1.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/5/8/2/4/1/TN_190169483_fbca09b481.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Over-Engineering</div>
<div class="text">Meine Implementierung der <span class="tx_code">range</span>-Funktion im letzten Artikel war zu kompliziert, wie ein Leser meines deutschen Artikels bemerkte. Der folgende Codeschnipsel zeigt sowohl die zu komplizierte als auch die verbesserte Variante der <span class="tx_code">range</span>-Funktion:</div>
<div class="pre">std::vector&lt;int&gt; range(int begin, int end, int stepsize = 1) {<br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; result{};<br>&nbsp;&nbsp;&nbsp; if (begin &lt; end) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto boundary = [end](int i){ return i &lt; end; };&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i: ranges::views::iota(begin)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::stride(stepsize) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::take_while(boundary)) {&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.push_back(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stepsize *= -1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto boundary = [begin](int i){ return i &lt; begin; }; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i: ranges::views::iota(end)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::take_while(boundary)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::reverse <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::stride(stepsize)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.push_back(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return result;<br>}&nbsp; <br><br>std::vector&lt;int&gt; range(int begin, int end, int stepsize = 1) {<br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; result{};<br>&nbsp;&nbsp;&nbsp; if (begin &lt; end) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i: ranges::views::iota(begin, end)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::stride(stepsize)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.push_back(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stepsize *= -1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i: ranges::views::iota(end, begin)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::reverse <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::stride(stepsize)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.push_back(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return result;<br>}<br></div>
<div class="text">Ich habe die Randbedingung (Zeile 1) in der ersten Implementierung entfernt und den unendlichen Zahlenerzeuger <span class="tx_code">ranges::views::iota(begin)</span> (Zeile 2) in einen endlichen Zahlenerzeuger <span class="tx_code">ranges::views::iota(begin, end)</span> (Zeile 3) umgeschrieben. Natürlich wende ich die gleichen Vereinfachungen auch auf den <span class="tx_code">else</span>-Zweig der Bedingung an.<br></div>
<div class="ztitel_kleiner">Von range zu xrange<br></div>
<div class="text">Die vorgestellte <span class="tx_code">range</span>-Funktion ist eager (gierig). Sie erzeugt einen<span class="tx_code"> std::vector&lt;int&gt;</span>. Aleksei Guzev erinnerte mich daran, dass Python 2 auch eine lazy (faule) <span class="tx_code">xrange-</span>Funktion besitzt. Diese entspricht der <span class="tx_code">range</span>-Funktion in Python 3. Er hat Recht. Nun bin ich ausreichend vertraut mit der Ranges-Bibliothek, um diese funktionalen Konzepte auf C++ anzuwenden. Wenn dich die Ausdrücke "eager" und "lazy" irritieren, lies meinen vorherigen Artikel "<a href="https://heise.de/-4661671" title="Link auf https://heise.de/-4661671" class="" alt="%7B%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%3A%20Funktionale%20Pattern%20mit%20der%20Ranges-Bibliothek%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4661671%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4661671%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D">C++20: Funktionale Pattern mit der Ranges-Bibliothek</a>".</div>
<div class="text">Das folgende Beispiel zeigt eine Variante der <span class="tx_code">range</span>-Funktion, die die Bedarfsauswertung (lazy) umsetzt. Konsequenterweise nenne ich die Funktion <span class="tx_code">xrange</span>:</div>
<div class="pre">// xrange.hpp<br><br>#include &lt;range/v3/all.hpp&gt;<br><br>template &lt;long long Begin, long long End&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>auto xrange(int stepsize = 1) {<br>&nbsp;&nbsp;&nbsp; if constexpr (Begin &lt; End) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ranges::views::iota(Begin, End)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::stride(stepsize); <br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long long end&nbsp; = End + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long long begin = Begin + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stepsize *= -1; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ranges::views::iota(end, begin)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::reverse <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::stride(stepsize);<br>&nbsp;&nbsp;&nbsp; }<br>}</div>
<div class="text">Die Implementierung der lazy <span class="tx_code">xrange</span>-Funktion ist deutlich komplizierter als die eager <span class="tx_code">range-</span>Funktion. Diese Komplexität zahlt sich aber aus. Die folgenden Zahlen entsprechen den Zahlen im Sourcecode:<br></div>
<div class="text"><ol><li>Die <span class="tx_code">xrange-</span>Funktion gibt keinen <span class="tx_code">std::vector&lt;int&gt;</span>, sondern eine Funktionskomposition zurück. Um mir die Aufgabe zu erleichtern, verwende ich den Rückgabetyp <span class="tx_code">auto</span>. Mit ihm beginnt die erste Herausforderung. Die Rückgabetypen des <span class="tx_code">if</span>- und <span class="tx_code">else</span>-Zweigs der Bedingung unterscheiden sich. Funktionen mit verschiedenen Rückgabetypen sind in C++ nicht möglich.</li><li>Um diese Herausforderung zu meistern, setze ich ein C++17-Feature ein: <span class="tx_code">constexpr if.</span> Es ermöglicht das bedingte Kompilieren. Wenn der Ausdruck <span class="tx_code">constexpr (Begin &lt; End)</span> zu true evaluiert, wird der <span class="tx_code">if-</span>Zweig kompiliert, ansonsten der <span class="tx_code">else</span>-Zweig. Damit die Bedingung gültig ist, müssen <span class="tx_code">Begin</span> und <span class="tx_code">End</span> konstante Ausdrücke sein. <br></li><li><span class="tx_code">Begin</span> und <span class="tx_code">End</span> sind jetzt Nicht-Typ-Template-Parameter. Damit lassen sie sich in <span class="tx_code">constexpr if </span>(Zeile 2) verwenden. Ich verwende Nicht-Typ-Template-Parameter vom Typ <span class="tx_code">long long</span>, um mit großen Zahlen umgehen zu können. <br></li><li>Konstante Ausdrücke wie <span class="tx_code">Begin</span> und <span class="tx_code">End</span> können nicht modifiziert werden. Daher muss ich die Variablen <span class="tx_code">begin</span> und <span class="tx_code">end</span> verwenden, um die Grenzen für den <span class="tx_code">ranges::views::iota</span>-Aufruf anzupassen.<br></li></ol></div>
<div class="text">&nbsp;Jetzt bin ich neugierig. Hier ist die <span class="tx_code">xrange</span>-Funktion in Anwendung:<br></div>
<div class="pre">// range.cpp<br><br>#include "xrange.hpp"<br><br>#include &lt;iostream&gt;<br>#include &lt;range/v3/all.hpp&gt;<br>#include &lt;vector&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; auto res = xrange&lt;1, 10&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; for (auto i: res) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; res = xrange&lt;1, 50&gt;(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; for (auto i: res) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto res2 = xrange&lt;20, 10&gt;(-1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; for (auto i: res2) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; res2 = xrange&lt;50, 10&gt;(-5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; for (auto i: res2) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; res = xrange&lt;1, 1'000'000'000'000'000'000&gt;();&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; // for (auto i: res) std::cout &lt;&lt; i &lt;&lt; " ";&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp;&nbsp;&nbsp; for (auto i: res | ranges::views::take(10)) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (8)<br>&nbsp;&nbsp;&nbsp; for (auto i: res | ranges::views::drop_while([](int i){ return i &lt; 1'000'000; })<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::take_while([](int i){ return i &lt; 1'000'010; })) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Die Zeilen (1) bis (4) zeigen, dass sich die Funktion <span class="tx_code">xrange</span> wie die Funktion <span class="tx_code">range</span> verhält. Der einzige Unterschied ist es, dass aus den Funktions- Template-Argumente wurden. Wenn ich alle Zahlen bis zu einer Trillion anfordere (Zeile 6), muss ich das Programm hart beenden.&nbsp; <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/5/8/2/4/1/TN_190169479_8505ce7d9b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Verwendung von Tics für Zahlen (<span class="tx_code">1'000'000'000'000'000'000</span>) (Zeile 5) ist seit C+14 zulässig und macht große Zahlen deutlich lesbarer. Ich sollte nicht alle Zahlen auf einmal anfordern. Wenn ich nur an zehn Ganzzahlen (Zeile 7) oder an allen Ganzzahlen zwischen<span class="tx_code"> 1'000'000</span> und <span class="tx_code">1'000'010 </span>(Zeile 8) interessiert bin, funktioniert der <span class="tx_code">xrange</span>-Aufruf wie erwartet. Lediglich die Zahlen werden erzeugt, die nachgefragt werden.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/5/8/2/4/1/TN_190169489_1b85bbbc57.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Wie bereits in meinem letzten Artikel "<a alt="%7B%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4671777%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%3A%20Pythonisch%20mit%20der%20Ranges-Bibliothek%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4671777%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%7D" title="Link auf https://heise.de/-4671777" href="https://heise.de/-4671777" class="">C++20: Pythonisch mit der Ranges-Bibliothek</a>" angekündigt, stelle ich im nächsten Beitrag die <span class="tx_code">map-</span>Funktion von Python vor. <span class="tx_code"></span>Sie erlaubt es, eine Funktion auf Sequenzen auszuführen. Aus praktischen Gründen werde ich die Funktion <span class="tx_code">map</span> und <span class="tx_code">filter</span> auch in einer Funktion anbieten. <br></div>
