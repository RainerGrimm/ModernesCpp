<div class="vorspann">Die cppcoro-Bibliothek von Lewis Baker bietet an, was der C++20-Standard nicht leistet: High-Level-Coroutinen. <br></div>
<div class="text">Zugegeben, meine zwei letzten Artikel "<a alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4697142%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4697142%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C%2B%2B20%3A%20Ein%20unendlicher%20Datenstrom%20mit%20Coroutinen%22%2C%22custom%22%3A%7B%7D%7D" href="https://heise.de/-4697142" title="Link auf https://heise.de/-4697142" class="">C++20: Ein unendlicher Datenstrom mit Coroutinen</a>" und "<a class="" alt="%7B%22text%22%3A%22C%2B%2B20%3A%20Thread-Synchronisation%20mit%20Coroutinen%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4701396%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4701396%22%2C%22user_params%22%3A%22%22%7D" href="https://heise.de/-4701396" title="Link auf https://heise.de/-4701396">C++20: Thread-Synchronisation mit Coroutinen</a>" waren schwere Kost. Meine nächsten Artikel zu Couroutinen werden deutlich bekömmlicher sein. Ich verwende Beispiele der Coroutinen-Bibliothek <a title="Link auf https://github.com/lewissbaker/cppcoro" alt="%7B%22text%22%3A%22cppcoro%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Flewissbaker%2Fcppcoro%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Flewissbaker%2Fcppcoro%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%7D" href="https://github.com/lewissbaker/cppcoro" class="">cppcoro</a>.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/8/1/3/5/6/TN_192234078_bb34b4da0f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Um mir meine Argumentation zu erleichtern, werde ich die Begriffe Coroutinen und Coroutinen-Framework verwenden. <br></div>
<div class="ztitel">cppcoro<br></div>
<div class="text">Die cppcoro-Bibliothek von Lewis Baker basiert auf dem Coroutinen TS. TS steht für Technical Specification und ist die vorläufige Spezifikation des Coroutinen-Frameworks, das wir in C++20 erhalten. Baker wird die cppcoro-Bibliothek noch auf das C++20-Coroutinen Framework-portieren. </div>
<div class="text">Diese Portierung von cppcoro ist aus meiner Sicht aus einem Grund sehr wichtig: <b>Wir erhalten keine Coroutinen, sondern ein Coroutinen-Framework mit C++20</b>. Dieser kleiner Unterschied bedeutet, dass du, wenn du Coroutinen in C++20 verwenden willst, diese auf Grundlage des C++ 20-Coroutinen-Frameworks umsetzen musst. Mit C++23 werden wir wohl konkrete Coroutinen erhalten. Ehrlich gesagt sehe ich das sehr kritisch, denn eigene Coroutinen aufgrund des C++20-Coroutinen-Frameworks zu implementieren, ist sehr anspruchsvoll und damit fehleranfällig. Diese Lücke ist genau die Lücke, die cppcoro schließt. cppcoro bietet viele Abstraktionen rund um Coroutinen-Datentypen an:</div>
<div class="text"><ul><li> Coroutinen-Datentypen<br></li><li>"Awaitable types"<br></li><li>Funktionen</li><li>Beendigung von Coroutinen</li><li>Netzwerk</li><li>Scheduler</li><li>Metafunktionen</li><li>Concepts<br></li></ul></div>
<div class="ztitel">Verwendung von cppcoro<br></div>
<div class="text">Zurzeit setzt cppcoro auf dem Coroutines TS auf und kann mit Windows (Visual Studio 2017) oder Linux (Clang 5.0/6.0 und libc++) verwendet werden. Für meine Experimente kommt die folgende Kommandozeile zum Einsatz:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/8/1/3/5/6/TN_192234085_31fb5c0da2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><ul><li>-<span class="tx_code">std=c++17</span>: Unterstützung für C++17</li><li><span class="tx_code">-fcoroutines-ts</span>: Unterstützung für das Coroutines TS</li><li><span class="tx_code">-Iinclude</span>: cppcoro-Headerdateien<br></li><li><span class="tx_code">-stdlib=libc++</span>: LLVM-Implementierung der Standard-Bibliothek<br></li><li><span class="tx_code">libcppcoro.a</span>: cppcoro-Bibliothek</li></ul></div>
<div class="text">Gerne will ich es nochmal betonen: Wenn cppcoro in der Zukunft auf C++20 basiert, lässt sich die Bibliothek mit jedem C++20-konformen Compiler verwenden. Zusätzlich gibt dir cppcoro ein Gefühl dafür, welche konkreten Coroutinen wir wohl mit C++23 erhalten werden.&nbsp; </div>
<div class="text">Nach meiner steilen Lernkurve möchte ich eine paar Beispiele zu cppcoro vorstellen. Ich verwende für meine Vorstellung der Features von cppcoro vorhandene Codeschnipsel oder dokumentierte Testfälle. Los geht es mit den Coroutinen.</div>
<div class="ztitel">Coroutinen-Datentypen</div>
<div class="text">cppcoro bietet Tasks und Generatoren in verschiedenen Variationen an.</div>
<div class="ztitel_kleiner"><span class="tx_code">task&lt;T&gt;</span></div>
<div class="text">Was ist eine Task? Dies ist die Definition von <span class="tx_code">task&lt;T&gt;</span> direkt von der Online-Dokumentation.</div>
<div class="text"><ul><li> A task represents an asynchronous computation that is executed lazily in that the execution of the coroutine does not start until the task is awaited.</li></ul></div>
<div class="text">Eine Task ist eine Coroutine. In dem folgenden Programm wartet die Funktion <span class="tx_code">main</span> auf die Funktion <span class="tx_code">first</span>, die Funktion <span class="tx_code">first</span> auf die Funktion <span class="tx_code">second</span> und die Funktion <span class="tx_code">second</span> auf die Funktion <span class="tx_code">third:</span><br></div>
<div class="pre">// cppcoroTask.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;thread&gt;<br><br>#include &lt;cppcoro/sync_wait.hpp&gt;<br>#include &lt;cppcoro/task.hpp&gt;<br><br>using std::chrono::high_resolution_clock;<br>using std::chrono::time_point;<br>using std::chrono::duration;<br><br>using namespace std::chrono_literals; // 1s<br>&nbsp;&nbsp; <br>auto getTimeSince(const time_point&lt;high_resolution_clock&gt;&amp; start) {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto end = high_resolution_clock::now();<br>&nbsp;&nbsp;&nbsp; duration&lt;double&gt; elapsed = end - start;<br>&nbsp;&nbsp;&nbsp; return elapsed.count();<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>cppcoro::task&lt;&gt; third(const time_point&lt;high_resolution_clock&gt;&amp; start) {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Third waited " &lt;&lt; getTimeSince(start) &lt;&lt; " seconds." &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; co_return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br><br>cppcoro::task&lt;&gt; second(const time_point&lt;high_resolution_clock&gt;&amp; start) {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto thi = third(start);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);<br>&nbsp;&nbsp;&nbsp; co_await thi;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Second waited " &lt;&lt;&nbsp; getTimeSince(start) &lt;&lt; " seconds." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>cppcoro::task&lt;&gt; first(const time_point&lt;high_resolution_clock&gt;&amp; start) {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto sec = second(start);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);<br>&nbsp;&nbsp;&nbsp; co_await sec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "First waited " &lt;&lt;&nbsp; getTimeSince(start)&nbsp; &lt;&lt; " seconds." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto start = high_resolution_clock::now();<br>&nbsp;&nbsp;&nbsp; cppcoro::sync_wait(first(start));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Main waited " &lt;&lt;&nbsp; getTimeSince(start) &lt;&lt; " seconds." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Zugegeben, das Programm löst kein Problem. Das Programm hilft aber, den Arbeitsablauf von Coroutinen besser zu verstehen.</div>
<div class="text">Zuerst einmal kann die <span class="tx_code">main</span>-Funktion keine Coroutine sein. Aus diesem Grund dient die Funktion <span class="tx_code">cppcoro::sync_wai</span><span class="tx_code">t</span> (Zeile 1) gerne als der startende Top-Level Task. Er wartet, bis er abgeschlossen ist. Die Coroutine <span class="tx_code">first</span> erhält wie die anderen Coroutinen als Argument die <span class="tx_code">start</span>-Zeit und stellt ihre Ausführungszeit dar. Was passiert in der Coroutine <span class="tx_code">first</span>? Sie startet die Coroutine <span class="tx_code">second</span> (Zeile 2), die sofort angehalten wird, anschließend schläft <span class="tx_code">first</span> für eine Sekunde und weckt die Coroutine <span class="tx_code">second</span> mithilfe des Coroutinen-Handle <span class="tx_code">sec</span> in Zeile 3 wieder auf. Die Coroutine <span class="tx_code">second</span> folgt demselben Arbeitsablauf. Dies gilt nicht für die Coroutine <span class="tx_code">third</span>. Diese gibt nichts zurück und wartet auch nicht auf eine andere Coroutine. Wenn <span class="tx_code">third</span> mit der Ausführung fertig ist, werden alle anderen Coroutinen ausgeführt. Damit besitzt jede Coroutine eine Ausführungszeit von drei Sekunden. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/8/1/3/5/6/TN_192234086_3d5be6da0c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Jetzt variiere ich den Arbeitsablauf ein wenig. Was passiert, wenn ich die Coroutine erst nach dem <span class="tx_code">co_awai</span><span class="tx_code">t</span> call schlafen lege? </div>
<div class="pre">// cppcoroTask2.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;thread&gt;<br><br>#include &lt;cppcoro/sync_wait.hpp&gt;<br>#include &lt;cppcoro/task.hpp&gt;<br><br>using std::chrono::high_resolution_clock;<br>using std::chrono::time_point;<br>using std::chrono::duration;<br><br>using namespace std::chrono_literals;<br><br>auto getTimeSince(const time_point&lt;::high_resolution_clock&gt;&amp; start) {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto end = high_resolution_clock::now();<br>&nbsp;&nbsp;&nbsp; duration&lt;double&gt; elapsed = end - start;<br>&nbsp;&nbsp;&nbsp; return elapsed.count();<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>cppcoro::task&lt;&gt; third(const time_point&lt;high_resolution_clock&gt;&amp; start) {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Third waited " &lt;&lt; getTimeSince(start) &lt;&lt; " seconds." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);<br>&nbsp;&nbsp;&nbsp; co_return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br><br><br>cppcoro::task&lt;&gt; second(const time_point&lt;high_resolution_clock&gt;&amp; start) {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto thi = third(start);<br>&nbsp;&nbsp;&nbsp; co_await thi;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Second waited " &lt;&lt;&nbsp; getTimeSince(start) &lt;&lt; " seconds." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>cppcoro::task&lt;&gt; first(const time_point&lt;high_resolution_clock&gt;&amp; start) {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto sec = second(start);<br>&nbsp;&nbsp;&nbsp; co_await sec;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "First waited " &lt;&lt;&nbsp; getTimeSince(start)&nbsp; &lt;&lt; " seconds." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; auto start = ::high_resolution_clock::now();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; cppcoro::sync_wait(first(start));<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Main waited " &lt;&lt;&nbsp; getTimeSince(start) &lt;&lt; " seconds." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Du erahnst es wohl schon. Die <span class="tx_code">main</span>-Funktion wartet drei Sekunden, aber jede sukzessiv aufgerufene Coroutine eine Sekunde kürzer.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/8/1/3/5/6/TN_192234092_3f4ac159d4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">In zukünftigen Artikeln werde ich Tasks um Threads und Signale erweitern.</div>
<div class="ztitel">generator&lt;T&gt;<br></div>
<div class="text">In bekannter Manier zitiere ich die Definition eines Generators <span class="tx_code">generator&lt;T&gt;</span> aus cppcoro.</div>
<div class="text"><ul><li>A <b>generator</b> represents a coroutine type that produces a sequence of values of type T, where values are produced lazily and synchronously.</li></ul></div>
<div class="text">Ohne viele Worte zeigt das Programm <span class="tx_code">cppcoroGenerator.cpp</span> zwei Generatoren in Aktion: </div>
<div class="pre">// cppcoroGenerator.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;cppcoro/generator.hpp&gt;<br><br>cppcoro::generator&lt;char&gt; hello() {<br>&nbsp;&nbsp;&nbsp; co_yield 'h';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; co_yield 'e';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; co_yield 'l';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; co_yield 'l';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; co_yield 'o';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>}<br><br>cppcoro::generator&lt;const long long&gt; fibonacci() {<br>&nbsp;&nbsp;&nbsp; long long a = 0;<br>&nbsp;&nbsp;&nbsp; long long b = 1;<br>&nbsp;&nbsp;&nbsp; while (true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; co_yield b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto tmp = a;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b += tmp;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; for (auto c: hello()) std::cout &lt;&lt; c; <br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; for (auto i: fibonacci()) {&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i &gt; 1'000'000 ) break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Die erste Coroutine <span class="tx_code">hello</span> gibt auf Anfrage den nächsten Buchstaben zurück; die Coroutine <span class="tx_code">fibonacci</span> die nächste Fibonaccizahl. <span class="tx_code">fibonacci</span> erzeugt dabei einen unendlichen Datenstrom. Was passiert in der Zeile 1? Die Range-basierte for-Schleife stößt die Ausführung der Coroutine an. Die erste Iteration startet die Coroutine, gibt den Wert <span class="tx_code">b</span> des Ausdrucks <span class="tx_code">co_yield b</span> zurück und legt sich schlafen. Darauf folgende Aufrufe der Range-basierten for-Schleife wecken die Coroutine <span class="tx_code">fibonacci</span> auf und geben die nächste Fibonacccizahl zurück. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/8/1/3/5/6/TN_192234102_04b52d27c9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Bevor ich diesen Artikel abschließe, möchte ich eine Intuition für den Unterschied von<span class="tx_code"> co_wait</span> (Task) und <span class="tx_code">co_yield</span> (Generator) anbieten: <b><span class="tx_code">co_wait</span> wartet nach innnen, <span class="tx_code">co_yield </span>wartet nach außen</b>. Zum Beispiel wartet die Coroutine <span class="tx_code">first</span> auf die aufgerufen Coroutine <span class="tx_code">second</span> (<span class="tx_code">cppcoroTask.cpp</span>), hingegen wartet die coroutine <span class="tx_code">fibonacci</span> (<span class="tx_code">cppcoroGenerator.cpp</span>), bis sie durch die externe Range-basierte for-Schleife angestoßen wird. </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Mein nächster Artikel zu cppcoro taucht tiefer in Tasks ein. Ich kombiniere sie mit Threads, Signalen und Thread-Pools.<br></div>
