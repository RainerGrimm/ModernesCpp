<div class="vorspann">Vor C++20 ließen sich Threads nicht unterbrechen. Mit C++20 kann man an einen Thread die Anfrage stellen, dass er sich beendet. Ihr kann er dann nachkommen. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/5/2/5/7/2/TN_206555082_12433f177d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Zuerst einmal: Warum ist es keine gute Idee, einen Thread zu beenden? Diese Antwort ist einfach. Man weiß nicht, in welchem Zustand der Thread ist, wenn man ihn beendet. Dies sind zwei mögliche Gefahren:</div>
<div class="text"><ul><li>Der Thread kann nur teilweise mit seinem Job fertig sein. Natürlich ist nun der Stand seines Jobs und damit auch der des Programms unbekannt. Am Ende führt das zum undefinierten Verhalten, und keine zuverlässige Aussage über das Programm ist mehr möglich.</li><li>Der Thread kann sich gerade in einem kritischen Bereich befinden und einen Mutex gelockt haben. Wird der Thread in dieser Phase beendet, führt das mit hoher Wahrscheinlichkeit zu einem Deadlock.</li></ul></div>
<div class="text">Einen Thread abrupt zu unterbrechen ist keine gute Idee. Da ist es schon besser, den Thread freundlich zu fragen, ob er sich beenden lassen will. Das ist genau, wofür kooperatives Unterbrechen in C++20 steht. Man fragt den Thread freundlich, ob er sich beenden will, und der Thread kann diesem Wunsch nachkommen oder ihn ignorieren.</div>
<div class="ztitel">Kooperatives Unterbrechen<br> </div>
<div class="text">Die zusätzliche Fähigkeit der kooperativen Unterbrechung in C++20 basiert auf den drei neuen Datentypen <span class="tx_code">std::stop_token</span>, <span class="tx_code">std::stop_callback</span> und <span class="tx_code">std::stop_source</span>. Sie ermöglichen es einem Thread, einen Thread asynchron zu beenden oder zu fragen, ob ein Thread ein Stoppsignal erhalten hat. Der<span class="tx_code"> std::stop_toke</span><span class="tx_code">n</span> lässt sich dafür an eine Operation übergeben. Dieses Stopp-Token kann anschließend dazu verwendet werden, die Operation zu fragen, ob an sie der Wunsch zur Beendigung geschickt wurde. Anderseits lässt sich mit <span class="tx_code">std::stop_token</span> ein Callback mittels <span class="tx_code">std::stop_callback</span> registrieren. Die Stoppanfrage wird von <span class="tx_code">std::stop_source</span> geschickt. Ihr Signal betrifft alle assoziierten <span class="tx_code">std::stop_token</span>. Die drei Klassen <span class="tx_code">std::stop_source</span>, <span class="tx_code">std::stop_token</span> und <span class="tx_code">std::stop_callback</span> teilen sich die Besitzverhältnisse des assoziierten Stoppzustands. Die Aufrufe <span class="tx_code">request_stop()</span>,<span class="tx_code"> stop_requested()</span> und <span class="tx_code">stop_possible()</span> sind atomar. <br></div>
<div class="text">Ein <span class="tx_code">std::stop_source</span> lässt sich auf zwei Arten erzeugen: </div>
<div class="pre">stop_source();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>explicit stop_source(std::nostopstate_t) noexcept;&nbsp; // (2)</div>
<div class="text">Der Default-Konstruktor (1) erzeugt ein <span class="tx_code">std::stop_source</span> mit einem Stoppzustand. Der Konstruktor, der <span class="tx_code">std::nostopstate_t</span> als Argument annimmt, erzeugt eine <span class="tx_code">std::stop_source</span> ohne assoziierten Stoppzustand. </div>
<div class="text">Die Komponente <span class="tx_code">std::stop_source src</span> bietet die folgenden Methoden an, um mit Stoppanfragen umzugehen:</div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/5/2/5/7/2/TN_206555097_4250911036.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><span class="tx_code">src.stop_possible()</span> bedeutet, dass <span class="tx_code">src</span> einen assoziierten Stoppzustand besitzt. <span class="tx_code">src.stop_requested()</span> gibt dann <span class="tx_code">true</span> zurück, wenn <span class="tx_code">src</span> einen assoziierten Stoppzustand besitzt und nicht bereits früher zu stoppen angefordert wurde. Der Aufruf <span class="tx_code">src.get_token()</span> gibt den Stopp-Token zurück. Dank ihm lässt sich prüfen, ob eine Stoppanfrage bereits erfolgt ist oder durchgeführt werden kann. </div>
<div class="text">Das Stopp-Token <span class="tx_code">stoken</span> beobachtet die Stoppquelle <span class="tx_code">src</span>. Die folgende Tabelle stellt die Methoden der <span class="tx_code">std::stop_token stoken</span> vor:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/5/2/5/7/2/TN_206555103_86df6e70c9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Ein Default-konstruiertes Token besitzt keinen assoziierten Stoppzustand. <span class="tx_code">stoken.stop_possible</span> gibt <span class="tx_code">true</span> zurück, falls <span class="tx_code">stoken</span> einen assoziierten Stoppzustand besitzt. <span class="tx_code">stoken_stop_requested()</span> gibt dann <span class="tx_code">true</span> zurück, wenn der Stopp-Token einen assoziierten Stoppzustand besitzt und bereits eine Stoppanfrage erhalten hat.</div>
<div class="text">Falls der <span class="tx_code">std::stop_token</span> zeitweise deaktiviert werden soll, lässt er sich mit einem Default-konstruierten Token ersetzen. Dieses hat keinen assoziierten Stoppzustand. Die folgenden Zeilen zeigen, wie sich die Fähigkeit eines Threads, Stoppanfragen zu erhalten, zeitweise deaktivieren lässt:</div>
<div class="pre">std::jthread jthr([](std::stop_token stoken) {<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; std::stop_token interruptDisabled;<br>&nbsp;&nbsp;&nbsp; std::swap(stoken, interruptDisabled);&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::swap(stoken, interruptDisabled);<br>&nbsp;&nbsp;&nbsp; ...<br>}<br></div>
<div class="text"><span class="tx_code">std::stop_token</span> <span class="tx_code">interruptDisabled</span> besitzt keinen assoziierten Stoppzustand. Das heißt, dass der Thread <span class="tx_code">jthr</span> in allen Zeilen außer (1) und (2) Stoppanfragen annehmen kann. </div>
<div class="text">Wer den Codeschnipsel sorgfältig studiert, dem fällt wohl <span class="tx_code">std::jthread</span> auf. <span class="tx_code">std::jthread</span> in C++20 ist ein erweiterter <span class="tx_code">std::thread</span> aus C++11. Das "j" in <span class="tx_code">jthread</span> steht für <i>joinable</i>, denn ein <span class="tx_code">std::jthread</span> joint automatisch in seinem Destruktor. Ursprünglich hieß dieser neue Thread <span class="tx_code">ithread</span>: "i" steht für <i>interruptable</i>. Ich stelle <span class="tx_code">std::jthread</span> im nächsten Artikel genauer vor. <br></div>
<div class="text">Das nächste Beispiel zeigt, wie sich <span class="tx_code">std::jthread</span> zusammen mit einem Callback verwenden lässt:</div>
<div class="pre">// invokeCallback.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br>#include &lt;vector&gt;<br><br>using namespace::std::literals;<br><br>auto func = [](std::stop_token stoken) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int counter{0};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto thread_id = std::this_thread::get_id();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::stop_callback callBack(stoken, [&amp;counter, thread_id] {&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Thread id: " &lt;&lt; thread_id <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "; counter: " &lt;&lt; counter &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (counter &lt; 10) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(0.2s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++counter;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; };<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::jthread&gt; vecThreads(10);<br>&nbsp;&nbsp;&nbsp; for(auto&amp; thr: vecThreads) thr = std::jthread(func);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; for(auto&amp; thr: vecThreads) thr.request_stop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Jeder der zehn Threads ruft die Lambda-Funktion <span class="tx_code">func</span> (1) auf. Der Callback (2) stellt die ID des Threads und den Zähler dar. Dank des einsekundigen Schlafens des <span class="tx_code">main</span>-Threads (3) und des Schlafens der Kinder-Threads besitzt der Zähler zum Zeitpunkt des Callback-Aufrufs den Wert 4. Der Aufruf&nbsp; <span class="tx_code">thr.request_stop()</span> (4) startet den Callback auf jedem Thread.<br></div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/5/2/5/7/2/TN_206555110_8fcf304565.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Wie ich im Artikel bereits erwähnt habe, besitzt <span class="tx_code">std::thread</span> eine große Schwäche. Wenn du vergisst ihn zu joinen, ruft sein Destruktor <span class="tx_code">std::terminate</span> auf. Damit beendet sich das Programm. <span class="tx_code">std::jthread </span>(C++20) überwindet dieses unintuitive Verhalten und lässt sich unterbrechen. <br></div>
<div class="ztitel">Neue Online-Seminare</div>
<div class="text">Ich freue mich darauf, neue Online-Seminare anbieten zu dürfen. Das erste Seminar stellt die Vorteile von modernem C++ in der Embedded-Programmierung vor, und das zweite geht auf Best Practices für modernes C++ ein. Natürlich sind zum jetzigen Zeitpunkt noch viele Plätze frei.<br></div>
<div class="text"><ul><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/30-embedded-programmierung-mit-modernem-c20210126195655" alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22Embedded-Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F30-embedded-programmierung-mit-modernem-c20210126195655%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F30-embedded-programmierung-mit-modernem-c20210126195655%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/30-embedded-programmierung-mit-modernem-c20210126195655" class="">Embedded-Programmierung mit modernem C++</a>: 12. bis 14. April 2021 (9 bis 17 Uhr)</li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/31-clean-code-mit-modernem-c" alt="%7B%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F31-clean-code-mit-modernem-c%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F31-clean-code-mit-modernem-c%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Clean%20Code%20mit%20modernem%20C%2B%2B%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%7D" href="https://www.modernescpp.de/index.php/c/2-c/31-clean-code-mit-modernem-c" class="">Clean Code mit modernem C++</a>: 22. bis 24. Juni 2021 (9 bis 17 Uhr)<br></li></ul></div>