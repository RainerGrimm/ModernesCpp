<div class="vorspann">C++20 bringt viele Concepts bereits mit. Natürlich sollte kein Concept definiert werden, das bereits existiert. Aus diesem Grund stellt der heutige Artikel die vordefinierten Concepts vor. Meine bisherigen Artikel zu Concepts gibt es hier: <a alt="%7B%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fc-20%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fc-20%22%2C%22text%22%3A%22C%2B%2B20%3A%20Concepts%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%7D" href="https://www.grimm-jaud.de/index.php/blog/category/c-20" class="" title="Link auf https://www.grimm-jaud.de/index.php/blog/category/c-20">C++20: Concepts</a>.&nbsp;</div>
<div class="text">Erfinde das Rad nicht neu. Diese goldene Regel sollte natürlich auch auf Concepts angewandt werden. Nebenbei gesagt, die C++ Core Guidelines bringen dies auch deutlich auch auf den Punkt:&nbsp;<a class="" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-concepts" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-concepts" alt="%7B%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-concepts%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-concepts%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22T.11%3A%20Whenever%20possible%20use%20standard%20concepts.%22%2C%22subject%22%3A%22%22%7D">T.11: Whenever possible use standard concepts.</a></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_186754115_9d5d72b640.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Meine Information beziehe ich aus den neuesten C++20-Entwurf: <a class="" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/n4842.pdf" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/n4842.pdf" alt="%7B%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2019%2Fn4842.pdf%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2019%2Fn4842.pdf%22%2C%22text%22%3A%22N4842%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%7D">N4842</a>. Obwohl es einen Index im Dokument zu allen Concepts gibt, ist es recht mühsehlig, alle Concepts zu finden. Die meisten sind im Kapitel 18 (concepts library) und im Kapitel 24 (ranges library) beschrieben. Zusätzlich gibt es weitere Concepts in den Kapiteln 17 (language support library), 20 (general utilities library), 23 (iterators library) und 26 (numeric library). Das Dokument stellt auch teilweise vor, wie Concepts implementiert sind.&nbsp;</div>
<div class="text">Ehrlich gesagt war ich überrascht, dass ich kein Concept wie <span class="tx_code">Lockable</span>&nbsp;zu Concurrency gefunden habe. Ursprünglich wurden die Concepts in CamelCase oder WikiSyntax geschrieben. Nun besitzen sie Unterstriche. So wurde aus <span class="tx_code">DerivedFrom</span> etwa <span class="tx_code">derived_from.</span></div>
<div class="text">Ich ignoriere in diesem Artikel die speziellen Concepts und Hilfs-Concepts. Ich ignoriere auch die Concepts aus der Ranges-Bibliothek. Um diese zu verstehen, muss ich erst auf die Ranges-Bibliothek eingehen. Über deren Concepts werde ich dann schreiben, wenn ich die sie genauer vorstellen. Diese Artikel werde direkt auf die Artikel zu den Concepts folgen.&nbsp;</div>
<div class="text">Heute möchte ich erst eine Warnung aussprechen: Wenn dir technische Artikel missfallen, missfällt dir wohl auch dieser Artikel.&nbsp;</div>
<div class="ztitel">Language support library</div>
<div class="text">Diese Kapitel besitzt das interessante Concept <span class="tx_code">three_way_comparable</span>, um den Drei-Weg-Vergleichsoperator &lt;=&gt; zu unterstützen.&nbsp;</div>
<div class="text">Wenn du es formaler willst: <span class="tx_code">a</span> und <span class="tx_code">b</span> sollen vom Datentyp <span class="tx_code">T</span> sein. Sie sind genau dann three_way_comparable, wenn:&nbsp;</div>
<div class="text"><ul> <li><span class="tx_code">(a &lt;=&gt; b == 0) == bool(a == b)</span> ist wahr,</li> <li>(<span class="tx_code">a &lt;=&gt; b != 0) == bool(a != b)</span> ist wahr,</li> <li><span class="tx_code">((a &lt;=&gt; b) &lt;=&gt; 0)</span> und <span class="tx_code">(0 &lt;=&gt; (b &lt;=&gt; a))</span> sind gleich,</li> <li><span class="tx_code">(a &lt;=&gt; b &lt; 0) == bool(a &lt; b)</span> ist wahr,</li> <li><span class="tx_code">(a &lt;=&gt; b &gt; 0) == bool(a &gt; b)</span> ist wahr</li> <li><span class="tx_code">(a &lt;=&gt; b &lt;= 0) == bool(a &lt;= b)</span> ist wahr,</li> <li><span class="tx_code">(a &lt;=&gt; b &gt;= 0) == bool(a &gt;= b)</span> ist wahr.</li></ul></div>
<div class="ztitel">Concepts library</div>
<div class="text">Dieses Kapitel enthält die Concepts, die wir im Wesentlichen verwenden werden. Als Überschriften verwende ich im Folgenden die Überschriften des Dokuments.&nbsp;</div>
<div class="ztitel_kleiner">Language-related concepts</div>
<div class="text">Das Unterkapitel enthält gut 15 Concepts, die selbsterklärend sein sollten. Diese Concepts drücken Beziehungen zwischen Datentypen, Typklassifizierungen und fundamentale Typeigenschaften aus. Ihre Implementierung basiert meist direkt auf der entsprechenden Funktion der <a title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" class="" href="https://en.cppreference.com/w/cpp/header/type_traits" alt="%7B%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22Type-Traits-Bibliothek%22%2C%22subject%22%3A%22%22%7D">Type-Traits-Bibliothek</a>. Ich habe ihre Reihenfolge ein wenig umgestellt und füge ein paar Worte hinzu, wenn es notwendig ist.</div>
<div class="text"><ul><li><span class="tx_code">same_as</span></li><li><span class="tx_code">derived_from</span></li><li><span class="tx_code">convertible_to</span></li><li><span class="tx_code">common_reference_with</span>: <span class="tx_code">common_reference_with&lt;T, U&gt;</span> muss wohldefiniert und <span class="tx_code">T</span>&nbsp;und <span class="tx_code">U</span> müssen zu einem Referenztyp <span class="tx_code">C</span> konvertierbar sein</li><li><span class="tx_code">common_with</span>: ähnlich zu <span class="tx_code">common_reference_with</span>, aber der gemeinsame Datentyp <span class="tx_code">C</span> muss keine Referenz sein</li><li><span class="tx_code">assignable_from</span></li><li><span class="tx_code">swappable</span></li></ul></div>
<div class="text"><ul><li><b>Arithmetic</b></li></ul></div>
<div class="text"><ul><li><span class="tx_code">integral</span></li><li><span class="tx_code">signed_integral</span></li><li><span class="tx_code">unsigned_integral</span></li><li><span class="tx_code">floating_point</span></li></ul></div>
<div class="text">Die Defintion der Concepts ist naheliegend:</div>
<div class="pre">template&lt;class T&gt;<br>concept integral = is_integral_v&lt;T&gt;;<br><br>template&lt;class T&gt;<br>concept signed_integral = integral&lt;T&gt; &amp;&amp; is_signed_v&lt;T&gt;;<br><br>template&lt;class T&gt;<br>concept unsigned_integral = integral&lt;T&gt; &amp;&amp; !signed_integral&lt;T&gt;;<br><br>template&lt;class T&gt;<br>concept floating_point = is_floating_point_v&lt;T&gt;;</div>
<div class="text"><ul><li><b>Lifetime</b></li></ul></div>
<div class="text"><ul><li><span class="tx_code">destructible</span></li><li><span class="tx_code">constructible_from</span></li><li><span class="tx_code">default_constructible</span></li><li><span class="tx_code">move_constructible</span></li><li><span class="tx_code">copy_constructible</span></li></ul></div>
<div class="ztitel_kleiner">Comparison concepts</div>
<div class="text"><ul><li><span class="tx_code">boolean</span>: gibt an, ob ein Datentyp als boolean verwendet werden kann; Interessanterweise gelten Zeiger, intelligente Zeiger und Datentypen mit einem expliziten Konvertierungsoperator nach bool nicht als <span class="tx_code">boolean</span>-Datentypen.&nbsp;</li><li><span class="tx_code">equality_comparable</span></li><li><span class="tx_code">totally_ordered</span></li></ul></div>
<div class="text">Für Werte <span class="tx_code">a</span>, <span class="tx_code">b</span> und <span class="tx_code">c</span> vom Datentyp <span class="tx_code">T</span> gilt, dass <span class="tx_code">T</span> das Concept <span class="tx_code">totally_ordered</span> genau dann unterstützt, wenn gilt:</div>
<div class="text"><ul><li>Genau eine von <span class="tx_code">bool(a &lt; b)</span>, <span class="tx_code">bool(a &gt; b)</span> oder <span class="tx_code">bool(a == b)</span> ist wahr.</li><li>Falls <span class="tx_code">bool(a &lt; b)</span> und <span class="tx_code">bool(b &lt; c)</span> gilt, dann <span class="tx_code">bool(a &lt; c)</span>.</li><li><span class="tx_code">bool(a &gt; b) == bool(b &lt; a)</span>.</li><li><span class="tx_code">bool(a &lt;= b) == !bool(b &lt; a)</span>.</li><li><span class="tx_code">bool(a &gt;= b) == !bool(a &lt; b)</span>.</li></ul></div>
<div class="ztitel_kleiner">Object concepts</div>
<div class="text"><ul><li><span class="tx_code">movable</span></li><li><span class="tx_code">copyable</span></li><li><span class="tx_code">semiregular</span></li><li><span class="tx_code">regular</span></li></ul></div>
<div class="text">Hier ist schon die Definition der vier Concepts:&nbsp;</div>
<div class="pre">template&lt;class T&gt;<br>concept movable = is_object_v&lt;T&gt; &amp;&amp; move_constructible&lt;T&gt;&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; assignable_from&lt;T&amp;, T&gt; &amp;&amp; swappable&lt;T&gt;;<br><br>template&lt;class T&gt;<br>concept copyable = copy_constructible&lt;T&gt; &amp;&amp; movable&lt;T&gt;&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; assignable_from&lt;T&amp;, const T&amp;&gt;;<br><br>template&lt;class T&gt;<br>concept semiregular = copyable&lt;T&gt; &amp;&amp; default_constructible&lt;T&gt;;<br><br>template&lt;class T&gt;<br>concept regular = semiregular&lt;T&gt; &amp;&amp; equality_comparable&lt;T&gt;;</div>
<div class="text">Dazu möchte ich ein paar Worte hinzufügen. Das Concept <span class="tx_code">movable</span> fordert für <span class="tx_code">T</span>, dass die Bedingung <a href="https://en.cppreference.com/w/cpp/types/is_object" class="" title="Link auf https://en.cppreference.com/w/cpp/types/is_object" alt="%7B%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_object%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_object%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22i%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%7D">i</a><span class="tx_code"><a title="Link auf https://en.cppreference.com/w/cpp/types/is_object" class="" href="https://en.cppreference.com/w/cpp/types/is_object" alt="%7B%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_object%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_object%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22s_object_v%26lt%3BT%26gt%3B%22%7D">s_object_v&lt;T&gt;</a></span> gilt. Das bedeutet im Wesentlichen, dass <span class="tx_code">T</span> ein Skalar, ein Array, eine Union oder eine Klasse sein muss.&nbsp;</div>
<div class="text">Ich werde die Concepts<span class="tx_code">&nbsp;semiregular und regular</span> in zukünftigen Artikeln implementieren. Informell ausgedrückt, verhalten sich <span class="tx_code">semiregular-</span>Datentypen ähnlich wie <span class="tx_code">ints</span>, und <span class="tx_code">regular-</span>Datentypen unterstützen darüber hinaus noch den ==-Operator.&nbsp;</div>
<div class="ztitel_kleiner">Callable concepts</div>
<div class="text"><ul><li><span class="tx_code">invocable</span></li><li><span class="tx_code">regular_invocable</span>: <span class="tx_code">F</span>&nbsp;setzt das Concept <span class="tx_code">invocable</span> um und ist <i>equality-preserving</i>; darüber hinaus verändert <span class="tx_code">F</span> nicht die Funktionsargumente; <i>equality-preserving</i> bedeutet, dass <span class="tx_code">F</span> immer das gleiche Ergebnis produziert, wenn es dieselben Eingaben erhält</li><li><span class="tx_code">predicate</span>: <span class="tx_code">F</span>&nbsp;setzt das Concept <span class="tx_code">predicate</span>&nbsp;um, falls <span class="tx_code">F</span>&nbsp;das Concept <span class="tx_code">invocable</span> umsetzt und einen Wahrheitswert zurückgibt</li></ul></div>
<div class="ztitel">General utilities library</div>
<div class="text">Die Conceps zu Speicher in diesem Kapitel sind zu speziell. Daher ignoriere ich diese.</div>
<div class="ztitel">Iterators library</div>
<div class="text">Die Bibliothek&nbsp; besitzt viele wichtige Concepts. Hier sind zuerst einmal die Iteratorenkategorien.</div>
<div class="text"><ul><li><span class="tx_code">input_iterator</span></li><li><span class="tx_code">output_iterator</span></li><li><span class="tx_code">forward_iterator</span></li><li><span class="tx_code">bidirectional_iterator</span></li><li><span class="tx_code">random_access_iterator</span></li><li><span class="tx_code">contiguous_iterator</span></li></ul></div>
<div class="text">Diese sechs Iteratorkategorien entsprechen den Concepts zu Iteratoren. Das Bild zeigt die drei wichtigsten Iteratorkategorien und die entsprechenden Container der Standard Template Library.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_186754119_23e9084449.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die folgenden Beziehungen gelten. Ein Random Access Iterator ist ein Bidirectional Iterator und ein Bidirectional Iterator ist ein Forward Iterator. Ein Contiguous Iterator ist ein Random Access Iterator und fordert, dass seine Elemente kontinuierlich im Speicher liegen. Das heißt, dass <span class="tx_code">std::array, std::vector </span>und <span class="tx_code">std::string </span>einen Contigious Iterator unterstützen, <span class="tx_code">std::deque</span> hingegen nicht.&nbsp;</div>
<div class="ztitel_kleiner">Algorithm concepts</div>
<div class="text"><ul> <li><span class="tx_code">permutable</span>: Neuordnung von Element <i>in-place </i>wird unterstützt</li> <li><span class="tx_code">mergeable</span>: Vereinigung sortierter Sequenzen in eine Ausgabesequenz wird unterstützt</li> <li><span class="tx_code">sortable:</span> Permutieren einer Sequenz in eine sortierte Sequenz wird unterstützt</li></ul></div>
<div class="ztitel">Numeric library</div>
<div class="text">Die numerische Bibliothek besitzt das Concept <span class="tx_code">uniform_random_bit_generator</span>. Ein&nbsp; &nbsp;<span class="tx_code">uniform_random_bit_generator</span>&nbsp;<span class="tx_code">g</span> vom Datentyp&nbsp;<span class="tx_code">G</span>&nbsp;muss ein<span class="tx_code"> unsigned int</span> zurückgeben und jeder Wert gleich wahrscheinlich sein. Weiter fordert das Concept, dass der Generator die Funktionen <span class="tx_code">G::max</span> und <span class="tx_code">G::min</span> unterstützt.</div>
<div class="ztitel">Wie geht's weiter?<br></div>
<div class="text">Mit dem nächsten Artikel wird es wieder praktischer. Ich schreibe über die Definition von Concepts wie integral, semiregular und regular. Das Definieren von Concepts ist deutlich mehr, als nur Einschränkungen auf Typ-Parametern auszusprechen.</div>
