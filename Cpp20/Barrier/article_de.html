<div class="vorspann">In <a title="Link auf https://heise.de/-5033716" alt="%7B%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5033716%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22meinem%20letzten%20Artikel%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5033716%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%7D" href="https://heise.de/-5033716" class="">meinem letzten Artikel</a> habe ich Latches zur Thread-Koordination in C++20 vorgestellt. Latch besitzt einen großen Bruder: Barrier. Diese können mehrmals verwendet werden. In diesem Artikel beschäftige ich mit Barrieren und atomaren Smart Pointers.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/4/8/3/2/9/TN_206167505_f506b3b741.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">std::barrier</div>
<div class="text">Es gibt zwei Unterschiede zwischen Latches und Barriers. Ein <span class="tx_code">std::latch</span> lässt sich nur einmal verwenden, ein&nbsp;<span class="tx_code">std::barrier</span> hingegen mehrmals. Zusätzlich erlaubt es ein <span class="tx_code">std::barrier</span>, eine Funktion im sogenannten Completion-Step auszuführen. Dieser ist der Zustand, wenn der Zähler den Wert null besitzt. Unmittelbar dann, wenn der Zähler den Wert null hat, wird eine aufrufbare Einheit ausgeführt. Die Barrier erhält ihre aufrufbare Einheit im Konstruktor. Eine aufrufbare Einheit (<i>callable</i>) ist eine Einheit, die sich wie eine Funktion verhält. Dies können Funktionen, Funktionsobjekte oder Lambda-Ausdrücke sein. <br></div>
<div class="text">Der Completion-Step führt die folgenden Schritte aus:</div>
<div class="text"><ol><li> Alle Threads werden blockiert.</li><li>Ein beliebiger Thread wird entblockt und führt die aufrufbare Einheit aus.</li><li>Wenn der Completion-Step fertig ist, werden alle Threads entblockt.</li></ol></div>
<div class="text">Die folgende Tabelle stellt das Interface einer <span class="tx_code">std::barrier bar</span> dar. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/4/8/3/2/9/TN_206167509_0328898779.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Der Aufruf <span class="tx_code">bar.arrive_and_drop()</span> bewirkt, dass der Zähler um 1 in der nächsten Phase dekrementiert wird. Das folgende Programm <span class="tx_code">fullTimePartTimeWorkers.cpp</span> halbiert die Anzahl der Arbeiter in der zweiten Phase:<br></div>
<div class="pre">// fullTimePartTimeWorkers.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;barrier&gt;<br>#include &lt;mutex&gt;<br>#include &lt;string&gt;<br>#include &lt;thread&gt;<br><br>std::barrier workDone(6);<br>std::mutex coutMutex;<br><br>void synchronizedOut(const std::string&amp; s) noexcept {<br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; lo(coutMutex);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; s;<br>}<br><br>class FullTimeWorker {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; FullTimeWorker(std::string n): name(n) { };<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; void operator() () {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronizedOut(name + ": " + "Morning work done!\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; workDone.arrive_and_wait();&nbsp; // Wait until morning work is done&nbsp;&nbsp;&nbsp;&nbsp; (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronizedOut(name + ": " + "Afternoon work done!\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; workDone.arrive_and_wait();&nbsp; // Wait until afternoon work is done&nbsp;&nbsp; (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; std::string name;<br>};<br>&nbsp; <br>class PartTimeWorker {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; PartTimeWorker(std::string n): name(n) { };<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; void operator() () {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronizedOut(name + ": " + "Morning work done!\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; workDone.arrive_and_drop();&nbsp; // Wait until morning work is done&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; std::string name;<br>};<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; FullTimeWorker herb("&nbsp; Herb");<br>&nbsp;&nbsp;&nbsp; std::thread herbWork(herb);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; FullTimeWorker scott("&nbsp;&nbsp;&nbsp; Scott");<br>&nbsp;&nbsp;&nbsp; std::thread scottWork(scott);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; FullTimeWorker bjarne("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bjarne");<br>&nbsp;&nbsp;&nbsp; std::thread bjarneWork(bjarne);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; PartTimeWorker andrei("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Andrei");<br>&nbsp;&nbsp;&nbsp; std::thread andreiWork(andrei);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; PartTimeWorker andrew("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Andrew");<br>&nbsp;&nbsp;&nbsp; std::thread andrewWork(andrew);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; PartTimeWorker david("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; David");<br>&nbsp;&nbsp;&nbsp; std::thread davidWork(david);<br><br>&nbsp;&nbsp;&nbsp; herbWork.join();<br>&nbsp;&nbsp;&nbsp; scottWork.join();<br>&nbsp;&nbsp;&nbsp; bjarneWork.join();<br>&nbsp;&nbsp;&nbsp; andreiWork.join();<br>&nbsp;&nbsp;&nbsp; andrewWork.join();<br>&nbsp;&nbsp;&nbsp; davidWork.join();<br>&nbsp; <br>}<br></div>
<div class="text">Dieser Arbeitsablauf besitzt zwei Klassen von Arbeitern: Ganztagsarbeiter (1) und Halbtagsarbeiter (2). Die Halbtagsarbeiter arbeiten am Morgen und die Ganztagsarbeiter am Morgen und am Nachmittag. Konsequenterweise rufen die Ganztagsarbeiter <span class="tx_code">wordDone.arrive_and_wait()</span> (Zeilen (3) und (4)) zweimal auf. Im Gegensatz dazu rufen die Halbtagsarbeiter <span class="tx_code">wordDone.arrive_and_drop(</span>) (5) genau einmal auf. Der Aufruf <span class="tx_code">workDone.arrive_and_drop()</span> bewirkt, dass die Halbtagsarbeiter die Arbeit am Nachmittag nicht ausführen. Entsprechend besitzt der Zähler in der ersten Phase (Morgen) den Wert 6 und in der zweiten Phase (Nachmittag) den Wert 3.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/4/8/3/2/9/TN_206167515_2d0baaa3c9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Nun möchte ich ein Feature in C++20 vorstellen, das ich in meinen Artikeln zu Atomics übersehen habe.</div>
<div class="ztitel">Atomare Smart Pointers</div>
<div class="text">Der Proposal <a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4162.pdf" alt="%7B%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2014%2Fn4162.pdf%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2014%2Fn4162.pdf%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22N4162%22%7D" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4162.pdf" class="">N4162</a>&nbsp;für atomare Smart Pointers bringt die Unzulänglichkeit der bisherigen Implementierung direkt auf den Punkt. Die Unzulänglichkeiten werden an den drei Punkten Konsistenz&nbsp;(consistency),&nbsp;Korrektheit&nbsp;(correctness)&nbsp;und Performanz&nbsp;(performance)&nbsp;festgemacht. Hier die Punkte kurz und knapp zusammengefasst. Die Details lassen sich im Proposal nachlesen.</div>
<div class="text"><ul><li><b>Konsistenz</b>:&nbsp;Die atomaren Operationen für den&nbsp;<span class="tx_code">std::shared_ptr</span>&nbsp;sind die einzigen Operationen, die für einen nichtatomaren Datentyp angeboten werden.</li><li><b>Korrektheit</b>:&nbsp;Die Verwendung der freien atomaren Operationen ist sehr fehleranfällig, da sie auf der Disziplin der Anwender basiert. Wie schnell wird statt einem&nbsp;<span class="tx_code">std::atomic_store(&amp;ptr, localPtr)</span> ein einfaches <span class="tx_code">ptr= localPtr</span> verwendet. Das Ergebnis ist ein undefiniertes Verhalten. Ist hingegen der Smart Pointer ein atomarer Datentyp, verbietet dies der Compiler.</li><li><b>Performanz</b>:&nbsp;Die&nbsp;<span class="tx_code">std::atomic_shared_prt</span> und&nbsp;<span class="tx_code">std::atomic_weak_ptr</span>&nbsp;besitzen einen deutlichen Vorteil gegenüber den freien <span class="tx_code">atomic_</span>*-Funktionen. Sie sind für den speziellen Anwendungsfall Multithreading konzipiert und können zum Beispiel ein&nbsp;<span class="tx_code">std::atomic_flag</span> besitzen, um einen billigen&nbsp;<a title="Link auf https://de.wikipedia.org/wiki/Spinlock" alt="%7B%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FSpinlock%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Spinlock%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FSpinlock%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%7D" href="https://de.wikipedia.org/wiki/Spinlock" class="">Spinlock</a>&nbsp;zu verwenden. Auf Verdacht macht es natürlich im Gegensatz dazu keinen Sinn, in jeden allgemein einsetzbaren&nbsp;<span class="tx_code">std::shared_ptr</span>&nbsp;oder <span class="tx_code">std::weak_ptr</span> ein&nbsp;<span class="tx_code">std::atomic_flag</span>&nbsp;zu verpacken. Das wäre aber die Konsequenz, wenn beide einen Spinlock im Multithreading-Anwendungsfall verwenden wollten und es keine atomare Smart Pointers gäbe. Damit wäre&nbsp;<span class="tx_code">std::shared_ptr</span>&nbsp;und&nbsp;<span class="tx_code">std::weak_ptr</span>&nbsp;für den speziellen Anwendungsfall Multithreading optimiert. <br></li></ul></div>
<div class="text">Persönlich finde ich das Korrektheitsargument mit Abstand das wichtigste. Warum? Genau darauf gibt das Proposal eine sehr schöne Antwort. Es stellte eine Thread-sichere einfach verkette Liste vor, die das Einfügen, Löschen und Finden von Elementen unterstützt. Diese ist lock-frei mit atomaren Smart Pointers implementiert.</div>
<div class="ztitel">Eine Thread-sichere einfach verkettete Liste</div>
<div class="ztitel_kleiner"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/4/8/3/2/9/TN_206167524_b71e2868c9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Alle Modifikationen, die notwendig sind, um den Code mit einem C++11-Compiler zu übersetzen, sind in Rot angedeutet. Die Implementierung mit expliziten, atomaren Datentypen ist deutlich einfacher und damit weniger fehleranfällig. </div>
<div class="text">Das Proposal <a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4162.pdf" alt="%7B%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2014%2Fn4162.pdf%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22text%22%3A%22N4162%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2014%2Fn4162.pdf%22%7D" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4162.pdf" class="">N4162</a> schlägt die zwei neuen Datentypen <span class="tx_code">std::atomic_shared_ptr</span> und <span class="tx_code">std::atomic_weak_ptr</span> vor. Durch die Aufnahme dieser neuen Datentypen in den ISO-C++-Standard wurden sie zu partiellen Template-Spezialisierungen von <span class="tx_code">std::atomic: std::atomic&lt;std::shared_ptr&gt;</span> und <span class="tx_code">std::atomic&lt;std::weak_ptr&gt;.</span></div>
<div class="text">Konsequenterweise sind die atomaren Operationen auf <span class="tx_code">std::shared_ptr&lt;T&gt;</span> mit C++20 "deprecated". <br></div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Mit C++20 lassen sich Threads kooperativ unterbrechen. In meinem nächsten Artikel zeige ich, was das bedeutet.<br></div>