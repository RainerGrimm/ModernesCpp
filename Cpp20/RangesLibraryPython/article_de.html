<div class="vorspann">Heute starte ich ein kleines Experiment. Ich will sehr beliebte Funktionen in Python mithilfe der Ranges-Bibliothek implementieren. Ich bin neugierig, wie leicht mir die Umsetzung von Python in C++ fällt.</div>
<div class="text">Seit 2004 gebe ich Python-Schulungen. Die Sprache besitzt beeindruckende Funktionen. Daher ist Python für mich die Messlatte für eine angenehm zu verwendende Programmiersprache. Heute werde ich die Python-Funktionen <span class="tx_code">range</span> und <span class="tx_code">filter</span> implementieren:<br></div>
<div class="text"><ul><li><span class="tx_code">range</span> erzeugt eine Liste "containing an arithmetic progression of integers" (Pythons built-in help).</li><li><span class="tx_code">filter</span> wendet ein Prädikat auf eine Sequenz an und gibt die Elemente zurück, für die das Prädikat gilt. <br></li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/5/2/9/8/0/TN_189589696_4888d36cec.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Eine Sequenz ist ein Begriff in Python, der für etwas steht, über das iteriert werden kann. Dies kann eine Liste (<span class="tx_code">[1, 2, 3</span>]), ein Tupel (<span class="tx_code">(1, 2, 3)</span>) oder ein String (<span class="tx_code">"123"</span>) sein. Anstelle einer Liste kommt in diesem Artikel ein <span class="tx_code">std::vector</span> in C++ zum Einsatz. Die Funktion <span class="tx_code">filter</span> steht für die funktionale Ader in Python. <br></div>
<div class="text">Bevor ich beginne, möchte ich noch ein paar Bemerkungen loswerden:</div>
<div class="text"><ol><li> Ich verwende in meinen Beispielen Eric Niebers range-v3-Bibliothek, die die Basis für die C++20-Ranges-Bibliothek ist. Im vorherigen Artikel "<a href="https://heise.de/-4661566" title="Link auf https://heise.de/-4661566" alt="%7B%22text%22%3A%22C%2B%2B20%3A%20Die%20Ranges-Bibliothek%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4661566%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4661566%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%7D" class="">C++20: Die Ranges-Bibliothek</a>" habe ich gezeigt, wie sich das Beispiel in C++20 übersetzen lässt.</li><li>Der Python-Code ist oft kürzer als das C++-Pendant. Dafür gibt es zwei einfache Gründe: Ich speichere die Listen in Python in keiner Variable ab und gebe sie nicht aus.</li><li>Ich möchte keinen Glaubenskrieg zu Programmiersprachen starten. Daher werde ich auf entsprechende Kommentare nicht reagieren.<br></li></ol></div>
<div class="text">Jetzt geht es aber los mit der <span class="tx_code">range</span>-Funktion. Sie ist das "Schweizer Taschenmesser" in Python für das Erzeugen ganzer Zahlen. <br></div>
<div class="ztitel">range<br></div>
<div class="text">Das folgende Beispiel zeige erst das Python-Beispiel in auskommentierter Form und anschließend das C++ Pendant: </div>
<div class="pre">// range.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;range/v3/all.hpp&gt;<br>#include &lt;vector&gt;<br><br>std::vector&lt;int&gt; range(int begin, int end, int stepsize = 1) {<br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; result{};<br>&nbsp;&nbsp;&nbsp; if (begin &lt; end) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto boundary = [end](int i){ return i &lt; end; };<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i: ranges::views::iota(begin) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::stride(stepsize) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::take_while(boundary)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.push_back(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stepsize *= -1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto boundary = [begin](int i){ return i &lt; begin; };<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i: ranges::views::iota(end) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::take_while(boundary) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::reverse <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::stride(stepsize)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.push_back(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return result;<br>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; // range(1, 50)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; auto res = range(1, 50);<br>&nbsp;&nbsp;&nbsp; for (auto i: res) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; // range(1, 50, 5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; res = range(1, 50, 5);<br>&nbsp;&nbsp;&nbsp; for (auto i: res) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; // range(50, 10, -1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; res = range(50, 10, -1);<br>&nbsp;&nbsp;&nbsp; for (auto i: res) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; // range(50, 10, -5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; res = range(50, 10, -5);<br>&nbsp;&nbsp;&nbsp; for (auto i: res) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Die Zeilen (1) bis (4) sollten einfach zu lesen sein, wenn du ihre Ausgabe betrachtest:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/5/2/9/8/0/TN_189589701_ef3f3065ef.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die ersten zwei Argumente für den <span class="tx_code">range</span>-Aufruf stehen für den Anfang und das Ende der zu erzeugenden Integrale. Dabei ist der Anfang inklusiv und das Ende exklusiv. Die Schrittweite ist das dritte Argument, das per default 1 ist. Wenn der Intervall <span class="tx_code">[begin, end] </span>absteigend ist, sollte die Schrittweite negativ sein. Falls nicht, erhältst du eine leere Liste oder einen leeren <span class="tx_code">std::vector&lt;int&gt;</span>.</div>
<div class="text">Ich habe in meinem Beispiel ein wenig geschummelt. Die Funktion <span class="tx_code">ranges::views::stride(n)</span>, die nicht Bestandteil von C++20 ist, gibt das n-te Element eines Ranges zurück. Schreibe mir, wenn du eine elegante Implementierung basierend auf C++20 kennst.</div>
<div class="text">Die<span class="tx_code"> if</span>-Bedingung (<span class="tx_code">begin &lt; end</span>) der <span class="tx_code">range</span>-Funktion in Zeile (1) sollte einfach zu verdauen sein. Erzeuge alle Integrale, die mit <span class="tx_code">begin</span> starten (<span class="tx_code">ranges::views::iota(begin)</span>), entnehme jedes n-te Element (<span class="tx_code">ranges::views::stride(stepsize)</span>) und fahre so lange fort, bis die Stopp-Bedingung eintritt (<span class="tx_code">ranges::views::take_while(boundary)</span>). Schiebe die Elemente zum Abschluss auf den <span class="tx_code">std::vector&lt;int&gt;</span>.</div>
<div class="text">Im <span class="tx_code">else</span>-Fall (Zeile 2) musste ich einen Trick anwenden. Der Algorithmus erzeugt die Integrale <span class="tx_code">[end++, begin++]</span>, schreitet voran, bis die Stopp-Bedingung erreicht ist, kehrt ihre Reihenfolge um (<span class="tx_code">ranges::views::reverse</span>) und entnimmt jedes n-te Element. </div>
<div class="text">Das Beipiel verwendet die gierige Version von <span class="tx_code">filter</span> und <span class="tx_code">map</span> (dazu mehr im nächsten Artikel). Mit Python 3 wird <span class="tx_code">filter</span> und <span class="tx_code">map</span> lazy. <span class="tx_code">map</span> und <span class="tx_code">lazy</span> geben in diesem Fall nur Generatoren zurück. Um das gierige Verhalten von Python 2 zu erzwingen, muss in Python 3 daher ein <span class="tx_code">list</span>-Aufruf um die <span class="tx_code">filter</span>- und <span class="tx_code">map</span>-Aufrufe gesetzt werden. <br></div>
<div class="pre">filter(lambda i: (i % 2) == 1 , range(1, 10))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Python 2&nbsp;&nbsp; <br><br>list(filter(lambda i: (i % 2) == 1&nbsp;, range(1, 10))) # Python 3</div>
<div class="text">Beide Aufrufe erzeugen dieselbe Liste: <span class="tx_code">[1, 3, 5, 9]</span>.</div>
<div class="text">Nun geht es mit der Funktion <span class="tx_code">filter</span> weiter, da sie einfacher als die Funktion <span class="tx_code">map</span> zu implementieren ist.</div>
<div class="ztitel">filter</div>
<div class="pre">// filter.cpp<br><br>#include "range.hpp"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>#include &lt;fstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;range/v3/all.hpp&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;utility&gt;<br><br>template &lt;typename Func, typename Seq&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>auto filter(Func func, Seq seq) {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; typedef typename Seq::value_type value_type;<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;value_type&gt; result{};<br>&nbsp;&nbsp;&nbsp; for (auto i : seq | ranges::views::filter(func)) result.push_back(i);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; return result;<br>}<br><br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; // filter(lambda i: (i % 3) == 0 , range(20, 50))&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; auto res = filter([](int i){ return (i % 3) == 0; }, range(20, 50) );<br>&nbsp;&nbsp;&nbsp; for (auto v: res) std::cout &lt;&lt; v &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4) <br>&nbsp;&nbsp;&nbsp; // filter(lambda word: word[0].isupper(), ["Only", "for", "testing", "purpose"]) <br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; myStrings{"Only", "for", "testing", "purpose"};<br>&nbsp;&nbsp;&nbsp; auto res2 = filter([](const std::string&amp; s){ return static_cast&lt;bool&gt;(std::isupper(s[0])); }, myStrings);<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (auto word: res2) std::cout &lt;&lt; word &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; // len(filter(lambda line: line[0] == "#", open("/etc/services").readlines()))<br>&nbsp;&nbsp;&nbsp; std::ifstream file("/etc/services", std::ios::in);<br>&nbsp;&nbsp;&nbsp; std::vector lines;<br>&nbsp;&nbsp;&nbsp; std::string line;<br>&nbsp;&nbsp;&nbsp; while(std::getline(file, line)){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lines.push_back(line);<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; commentLines = filter([](const std::string&amp; s){&nbsp; return s[0] == '#'; }, lines);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Comment lines: " &lt;&lt; commentLines.size() &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Bevor ich das Programm erläutere, möchte ich seine Ausgabe vorstellen:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/5/2/9/8/0/TN_189589710_b803b99369.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;">&nbsp;</div>
<div class="text">In diesem Beispiel wird die <span class="tx_code">range</span>-Implementierung nur inkludiert (Zeile 1). Die <span class="tx_code">filter</span>-Funktion in Zeile 2 sollte einfach zu lesen sein. Sie wendet lediglich die aufrufbare Einheit <span class="tx_code">func</span> auf jedes Element der Sequenz an und materialisiert sie in dem <span class="tx_code">std::vector</span>. Die Zeile 3 erzeugt alle Zahlen von 20 bis 50, für die <span class="tx_code">(i % 3) == 0 </span>gilt. Nur die Strings, die mit einem Großbuchstaben beginnen, überwinden den Filter in Zeile (4). Die Zeile (5) zählt, wie viele Zeilen in der Datei <span class="tx_code">"/etc/services"</span> Kommentare sind. Kommentare sind Zeilen, die mit "'#" beginnen.</div>
<div class="text">Wenn du die verschiedenen Arten, Lambdas in Python und C++ zu erzeugen, ignorierst, sind die <span class="tx_code">filter</span> Aufrufe sehr ähnlich.</div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text"><span class="tx_code">map</span> war deutlich schwieriger, als <span class="tx_code">filter</span> in C++ zu implementieren. Einerseits kann <span class="tx_code">map</span> den Typ der Inputsequenz ändern. Andererseits verursachte meine <span class="tx_code">map</span>-Implemtierung einen GCC-Bugreport. Danach kombiniere ich die Funktionen <span class="tx_code">map</span> und <span class="tx_code">filter</span> in einer Funktion und erhalte ... . Die Details gibt es in meinem nächsten Artikel.<br></div>
