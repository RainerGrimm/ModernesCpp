<div class="vorspann">In meinem letzten Artikel <a href="https://heise.de/-4661566" class="" alt="%7B%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4661566%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22C%2B%2B20%3A%20Die%20Ranges-Bibliothek%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4661566%22%2C%22anchor%22%3A%22%22%7D" title="Link auf https://heise.de/-4661566">C++20: Die Ranges-Bibliothek</a> habe ich den ersten Einblick in die Ranges-Bibliothek gegeben. Heute geht es um die funktionale Pattern Funktionskomposition und Bedarfsauswertung. Beide werden Bürger erster Klasse in C++20.</div>
<div class="text">Die Algorithmen der Standard Template Library (STL) sind manchmal etwas umständlich zu verwenden. Sie benötigen Begin- und End-Iteratoren, was oft unnötigen Schreibaufwand bedeutet:<br></div>
<div class="pre">#include &lt;numeric&gt;<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; myVec{1, 2, 3, 4, 5, 6, 7, 8, 9};<br>&nbsp;&nbsp;&nbsp; auto res = std::accumulate(std::begin(myVec), std::end(myVec), 0); <br>&nbsp;&nbsp;&nbsp; // std::accumulate(myVec, 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; res &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 45 <br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Wäre es nicht angenehm, wenn der Algorithmus <span class="tx_code">std::accumulate</span> direkt auf dem Container wie in Zeile (1) ausgeführt werden könnte? <br></div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/4/7/7/8/7/TN_189025337_3ec0217525.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Direkt auf dem Container<br></div>
<div class="text">Das folgende Programm erzeugt direkte Views auf den Schlüsseln (Zeile 1) und Werten (Zeile 2) einer <span class="tx_code">std::unordered_map</span>:<br></div>
<div class="pre">// rangesEntireContainer.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;ranges&gt;<br>#include &lt;string&gt;<br>#include &lt;unordered_map&gt;<br><br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, int&gt; freqWord{ {"witch", 25}, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"wizard", 33}, {"tale", 45}, {"dog", 4}, {"cat", 34}, {"fish", 23} };<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Keys" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; auto names = std::views::keys(freqWord);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; name : names){ std::cout &lt;&lt; name &lt;&lt; " "; };<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; name : std::views::keys(freqWord)){ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; name &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Values: " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; auto values = std::views::values(freqWord);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; value : values){ std::cout &lt;&lt; value &lt;&lt; " "; };<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; value : std::views::values(freqWord)){ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; value &lt;&lt; " "; <br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Natürlich lassen sich die Schlüssel und Werte auch direkt ausgeben (Zeilen 2 und 4). Die Ausgabe ist identisch:<br></div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/4/7/7/8/7/TN_189025344_1d2e4a92d3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das direkte Arbeiten auf dem Container ist keine Revolution in C++, Funktionskomposition und Bedarfsauswertung aber sehr wohl.</div>
<div class="ztitel">Funktionskomposition</div>
<div class="text">Im nächsten Beispiel kommt die <span class="tx_code">std::map</span> zum Einsatz, den die Ordnung der Schlüssel ist in diesem Fall entscheidend:<br></div>
<div class="pre"><span class="tx_code">// rangesComposition.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;ranges&gt;<br>#include &lt;string&gt;<br>#include &lt;map&gt;<br><br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::map&lt;std::string, int&gt; freqWord{ {"witch", 25}, {"wizard", 33}, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"tale", 45}, {"dog", 4}, {"cat", 34}, {"fish", 23} };<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "All words: ";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; name : std::views::keys(freqWord)) { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; name &lt;&lt; " "; <br>&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "All words reverse: ";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; name : std::views::keys(freqWord) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | std::views::reverse) { std::cout &lt;&lt; name &lt;&lt; " "; }; &nbsp;<br>&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "The first 4 words: ";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; name : std::views::keys(freqWord) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | std::views::take(4)) { std::cout &lt;&lt; name &lt;&lt; " "; }; <br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "All words starting with w: ";&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; auto firstw = [](const std::string&amp; name){ return name[0] == 'w'; };<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; name : std::views::keys(freqWord) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | std::views::filter(firstw)) { std::cout &lt;&lt; name &lt;&lt; " "; };<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; auto lengthOf = [](const std::string&amp; name){ return name.size(); };<br>&nbsp;&nbsp;&nbsp; auto res = ranges::accumulate(std::views::keys(freqWord) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | std::views::transform(lengthOf), 0);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Sum of words: " &lt;&lt; res &lt;&lt; std::endl;<br>&nbsp; &nbsp;<br>}</span></div>
<div class="text">Jetzt interessieren mich nur die Schlüssel. Das Programm stellt alle Schlüssel in Zeile (1) dar, sie dann in Zeile (2) umgekehrt sortiert und darauf in Zeile (3) die ersten vier und in Zeile (4) nur die Schlüssel, die mit '<span class="tx_code">w</span>' beginnen. Zum Abschluss berechnet Zeile (5) die Summer aller Wortlängen. </div>
<div class="text">Das Pipe Symbol | ist <a href="https://en.wikipedia.org/wiki/Syntactic_sugar" title="Link auf https://en.wikipedia.org/wiki/Syntactic_sugar" alt="%7B%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSyntactic_sugar%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Syntactic%20Sugar%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSyntactic_sugar%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%7D" class="">Syntactic Sugar</a> für die Funktionskomposition. Damit lässt sich <span class="tx_code">C(R)</span> einfacher als <span class="tx_code">R | C</span> schreiben. Konsequenterweise sind die nächsten zwei Zeilen äquivalent:</div>
<div class="pre"><span class="tx_code">auto rev2 = std::views::reverse(ranges::views::keys(freqWord));<br>auto rev = std::views::keys(freqWord) | ranges::views::reverse;</span></div>
<div class="text">Zum Abschluss ist hier die Ausgabe des Programms:<span class="tx_code"><br></span></div>
<div class="ztitel"><span class="tx_code"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/4/7/7/8/7/TN_189025349_32c8619632.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></span></div>
<div class="ztitel">Bedarfsauswertung (Lazy Evaluation)</div>
<div class="text">In meinem Beispiel kommt <span class="tx_code">std::views::iota</span> zum Einsatz. Diese Funktion ist eine Zahlenfabrik, die eine Sequenz von Zahlen erzeugt, in dem ein initialer Wert sukzessiv inkrementiert wird. Diese Sequenz kann endlich oder unendlich sein. Das folgende Beispiel füllt einen <span class="tx_code">std::vecto</span><span class="tx_code">r</span> mit 10 <span class="tx_code">int</span>s, die bei 0 starten: </div>
<div class="pre">// rangesIota.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;numeric&gt;<br>#include &lt;ranges&gt;<br>#include &lt;vector&gt;<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; vec;<br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; vec2;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (int i: std::views::iota(0, 10)) vec.push_back(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (int i: std::views::iota(0) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | std::views::take(10)) vec2.push_back(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "vec == vec2: " &lt;&lt; (vec == vec2) &lt;&lt; '\n'; // true<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (int i: vec) std::cout &lt;&lt; i &lt;&lt; " ";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 0 1 2 3 4 5 6 7 8 9<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Der erste <span class="tx_code">iota</span>-Aufruf (Zeile 1) erzeugt alle Zahlen von 0 bis 9 durch sukzessives Inkrementieren um 1. Der zweite <span class="tx_code">iota</span>-Aufruf (Zeile 2) generiert einen unendlichen Datenstrom, der mit 0 startet und die nächste um 1 inkrementierte Zahl zurückgibt. <span class="tx_code">std::views::iota(0)</span> ist lazy. Der Ausdruck gibt nur den nächsten Wert zurück, wenn ich danach frage. Genau zehnmal frage ich danach. Damit sind beide Vektoren identisch.</div>
<div class="text">Jetzt möchte ich mir eine kleine Herausforderung stellen. Ich möchte die ersten 20 Primzahlen finden, die bei 1.000.000 beginnen: <br></div>
<div class="pre">// rangesLazy.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;ranges&gt;<br><br><br>bool isPrime(int i) {<br>&nbsp;&nbsp;&nbsp; for (int j=2; j*j &lt;= i; ++j){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i % j == 0) return false;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return true;<br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Numbers from 1000000 to 1001000 (dispayed each 100th): " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; for (int i: std::views::iota(1000000, 1001000)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i % 100 == 0) std::cout &lt;&lt; i &lt;&lt; " ";&nbsp; <br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; auto odd = [](int i){ return i % 2 == 1; };<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Odd numbers from 1000000 to 1001000 (displayed each 100th): " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; for (int i: std::views::iota(1000000, 1001000) | std::views::filter(odd)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i % 100 == 1) std::cout &lt;&lt; i &lt;&lt; " ";&nbsp; <br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Prime numbers from 1000000 to 1001000: " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; for (int i: std::views::iota(1000000, 1001000) | std::views::filter(odd) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | std::views::filter(isPrime)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; i &lt;&lt; " ";&nbsp; <br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "20 prime numbers starting with 1000000: " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; for (int i: std::views::iota(1000000) | std::views::filter(odd) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | std::views::filter(isPrime) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | std::views::take(20)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; i &lt;&lt; " ";&nbsp; <br>&nbsp;&nbsp;&nbsp; }<br><br>}</div>
<div class="text">Dies ist meine schrittweise Strategie:</div>
<div class="text"><ol><li> Natürlich weiß ich nicht, wann ich die 20 Primzahlen erhalte werde, die größter als 1.000.000 sind. Um sicherzugehen, erzeugt ich 1000 Zahlen. Aus offensichtlichen Gründen stelle ich nur jede 100te Zahl dar.</li><li>Die gewünschten Zahlen müssen natürlich ungerade sein. Daher entferne ich die geraden Zahlen.</li><li>Jetzt ist es Zeit für den nächsten Filter. Das Prädikat <span class="tx_code">isPrime</span> gibt zurück, ob die Zahl eine Primzahl ist. Wie im folgenden Screenshot zu sehen ist, war ich zu gierig. Ich habe 75 Primzahlen erhalten.</li><li>Faulheit ist eine Tugend. Ich wende nun <span class="tx_code">std::iota</span> als unendlichen Zahlengenerator an, der bei 1.000.000 startet und frage ihn direkt nach 20 Primzahlen.</li></ol></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/4/7/7/8/7/TN_189025356_3191f42783.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Ich werde ein Experiment in meinem nächsten Artikel wagen. Python besitzt sehr viele praktische Funktionen wie <span class="tx_code">range</span>, <span class="tx_code">map</span>, <span class="tx_code">filter</span>, reduce und <span class="tx_code">zip</span>. Natürlich muss ich noch List Comprehension und den Slice Operator erwähnen. All diese Funktion sind eager in Python 2; <span class="tx_code">map</span>, <span class="tx_code">filter</span> und <span class="tx_code">reduce</span> sind hingegen lazy in Python 3. Welche der Funktionen kann ich mit ähnlicher Funktionalität in C++ anwenden, indem ich die Ranges-Bibliothek verwende?<br></div>