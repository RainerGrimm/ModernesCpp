<div class="vorspann">Häufig müssen Threads synchronisiert werden. Das typische Szenario ist, dass ein Thread ein Arbeitspaket vorbereitet, auf das ein anderer Thread wartet. </div>
<div class="text">Ich nehme an, die meisten Anwender verwenden Bedingungsvariablen für einen Sender/Empfänger- oder Producer/Consumer-Arbeitsablauf. Bedingungsvariablen besitzen viele implizite Gefahren wie <i>Spurious Wakeups</i> oder<i> Lost Wakeups</i>. Bevor ich daher die Thread-Synchronisation mit Coroutinen umsetzen will, möchte ich einen vorherigen Artikel, der die inhärenten Herausforderungen von Bedingungsvariablen beschreibt, kurz ins Gedächtnis zurückrufen. </div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/7/8/0/0/3/TN_191942045_5f129d56f9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Die Herausforderungen von Bedingungsvariablen</div>
<div class="text">Zuerst einmal der richtige Einsatz von Bedingungsvariablen:<br></div>
<div class="pre">// conditionVariables.cpp<br><br>#include &lt;condition_variable&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>std::mutex mutex_;<br>std::condition_variable condVar; <br><br>bool dataReady{false};<br><br>void waitingForWork(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Waiting " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp; condVar.wait(lck, []{ return dataReady; });&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Running " &lt;&lt; std::endl;<br>}<br><br>void setDataReady(){<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataReady = true;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Data prepared" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; condVar.notify_one();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; std::thread t1(waitingForWork);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; std::thread t2(setDataReady);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp; t1.join();<br>&nbsp; t2.join();<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>}<br></div>
<div class="text">Wie funktioniert die Synchronisation? Das Programm besitzt zwei Kinder-Threads:&nbsp;<span class="tx_code">t1</span>&nbsp;und&nbsp;<span class="tx_code">t2</span>. Diese erhalten ihr Arbeitspaket&nbsp;<span class="tx_code">waitingForWork</span>&nbsp;und&nbsp;<span class="tx_code">setDataReady</span>&nbsp;in den Zeilen (1) und (2).&nbsp;<span class="tx_code">setDataReady</span>&nbsp;sendet seine Nachricht, dass er mit der Vorbereitung der Arbeit fertig ist, mithilfe der Bedingungsvariable&nbsp;<span class="tx_code">condVar</span>: <span class="tx_code">condVar.notify_one()</span> (Zeile 3). Während der Thread&nbsp;<span class="tx_code">t1</span>&nbsp;den Lock besitzt, wartet er auf seine Benachrichtigung:&nbsp;<span class="tx_code">condVar.wait(lck,[] return dataReady;</span>) (Zeile 4). Sowohl der Sender als auch der Empfänger der Nachricht benötigen einen Lock. Im Falle des Senders ist ein einfacher&nbsp;<span class="tx_code">std::lock_guard&nbsp;</span>ausreichend, da er einen Mutex nur ein einziges Mal "lockt" und wieder freigibt. Der Empfänger benötigt hingegen ein&nbsp;<span class="tx_code">std::unique_lock</span>, da er gegebenenfalls einen Mutex mehrmals "locken" und wieder freigeben muss.</div>
<div class="text">Das Programm besitzt die erwartete Ausgabe:<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/7/8/0/0/3/TN_191942047_a8598713f1.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Vermutlich wunderst du dich: Warum benötigt der&nbsp;<span class="tx_code">wait</span>-Aufruf ein Prädikat, denn es sich auch ohne dieses verwenden lässt? Dieser Ablauf wirkt viel zu kompliziert für eine solch einfache Aufgabe wie die Synchronisation von Threads.</div>
<div class="text">Jetzt komme ich auf das fehlende Gedächtnis von Bedingungsvariablen und die zwei Phänomene Lost Wakeup und Spurious Wakeup zurück.</div>
<div class="text"><ul><li><b>Lost Wakeup</b>: Der Sender verschickt seine Benachrichtigung, bevor der Empfänger im Wartezustand ist. Als Konsequenz geht die Benachrichtigung verloren. <br></li><li><b>Spurious Wakeup</b>: Der Empfänger der Nachricht wacht auf, obwohl der Sender keine Benachrichtigung geschickt hat. <br></li></ul></div>
<div class="text">Als Schutz gegen diese beiden Phänomene benötigt der Empfänger ein zusätzliches Prädikat als Gedächtnis, das er prüft. Damit beginnt die Komplexität. Falls du kein Prädikat in diesem Fall einsetzt, besteht eine 50/50-Wahrscheinlichkeit für ein Lost Wakeup. Dieses verursacht vereinfachend gesagt ein Deadlock, da ein Thread auf ein Ereignis wartet, das nicht eintritt.</div>
<div class="text">Das ist nicht die letzte Falle, die bei der Verwendung von Bedingungsvariablen lauert. Die Details dazu gibt es in dem früheren Artikel: "<a href="https://heise.de/-4063822" title="Link auf https://heise.de/-4063822" class="" alt="%7B%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4063822%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Sei%20dir%20der%20Fallen%20von%20Bedingungsvariablen%20bewusst%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4063822%22%2C%22version%22%3A1%7D">C++ Core Guidelines: Sei dir der Fallen von Bedingungsvariablen bewusst</a>". </div>
<div class="text">Dank Coroutinen ist die Synchronisation von Threads deutlich einfacher. Darüber hinaus lauern keine Fallen wie <i>Spurious Wakeups</i> oder <i>Lost Wakeups</i>.</div>
<div class="ztitel">Thread-Synchronisation mit co_await</div>
<div class="pre"><span class="tx_code">// senderReceiver.cpp<br><br>#include &lt;coroutine&gt;<br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br>#include &lt;functional&gt;<br>#include &lt;string&gt;<br>#include &lt;stdexcept&gt;<br>#include &lt;atomic&gt;<br>#include &lt;thread&gt;<br><br>class Event {<br>&nbsp;public:<br><br>&nbsp;&nbsp;&nbsp; Event() = default;<br><br>&nbsp;&nbsp;&nbsp; Event(const Event&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; Event(Event&amp;&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; Event&amp; operator=(const Event&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; Event&amp; operator=(Event&amp;&amp;) = delete;<br><br>&nbsp;&nbsp;&nbsp; class Awaiter;<br>&nbsp;&nbsp;&nbsp; Awaiter operator co_await() const noexcept;<br><br>&nbsp;&nbsp;&nbsp; void notify() noexcept;<br><br>&nbsp;private:<br><br>&nbsp;&nbsp;&nbsp; friend class Awaiter;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; mutable std::atomic&lt;void*&gt; suspendedWaiter{nullptr};<br>&nbsp;&nbsp;&nbsp; mutable std::atomic&lt;bool&gt; notified{false};<br><br>};<br><br>class Event::Awaiter {<br>&nbsp;public:<br>&nbsp; Awaiter(const Event&amp; eve): event(eve) {}<br><br>&nbsp; bool await_ready() const;<br>&nbsp; bool await_suspend(std::coroutine_handle&lt;&gt; corHandle) noexcept;<br>&nbsp; void await_resume() noexcept {}<br><br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; friend class Event;<br><br>&nbsp;&nbsp;&nbsp; const Event&amp; event;<br>&nbsp;&nbsp;&nbsp; std::coroutine_handle&lt;&gt; coroutineHandle;<br>};<br><br>bool Event::Awaiter::await_ready() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; // allow at most one waiter<br>&nbsp;&nbsp;&nbsp; if (event.suspendedWaiter.load() != nullptr){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw std::runtime_error("More than one waiter is not valid");<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; // event.notified == false; suspends the coroutine<br>&nbsp;&nbsp;&nbsp; // event.notified == true; the coroutine is executed such as a usual function<br>&nbsp;&nbsp;&nbsp; return event.notified;<br>}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (8)<br>bool Event::Awaiter::await_suspend(std::coroutine_handle&lt;&gt; corHandle) noexcept {<br><br>&nbsp;&nbsp;&nbsp; coroutineHandle = corHandle;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; <br>&nbsp;&nbsp;&nbsp; if (event.notified) return false;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; // store the waiter for later notification<br>&nbsp;&nbsp;&nbsp; event.suspendedWaiter.store(this);<br><br>&nbsp;&nbsp;&nbsp; return true;<br>}<br><br>void Event::notify() noexcept {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp; notified = true;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; // try to load the waiter<br>&nbsp;&nbsp;&nbsp; auto* waiter = static_cast&lt;Awaiter*&gt;(suspendedWaiter.load());<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; // check if a waiter is available<br>&nbsp;&nbsp;&nbsp; if (waiter != nullptr) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // resume the coroutine =&gt; await_resume<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; waiter-&gt;coroutineHandle.resume();<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>Event::Awaiter Event::operator co_await() const noexcept {<br>&nbsp;&nbsp;&nbsp; return Awaiter{ *this };<br>}<br><br>struct Task {<br>&nbsp;&nbsp;&nbsp; struct promise_type {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task get_return_object() { return {}; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_never initial_suspend() { return {}; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_never final_suspend() { return {}; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void return_void() {}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void unhandled_exception() {}<br>&nbsp;&nbsp;&nbsp; };<br>};<br><br>Task receiver(Event&amp; event) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; auto start = std::chrono::high_resolution_clock::now();<br>&nbsp;&nbsp;&nbsp; co_await event;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Got the notification! " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; auto end = std::chrono::high_resolution_clock::now();<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; elapsed = end - start;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Waited " &lt;&lt; elapsed.count() &lt;&lt; " seconds." &lt;&lt; std::endl;<br>}<br><br>using namespace std::chrono_literals;<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Notification before waiting" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; Event event1{};<br>&nbsp;&nbsp;&nbsp; auto senderThread1 = std::thread([&amp;event1]{ event1.notify(); });// (1)<br>&nbsp;&nbsp;&nbsp; auto receiverThread1 = std::thread(receiver, std::ref(event1)); // (4)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; receiverThread1.join();<br>&nbsp;&nbsp;&nbsp; senderThread1.join();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Notification after 2 seconds waiting" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; Event event2{};<br>&nbsp;&nbsp;&nbsp; auto receiverThread2 = std::thread(receiver, std::ref(event2));// (5)<br>&nbsp;&nbsp;&nbsp; auto senderThread2 = std::thread([&amp;event2]{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(2s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event2.notify();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; receiverThread2.join();<br>&nbsp;&nbsp;&nbsp; senderThread2.join();<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</span></div>
<div class="text">Thread-Synchronisation mit Coroutinen geht aus der Anwendersicht leicht von der Hand. Die Threads <span class="tx_code">senderThread1</span> (Zeile 1) und <span class="tx_code">senderThread2</span> (Zeile 2) verwenden Objekte vom Datentyp <span class="tx_code">Event</span>, um ihre Benachrichtigungen zu verschicken. Die Funktion <span class="tx_code">receiver</span> in Zeile (3) ist die Coroutine, die in dem Thread <span class="tx_code">receiverThread1</span> (Zeile 4) und <span class="tx_code">receiverThread2</span> (Zeile 5) zum Einsatz kommt. Ich habe die Zeit zwischen dem Beginn und dem Ende der Coroutine gemessen und ausgegeben. Die Zahl zeigt schön, wie lange die Coroutine warten muss. Der folgende Screenshot stellt die Ausgabe des Programms mit dem Online-Compiler <a title="Link auf https://wandbox.org/permlink/qClEIVff0OXp51Av" href="https://wandbox.org/permlink/qClEIVff0OXp51Av" class="" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwandbox.org%2Fpermlink%2FqClEIVff0OXp51Av%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwandbox.org%2Fpermlink%2FqClEIVff0OXp51Av%22%2C%22text%22%3A%22Wandbox%22%2C%22target%22%3A%22_blank%22%7D">Wandbox</a> vor. Der <a title="Link auf https://godbolt.org/" href="https://godbolt.org/" class="" alt="%7B%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Compiler%20Explorer%22%7D">Compiler Explorer</a> erlaubt noch nicht das Erzeugen von Threads, sein Entwickler ist aber gerade dran. &nbsp; </div>
<div class="text"><span class="tx_code"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/7/8/0/0/3/TN_191942052_9e19925ba5.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></span></div>
<div class="text">Die Ausführung der zweiten Coroutine benötigt im Gegensatz zur ersten zwei Sekunden. Der Grund ist, dass <span class="tx_code">event1</span> seine Benachrichtigung verschickt (Zeile 1), bevor die Coroutine wartet. Hingegen verschickt <span class="tx_code">event2</span> seine Benachrichtigungen, nachdem die zweite Coroutine bereits zwei Sekunden gewartet hat.</div>
<div class="text">Nun werde ich den Arbeitsablauf des Coroutinen-Frameworks aus der Sicht der Implementierung vereinfacht darstellen. </div>
<div class="ztitel_kleiner">Der vereinfachte Arbeitsablauf<br></div>
<div class="text">Wenn du die Klasse <span class="tx_code">Generator</span> im letzten Artikel "<a alt="%7B%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4697142%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4697142%22%2C%22text%22%3A%22C%2B%2B20%3A%20Ein%20unendlicher%20Datenstrom%20mit%20Coroutinen%22%2C%22target%22%3A%22_blank%22%7D" class="" title="Link auf https://heise.de/-4697142" href="https://heise.de/-4697142">C++20: Ein unendlicher Datenstrom mit Coroutinen</a>" mit der Klasse <span class="tx_code">Event</span> in diesem Beispiel vergleichst, fällt dir eventuell ein feiner Unterschied auf. Im ersten Fall ist der Generator der "Awaitable" und der "Awaiter"; im zweiten Fall verwendet <span class="tx_code">Event</span> den Operator <span class="tx_code">co_await</span>, um den "Awaiter" zurückzugeben. Diese Trennung der Zuständigkeiten verbessert die Struktur des Codes.</div>
<div class="text">In meiner Erklärung der beiden Abläufe nehme ich an, dass im ersten Fall die Benachrichtigung stattfindet, bevor die Coroutine auf diese wartet. Für den zweiten Fall nehme ich das Gegenteil an. </div>
<div class="text">Zuerst beschäftige ich mich mit <span class="tx_code">event1</span> und dem ersten Arbeitsablauf. <span class="tx_code">event1</span> schickt seine Benachrichtigung, bevor der <span class="tx_code">receiverThread1</span> startet. Der Aufruf <span class="tx_code">event1</span> (line 1) stößt die Methode <span class="tx_code">notify</span> (Zeile 6) an. Zuerst wird das Benachrichtigungs-Flag <span class="tx_code">flag</span> gesetzt und dann lädt der Aufruf <span class="tx_code">auto* waiter = static_cast&lt;awaiter*&gt;(suspendedWaiter.load());</span> den möglichen Warter. In diesem Fall ist dieser ein <span class="tx_code">nullptr</span>, da er davor noch nicht gesetzt wurde. Das bedeutet, dass der folgende <span class="tx_code">resume</span>-Aufruf nicht ausgeführt wird. Die darauffolgend ausgeführte Funktion <span class="tx_code">await_ready</span> (Zeile 7) prüft, ob es mehr als einen Warter gibt. Der Einfachheit halber löse ich eine <span class="tx_code">std::runtime</span>-Ausnahme aus. Der entscheidende Punkt der Methode ist ihr Rückgabewert. <span class="tx_code">event.notification</span> wurde in der <span class="tx_code">notify</span>-Methode bereits auf <span class="tx_code">true</span> gesetzt. <span class="tx_code">true</span> als Rückgabewert bedeutet für den Arbeitsablauf, dass die Coroutine nicht angehalten und entsprechend einer gewöhnlichen Funktion ausgeführt wird.</div>
<div class="text">Im zweiten Arbeitsablauf findet <span class="tx_code">co_await event2</span> statt, bevor <span class="tx_code">event2</span> seine Benachrichtigung verschickt. <span class="tx_code">co_wait event2</span> stößt den Aurfruf <span class="tx_code">await_ready</span> in Zeile (7) an. Der große Unterschied ist es, dass in diesem Fall <span class="tx_code">event.notified false</span> ist. Der <span class="tx_code">false</span>-Wert verursacht die Suspension der Coroutine. Damit wird die Methode <span class="tx_code">await_suspend</span> (Zeile 8) ausgeführt. <span class="tx_code">await_suspend</span> erhält den Verweis auf die Coroutine dank <span class="tx_code">corHandle</span> und speichert sie für ihre spätere Ausführung in der Variable <span class="tx_code">coroutineHandle</span>. Spätere Ausführung heißt natürlich die Wiederaufnahme der Ausführung. Darüber hinaus wird der Warter in der Variable <span class="tx_code">suspendedWaiter</span> gespeichert. Wenn somit später <span class="tx_code">event2.notify</span> seine Benachrichtigung schickt, wird die Methode <span class="tx_code">notify</span> (Zeile 6) ausgeführt. Der Unterschied zum ersten Arbeitsablauf ist es, dass die Bedingung <span class="tx_code">waiter != nullptr true</span> ergibt. Die Konsequenz ist, dass der Warter <span class="tx_code">coroutineHandle</span> verwendet, um die Ausführung der Coroutine fortzusetzen.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Wenn ich einen Schluss auf diesem und meinem letzten Artikel "<a class="" alt="%7B%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4697142%22%2C%22text%22%3A%22C%2B%2B20%3A%20Ein%20unendlicher%20Datenstrom%20mit%20Coroutinen%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4697142%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%7D" href="https://heise.de/-4697142" title="Link auf https://heise.de/-4697142">C++20: Ein unendlicher Datenstrom mit Coroutinen</a>" ziehen möchte, dann diesen: <b>Implementiere nicht deine eigenen Coroutinen.</b> Verwende existierende Coroutinen wie die, die Lewis Barker in der Bibliothek <a class="" alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Flewissbaker%2Fcppcoro%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22cppcoro%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Flewissbaker%2Fcppcoro%22%2C%22version%22%3A1%7D" href="https://github.com/lewissbaker/cppcoro" title="Link auf https://github.com/lewissbaker/cppcoro">cppcoro</a> zur Verfügung stellt. Genau diesen Ratschlag werde ich in meinem nächsten Artikel befolgen.</div>
<div class="ztitel">Vier Gutscheine für Educative zu gewinnen</div>
<div class="text">Auf meinem englischen Blog gibt es vier Gutscheine für Educative zu gewinnen: <a class="" alt="%7B%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fbit.ly%2FVoucherEducative%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22https%3A%2F%2Fbit.ly%2FVoucherEducative.%22%2C%22href%22%3A%22https%3A%2F%2Fbit.ly%2FVoucherEducative%22%2C%22version%22%3A1%7D" href="https://bit.ly/VoucherEducative" title="Link auf https://bit.ly/VoucherEducative">https://bit.ly/VoucherEducative.</a> Die Gutscheine erlauben es dir, ein Viertel Jahr auf alle Kurse von <a alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.educative.io%2F%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.educative.io%2F%22%2C%22text%22%3A%22educative.io%22%2C%22target%22%3A%22_blank%22%7D" class="" title="Link auf https://www.educative.io/" href="https://www.educative.io/">educative.io</a> zuzugreifen.<br></div>
