<div class="vorspann">In meinen Seminaren gibt es häufig die Diskussion: Wie kann ein einfaches Array an eine Funktion übergeben werden? Mit C++20 ist die Antwort ganz einfach: Verwende den Container <span class="tx_code">std::span</span>.</div>
<div class="text"><span class="tx_code">std::span</span>&nbsp;steht für ein Objekt, das sich auf eine zusammenhängende Sequenz von Objekten bezieht. Ein&nbsp;<span class="tx_code">std::span</span>, manchmal auch View genannt, ist niemals ein Besitzer. Der zusammenhängende Speicherbereich kann ein Array, ein Zeiger mit einer Länge, ein&nbsp;<span class="tx_code">std::vector</span> oder ein <span class="tx_code">std::string</span> sein. Eine typische Implementierung eines&nbsp;<span class="tx_code">std::span</span>&nbsp;benötigt einen Zeiger auf das erste Element der Sequenz und seine Länge. Der wichtigste Grund, weshalb <span class="tx_code">std::span</span>&nbsp;im C++20 Standards enthalten ist, ist der Tatsache geschuldet, dass ein C-Array zu einem Zeiger vereinfacht wird (<a class="" href="http://codeofthedamned.com/index.php/type-decay" alt="%7B%22destination%22%3A%22http%3A%2F%2Fcodeofthedamned.com%2Findex.php%2Ftype-decay%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22decay%22%2C%22href%22%3A%22http%3A%2F%2Fcodeofthedamned.com%2Findex.php%2Ftype-decay%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D" title="Link auf http://codeofthedamned.com/index.php/type-decay">decay</a>), wenn dieses an eine Funktion übergeben wird. Dieser <i>decay</i> ist eine typische Ursache für Fehler in C/C++.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/6/6/0/3/4/TN_199316597_5159d5c5ce.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Automatische Bestimmung der Länge der kontinuierlichen Sequenz von Objekten<br></div>
<div class="text"><span class="tx_code">std::span&lt;T&gt;</span> bestimmt automatisch die Länge eines C-Arrays, eines <span class="tx_code">std::vector</span> oder eines <span class="tx_code">std::array</span>. </div>
<div class="pre">// printSpan.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;array&gt;<br>#include &lt;span&gt;<br><br>void printMe(std::span&lt;int&gt; container) {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "container.size(): " &lt;&lt; container.size() &lt;&lt; '\n';&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; for(auto e : container) std::cout &lt;&lt; e &lt;&lt; ' ';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>}<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; int arr[]{1, 2, 3, 4};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; printMe(arr);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::vector vec{1, 2, 3, 4, 5};&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; printMe(vec);<br><br>&nbsp;&nbsp;&nbsp; std::array arr2{1, 2, 3, 4, 5, 6}; // (3)<br>&nbsp;&nbsp;&nbsp; printMe(arr2);<br>&nbsp;&nbsp; &nbsp;<br>}<br></div>
<div class="text">Das C-Array (1), der <span class="tx_code">std::vector</span>&nbsp;(2) und <span class="tx_code">std::array</span> (3) besitzen <span class="tx_code">int</span>s. Konsequenterweise erwartet <span class="tx_code">std::span</span> diese <span class="tx_code">int</span>s. Das kleine Beispiel verdeutlicht aber einen viel interessanteren Punkt. Für jeden Container kann <span class="tx_code">std::span</span> seine Länge bestimmen (4).</div>
<div class="text">Alle drei großen C++-Compiler MSVC, GCC und Clang unterstützen bereits <span class="tx_code">std::span</span>.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/6/6/0/3/4/TN_199316603_aa50c247dc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Es gibt mehrere Möglichkeiten, einen <span class="tx_code">std::span</span> zu erzeugen.</div>
<div class="ztitel">Ein<span class="tx_code"> std::span</span> mithilfe eines Zeigers und einer Länge erzeugen<br></div>
<div class="text">Ein <span class="tx_code">std::span</span> lässt sich auch mithilfe eines Zeigers und einer Länge erzeugen:<br></div>
<div class="pre">// createSpan.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;span&gt;<br>#include &lt;vector&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br><br>&nbsp;&nbsp;&nbsp; std::vector myVec{1, 2, 3, 4, 5};<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::span mySpan1{myVec};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::span mySpan2{myVec.data(), myVec.size()};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; bool spansEqual = std::equal(mySpan1.begin(), mySpan1.end(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySpan2.begin(), mySpan2.end());<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "mySpan1 == mySpan2: " &lt;&lt; spansEqual &lt;&lt; std::endl;&nbsp; // (3)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Wie erwartet, besitzen der von einem <span class="tx_code">std::vector</span> erzeugte <span class="tx_code">mySpan1</span> (1) und der von einem Zeiger und einer Länge erzeugte <span class="tx_code">mySpan2</span> (2) den gleichen Inhalt (3).</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/6/6/0/3/4/TN_199316613_95a2ddd6f0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Gerne wird <span class="tx_code">std::span</span> auch als View bezeichnet. Verwechsle nicht <span class="tx_code">std::span</span> mit einem View der <a title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/ranges-bibliothek" class="" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Ranges-Bibliothek%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Franges-bibliothek%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Franges-bibliothek%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%7D" href="https://www.grimm-jaud.de/index.php/blog/tag/ranges-bibliothek">Ranges-Bibliothek</a> (C++20) oder einem <span class="tx_code">std::string_view</span> (C++17).</div>
<div class="text">Eine View der Ranges-Bibliothek lässt sich auf einer Range anwenden. Dabei wird eine Operation ausgeführt. Views besitzen keine Daten. Konsequenterweise sind seine Copy-, Move- oder Zuweisungsoperationen konstant. Eric Niebler, Autor der<a title="Link auf https://github.com/ericniebler/range-v3" alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fericniebler%2Frange-v3%22%2C%22text%22%3A%22%26nbsp%3Branges-v3%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fericniebler%2Frange-v3%22%7D" href="https://github.com/ericniebler/range-v3" class="">&nbsp;ranges-v3</a>-Implementierung, die Grundlage für die Ranges-Bibliothek in C++20 ist, beschreibt Ranges mit folgenden Worten: "Views are composable adaptations of ranges where the adaptation happens lazily as the view is iterated." Hier sind alle meine Artikel, die sich mit der Ranges-Bibliothek beschäftigen: <a class="" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Franges-bibliothek%22%2C%22text%22%3A%22Kategorie%20Ranges-Bibliothek%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Franges-bibliothek%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%7D" href="https://www.grimm-jaud.de/index.php/blog/tag/ranges-bibliothek" title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/ranges-bibliothek">Kategorie Ranges-Bibliothek</a>.</div>
<div class="text">Ein View (<span class="tx_code">std::span</span>) und ein <span class="tx_code">std::string_view</span> sind nichtbesitzende Views und können mit Strings umgehen. Der entscheidende Unterschied zwischen einem <span class="tx_code">std::span</span> und einem <span class="tx_code">std::string_view</span> ist, dass ein <span class="tx_code">std::span</span> seine referenzierten Objekte verändern kann. Falls du mehr zu <span class="tx_code">std::string_view</span> lesen willst, hier sind meine älteren Artikel: <a class="" alt="%7B%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-17-was-gibts-neues-in-der-bibliothek%22%2C%22text%22%3A%22C%2B%2B17%3A%20Was%20gibts%20Neues%20in%20der%20Bibliothek%3F%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-17-was-gibts-neues-in-der-bibliothek%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%7D" href="https://www.grimm-jaud.de/index.php/blog/c-17-was-gibts-neues-in-der-bibliothek" title="Link auf https://www.grimm-jaud.de/index.php/blog/c-17-was-gibts-neues-in-der-bibliothek">C++17: Was gibts Neues in der Bibliothek?</a> und <a alt="%7B%22subject%22%3A%22%22%2C%22text%22%3A%22C%2B%2B17%3A%20Vermeide%20Kopieren%20mit%20std%3A%3Astring_view%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-17-vermeide-kopieren-mit-std-string-view%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-17-vermeide-kopieren-mit-std-string-view%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/c-17-vermeide-kopieren-mit-std-string-view" class="" title="Link auf https://www.grimm-jaud.de/index.php/blog/c-17-vermeide-kopieren-mit-std-string-view">C++17: Vermeide Kopieren mit std::string_view</a>.</div>
<div class="ztitel">Die Objekte verändern</div>
<div class="text">Sowohl der ganze<span class="tx_code"> std::span</span> als auch nur Teile von ihm lassen sich verändern. Wenn du den <span class="tx_code">std::span</span> modifizierst, hat das natürlich auch Ausweirkungen auf seine referenzierten Objekte.</div>
<div class="text">Das folgende Beispiel zeigt, wie sich mithilfe eines Teilbereichs (subspan) die referenzierten Objekte eines <span class="tx_code">std::vector </span>verändern lassen:<br></div>
<div class="pre">// spanTransform.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;span&gt;<br><br>void printMe(std::span&lt;int&gt; container) {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "container.size(): " &lt;&lt; container.size() &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; for(auto e : container) std::cout &lt;&lt; e &lt;&lt; ' ';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>}<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::vector vec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; printMe(vec);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::span span1(vec);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) <br>&nbsp;&nbsp;&nbsp; std::span span2{span1.subspan(1, span1.size() - 2)};&nbsp; // (2)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::transform(span2.begin(), span2.end(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; span2.begin(), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int i){ return i * i; });<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; printMe(vec);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text"><span class="tx_code">span1</span> referenziert den <span class="tx_code">std::vector vec</span> (1). Im Gegensatz dazu verweist <span class="tx_code">span2</span> auf die Elemente des zugrundeliegenden <span class="tx_code">vec</span> . Dabei ignoriert <span class="tx_code">span2</span> das erste und letzte Elements. Konsequenterweise adressiert die Abbildung jedes Elements auf sein Quadrat (2) nur diese Elemente.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/6/6/0/3/4/TN_199316620_7af353ef3a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Ein <span class="tx_code">std::span</span> enthält einige komfortable Funktionen, um auf seine Elemente zuzugreifen.</div>
<div class="ztitel">Zugriff auf die Elemente eines std::span </div>
<div class="text">Die Tabelle stellt kompakt die Zugriffsfunktionen des <span class="tx_code">std::span</span> vor.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/6/6/0/3/4/TN_199316625_51dcd9ba37.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das folgende Beispiel zeigt die Funktion <span class="tx_code">subspan</span> in der Anwendung:</div>
<div class="pre">// subspan.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;numeric&gt;<br>#include &lt;span&gt;<br>#include &lt;vector&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; myVec(20);<br>&nbsp;&nbsp;&nbsp; std::iota(myVec.begin(), myVec.end(), 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; for (auto v: myVec) std::cout &lt;&lt; v &lt;&lt; " ";<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp;&nbsp;&nbsp; std::span&lt;int&gt; mySpan(myVec);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; auto length = mySpan.size();<br><br>&nbsp;&nbsp;&nbsp; auto count = 5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; for (long unsigned int first = 0; first &lt;= (length - count); first += count ) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto ele: mySpan.subspan(first, count)) std::cout &lt;&lt; ele &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br><br>}</div>
<div class="text">Das Programm füllt den Vektor mit den Zahlen von 0 bis 19 (1) und initialisiert einen <span class="tx_code">std::span</span> mit diesem (2). Der Algorithmus <span class="tx_code">std::iota</span> füllt den Bereich mit aufeinanderfolgenden Werten, die per Default bei 0 beginnen, auf. Zuletzt setzt die for-Schleife (3) die Funktion <span class="tx_code">subspan</span> ein, um alle Teilbereiche zu erzeugen, die <span class="tx_code">count</span> Elemente besitzen und bei <span class="tx_code">first</span> beginnen. Die Schleife wird so lange ausgeführt, bis <span class="tx_code">mySpan</span> konsumiert ist.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/6/6/0/3/4/TN_199316630_4f7d2a02b0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Container der STL werden mit C++20 noch mächtiger. Zum Beispiel lassen sich <span class="tx_code">std::string</span> und <span class="tx_code">std::vector</span> zur Compilezeit erzeugen und modifizieren. Darüber hinaus geht dank der Funktionen <span class="tx_code">std::erase</span> und <span class="tx_code">std::erase_if</span> das Löschen der Elemente eines Containers deutlich leichter von der Hand.<br></div>