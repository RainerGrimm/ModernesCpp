<div class="vorspann">Heute freue ich mich darauf, Peter Gottschlings Gastartikel zur neuen Formatierungsbibliothek in C++20 zu präsentieren: std::format. Dank std::format wird Textformatierung in C++20 so einfach wie in Python.</div>
<div class="text">Peter Gottschling ist Autor der Pflichtlektüre "Discovering Modern C++" für professionelle C++Entwickler. Sein Buch ist auch in Deutsch unter dem Titel "Forschung mit modernem C++" erhältlich. </div>
<div class="ztitel">Die neue Formatierung</div>
<div class="text">Traditionelle Stream-Formatierung erfordert ein hohes Maß an Tipparbeit. Format-Strings in <span class="tx_code">printf</span> und ähnlichen Befehlen sind deutlich ausdrucksstärker und erlauben uns, mit wenigen Symbolen zu deklarieren, was wir sonst mit mehreren I/O-Manipulatoren geschrieben haben.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/7/9/5/8/8/TN_200236255_e831a186c4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Dennoch kann man von der Verwendung von <span class="tx_code">printf</span> nur abraten. Aus zwei Gründen: Nutzertypen werden nicht unterstützt und die Funktion ist nicht typsicher. Der Format-String wird zur Laufzeit geparst und die folgenden Argumente werden mit einem obskuren Makromechanismus verarbeitet. Wenn die Argumente nicht mit der Formatierungszeichenfolge übereinstimmen, ist das Verhalten undefiniert und kann zu Programmabstürzen führen. Beispielsweise wird ein String als Zeiger übergeben und ab der angegebenen Adresse werden die Bytes gelesen und als <span class="tx_code">char</span> ausgegeben, bis ein binäres <span class="tx_code">0</span> im Speicher gefunden wird. Wenn wir versehentlich versuchen, einen <span class="tx_code">int</span> als Zeichenkette auszugeben, wird der Wert <span class="tx_code">int</span> als Adresse fehlinterpretiert, von der aus eine Sequenz von <span class="tx_code">char</span> ausgegeben werden soll. Dies führt entweder zu einer absolut unsinnigen Ausgabe oder (was wahrscheinlicher ist) zu einem Speicherfehler, wenn auf die Adresse nicht zugegriffen werden darf. Wir müssen einräumen, dass neuere Compiler Formatierungszeichenketten parsen (wenn sie zur Kompilierzeit bekannt sind) und vor Argumentfehlern warnen.</div>
<div class="text">Die neue <a class="" href="https://en.cppreference.com/w/cpp/utility/format/format" title="Link auf https://en.cppreference.com/w/cpp/utility/format/format" alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22format%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fformat%2Fformat%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fformat%2Fformat%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%7D">format</a>-Bibliothek in C++20 kombiniert die Expressivität des Format-Strings mit der Typsicherheit und der Nutzer-Erweiterbarkeit von Stream-I/O. Des Weiteren erlaubt sie, Argumente in der Ausgabe neu anzuordnen. (Zum Zeitpunkt des Schreibens unterstützt kein Compiler die format-Bibliothek, und die Beispiele wurden mit ihrer Prototyp-Version implementiert: der <a class="" alt="%7B%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Ffmtlib%2Ffmt%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22fmt%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Ffmtlib%2Ffmt%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" href="https://github.com/fmtlib/fmt" title="Link auf https://github.com/fmtlib/fmt">fmt</a>-Bibliothek.)</div>
<div class="ztitel">Integrale<br> </div>
<div class="text">Statt einer formalen Spezifikation haben wir zunächst einige <span class="tx_code">printf</span>-Beispiele von <a alt="%7B%22text%22%3A%22cppreference.com%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fio%2Fc%2Ffprintf%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fio%2Fc%2Ffprintf%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D" href="https://en.cppreference.com/w/cpp/io/c/fprintf" title="Link auf https://en.cppreference.com/w/cpp/io/c/fprintf" class="">cppreference.com</a> in das neue Format portiert:<br> </div>
<div class="pre">print("Decimal:\t{} {} {:06} {} {:0} {:+} {:d}\n", 1, 2, 3, 0, 0, 4, -1);<br>print("Hexadecimal:\t{:x} {:x} {:X} {:#x}\n", 5, 10, 10, 6);<br>print("Octal:\t\t{:o} {:#o} {:#o}\n", 10, 10, 4);<br>print("Binary:\t\t{:b} {:#b} {:#b}\n", 10, 10, 4);<br></div>
<div class="text">Dieser Code-Schnipsel erzeugt die folgende Ausgabe:<br> </div>
<div class="pre">Decimal:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 2 000003 0 0 +4 -1<br>Hexadecimal:&nbsp;&nbsp;&nbsp; 5 a A 0x6<br>Octal:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12 012 04<br>Binary:1010 0b1010 0b100<br></div>
<div class="text">Die ersten beiden Zahlen wurden einfach ausgegeben, ohne irgendwelche Formatangaben zu machen. Die gleiche Ausgabe wird erzeugt, wenn wir eine Dezimalzahl mit der Formatangabe <span class="tx_code">:d</span> verlangen. Die dritte Zahl wird (mindestens) 6 Zeichen breit ausgegeben und mit führendem Nullen aufgefüllt. Der Spezifizierer <span class="tx_code">+</span> ermöglicht uns, die Ausgabe des Vorzeichens für alle Zahlen zu erzwingen. <span class="tx_code">printf</span> erlaubt es, die Ausgabe von Zahlen als <span class="tx_code">unsigned</span> zu spezifizieren. Wenn der Wert negativ ist, wird eine falsche positive Zahl (im entsprechenden Zweierkomplement) ausgeben. Die <span class="tx_code">format</span>-Bibliothek verzichtet auf Nutzerdeklarationen von <span class="tx_code">unsigned</span>-Ausgaben, da diese Information bereits im Typ des entsprechenden Arguments enthalten ist. Falls jemand dennoch das unbändige Bedürfnis verspürt, eine negative Zahl als großen positiven Wert auszugeben, muss er diese explizit konvertieren.</div>
<div class="text">Die zweite Zeile zeigt, dass wir Werte hexadezimal darstellen können – sowohl mit Klein- als auch mit Großbuchstaben für die Ziffern größer als 9. Der Spezifizierer <span class="tx_code">#</span> erzeugt das in hexadezimalen Literalen verwendete Präfix<span class="tx_code"> 0x</span>. </div>
<div class="text">Ebenso können wir die Werte oktal und binär ausgeben – optional mit den entsprechenden Literalpräfixen.<br> </div>
<div class="ztitel">Fließkommazahlen<br></div>
<div class="pre">print("Default:\t{} {:g} {:g}\n", 1.5, 1.5, 1e20);<br> print("Rounding:\t{:f} {:.0f} {:.22f}\n", 1.5, 1.5, 1.3);<br> print("Padding:\t{:05.2f} {:.2f} {:5.2f}\n", 1.5, 1.5, 1.5);<br> print("Scientific:\t{:E} {:e}\n", 1.5, 1.5);<br> print("Hexadecimal:\t{:a} {:A}\n\n", 1.5, 1.3);<br> </div>
<div class="text">Dies führt zu folgender Ausgabe:<br> </div>
<div class="pre">Default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.5 1.5 1e+20<br>Rounding:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.500000 2 1.3000000000000000444089<br>Padding:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01.50 1.50&nbsp; 1.50<br>Scientific:&nbsp;&nbsp;&nbsp;&nbsp; 1.500000E+00 1.500000e+00<br>Hexadecimal:0x1.8p+0 0X1.4CCCCCCCCCCCDP+0</div>
<div class="text">Mit leeren Klammern oder nur mit einem Doppelpunkt erhalten wir die Standardausgabe. Dies entspricht der Formatangabe <span class="tx_code">:g</span> und ergibt die gleiche Ausgabe wie bei Streams ohne Manipulatoren. Die Anzahl der Nachkommastellen kann zwischen einem Punkt und dem Formatbezeichner <span class="tx_code">f</span> angegeben werden. Dann wird der Wert auf diese Genauigkeit gerundet. Wenn die angeforderte Zahl größer ist als das, was durch den Typ des Wertes darstellbar ist, sind die letzten Ziffern nicht sonderlich sinnvoll. Eine Ziffer vor dem Punkt gibt die (minimale) Breite der Ausgabe an. Wie bei ganzen Zahlen können wir führende Nullen verlangen. Gleitkommazahlen können mit den Bezeichnern <span class="tx_code">e</span> und <span class="tx_code">E</span> in der wissenschaftlichen Notation ausgegeben werden, wobei der Exponentialteil entsprechend mit einem Groß- oder Kleinbuchstaben beginnt. Die hexadezimale Ausgabe kann verwendet werden, um eine Variable in einem anderen Programm (ab C++17) mit genau den gleichen Bits zu initialisieren.<br></div>
<div class="ztitel">Ausgaben umleiten<br></div>
<div class="text">Die Ausgabe kann zu jedem anderen <span class="tx_code">std::ostream</span> umgeleitet werden. (Mit der fmt-Bibliothek muss dafür <span class="tx_code">ostream.h</span> inkludiert werden.) </div>
<div class="pre">print(std::cerr, "System error code = {}\n", 7);<br> ofstream error_file("error_file.txt");<br> print(error_file, "System error code = {}\n", 7);<br> </div>
<div class="ztitel">Argumente umordnen und ihnen Namen geben<br></div>
<div class="text">Die Bibliothek führt auch ein Feature ein, das von keinem der beiden existierenden Ausgabetechniken unterstützt wird, nämlich die Möglichkeit, Argumente umzuordnen:</div>
<div class="pre">print("I'd rather be {1} than {0}.\n", "right", "happy");<br> </div>
<div class="text">Wir können auf die Argumente nicht nur nach ihren Positionen verweisen, sondern ihnen auch Namen geben:<br> </div>
<div class="pre">print("Hello, {name}! The answer is {number}. Goodbye, {name}.\n",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg("name", name), arg("number", number));<br></div>
<div class="text">Oder kürzer:<br> </div>
<div class="pre">print("Hello, {name}! The answer is {number}. Goodbye, {name}.\n",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "name"_a=name, "number"_a=number);<br> </div>
<div class="text">Das Beispiel zeigt auch, dass wir ein Argument mehrfach ausgeben können.<br> </div>
<div class="text">Die Umordnung von Argumenten ist in mehrsprachiger Software sehr wichtig, um eine natürliche Ausdrucksweise zu gewährleisten. Im Folgenden wollen wir den Durchschnitt von zwei Werten in fünf Sprachen ausgeben: <br></div>
<div class="pre">void print_average(float v1, float v2, int language)<br>{&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; using namespace fmt;<br>&nbsp;&nbsp;&nbsp; string formats[]= {"The average of {v1} and {v2} is {result}.\n",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "{result:.6f} ist der Durchschnitt von {v1} und {v2}.\n",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "La moyenne de {v1} et {v2} est {result}.\n",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "El promedio de {v1} y {v2} es {result}.\n",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "{result} corrisponde alla media di {v1} e {v2}.\n"};<br>&nbsp;&nbsp;&nbsp; print (formats[language], "v1"_a= v1, "v2"_a= v2, "result"_a= (v1+v2)/2.0f);<br>}</div>
<div class="text">Selbstverständlich ist die deutsche Version die pedantischste, die unter allen Umständen sechs Nachkommastellen verlangt.</div>
<div class="pre">The average of 3.5 and 7.3 is 5.4.<br> 5.400000 ist der Durchschnitt von 3.5 und 7.3.<br> La moyenne de 3.5 et 7.3 est 5.4.<br> El promedio de 3.5 y 7.3 es 5.4.<br>5.4 corrisponde alla media di 3.5 e 7.3.</div>
<div class="text">Dieses Beispiel hätte zugegebenermaßen auch ohne eine Umstellung der Argumente funktioniert, aber es illustriert sehr schön diese wichtige Möglichkeit, den Text und die Formatierung von den Werten zu separieren.</div>
<div class="text">Um formatierten Text in einen String zu speichern, benötigen wir auch keinen Umweg über einen <span class="tx_code">stringstream</span> mehr, sondern können dies direkt mit der Funktion <span class="tx_code">format</span> erledigen.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">In seinem nächsten Artikel wird Peter Gottschling seine Vorstellung von <span class="tx_code">std::format</span> abschließen. Peter wird das Formatieren von benutzterdefinierten Datentypen vorstellen.<br> </div>