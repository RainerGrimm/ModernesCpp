<div class="vorspann">In <a alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4641100%22%2C%22text%22%3A%22meinem%20letzten%20Artikel%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4641100%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" class="" href="https://heise.de/-4641100" title="Link auf https://heise.de/-4641100">meinem letzten Artikel</a> habe ich das Concept <span class="tx_code">Equal</span> definiert. Heute gehe ich einen Schritt weiter und verwende das Concept <span class="tx_code">Equal</span>, um das Concept <span class="tx_code">Ordering</span> zu definieren.</div>
<div>Zur Erinnerung: Das folgende Beispiel zeigt das Concept <span class="tx_code">Equal</span> und die Funktion <span class="tx_code">areEqual</span> aus dem letzten Artikel:<br></div>
<div class="pre">template&lt;typename T&gt;<br>concept Equal =<br>&nbsp;&nbsp;&nbsp; requires(T a, T b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a == b } -&gt; bool;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a != b } -&gt; bool;<br>};<br><br><br>bool areEqual(Equal auto fir, Equal auto sec) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp; return fir == sec;<br>}</div>
<div class="ztitel_kleiner"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/3/1/1/4/4/TN_187584815_0bfa1913da.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel_kleiner">Meine falsche Anwendung des Concepts <span class="tx_code">Equal</span></div>
<div class="text">Ich wendete das Concept <span class="tx_code">Equal</span> in meinem letzten Artikel auf falsche Art an. Es fordert von<span class="tx_code"> a </span>und <span class="tx_code">b</span>, dass beide denselben Datentyp besitzen müssen. Die Funktion <span class="tx_code">areEqual</span> erlaubt es aber, dass <span class="tx_code">fi</span><span class="tx_code">r</span> und <span class="tx_code">sec</span> verschiedene Datentypen sein können. Beide müssen natürlich das Concept <span class="tx_code">Equal</span> unterstützen. Die Verwendung eines Constrained Template anstelle der Placeholder-Syntax löst das Problem:</div>
<div class="pre">template &lt;Equal T&gt;<br>bool areEqual(T fir, T sec) {<br>&nbsp;&nbsp;&nbsp; fir == sec;<br>}</div>
<div class="text"><span class="tx_code">fir</span> und <span class="tx_code">sec</span> müssen jetzt denselben Datentyp besitzen. </div>
<div class="text">(Vielen Dank an Corentin Jabot, der mich auf diese Asymmetrie aufmerksam gemacht hat.)</div>
<div class="text">Zusätzlich sollte das Concept <span class="tx_code">Equal</span> nicht prüfen, ob der Gleichheits- und Ungleichheitsoperator <span class="tx_code">bool</span> zurückgibt. Das Concept sollte prüfen, ob sich der Rückgabewert zu <span class="tx_code">bool</span> implizit oder explizit konvertieren lässt. Hier ist die verbesserte Definition des Concepts:<br></div>
<div class="pre">template&lt;typename T&gt;<br>concept Equal =<br>&nbsp;&nbsp;&nbsp; requires(T a, T b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a == b } -&gt; std::convertible_to&lt;bool&gt;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a != b } -&gt; std::convertible_to&lt;bool&gt;;<br>};</div>
<div class="text"><span class="tx_code">s</span><span class="tx_code">td::convertible_to</span> ist selbst ein Concept des C++20-Standards und benötigt daher die Headerdatei <span class="tx_code">&lt;concepts&gt;</span>:<br></div>
<div class="pre">template &lt;class From, class To&gt;<br>concept convertible_to =<br>&nbsp; std::is_convertible_v&lt;From, To&gt; &amp;&amp;<br>&nbsp; requires(From (&amp;f)()) {<br>&nbsp;&nbsp;&nbsp; static_cast&lt;To&gt;(f());<br>&nbsp; };</div>
<div class="text">Der C++20-Standard definiert bereits zwei Concepts für Gleichheit:</div>
<div class="text"><ul><li> <span class="tx_code">std::equality_comparable</span>: entspricht meinem Concept <span class="tx_code">Equal.</span></li><li><span class="tx_code">std::equality_comparable_with</span>: erlaubt den Vergleich von Werten mit verschiedenen Datentypen; zum Beispiel: <span class="tx_code">1.0 == 1.0f.</span></li></ul></div>
<div class="ztitel">Die Herausforderung</div>
<div class="text">Ich habe meinen letzten Artikel damit beendet, dass ich einen Teil von Haskells Typklassen-Hierarchie vorgestellt habe:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/3/1/1/4/4/TN_187584820_b82f13b9e0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die Klassenhierarchie zeigt, dass die Typklasse <span class="tx_code">Ord</span> eine Verfeinerung der Typklasse <span class="tx_code">Eq</span> ist. Dies lässt sich elegant in Haskell ausdrücken:</div>
<div class="pre">class Eq a where<br>&nbsp;&nbsp;&nbsp; (==) :: a -&gt; a -&gt; Bool<br>&nbsp;&nbsp;&nbsp; (/=) :: a -&gt; a -&gt; Bool<br><br>class Eq a =&gt; Ord a where<br>&nbsp;&nbsp;&nbsp; compare :: a -&gt; a -&gt; Ordering<br>&nbsp;&nbsp;&nbsp; (&lt;) :: a -&gt; a -&gt; Bool<br>&nbsp;&nbsp;&nbsp; (&lt;=) :: a -&gt; a -&gt; Bool<br>&nbsp;&nbsp;&nbsp; (&gt;) :: a -&gt; a -&gt; Bool<br>&nbsp;&nbsp;&nbsp; (&gt;=) :: a -&gt; a -&gt; Bool<br>&nbsp;&nbsp;&nbsp; max :: a -&gt; a -&gt; a</div>
<div class="text">Hier ist meine Herausforderung: Lässt sich diese Beziehung ähnlich elegant in C++ mit Concepts ausdrücken? Der Einfachheit halber ignoriere ich die Funktionen <span class="tx_code">compare</span> und <span class="tx_code">max</span> aus Haskells Typklasse <span class="tx_code">Ord</span>. </div>
<div class="ztitel">Das Concept <span class="tx_code">Ordering</span></div>
<div class="text">Dank der requires-expressions besitzt die Definition des Concepts <span class="tx_code">Ordering</span> eine große Ähnlichkeit mit&nbsp; der Definition der Typklasse <span class="tx_code">Ord</span>.</div>
<div class="pre">template &lt;typename T&gt;<br>concept Ordering =<br>&nbsp;&nbsp;&nbsp; Equal&lt;T&gt; &amp;&amp;<br>&nbsp;&nbsp;&nbsp; requires(T a, T b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a &lt;= b } -&gt; bool;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a &lt; b } -&gt; bool;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a &gt; b } -&gt; bool;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a &gt;= b } -&gt; bool;<br>&nbsp;&nbsp;&nbsp; };</div>
<div class="text">Das folgende Beispiel zeigt das Concept <span class="tx_code">Ordering</span> in Aktion:</div>
<div class="pre">// conceptsDefinitionOrdering.cpp<br><br>#include &lt;concepts&gt;<br>#include &lt;iostream&gt;<br>#include &lt;unordered_set&gt;<br><br>template&lt;typename T&gt;<br>concept Equal =<br>&nbsp;&nbsp;&nbsp; requires(T a, T b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a == b } -&gt; std::convertible_to&lt;bool&gt;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a != b } -&gt; std::convertible_to&lt;bool&gt;;<br>&nbsp;&nbsp;&nbsp; };<br><br><br>template &lt;typename T&gt;<br>concept Ordering =<br>&nbsp;&nbsp;&nbsp; Equal&lt;T&gt; &amp;&amp;<br>&nbsp;&nbsp;&nbsp; requires(T a, T b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a &lt;= b } -&gt; std::convertible_to&lt;bool&gt;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a &lt; b } -&gt; std::convertible_to&lt;bool&gt;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a &gt; b } -&gt; std::convertible_to&lt;bool&gt;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { a &gt;= b } -&gt; std::convertible_to&lt;bool&gt;;<br>&nbsp;&nbsp;&nbsp; };<br><br>template &lt;Equal T&gt;<br>bool areEqual(T a, T b) {<br>&nbsp;&nbsp;&nbsp; return a == b;<br>}<br><br>template &lt;Ordering T&gt;<br>T getSmaller(T a, T b) {<br>&nbsp;&nbsp;&nbsp; return (a &lt; b) ? a : b;<br>}<br>&nbsp;&nbsp;&nbsp; <br>int main() {<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "areEqual(1, 5): " &lt;&lt; areEqual(1, 5) &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getSmaller(1, 5): " &lt;&lt; getSmaller(1, 5) &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::unordered_set&lt;int&gt; firSet{1, 2, 3, 4, 5};<br>&nbsp;&nbsp;&nbsp; std::unordered_set&lt;int&gt; secSet{5, 4, 3, 2, 1};<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "areEqual(firSet, secSet): " &lt;&lt; areEqual(firSet, secSet) &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; // auto smallerSet = getSmaller(firSet, secSet);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>}</div>
<div class="text">Die Funktion <span class="tx_code">getSmaller</span> fordert, dass beide Argumente <span class="tx_code">a</span> und <span class="tx_code">b</span> das Concept <span class="tx_code">Ordering</span> unterstützen. Darüber hinaus müssen sie denselben Datentyp besitzen. Diese Anforderung gilt natürlich für die Zahlen 1 und 5. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/3/1/1/4/4/TN_187584823_1b59fbc672.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="text"><span class="tx_code">std::unordered_set</span> setzt das Concept <span class="tx_code">Ordering</span> nicht um. Der aktuelle Microsoft-Compiler ist sehr eindeutig, wenn ich die Zeile <span class="tx_code">auto smaller = getSmaller(firSet, secSet)</span> mit dem Flag <span class="tx_code">/std:c++latest</span> übersetze.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/3/1/1/4/4/TN_187584831_c4aa2db2e3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Ich möchte hervorheben, dass die Fehlermeldung das Problem sehr gut auf den Punkt bringt: <span class="tx_code">t</span><span class="tx_code">he associated constraints are not satisfied</span>.</div>
<div class="text">Natürlich besitzt C++20 bereits das Concept <span class="tx_code">Ordering</span>:</div>
<div class="text"><ul><li> <span class="tx_code">std::three_way_comparable</span>: entspricht meinem Concept <span class="tx_code">Ordering.</span></li><li><span class="tx_code">std::three_way_comparable_with</span>: erlaubt den Vergleich von Werten mit verschiedenen Datentypen; zum Beispiel: <span class="tx_code">1.0 &lt; 1.0f.</span></li></ul></div>
<div class="text">Eventuell verwirrt dich ein wenig der Ausdruck three-way. Mit C++20 erhalten wir den Drei-Wege- Vergleichsoperator; auch bekannt unter den Name Spaceship Operator:<span class="tx_code"> &lt;=&gt;</span>. Hier gibt es den ersten Überblick zu dem neuen Operator: <a href="/exec/mainmenu.pl?sid=24a1d573114dca1da189a6575c816f46&amp;rm=open_article_id&amp;bid=2780355" class="" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A2780355%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C%2B%2B20%3A%20%C3%9Cberblick%20zur%20Kernsprache%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D24a1d573114dca1da189a6575c816f46%26rm%3Dopen_article_id%26bid%3D2780355%22%7D" title="Link auf Beitrag 2780355">C++20: Überblick zur Kernsprache</a>. Den Operator werde ich in einem zukünftigen Artikel genauer vorstellen.</div>
<div class="ztitel_kleiner">Compiler-Unterstützung</div>
<div class="text">Ich lerne Neues immer am besten, wenn ich es ausprobiere. Eventuell hast du keinen aktuellen Microsoft-Compiler. In diesem Fall bietet es sich an, den aktuellen GCC (trunk) des Compiler Explorer zu verwenden. GCC unterstützt die C++20-Syntax für Concepts. Hier ist der direkte Link zu dem Programm <span class="tx_code">conceptsDefinitionOrdering.cpp</span> für weitere Experimente: <a title="Link auf https://godbolt.org/z/uyVFX8" alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FuyVFX8%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FuyVFX8%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FuyVFX8%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%7D" href="https://godbolt.org/z/uyVFX8" class="">https://godbolt.org/z/uyVFX8</a>.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Wenn du einen konkreten Datentyp definieren willst, der sich einfach im C++-Ökosystem verwenden lässt, sollte er sich "<i>wie ein int verhalten</i>". Solch ein konkreter Typ lässt sich kopieren und das Ergebnis der Copy-Operation ist unabhängig von dem ursprünglichen Wert. Beide Objekte besitzen natürlich nach der Copy-Operation den gleichen Wert. Formal gesprochen, sollte ein konkreter Datentyp ein <i>regular type</i> sein. In meinem nächsten Artikel werde ich die Concepts <span class="tx_code">Regular</span> und <span class="tx_code">SemiRegular</span> definieren.</div>
<div class="ztitel">C++-Schulungen im Großraum Stuttgart</div>
<div class="text">Ich freue mich darauf, weitere C++-Schulungen halten zu dürfen.</div>
<div class="text"><ul><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/22-embedded-programmierung-mit-modernem-c20190511084954" alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22Embedded-Programmierung%20mit%20modernem%20C%2B%2B%3A%203.%20bis%205.%20M%C3%A4rz%202020%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F22-embedded-programmierung-mit-modernem-c20190511084954%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F22-embedded-programmierung-mit-modernem-c20190511084954%22%7D" class="" href="https://www.modernescpp.de/index.php/c/2-c/22-embedded-programmierung-mit-modernem-c20190511084954">Embedded-Programmierung mit modernem C++: 3. bis 5. März 2020</a> <br></li></ul><ul><li> <a href="https://www.modernescpp.de/index.php/c/2-c/23-c-11-und-c-1420190917134222" class="" alt="%7B%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F23-c-11-und-c-1420190917134222%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F23-c-11-und-c-1420190917134222%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C%2B%2B11%2F14%3A%2018.%20bis%2020.%20Mai%202020%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%7D" title="Link auf https://www.modernescpp.de/index.php/c/2-c/23-c-11-und-c-1420190917134222">C++11/14: 18. bis 20. Mai 2020</a> <br></li></ul></div>
<div class="text">Die Details zu meinen C++- und Python-Schulungen gibt es auf&nbsp;<a class="" href="https://www.modernescpp.de/" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22www.ModernesCpp.de%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%7D" title="Link auf https://www.modernescpp.de/">www.ModernesCpp.de</a>.<br></div>
