<div class="vorspann">Wenn Lambda-Ausdrücke zustandslos sind, besitzen sie einen Default-Konstruktor und einen Copy-Zuweisungsoperator. Darüber hinaus können sie in C++20 in nicht evaluierten Kontexten verwendet werden, und der C++20-Compiler stellt fest, wenn der <span class="tx_code">this</span>-Zeiger implizit kopiert wird. Das heißt, dass eine häufige Ursache von undefinierten Verhalten mit Lambdas der Vergangenheit angehört.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/4/9/1/5/7/TN_197984733_979f410e43.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Mit dem letzten Feature der Einleitung möchte ich heute beginnen. Der Compiler stellt das undefinierte Verhalten fest, wenn der <span class="tx_code">this</span>-Zeiger implizit kopiert wird. Doch was heißt undefiniertes Verhalten? <b>Mit undefiniertem Verhalten gibt es keine Einschränkungen zum möglichen Verhalten des Programms.</b> Damit gibt es auch keine Garantie dafür, was passieren kann.&nbsp;</div>
<div class="text">In meinen Schulungen sage ich gerne: Wenn das Programm undefiniertes Verhalten hat, besitzt das Programm catch-fire Semantik. Das bedeutet, selbst dein Rechner kann in Rauch aufgehen. In früheren Jahren wurde undefiniertes Verhalten noch radikaler beschrieben: Wenn das Programm undefiniertes Verhalten besitzt, kann es eine Cruise-Missile (launch a cruise missile) starten. Eigentlich ist es unerheblich: Wenn das Programm undefiniertes Verhalten besitzt, besteht die einzige mögliche Aktion darin, das undefinierte Verhalten zu beseitigen. </div>
<div class="text">Im nächsten Abschnitt werde ich bewusst undefiniertes Verhalten provozieren.<br></div>
<div class="ztitel">Impliziertes Kopieren des <span class="tx_code">this</span>-Zeigers<br></div>
<div class="text">Das folgende Programm bindet den <span class="tx_code">this</span>-Zeiger implizit per Copy. <br></div>
<div class="pre">// lambdaCaptureThis.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>struct Lambda {<br>&nbsp;&nbsp;&nbsp; auto foo() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [=] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; // (1) <br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::string s = "lambda";<br>&nbsp;&nbsp;&nbsp;&nbsp; ~Lambda() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Goodbye" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>auto makeLambda() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Lambda lambda;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; return lambda.foo();<br>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; auto lam = makeLambda();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; lam();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Das Kompilieren des Programms funktioniert erwartungsgemäß, aber nicht dessen Ausführen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/4/9/1/5/7/TN_197984744_e4196de072.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Der Fehler im Programm <span class="tx_code">lambdaCaptureThis.cpp</span>ist folgender: Die Methode <span class="tx_code">foo</span> (1) gibt den Lambda-Ausdruck <span class="tx_code">[=] { std::cout &lt;&lt; s &lt;&lt; std::endl; } </span>zurück, der implizit eine Kopie des <span class="tx_code">this</span>-Zeigers anlegt. Die implizite Kopie ist in (2) noch kein Problem, aber sie wird ein Problem am Ende des Gültigkeitsbereichs der lokalen Variable <span class="tx_code">lambda</span> (3). Konsequenterweise verursacht der Aufruf<span class="tx_code"> lam()</span> (4) das undefinierte Verhalten. </div>
<div class="text">Der C++20 Compiler muss in diesem Fall eine Warnung ausgeben. Hier ist auch schon die Ausgabe des GCC mit dem <a href="https://godbolt.org/" class="" title="Link auf https://godbolt.org/" alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22Compiler%20Explorer%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%7D">Compiler Explorer</a>.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/4/9/1/5/7/TN_197984760_4ec22d28e7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die zwei noch fehlenden Lambda-Features in C++20 klingen nicht so aufregend. Lambdas lassen sich in C++20 default-konstruieren und sie unterstützen die Kopiezuweisungen, wenn sie zustandslos sind. Lambdas lassen sich auch in nicht-evaluierten (unevaluated) Kontexten verwenden. Bevor ich beide Feature zusammen vorstelle, steht noch ein kleiner Umweg an. Was ist ein nicht-evaluierter Kontext?</div>
<div class="ztitel">Nicht-evaluierter Kontext<br></div>
<div class="text">Der folgende Codeschnipsel besitzt eine Funktionsdeklaration und eine Funktionsdefinition.</div>
<div class="pre">int add1(int, int);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // declaration<br>int add2(int a, int b) { return a + b; }&nbsp; // definition<br></div>
<div class="text"><span class="tx_code">add1</span> ist eine Funktionsdeklaration, während <span class="tx_code">add2</span> eine Funktionsdefinition ist. Wenn <span class="tx_code">add1</span> in einem evaluierten Kontext wie einem Funktionsaufruf verwende wird, ist das Ergebnis ein Linking-Fehler. Daher lässt sich <span class="tx_code">add1</span> nur in einem nicht-evaluierten Kontext wie <span class="tx_code">typeid</span> oder <span class="tx_code">decltype</span> verwenden. Beide Operatoren nehmen nicht-evaluierte Operanden an.&nbsp; </div>
<div class="pre">// unevaluatedContext.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;typeinfo&gt;&nbsp; // typeid<br><br>int add1(int, int);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // declaration<br>int add2(int a, int b) { return a + b; }&nbsp; // definition<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(add1).name(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(add1).name() &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; decltype(*add1) add = add2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "add(2000, 20): " &lt;&lt; add(2000, 20) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text"><span class="tx_code">typeid.(add1).name()</span> (1) gibt eine String-Repräsentierung seines Arguments zurück und <span class="tx_code">decltype</span> (2) deduziert den Datentyp seines Arguments. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/4/9/1/5/7/TN_197984745_a09874bb1e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="ztitel">Zustandslose Lambdas besitzen einen Default-Konstruktor und einen Kopiezuweisungsoperator</div>
<div class="ztitel">Lambdas lassen sich in nicht-evaluierten Kontexten verwenden</div>
<div class="text">Zugegeben, das ist ein recht langer Titel. Für einige Entwickler mag der Begriff zustandlose Lambda zudem neu sein. Ein zustandsloses Lambda bindet nichts aus seinem Definitionskontext. Anders ausgedrückt: Ein zustandsloses Lambda besitzt leere initialen eckige Klammern<span class="tx_code"> [ ]</span>. Zum Beispiel ist der folgende Lambda-Ausdruck zustandlos: <span class="tx_code">auto add = [ ](int a, int b) { return a + b; };</span></div>
<div class="text">Aus der Kombination beider Features resultieren praktische Lambda-Ausdrücke.</div>
<div class="text">Bevor ich das Beispiel zeige, möchte ich ein paar Anmerkungen machen.<span class="tx_code"> std::se</span>t wie alle anderen geordneten assoziativen Container der Standard Template Library (<span class="tx_code">std::map</span>, <span class="tx_code">std::multiset </span>und <span class="tx_code">std::multimap</span>) verwenden per-Default <span class="tx_code">std::less</span> zum Sortieren ihrer Schlüssel. Dank<span class="tx_code"> std::less</span> werden alle Schlüssel der geordneten assoziativen Container lexikografisch aufsteigend sortiert. Die Deklaration von <span class="tx_code">std::set</span> auf <a href="https://en.cppreference.com/w/cpp/container/set" class="" alt="%7B%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcontainer%2Fset%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22cppreference.com%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcontainer%2Fset%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%7D" title="Link auf https://en.cppreference.com/w/cpp/container/set">cppreference.com</a> zeigt schön das Ordnungsverhalten.</div>
<div class="pre">template&lt;<br>&nbsp;&nbsp;&nbsp; class Key,<br>&nbsp;&nbsp;&nbsp; class Compare = std::less&lt;Key&gt;,<br>&nbsp;&nbsp;&nbsp; class Allocator = std::allocator&lt;Key&gt;<br>&gt; class set;</div>
<div class="text">Nun möchte ich in dem folgenden Beispiel ein wenig das Ordnungsverhalten variieren.</div>
<div class="pre">// lambdaUnevaluatedContext.cpp<br><br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;memory&gt;<br>#include &lt;set&gt;<br>#include &lt;string&gt;<br><br>template &lt;typename Cont&gt;<br>void printContainer(const Cont&amp; cont) {<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; c: cont) std::cout &lt;&lt; c &lt;&lt; "&nbsp; ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n";<br>}<br><br>int main() {<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::set&lt;std::string&gt; set1 = {"scott", "Bjarne", "Herb", <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Dave", "michael"};<br>&nbsp;&nbsp;&nbsp; printContainer(set1);<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; using SetDecreasing = std::set&lt;std::string, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decltype([](const auto&amp; l,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const auto&amp; r)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { return l &gt; r; })<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; SetDecreasing set2 = {"scott", "Bjarne", "Herb", "Dave", "michael"};<br>&nbsp;&nbsp;&nbsp; printContainer(set2);&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; using SetLength = std::set&lt;std::string, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decltype([](const auto&amp; l, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const auto&amp; r)<br>&nbsp;&nbsp;&nbsp;&nbsp; { return l.size() &lt; r.size(); })<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;; // (1)<br>&nbsp;&nbsp;&nbsp; SetLength set3 = {"scott", "Bjarne", "Herb", "Dave", "michael"};<br>&nbsp;&nbsp;&nbsp; printContainer(set3);&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::set&lt;int&gt; set4 = {-10, 5, 3, 100, 0, -25};<br>&nbsp;&nbsp;&nbsp; printContainer(set4);<br><br>&nbsp;&nbsp;&nbsp; using setAbsolute = std::set&lt;int , <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decltype([](const auto&amp; l, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const auto&amp; r)<br>&nbsp;&nbsp;&nbsp;&nbsp; { return&nbsp; std::abs(l)&lt; std::abs(r); })<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;; // (1)<br>&nbsp;&nbsp;&nbsp; setAbsolute set5 = {-10, 5, 3, 100, 0, -25};<br>&nbsp;&nbsp;&nbsp; printContainer(set5);&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp; <br>}<br></div>
<div class="text"><span class="tx_code">set1</span> und <span class="tx_code">set4</span> sortieren ihre Schlüssel in aufsteigenden Reihenfolge. <span class="tx_code">set2</span>, <span class="tx_code">set3</span> und <span class="tx_code">set5</span> wenden eine Lambda in einem nicht-evaluierten Kontext an. Das <span class="tx_code">using</span> Schlüsselwort (1) deklariert einen Typ-Alias, der in der folgenden Zeile eingesetzt wird (2) um ein Set zu definieren. Das Erzeugen des Sets verursacht den Aufruf des Default-Konstruktors der zustandslosen Lambda.</div>
<div class="text">Dank dem Compiler Explorer und dem GCC kann ich die Ausgabe des Programms vorstellen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/4/9/1/5/7/TN_197984752_193d724428.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Das sorgfältie Studieren der Ausgabe birgt eine Überraschung. Das spezielle Set, das den Lambda-Ausdruck <span class="tx_code">[](const auto&amp; l, const auto&amp; r){ return l.size() &lt; r.size(); } </span>als Prädikat verwendet, ignorierten den Name "<span class="tx_code">Dave</span>".&nbsp; Der Grund ist einfach. "<span class="tx_code">Dave</span>" besitzen dieselbe Länge wie "<span class="tx_code">Herb</span>", das zuerst zu dem Set hinzugefügt wurde. Die Schlüssel eines<span class="tx_code"> std::set </span>können nur einmal vorkommen. Mit einem <span class="tx_code">std::multiset</span> sind mehrere gleiche Schlüssel möglich.&nbsp;</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Nur noch wenige Feature in der C++ Kernsprache habe ich noch nicht vorgestellt. Zu diesen kleinen Featuren gehören die neuen Attribute <span class="tx_code">[[likely]]</span> und <span class="tx_code">[[unlikely]]. </span>Dazu wird die Semantik von <span class="tx_code">volatile</span> deutlich eingeschränkt.<br></div>
