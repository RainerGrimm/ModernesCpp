<div class="vorspann">Mit C++20 erhalten wir die neuen und verbesserten Attribute <span class="tx_code">[[nodiscard("reason")]]</span>, <span class="tx_code">[[likely]]</span>, <span class="tx_code">[[unlikely]]</span> und <span class="tx_code">[[no_unique_address]]</span>. Insbesondere <span class="tx_code">[[nodiscard("reason")]]</span> erlaubt es, die Intention eines Interfaces deutlicher auf den Punkt zu bringen.</div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/5/2/6/7/6/TN_198244495_9d4698b9a7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Dank Attributen lässt sich die Absicht des Codes deklarativ ausdrücken.</div>
<div class="ztitel">Neue Attribute<br></div>
<div class="text">Während des Schreibens dieses Artikels bin ich zu einem großen Fan von <span class="tx_code">[[nodiscard("reason")]] </span>geworden. Daher beginne ich damit. Bereits seit C++17 gibt es das Attribut <span class="tx_code">[[nodiscard]]</span>. Mit C++20 wurde es um die Möglichkeit erweitert, eine Nachricht hinzuzufügen. Unglücklicherweise habe ich <span class="tx_code">[[nodiscard]]</span> in den letzten Jahren ignoriert. Diese Scharte möchte ich jetzt auswetzen und mit dem folgenden Programm starten:<br></div>
<div class="pre">// withoutNodiscard.cpp<br><br>#include &lt;utility&gt;<br><br>struct MyType {<br><br>&nbsp;&nbsp;&nbsp;&nbsp; MyType(int, bool) {}<br><br>};<br><br>template &lt;typename T, typename ... Args&gt;<br>T* create(Args&amp;&amp; ... args){<br>&nbsp; return new T(std::forward&lt;Args&gt;(args)...);<br>}<br><br>enum class ErrorCode {<br>&nbsp;&nbsp;&nbsp; Okay,<br>&nbsp;&nbsp;&nbsp; Warning,<br>&nbsp;&nbsp;&nbsp; Critical,<br>&nbsp;&nbsp;&nbsp; Fatal<br>};<br><br>ErrorCode errorProneFunction() { return ErrorCode::Fatal; }<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; int* val = create&lt;int&gt;(5);<br>&nbsp;&nbsp;&nbsp; delete val;<br><br>&nbsp;&nbsp;&nbsp; create&lt;int&gt;(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp;&nbsp;&nbsp; errorProneFunction();&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MyType(5, true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>} <br></div>
<div class="text">Dank Perfect Forwarding und Parameter Packs erlaubt es die Fabrikfunktion <span class="tx_code">create</span>, jeden Konstruktor aufzurufen und ein Heap-allokiertes Objekt zurückzugeben. </div>
<div class="text">Das Programm hat einige Unzulänglichkeiten. Zuerst einmal verursacht die Zeile (1) ein Speicherleck, denn das auf dem Heap erzeugte Objekt wird nicht destruiert. Darüber hinaus wird der Fehlercode der Funktion <span class="tx_code">errorProneFunction</span> (2) nicht geprüft. Zuletzt erzeugt der Konstruktoraufruf <span class="tx_code">MyType(5, true</span><span class="tx_code">)</span> eine temporäre Variable, die sofort wieder gelöscht wird. Das ist zumindest Verschwendung von Ressouren. </div>
<div class="text">Nun kommt aber <span class="tx_code">[[nodiscard]]</span> ins Spiel. Es lässt sich in Funktions-, Aufzähler- und Klassendeklaration verwenden. Der Compiler soll eine Warnung ausgeben, falls du den Rückgabewert einer als "nodiscard" deklarierten Funktion ignorierst, die ihren Wert per Copy zurückgibt. Dasselbe gilt für eine Funktion, die eine als "nodiscard" erklärte Aufzählung oder eine Klasse per Copy zurückgibt. Das gilt aber nicht, falls eine Konvertierung nach <span class="tx_code">void</span> angewandt wird.</div>
<div class="text">Was heißt das nun? Im folgenden Beispiel setze ich die C++17-Synax des Attributes <span class="tx_code">[[nodiscard]]</span> ein:<br></div>
<div class="pre">// nodiscard.cpp<br><br>#include &lt;utility&gt;<br><br>struct MyType {<br><br>&nbsp;&nbsp;&nbsp;&nbsp; MyType(int, bool) {}<br><br>};<br><br>template &lt;typename T, typename ... Args&gt;<br>[[nodiscard]]<br>T* create(Args&amp;&amp; ... args){<br>&nbsp; return new T(std::forward&lt;Args&gt;(args)...);<br>}<br><br>enum class [[nodiscard]] ErrorCode {<br>&nbsp;&nbsp;&nbsp; Okay,<br>&nbsp;&nbsp;&nbsp; Warning,<br>&nbsp;&nbsp;&nbsp; Critical,<br>&nbsp;&nbsp;&nbsp; Fatal<br>};<br><br>ErrorCode errorProneFunction() { return ErrorCode::Fatal; }<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; int* val = create&lt;int&gt;(5);<br>&nbsp;&nbsp;&nbsp; delete val;<br><br>&nbsp;&nbsp;&nbsp; create&lt;int&gt;(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp;&nbsp;&nbsp; errorProneFunction();&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MyType(5, true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>}</div>
<div class="text">Die Fabrikfunktion <span class="tx_code">create</span> und die enum <span class="tx_code">ErrorCode</span> sind als <span class="tx_code">[[nodiscard]]</span> deklariert. Konsequenterweise erzeugen die Aufrufe (1) und (2) eine Warnung.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/5/2/6/7/6/TN_198244484_87e656994d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Das ist schon deutlich besser, einige Unzulänglichkeiten bestehen aber immer noch. <span class="tx_code">[[nodiscard]]</span> lässt sich nicht auf Konstruktoren, die natürlich nichts zurückgeben, anwenden. Daher wird der temporäre Wert <span class="tx_code">MyType(5, true)</span> ohne Warnung erzeugt. Darüber hinaus sind mir die Fehlermeldungen zu allgemein. Als Anwender der Funktionen möchte ich wissen, warum das Verwerfen des Werts ein Problem darstellt.</div>
<div class="text">Beide Unzulänglichkeiten lassen sich mit C++20 lösen. Konstruktoren können als <span class="tx_code">[[nodiscard]] </span>deklariert werden und der Warnung lässt sich eine zusätzliche Nachricht hinzufügen:</div>
<div class="pre">// nodiscardString.cpp<br><br>#include &lt;utility&gt;<br><br>struct MyType {<br><br>&nbsp;&nbsp;&nbsp;&nbsp; [[nodiscard("Implicit destroying of temporary MyInt.")]] MyType(int, bool) {}<br><br>};<br><br>template &lt;typename T, typename ... Args&gt;<br>[[nodiscard("You have a memory leak.")]]<br>T* create(Args&amp;&amp; ... args){<br>&nbsp; return new T(std::forward&lt;Args&gt;(args)...);<br>}<br><br>enum class [[nodiscard("Don't ignore the error code.")]] ErrorCode {<br>&nbsp;&nbsp;&nbsp; Okay,<br>&nbsp;&nbsp;&nbsp; Warning,<br>&nbsp;&nbsp;&nbsp; Critical,<br>&nbsp;&nbsp;&nbsp; Fatal<br>};<br><br>ErrorCode errorProneFunction() { return ErrorCode::Fatal; }<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; int* val = create&lt;int&gt;(5);<br>&nbsp;&nbsp;&nbsp; delete val;<br><br>&nbsp;&nbsp;&nbsp; create&lt;int&gt;(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp;&nbsp;&nbsp; errorProneFunction();&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MyType(5, true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>}</div>
<div class="text">Nun erhalten Anwender der Funktion eine spezifische Warnung. Hier ist die Ausgabe des Microsoft-Compilers:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/5/2/6/7/6/TN_198244487_a6814b1057.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Viele Funktionen in C++ können vom <span class="tx_code">[[nodiscard]]</span>-Attribut profitieren. Wenn du zum Beispiel den Rückgabewert von <span class="tx_code">std::async</span> nicht verwendest, wird aus einem asynchronen Aufruf ein synchroner. Was in einem separaten Thread ausgeführt werden soll, wird daher zu einem blockierenden Funktionsaufruf. Mehr Details zum überraschenden Verhalten von <span class="tx_code">std::async</span> bietet mein Artikel "<a alt="%7B%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-async-warten-im-destruktor%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-async-warten-im-destruktor%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Besondere%20Futures%20mit%20std%3A%3Aasync%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/std-async-warten-im-destruktor" href="https://www.grimm-jaud.de/index.php/blog/std-async-warten-im-destruktor" class="">Besondere Futures mit std::async</a>". </div>
<div class="text">Bei meiner Recherche zur <span class="tx_code">[[nodiscard]]</span>-Syntax auf cppreference.com fiel mir auf, dass die Überladungen von <span class="tx_code"><a alt="%7B%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22std%3A%3Aasync%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fthread%2Fasync%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fthread%2Fasync%22%2C%22ir_link%22%3A1%7D" title="Link auf https://en.cppreference.com/w/cpp/thread/async" href="https://en.cppreference.com/w/cpp/thread/async" class="">std::async</a></span> mit C++20 verändert wurden. Hier ist exemplarisch eine der Überladungen:</div>
<div class="pre">template&lt; class Function, class... Args&gt;<br>[[nodiscard]]<br>std::future&lt;std::invoke_result_t&lt;std::decay_t&lt;Function&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::decay_t&lt;Args&gt;...&gt;&gt;<br>&nbsp;&nbsp;&nbsp; async( Function&amp;&amp; f, Args&amp;&amp;... args );<br></div>
<div class="text"><span class="tx_code">std::future</span> als Rückgabetyp des Promise <span class="tx_code">std::async</span> ist als <span class="tx_code">[[nodiscard]]</span> deklariert.</div>
<div class="text">Die nächsten zwei neue Attribute <span class="tx_code">[[likely]]</span> und <span class="tx_code">[[unlikely]]</span> beschäftigen sich mit der Optimierung.<br></div>
<div class="ztitel">[[likely]] und [[unlikely]] </div>
<div class="text">Das Proposal P0479R5 zu "likelyl" und "unlikey" ist das kürzeste, das ich kenne. Es besteht fast nur aus einer Anmerkung, die ich zitieren möchte: "The use of the <b>likely</b> attribute is intended to allow implementations to optimize for the case where paths of execution including it are arbitrarily more likely than any alternative path of execution that does not include such an attribute on a statement or label. The use of the <b>unlikely</b> attribute is intended to allow implementations to optimize for the case where paths of execution including it are arbitrarily more unlikely than any alternative path of execution that does not include such an attribute on a statement or label. A path of execution includes a label if and only if it contains a jump to that label. Excessive usage of either of these attributes is liable to result in performance degradation." </div>
<div class="text">Beide Attribute erlauben es, dem Compiler einen Hinweis zu geben, welcher Ausführungspfad mit höherer Wahrscheinlichkeit ausgeführt wird:</div>
<div class="pre">for(size_t i=0; i &lt; v.size(); ++i){<br>&nbsp;&nbsp;&nbsp; if (v[i] &lt; 0) [[likely]] sum -= sqrt(-v[i]);<br>&nbsp;&nbsp;&nbsp; else sum += sqrt(v[i]);<br>}</div>
<div class="text">Die Geschichte zur Optimierung mit den neuen Attributen endet hier aber noch nicht. Dank <span class="tx_code">[[no_unique_address]]</span> lässt sich der Addressraum optimieren. </div>
<div class="ztitel">[[no_unique_address]]</div>
<div class="text"><span class="tx_code">[[no_unique_address]]</span> drückt aus, dass dieses Mitglied einer Klasse keine Adresse benötigt, die sich von allen anderen nichtstatischen Mitgliedern der Klasse unterscheidet. Falls dieses Mitglied ein <i>Empty Type</i> ist, kann der Compiler konsequenterweise seinen Speicherplatz wegoptimieren.</div>
<div class="text">Das folgende Beispiel stellt <span class="tx_code">[[no_unique_address]]</span> genauer vor:</div>
<div class="text"><span class="tx_code">// uniqueAddress.cpp<br><br>#include &lt;iostream&gt;<br>&nbsp;<br>struct Empty {}; <br>&nbsp;<br>struct NoUniqueAddress {<br>&nbsp;&nbsp;&nbsp; int d{};<br>&nbsp;&nbsp;&nbsp; Empty e{};<br>};<br>&nbsp;<br>struct UniqueAddress {<br>&nbsp;&nbsp;&nbsp; int d{};<br>&nbsp;&nbsp;&nbsp; [[no_unique_address]] Empty e{};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>};<br>&nbsp;<br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sizeof(int) == sizeof(NoUniqueAddress): "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; (sizeof(int) == sizeof(NoUniqueAddress)) &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sizeof(int) == sizeof(UniqueAddress): "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; (sizeof(int) == sizeof(UniqueAddress)) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; NoUniqueAddress NoUnique;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&amp;NoUnique.d: " &lt;&lt;&nbsp; &amp;NoUnique.d &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&amp;NoUnique.e: " &lt;&lt;&nbsp; &amp;NoUnique.e &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; UniqueAddress unique;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&amp;unique.d: " &lt;&lt;&nbsp; &amp;unique.d &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&amp;unique.e: " &lt;&lt;&nbsp; &amp;unique.e &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</span></div>
<div class="text">(1) wendet das neue Attribut <span class="tx_code">[[no_unique_address]]</span> an. Die Größe der Klasse <span class="tx_code">NoUniqueAddress</span> unterscheidet sich vom Datentyp <span class="tx_code">int</span> (2). Das gilt aber nicht für die Klasse <span class="tx_code">UniqueAddress</span> (3). Die Mitglieder <span class="tx_code">d</span> und <span class="tx_code">e</span> der Klasse <span class="tx_code">NoUniqueAddress</span> (4) besitzen verschiedene Adressen. Das gilt wiederum nicht für die Mitglieder der Klasse <span class="tx_code">UniqueAddress</span> (5).</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/5/2/6/7/6/TN_198244500_5a4e0546e8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Der <span class="tx_code">volatile</span>-Spezifizier steht für eines der dunkelsten Ecken in C++. Daher wird seine Semantik in C++20 deutlich eingeschränkt. <br></div>
