<div class="vorspann"><span class="tx_code">std::jthread</span> steht für einen automatisch <i>joinenden</i> Thread. Im Gegensatz zu <span class="tx_code">std::thread</span> (C++11) joint <span class="tx_code">std::jthread</span> automatisch in seinem Destruktor und kann kooperativ unterbrochen werden. Dieser Artikel zeigt, warum <span class="tx_code">std::jthread</span> die erste Wahl sein sollte. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/5/6/3/7/1/TN_206837557_62c9e9bab8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die folgende Tabelle gibt den ersten kompakten Überblick des Interfaces eines <span class="tx_code">std::jthread</span>.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/5/6/3/7/1/TN_206837564_18c0705c9a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Weitere Details liefert wie immer <a title="Link auf https://en.cppreference.com/w/cpp/thread/jthread" alt="%7B%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fthread%2Fjthread%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22cppreference.com%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fthread%2Fjthread%22%7D" href="https://en.cppreference.com/w/cpp/thread/jthread" class="">cppreference.com</a>. Die Details zu <span class="tx_code">std::thread</span> lassen sich auf meinem Blog nachlesen: <a title="Link auf https://www.grimm-jaud.de/index.php/der-einstieg-in-modernes-c#h1-2-standardisierte-threading-schnittstelle" alt="%7B%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fder-einstieg-in-modernes-c%23h1-2-standardisierte-threading-schnittstelle%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Meine%20Artikel%20zu%20std%3A%3Athread%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fder-einstieg-in-modernes-c%23h1-2-standardisierte-threading-schnittstelle%22%7D" href="https://www.grimm-jaud.de/index.php/der-einstieg-in-modernes-c#h1-2-standardisierte-threading-schnittstelle" class="">Meine Artikel zu std::thread</a>. </div>
<div class="text">Warum benötigen wir einen verbesserten Thread in C++20?<br></div>
<div class="ztitel">Automatisch <i>joinen</i></div>
<div class="text">Hier ist das nicht intuitive Verhalten des <span class="tx_code">std::thread</span>. Wenn ein <span class="tx_code">std::thread</span> noch <i>joinable</i> ist, wird automatisch <span class="tx_code">std::terminate</span> in seinem Destruktor aufgerufen. Ein Thread <span class="tx_code">thr</span> ist <i>joinable</i>, wenn auf ihm noch nicht <span class="tx_code">thr.join()</span> oder <span class="tx_code">thr.detach()</span> ausgeführt wurde: </div>
<div class="pre">// threadJoinable.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::thread thr{[]{ std::cout &lt;&lt; "Joinable std::thread" &lt;&lt; '\n'; }};<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "thr.joinable(): " &lt;&lt; thr.joinable() &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>}<br></div>
<div class="text">Wird das Programm ausgeführt, beendet es sich abrupt, wenn das lokale Objekt <span class="tx_code">thr</span> seinen Gültigkeitsbereich verliert.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/5/6/3/7/1/TN_206837572_1746270a86.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=1>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Beide Threads beenden sich abrupt. Im zweiten Fall besitzt der Thread noch genügend Zeit, seine Nachricht auszugeben: <span class="tx_code">Joinable std::thread</span>.</div>
<div class="text">In meinem nächsten Beispiel verwende ich <span class="tx_code">std::jthread</span> aus dem C++20-Standard:<br></div>
<div class="pre">// jthreadJoinable.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::jthread thr{[]{ std::cout &lt;&lt; "Joinable std::thread" &lt;&lt; '\n'; }};<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "thr.joinable(): " &lt;&lt; thr.joinable() &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Nun ruft der Thread <span class="tx_code">thr</span> automatisch <span class="tx_code">join</span> in seinem Destruktor auf, wenn er wie in diesem Fall noch <i>joinable</i> ist. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/5/6/3/7/1/TN_206837573_3dd6b864e9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das ist noch nicht alles, was ein <span class="tx_code">std::jthread</span> zusätzlich zu einem <span class="tx_code">std::thread</span> anbietet. Ein <span class="tx_code">std::jthread</span> lässt sich auch kooperativ unterbrechen. <a title="Link auf https://heise.de/-5047812" alt="%7B%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5047812%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5047812%22%2C%22text%22%3A%22Ich%20habe%20bereits%20in%20meinem%20letzten%20Artikel%20die%20Idee%20des%20kooperativen%20Unterbrechens%20vorgestellt%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D" href="https://heise.de/-5047812" class="">Ich habe bereits in meinem letzten Artikel die Idee des kooperativen Unterbrechens vorgestellt</a>.</div>
<div class="text">Das folgende Programm stellt das Unterbrechen eines <span class="tx_code">std::jthread</span> genauer vor:<br></div>
<div class="pre">// interruptJthread.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>using namespace::std::literals;<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::jthread nonInterruptable([]{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int counter{0};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (counter &lt; 10){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(0.2s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "nonInterruptable: " &lt;&lt; counter &lt;&lt; '\n'; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++counter;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::jthread interruptable([](std::stop_token stoken){&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int counter{0};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (counter &lt; 10){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(0.2s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (stoken.stop_requested()) return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "interruptable: " &lt;&lt; counter &lt;&lt; '\n'; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++counter;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "Main thread interrupts both jthreads" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; nonInterruptable.request_stop();<br>&nbsp;&nbsp;&nbsp; interruptable.request_stop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Ich starte im <span class="tx_code">main</span>-Programm die zwei Threads <span class="tx_code"> nonInterruptable</span> und <span class="tx_code">interruptable</span> (Zeilen 1 und 2). Im Gegensatz zum Thread <span class="tx_code">nonInterruptable</span> erhält der Thread <span class="tx_code">interruptable</span> ein <span class="tx_code">std::interrupt_token</span> und verwendet diesen, um in Zeile (3) zu prüfen, ob er unterbrochen wurde:<span class="tx_code"> itoken.is_interrupted()</span>. Im Fall einer Unterbrechung wird die Lambda-Funktion einfach beendet, sodass der Thread mit seiner Ausführung fertig ist. Der Aufruf <span class="tx_code">interruptable.interrupt()</span> in Zeile (4) stößt die Beendigung des Threads an. Dies gilt nicht für den vorherigen Aufruf <span class="tx_code">nonInterruptable.interrupt()</span>, der keinen Effekt besitzt.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/5/6/3/7/1/TN_206837579_1bcd46fe65.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Um den Artikel schön abzuschließen, zeige ich, wie sich in C++20 auch eine Bedingungsvariable kooperativ unterbrechen lässt.</div>
<div class="ztitel">Neue wait-Überladungen für std::condition_variable_any</div>
<div class="text">Bevor ich genauer auf <span class="tx_code">std::condition_variable_any</span> eingehe, möchte ich auf meine Artikel zu Bedingungsvariablen verweisen: <a title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/bedingungsvariablen" alt="%7B%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fbedingungsvariablen%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fbedingungsvariablen%22%2C%22text%22%3A%22Bedingungsvariablen%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/tag/bedingungsvariablen" class="">Bedingungsvariablen</a>.</div>
<div class="text">Die wait-Varianten <span class="tx_code">wait</span>, <span class="tx_code">wait_for</span> und <span class="tx_code">wait_until</span> der <span class="tx_code">std::condition_variable_any</span> erhalten neue Überladungen. Diese können ein <span class="tx_code">std::stop_token</span> annehmen: </div>
<div class="text"><span class="tx_code">template &lt;class Predicate&gt;<br>bool wait(Lock&amp; lock, &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop_token stoken,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Predicate pred);<br><br>template &lt;class Rep, class Period, class Predicate&gt;<br>bool wait_for(Lock&amp; lock, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop_token stoken, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Predicate pred);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>template &lt;class Clock, class Duration, class Predicate&gt;<br>bool wait_until(Lock&amp; lock, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop_token stoken,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Predicate pred);</span></div>
<div class="text">Die neuen Überladungen benötigen ein Prädikat. Die Varianten stellen sicher, benachrichtigt zu werden, wenn eine Unterbrechung an den übergebenen <span class="tx_code">std::interrupt_token stoken</span> geschickt wurde. Nach dem <span class="tx_code">wait</span>-Aufruf lässt sich dann prüfen, ob eine Unterbrechung vorliegt:</div>
<div class="pre">cv.wait(lock, stoken, predicate);<br>if (stoken.is_interrupted()){<br>&nbsp;&nbsp;&nbsp; // interrupt occurred<br>}</div>
<div class="text">Das folgende Beispiel stellt die Anwendung einer Bedingungsvariable mit einer Stopp-Aufforderung vor.<br></div>
<div class="text"><span class="tx_code">// conditionVariableAny.cpp<br><br>#include &lt;condition_variable&gt;<br>#include &lt;thread&gt;<br>#include &lt;iostream&gt;<br>#include &lt;chrono&gt;<br>#include &lt;mutex&gt;<br>#include &lt;thread&gt;<br><br>using namespace std::literals;<br><br>std::mutex mutex_;<br>std::condition_variable_any condVar;<br><br>bool dataReady;<br><br>void receiver(std::stop_token stopToken) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Waiting" &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp; bool ret = condVar.wait(lck, stopToken, []{return dataReady;});<br>&nbsp;&nbsp;&nbsp; if (ret){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Notification received: " &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Stop request received" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>void sender() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(5ms);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataReady = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Send notification"&nbsp; &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; condVar.notify_one();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>}<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp; std::jthread t1(receiver);<br>&nbsp; std::jthread t2(sender);<br>&nbsp; <br>&nbsp; t1.request_stop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br><br>&nbsp; t1.join();<br>&nbsp; t2.join();<br><br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>}</span></div>
<div class="text">Der Empfänger-Thread (Zeile 1) wartet auf die Benachrichtigung des Sender-Threads (Zeile 2). Bevor der Sender seine Benachrichtigung schickt (Zeile 3), stößt der <span class="tx_code">main-</span>Thread eine Stopp-Anfrage an (Zeile 4). Die Ausgabe des Programms zeigt, dass die Stopp-Anforderung vor der Benachrichtigung stattfindet:<span class="tx_code"><br></span></div>
<div class="text"><span class="tx_code"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/5/6/3/7/1/TN_206837596_a65ca1d2d7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></span></div>
<div class="ztitel">Wie geht's weiter</div>
<div class="text">Was kann passieren, wenn du unsynchroniziert auf <span class="tx_code">std::cout</span> schreibst? Du erhältst ein Durcheinander. Dank C++20 lassen sich auch synchronisierte Ausgabestreams einsetzen.<span class="tx_code"><br></span></div>