<div class="vorspann">Der Drei-Weg-Vergleichsoperator &lt;=&gt; wird auch gerne Spaceship Operator genannt. Er bestimmt für zwei Werte A und B, ob A &lt; B, A = B oder ob A &gt; B ist. Der Spaceship Operator lässt sich direkt definieren oder vom Compiler automatisch erzeugen.<br></div>
<div class="text">Um die Vorteile des Drei-Weg-Vergleichsoperators richtig wertzuschätzen, möchte ich meinen Artikel klassisch starten.</div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/1/0/9/5/2/TN_194772073_beaa64b4f7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Ordnung vor C++20</div>
<div class="text">Ich habe den einfachen Wrapper <span class="tx_code">MyInt</span> für <span class="tx_code">int</span> implementiert. Natürlich sollen sich Instanzen von <span class="tx_code">MyInt</span> vergleichen lassen. Die folgenden Zeilen zeigen meine Lösung mithilfe des Funktion-Templates<span class="tx_code"> isLessThan</span>:</div>
<div class="pre">// comparisonOperator.cpp<br><br>#include &lt;iostream&gt;<br><br>struct MyInt {<br>&nbsp;&nbsp;&nbsp; int value;<br>&nbsp;&nbsp;&nbsp; explicit MyInt(int val): value{val} { }<br>&nbsp;&nbsp;&nbsp; bool operator &lt; (const MyInt&amp; rhs) const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return value &lt; rhs.value;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>template &lt;typename T&gt;<br>constexpr bool isLessThan(const T&amp; lhs, const T&amp; rhs) {<br>&nbsp;&nbsp;&nbsp; return lhs &lt; rhs;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; MyInt myInt2011(2011);<br>&nbsp;&nbsp;&nbsp; MyInt myInt2014(2014);<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isLessThan(myInt2011, myInt2014): "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; isLessThan(myInt2011, myInt2014) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Das Programm erfüllt erwartungsgemäß seine Aufgabe:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/1/0/9/5/2/TN_194772076_e905412f47.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Ehrlich gesagt, verhält sich der Datentyp <span class="tx_code">MyInt</span> sehr unintuitiv. Wenn du einen der sechs Vergleichsoperatoren implementierst, solltest du alle sechs implementieren. Intuitive Datentypen sollten zumindest semiregulär sein: "<a title="Link auf https://heise.de/-4651337" class="" href="https://heise.de/-4651337" alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22C%2B%2B20%3A%20Die%20Concepts%20SemiRegular%20und%20Regular%20definieren%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4651337%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4651337%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%7D">C++20: Die Concepts SemiRegular und Regular definieren</a>". </div>
<div class="text">Nun gilt es, viel Boilerplate Code zu schreiben. Hier sind die fünf fehlenden Operatoren:</div>
<div class="pre">bool operator==(const MyInt&amp; rhs) const { <br>&nbsp;&nbsp;&nbsp; return value == rhs.value; <br>}<br>bool operator!=(const MyInt&amp; rhs) const { <br>&nbsp;&nbsp;&nbsp; return !(*this == rhs);&nbsp;&nbsp;&nbsp; <br>}<br>bool operator&lt;=(const MyInt&amp; rhs) const { <br>&nbsp;&nbsp;&nbsp; return !(rhs &lt; *this);&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br>bool operator&gt;(const MyInt&amp; rhs)&nbsp; const { <br>&nbsp;&nbsp;&nbsp; return rhs &lt; *this;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br>bool operator&gt;=(const MyInt&amp; rhs) const {&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; return !(*this &lt; rhs);&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Fertig? Leider nicht. Ich nehme an, dass du <span class="tx_code">MyInt</span> mit <span class="tx_code">int</span> vergleichen willst. Um den Vergleich von <span class="tx_code">MyInt</span> und <span class="tx_code">MyInt</span>, von <span class="tx_code">int</span> und <span class="tx_code">MyInt</span> und von <span class="tx_code">MyInt</span> und <span class="tx_code">int</span> zu unterstützen, müssen alle der sechs Operatoren dreimal überladen werden. Der Grund ist, dass keine implizite Konvertierungen von <span class="tx_code">int</span> nach <span class="tx_code">MyInt</span> möglich ist, denn der Konstruktor ist als <span class="tx_code">explicit</span> deklariert. Die einfachste Strategie ist daher, die Operatoren als <span class="tx_code">friend</span> zu deklarieren. Falls du an mehr Hintergrundwissen zu meiner Designentscheidung interessiert bist, so kannst du diese in meinem älteren Artikel "<a href="https://heise.de/-3879406" title="Link auf https://heise.de/-3879406" class="" alt="%7B%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-3879406%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-3879406%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20%C3%9Cberladen%20von%20Funktionen%20und%20Operatoren%22%7D">C++ Core Guidelines: Überladen von Funktionen und Operatoren</a>" nachlesen. </div>
<div class="text">Die anschließenden Codezeilen stellen die drei Überladungen für den Kleiner-als-Operator vor:</div>
<div class="pre">friend bool operator &lt; (const MyInts&amp; lhs, const MyInt&amp; rhs) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; return lhs.value &lt; rhs.value;<br>}<br><br>friend bool operator &lt; (int lhs, const MyInt&amp; rhs) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; return lhs &lt; rhs.value;<br>}<br><br>friend bool operator &lt; (const MyInts&amp; lhs, int rhs) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; return lhs.value &lt; rhs;<br>}</div>
<div class="text">Das bedeutet, dass du 18 Operatoren implementieren musst. Ist dies das Ende meines historischen Ausflugs? Leider noch nicht. Die 18 Operatoren sollten als <span class="tx_code">constexpr</span> deklariert werden. Darüber hinaus bietet es sich an, die Operatoren auch als <span class="tx_code">noexcept</span> zu deklarieren.</div>
<div class="text">Ich denke, dieser kleine Exkurs enthält ausreichend Motivation für den Drei-Weg-Vergleichsoperator.</div>
<div class="ztitel">Ordnung mit C++20</div>
<div class="text">Du kannst den Drei-Weg-Vergleichsoperator selbst definieren oder ihm vom Compiler mit <span class="tx_code">=default </span>anfordern. In beiden Fällen erzeugt der Compiler alle sechs Vergleichsoperatoren: <span class="tx_code">==,&nbsp;!=, &lt;, &lt;=, &gt;</span> und <span class="tx_code">&gt;=</span>:</div>
<div class="pre">// threeWayComparison.cpp<br><br>#include &lt;compare&gt;<br>#include &lt;iostream&gt;<br><br>struct MyInt {<br>&nbsp;&nbsp;&nbsp; int value;<br>&nbsp;&nbsp;&nbsp; explicit MyInt(int val): value{val} { }<br>&nbsp;&nbsp;&nbsp; auto operator&lt;=&gt;(const MyInt&amp; rhs) const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return value &lt;=&gt; rhs.value;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>struct MyDouble {<br>&nbsp;&nbsp;&nbsp; double value;<br>&nbsp;&nbsp;&nbsp; explicit constexpr MyDouble(double val): value{val} { }<br>&nbsp;&nbsp;&nbsp; auto operator&lt;=&gt;(const MyDouble&amp;) const = default;&nbsp;&nbsp; // (2)<br>};<br><br>template &lt;typename T&gt;<br>constexpr bool isLessThan(const T&amp; lhs, const T&amp; rhs) {<br>&nbsp;&nbsp;&nbsp; return lhs &lt; rhs;<br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MyInt myInt1(2011);<br>&nbsp;&nbsp;&nbsp; MyInt myInt2(2014);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isLessThan(myInt1, myInt2): "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; isLessThan(myInt1, myInt2) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MyDouble myDouble1(2011);<br>&nbsp;&nbsp;&nbsp; MyDouble myDouble2(2014);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isLessThan(myDouble1, myDouble2): "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; isLessThan(myDouble1, myDouble2) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Sowohl der benutzerdefinierte (1) als auch der vom Compiler erzeugte (2) Drei-Weg-Vergleichsoperator verrichten ihre Dienste zuverlässig:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/1/0/9/5/2/TN_194772086_2720b0d1b8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Es gibt aber ein paar kleine Unterschiede bei den beiden Drei-Weg-Vergleichsoperatoren. Der vom Compiler deduzierte Rückgabetyp für <span class="tx_code">MyInt</span> (1) unterstützt die strenge Ordnung, der vom Compiler deduzierte Rückgabetyp für <span class="tx_code">MyDouble</span> (2) unterstützt hingegen nur die partielle Ordnung. Gleitkommazahlen können nur die partielle Ordnung unterstützen, da sich Werte wie <a href="https://en.wikipedia.org/wiki/NaN" class="" title="Link auf https://en.wikipedia.org/wiki/NaN" alt="%7B%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FNaN%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FNaN%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22NaN%22%7D">NaN</a> (Not a Number) nicht ordnen lassen. Zum Beispiel gilt, dass <span class="tx_code">NaN == Na</span><span class="tx_code">n</span> zu <span class="tx_code">false</span> evaluiert.</div>
<div class="text">Für den Rest des Artikels werde ich mich auf den vom Compiler erzeugten Spaceship Operator fokussieren.</div>
<div class="ztitel">Der Compiler erzeugte Spaceship Operator</div>
<div class="text">Der vom Compiler erzeugte Drei-Weg-Vergleichsoperator benötigt die Header-Datei <span class="tx_code">&lt;compare&gt;</span>. Er ist implizit <span class="tx_code">constexpr</span> und <span class="tx_code"> <a alt="%7B%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4121657%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4121657%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22noexcept%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%7D" class="" title="Link auf https://heise.de/-4121657" href="https://heise.de/-4121657">noexcept</a></span>. Darüber hinaus vergleicht er lexikografisch. Zugegeben, diese Erläuterung war zu kompakt, daher möchte ich mir zuerst <span class="tx_code">constexpr</span> genauer anschauen.</div>
<div class="text"><ul><li><b>Vergleichen zur Compilezeit</b></li></ul></div>
<div class="text">Der Drei-Weg-Vergleichsoperator ist implizit <span class="tx_code">constexpr</span>. Konsequenterweise kann ich das vorherige Programm <span class="tx_code">threeWayComparison</span> vereinfachen und <span class="tx_code">MyDouble</span> in dem folgenden Programm zur Compilezeit vergleichen: <br></div>
<div class="pre">// threeWayComparisonAtCompileTime.cpp<br><br>#include &lt;compare&gt;<br>#include &lt;iostream&gt;<br><br>struct MyDouble {<br>&nbsp;&nbsp;&nbsp; double value;<br>&nbsp;&nbsp;&nbsp; explicit constexpr MyDouble(double val): value{val} { }<br>&nbsp;&nbsp;&nbsp; auto operator&lt;=&gt;(const MyDouble&amp;) const = default;&nbsp;&nbsp;&nbsp; <br>};<br><br>template &lt;typename T&gt;<br>constexpr bool isLessThan(const T&amp; lhs, const T&amp; rhs) {<br>&nbsp;&nbsp;&nbsp; return lhs &lt; rhs;<br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; constexpr MyDouble myDouble1(2011);<br>&nbsp;&nbsp;&nbsp; constexpr MyDouble myDouble2(2014);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; constexpr bool res = isLessThan(myDouble1, myDouble2); // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isLessThan(myDouble1, myDouble2): "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; res &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Ich habe nach dem Ergebnis des Vergleichs zur Compilezeit gefragt (1) und es erhalten:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/1/0/9/5/2/TN_194772093_5f489a5973.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Der vom Compiler erzeugte Drei-Weg-Vergleichsoperator wendet lexikografisches Vergleichen an. </div>
<div class="text"><ul><li><b>Lexikografisches Vergleichen</b></li></ul></div>
<div class="text">Lexikografisches Vergleichen bedeutet in diesem Fall, dass alle Basisklassen von links nach rechts verglichen werden und alle nichtstatischen Mitglieder der Klasse in ihrer Deklarationsreihenfolge. Hier muss ich gleich ein wenig einschränken: Aus Performanzgründen verhalten sich der ==- und der !=-Operator anders in C++20. Ich werde auf die Ausnahme der Regel noch in meinem nächsten Artikel eingehen.</div>
<div class="text">Der Artikel "<a class="" title="Link auf https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/" href="https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/" alt="%7B%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fdevblogs.microsoft.com%2Fcppblog%2Fsimplify-your-code-with-rocket-science-c20s-spaceship-operator%2F%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fdevblogs.microsoft.com%2Fcppblog%2Fsimplify-your-code-with-rocket-science-c20s-spaceship-operator%2F%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22text%22%3A%22Simplify%20Your%20Code%20With%20Rocket%20Science%3A%20C%2B%2B20%C2%92s%20Spaceship%20Operator%22%2C%22custom%22%3A%7B%7D%7D">Simplify Your Code With Rocket Science: C++20’s Spaceship Operator</a>" auf Microsofts C++ Team Blog stellt ein beeindruckendes Beispiel für lexikografisches Vergleichen vor:</div>
<div class="pre">struct Basics {<br>&nbsp; int i;<br>&nbsp; char c;<br>&nbsp; float f;<br>&nbsp; double d;<br>&nbsp; auto operator&lt;=&gt;(const Basics&amp;) const = default;<br>};<br><br>struct Arrays {<br>&nbsp; int ai[1];<br>&nbsp; char ac[2];<br>&nbsp; float af[3];<br>&nbsp; double ad[2][2];<br>&nbsp; auto operator&lt;=&gt;(const Arrays&amp;) const = default;<br>};<br><br>struct Bases : Basics, Arrays {<br>&nbsp; auto operator&lt;=&gt;(const Bases&amp;) const = default;<br>};<br><br>int main() {<br>&nbsp; constexpr Bases a = { { 0, 'c', 1.f, 1. },&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { { 1 }, { 'a', 'b' }, { 1.f, 2.f, 3.f }, { { 1., 2. }, { 3., 4. } } } };<br>&nbsp; constexpr Bases b = { { 0, 'c', 1.f, 1. },&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { { 1 }, { 'a', 'b' }, { 1.f, 2.f, 3.f }, { { 1., 2. }, { 3., 4. } } } };<br>&nbsp; static_assert(a == b);<br>&nbsp; static_assert(!(a != b));<br>&nbsp; static_assert(!(a &lt; b));<br>&nbsp; static_assert(a &lt;= b);<br>&nbsp; static_assert(!(a &gt; b));<br>&nbsp; static_assert(a &gt;= b);<br>}</div>
<div class="text">Ich denke, der anspruchsvollste Aspekt des Programms ist nicht der Spaceship Operator, sondern die Initialisierung von <span class="tx_code">Base</span> mittels Aggregat-Initialisierung (1). Sie erlaubt das direkte Initialisieren der Mitglieder eines Klassentyps (<span class="tx_code">class, struct, union</span>), wenn diese Mitglieder alle <span class="tx_code">public</span> sind. In diesem Fall können einfach geschweifte Klammern verwendet werden. Wenn du mehr zur Aggregat-Initialisierung wissen möchtest, bietet <a class="" title="Link auf https://en.cppreference.com/w/cpp/language/aggregate_initialization" href="https://en.cppreference.com/w/cpp/language/aggregate_initialization" alt="%7B%22text%22%3A%22cppreference.com%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Faggregate_initialization%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Faggregate_initialization%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%7D">cppreference.com</a> genau diese Information an. Ich werde die Aggregat-Initialisierung in einem zukünftigen Blogartikel genauer vorstellen, wenn ich mich mit der Designated Initialization in C++20 beschäftige. </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Der Compiler führt einen sehr smarten, fast schon magischen Job aus, wenn er alle Operatoren erzeugt. Am Ende erhält der Anwender die sich intuitiv und effizient verhaltenden Operatoren geschenkt. In meinem nächsten Artikel schaue ich mir die Magie unter der Haube genauer an.<br></div>
