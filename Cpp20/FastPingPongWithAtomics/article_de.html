<div class="vorspann">Nach Einführen des <span class="tx_code">std::atomic_flag</span> in meinem letzten Artikel "<a title="Link auf Beitrag 3022332" alt="%7B%22type%22%3A%22B%22%2C%22text%22%3A%22Synchronisation%20mit%20atomaren%20Variablen%20in%20C%2B%2B20%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D8d408ee698fb33fe8bf7243ba8b02ed8%26rm%3Dopen_article_id%26bid%3D3022332%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A3022332%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%7D" href="/exec/mainmenu.pl?sid=8d408ee698fb33fe8bf7243ba8b02ed8&amp;rm=open_article_id&amp;bid=3022332" class="">Synchronisation mit atomaren Variablen in C++20</a>" möchte ich nun tiefer eintauchen. Heute implementiere ich ein Ping-Pong-Spiel mit Bedingungsvariablen: <span class="tx_code">std::atomic_flag</span> und <span class="tx_code">std::atomic&lt;bool&gt;</span>. Los geht das Spiel!</div>
<div class="text">Die zentrale Frage, die ich in diesem Artikel beantworten will, ist folgende: Auf welche Art lassen sich am schnellsten Threads in C++20 synchronisieren? Ich verwende dazu drei verschiedene Datentypen: <span class="tx_code">std::condition_variable</span>, <span class="tx_code">std::atomic_flag</span> und <span class="tx_code">std::atomic&lt;bool&gt;</span>. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/3/5/7/5/6/TN_205187815_d2492988bc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Um vergleichbare Zahlen zu erhalten, implementiere ich ein Ping-Pong-Spiel. Ein Thread führt dazu eine <span class="tx_code">ping</span>-Funktion und ein anderer eine <span class="tx_code">pong-</span>Funktion aus. Der Einfachheit halber nenne ich den Thread, der die <span class="tx_code">ping</span>-Funktion ausführt Ping-Thread und den anderen Pong-Thread. Der Ping-Thread wartet bei dem Spiel auf die Benachrichtigung des Pong-Thread. Der Pong-Thread schickt wiederum die Benachrichtigung zurück. Das Spiel soll nach 1.000.000 Ballwechseln beendet sein. Jedes Spiel führe ich fünfmal aus, um vergleichbare Performanzzahlen zu erhalten.</div>
<div class="text">Den Performanztest habe ich mit einem aktuellen Visual Studio Compiler durchgeführt, der bereits die Synchronisation mit Atomics unterstützt. Zusätzlich ist das Programm mit maximaler Optimierung (<span class="tx_code">/Ox</span>) übersetzt.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/3/5/7/5/6/TN_205187820_63ac564260.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Los geht das Spiel mit einer Umsetzung in C++11.</div>
<div class="ztitel">Bedingungsvariablen<br></div>
<div class="pre">// pingPongConditionVariable.cpp<br><br>#include &lt;condition_variable&gt;<br>#include &lt;iostream&gt;<br>#include &lt;atomic&gt;<br>#include &lt;thread&gt;<br><br>bool dataReady{false};<br><br>std::mutex mutex_;<br>std::condition_variable condVar1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>std::condition_variable condVar2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>std::atomic&lt;int&gt; counter{};<br>constexpr int countlimit = 1'000'000;<br><br>void ping() {<br><br>&nbsp;&nbsp;&nbsp; while(counter &lt;= countlimit) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condVar1.wait(lck, []{return dataReady == false;});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataReady = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++counter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condVar2.notify_one();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; }<br>}<br><br>void pong() {<br><br>&nbsp;&nbsp;&nbsp; while(counter &lt; countlimit) { &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condVar2.wait(lck, []{return dataReady == true;});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataReady = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condVar1.notify_one();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; }<br><br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; auto start = std::chrono::system_clock::now(); &nbsp;<br><br>&nbsp;&nbsp;&nbsp; std::thread t1(ping);<br>&nbsp;&nbsp;&nbsp; std::thread t2(pong);<br><br>&nbsp;&nbsp;&nbsp; t1.join();<br>&nbsp;&nbsp;&nbsp; t2.join();<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; dur = std::chrono::system_clock::now() - start;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Duration: " &lt;&lt; dur.count() &lt;&lt; " seconds" &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Ich verwende in dem Beispiel zwei Bedingungsvariablen: <span class="tx_code">condVar1</span> und <span class="tx_code">condVar2</span> (Zeile 1 und 2). Der Ping-Thread wartet auf die Benachrichtigung durch <span class="tx_code">convVar1</span> und schickt seine Benachrichtigung mit <span class="tx_code">condVar2</span>. <span class="tx_code">dataReady</span> ist der Schutz gegen spurious wakeups und lost wakeups (siehe "<a title="Link auf Beitrag 2435822" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Sei%20dir%20der%20Fallen%20von%20Bedingungsvariablen%20bewusst%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D8d408ee698fb33fe8bf7243ba8b02ed8%26rm%3Dopen_article_id%26bid%3D2435822%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22destination%22%3A2435822%2C%22target%22%3A%22_blank%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%7D" href="/exec/mainmenu.pl?sid=8d408ee698fb33fe8bf7243ba8b02ed8&amp;rm=open_article_id&amp;bid=2435822" class="">C++ Core Guidelines: Sei dir der Fallen von Bedingungsvariablen bewusst</a>"). Das Ping-Pong-Spiel endet, wenn der <span class="tx_code">counter</span> <span class="tx_code">countlimit</span> erreicht. Die Aufrufe <span class="tx_code">notification_one</span> (Zeile 3) und der <span class="tx_code">counter</span> sind Thread-sicher und befinden sich daher außerhalb des kritischen Bereichs. </div>
<div class="text">Hier sind die Zahlen:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/3/5/7/5/6/TN_205187836_7043cb46bc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die durchschnittliche Ausführungszeit beträgt 0,52 Sekunden.</div>
<div class="text"><span class="tx_code">std::atomic_flag</span></div>
<div class="text">Dieses Spiel lässt sich einfach mit dem <span class="tx_code">std::atomic_flag</span> in C++20 umsetzen. Zuerst implementiere ich das Spiel, das auf zwei<span class="tx_code"> std::atomic_flag</span> basiert. </div>
<div class="ztitel_kleiner">Spielvariante mit zwei atomaren Flags</div>
<div class="text">Im folgenden Programm ersetze ich das Warten auf die Bedingungsvariable durch das Warten auf das atomare Flag und die Benachrichtigung durch die Bedingungsvariable durch das Setzen des atomaren Flags, auf das die Benachrichtigung unmittelbar folgt.</div>
<div class="pre">// pingPongAtomicFlags.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;atomic&gt;<br>#include &lt;thread&gt;<br><br>std::atomic_flag condAtomicFlag1{};<br>std::atomic_flag condAtomicFlag2{};<br><br>std::atomic&lt;int&gt; counter{};<br>constexpr int countlimit = 1'000'000;<br><br>void ping() {<br>&nbsp;&nbsp;&nbsp; while(counter &lt;= countlimit) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condAtomicFlag1.wait(false);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condAtomicFlag1.clear();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++counter;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condAtomicFlag2.test_and_set();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condAtomicFlag2.notify_one();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>void pong() {<br>&nbsp;&nbsp;&nbsp; while(counter &lt; countlimit) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condAtomicFlag2.wait(false);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condAtomicFlag2.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condAtomicFlag1.test_and_set();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condAtomicFlag1.notify_one();<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp; auto start = std::chrono::system_clock::now(); &nbsp;<br><br>&nbsp;&nbsp;&nbsp; condAtomicFlag1.test_and_set();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; std::thread t1(ping);<br>&nbsp;&nbsp;&nbsp; std::thread t2(pong);<br><br>&nbsp;&nbsp;&nbsp; t1.join();<br>&nbsp;&nbsp;&nbsp; t2.join();<br><br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; dur = std::chrono::system_clock::now() - start;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Duration: " &lt;&lt; dur.count() &lt;&lt; " seconds" &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Der Aufruf <span class="tx_code">condAtomicFlag1.wait(false)</span> (1) blockiert, falls der Wert des atomaren Flags <span class="tx_code">false</span> ist. Im Gegensatz dazu kommt der Aufruf zurück, falls das <span class="tx_code">condAtomicFlag1</span> den Wert <span class="tx_code">true</span> besitzt. Der Wahrheitswert dient als ein Prädikat und muss daher auf <span class="tx_code">false</span> zurückgesetzt werden (2). Bevor die Benachrichtigung (3) an den Pong-Thread geschickt wird, wird <span class="tx_code">condAtomicFlag1</span> auf <span class="tx_code">true</span> gesetzt. Das initiale Setzen von <span class="tx_code">condAtomicFlag1</span> auf <span class="tx_code">true</span> (5) startet das Spiel</div>
<div class="text">Dank <span class="tx_code">std::atomic_flag</span> ist das Spiel früher beendet:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/3/5/7/5/6/TN_205187842_46dd09e284.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Im Durchschnitt benötigt ein Spiel 0,32 Sekunden.</div>
<div class="text">Wer das Programm genauer unter die Lupe nimmt, stellt fest, dass ein atomares Flag für das Spiel ausreichend ist. </div>
<div class="ztitel_kleiner">Spielvariante mit einem atomaren Flag</div>
<div class="text">Durch Verwenden nur eines atomaren Flags ist das Spiel einfacher verständlich.</div>
<div class="pre">// pingPongAtomicFlag.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;atomic&gt;<br>#include &lt;thread&gt;<br><br>std::atomic_flag condAtomicFlag{};<br><br>std::atomic&lt;int&gt; counter{};<br>constexpr int countlimit = 1'000'000;<br><br>void ping() {<br>&nbsp;&nbsp;&nbsp; while(counter &lt;= countlimit) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condAtomicFlag.wait(true);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condAtomicFlag.test_and_set();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++counter;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condAtomicFlag.notify_one();<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>void pong() {<br>&nbsp;&nbsp;&nbsp; while(counter &lt; countlimit) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condAtomicFlag.wait(false);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condAtomicFlag.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condAtomicFlag.notify_one();<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp; auto start = std::chrono::system_clock::now(); &nbsp;<br><br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; condAtomicFlag.test_and_set();<br>&nbsp;&nbsp;&nbsp; std::thread t1(ping);<br>&nbsp;&nbsp;&nbsp; std::thread t2(pong);<br><br>&nbsp;&nbsp;&nbsp; t1.join();<br>&nbsp;&nbsp;&nbsp; t2.join();<br><br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; dur = std::chrono::system_clock::now() - start;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Duration: " &lt;&lt; dur.count() &lt;&lt; " seconds" &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">In diesem Fall blockiert der Ping-Thread beim Status <span class="tx_code">true</span> und der Pong-Thread beim Status <span class="tx_code">false</span>. Durch die Performanzbrille betrachtet, sind beide Varianten mit einem oder zwei atomaren Flags gleich schnell. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/3/5/7/5/6/TN_205187849_8c036aba32.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die durchschnittliche Ausführungszeit beträgt 0,31 Sekunden.</div>
<div class="text">In dem Beispiel habe ich das<span class="tx_code"> std::atomic_flag</span> wie ein atomares Bool verwendet. Daher möchte ich noch ein <span class="tx_code">std::atomic&lt;bool&gt;</span> für die Implementierung des Spiels einsetzen. </div>
<div class="ztitel">std::atomic&lt;bool&gt;</div>
<div class="text">Aus der Perspektive der Lesbarkeit betrachtet, präferiere ich die Umsetzung des Spiels in C++20 mit <span class="tx_code">std::atomic&lt;bool&gt;</span>. </div>
<div class="pre">// pingPongAtomicBool.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;atomic&gt;<br>#include &lt;thread&gt;<br><br>std::atomic&lt;bool&gt; atomicBool{};<br><br>std::atomic&lt;int&gt; counter{};<br>constexpr int countlimit = 1'000'000;<br><br>void ping() {<br>&nbsp;&nbsp;&nbsp; while(counter &lt;= countlimit) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomicBool.wait(true);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomicBool.store(true);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++counter;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomicBool.notify_one();<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>void pong() {<br>&nbsp;&nbsp;&nbsp; while(counter &lt; countlimit) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomicBool.wait(false);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomicBool.store(false);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomicBool.notify_one();<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "atomicBool.is_lock_free(): "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; atomicBool.is_lock_free()&nbsp; &lt;&lt; std::endl; <br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; auto start = std::chrono::system_clock::now();<br><br>&nbsp;&nbsp;&nbsp; atomicBool.store(true);<br>&nbsp;&nbsp;&nbsp; std::thread t1(ping);<br>&nbsp;&nbsp;&nbsp; std::thread t2(pong);<br><br>&nbsp;&nbsp;&nbsp; t1.join();<br>&nbsp;&nbsp;&nbsp; t2.join();<br><br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; dur = std::chrono::system_clock::now() - start;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Duration: " &lt;&lt; dur.count() &lt;&lt; " seconds" &lt;&lt; std::endl;<br><br>}</div>
<div class="text"><span class="tx_code">std::atomic&lt;bool&gt;</span> kann intern einen Locking-Mechanismus wie ein Mutex verwenden. Wie ich es vermutet habe, trifft dies auf meiner Windows-Laufzeit nicht zu (1).</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/3/5/7/5/6/TN_205187853_cc2385b80f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:8 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Im Durchschnitt beträgt die Ausführungszeit 0,38 Sekunden.</div>
<div class="ztitel">Alle Zahlen im Vergleich<br></div>
<div class="text">Wie vermutet, stellen Bedingungsvariablen die langsamste und atomare Flags die schnellste Art dar, Threads zu synchronisieren. Die Performanz von <span class="tx_code">std::atomic&lt;bool&gt;</span> liegt dazwischen. Es gibt aber einen Nachteil von <span class="tx_code">std::atomic&lt;bool&gt;</span>. Nur für <span class="tx_code">std::atomic_flag</span> sichert der C++-Standard zu, dass sie Lock-frei sind.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/3/5/7/5/6/TN_205187869_44dd8551a0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:10 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">C++20 bietet weitere Mechanismen, um Threads zu koordinieren. Darunter finden sich Latches, Barriers und Semaphoren. Mit ihnen lässt sich auch ein schnelles Ping-Pong-Spiel umsetzen.<br></div>