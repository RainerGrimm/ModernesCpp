<div class="vorspann">Wenn das Kompilieren eines Programms mit einem hochaktuellen Feature von C++20 fehlschlägt, gibt es ein paar Fragen zu klären: Besitzt das Programm einen Fehler? Oder der Compiler einen Bug? Unterstützt der Compiler das Feature noch nicht? Dank der Möglichkeit, mit C++20 den Compiler explizit auf seine Standardunterstützung zu prüfen, ist die letzte Frage schnell beantwortet.<br></div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/0/4/3/1/TN_203038868_dd69621dd6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Wenn ich mit aktuellen C++-Featuresn experimentiere, prüfe ich zuerst, welcher Compiler das Feature bereits unterstützt. Genau zu dem Zeitpunkt besuche ich die Seite <a alt="%7B%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcompiler_support%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcompiler_support%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22text%22%3A%22cppreference.com%22%2C%22subject%22%3A%22%22%7D" class="" href="https://en.cppreference.com/w/cpp/compiler_support" title="Link auf https://en.cppreference.com/w/cpp/compiler_support">cppreference.com</a>, suche das gewünschte Feature und hoffe, dass zumindest ein Compiler der drei Großen (GCC, Clang und MSVC) das neue Feature bereits anbietet.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/0/4/3/1/TN_203038876_392deb6979.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Falls ich als Antwort "teilweise" erhalte, ist das nicht zufriedenstellend. Am Ende weiß ich nicht, wer dafür verantwortlich ist, wenn sich der Sourcecode nicht übersetzen lässt. Es gibt aber einen cleveren Weg herauszubekommen, ob ein Compiler ein bestimmtes Feature unterstützt.<br></div>
<div class="ztitel">Prüfen von C++-Features<br></div>
<div class="text">Die Header-Datei <span class="tx_code">&lt;version&gt;</span> erlaubt es, den Compiler nach seiner Unterstützung der Features des C++20-Standards und späterer Standards zu fragen. Dabei lässt sich nach Attributen, Features der Kernsprache oder der Bibliothek fragen. <span class="tx_code">&lt;version&gt;</span> besitzt dazu um die 200 Makros, die sich zu Zahlen expandieren, falls das Feature unterstützt wird. Die Zahl steht für die Jahreszahl und den Monat, in dem das Feature zum neuen C++-Standard hinzugefügt wurde. Das sind die Zahlen für <span class="tx_code">static_asser</span><span class="tx_code">t</span>, Lambdas und Concepts:</div>
<div class="pre">__cpp_static_assert&nbsp; 200410L<br>__cpp_lambdas&nbsp; 200907L<br>__cpp_concepts 201907L</div>
<div class="text">Die cppreference.com-Seite zum <a alt="%7B%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ffeature_test%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ffeature_test%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Feature%20Testing%22%2C%22subject%22%3A%22%22%7D" class="" href="https://en.cppreference.com/w/cpp/feature_test" title="Link auf https://en.cppreference.com/w/cpp/feature_test">Feature Testing</a> bietet ein langes Programm an, um alle Makros abzufragen.:<br></div>
<div class="pre">// featureTest.cpp<br>// from cppreference.com<br><br>#if __cplusplus &lt; 201100<br>#&nbsp; error "C++11 or better is required"<br>#endif<br>&nbsp;<br>#include &lt;algorithm&gt;<br>#include &lt;cstring&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>&nbsp;<br>#ifdef __has_include<br># if __has_include(&lt;version&gt;)<br>#&nbsp;&nbsp; include &lt;version&gt;<br># endif<br>#endif<br>&nbsp;<br>#define COMPILER_FEATURE_VALUE(value) #value<br>#define COMPILER_FEATURE_ENTRY(name) { #name, COMPILER_FEATURE_VALUE(name) },<br>&nbsp;<br>#ifdef __has_cpp_attribute<br># define COMPILER_ATTRIBUTE_VALUE_AS_STRING(s) #s<br># define COMPILER_ATTRIBUTE_AS_NUMBER(x) COMPILER_ATTRIBUTE_VALUE_AS_STRING(x)<br># define COMPILER_ATTRIBUTE_ENTRY(attr) \<br>&nbsp; { #attr, COMPILER_ATTRIBUTE_AS_NUMBER(__has_cpp_attribute(attr)) },<br>#else<br># define COMPILER_ATTRIBUTE_ENTRY(attr) { #attr, "_" },<br>#endif<br>&nbsp;<br>// Change these options to print out only necessary info.<br>static struct PrintOptions {<br>&nbsp;&nbsp;&nbsp; constexpr static bool titles&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1;<br>&nbsp;&nbsp;&nbsp; constexpr static bool attributes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1;<br>&nbsp;&nbsp;&nbsp; constexpr static bool general_features&nbsp;&nbsp;&nbsp;&nbsp; = 1;<br>&nbsp;&nbsp;&nbsp; constexpr static bool core_features&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1;<br>&nbsp;&nbsp;&nbsp; constexpr static bool lib_features&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1;<br>&nbsp;&nbsp;&nbsp; constexpr static bool supported_features&nbsp;&nbsp; = 1;<br>&nbsp;&nbsp;&nbsp; constexpr static bool unsupported_features = 1;<br>&nbsp;&nbsp;&nbsp; constexpr static bool sorted_by_value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;<br>&nbsp;&nbsp;&nbsp; constexpr static bool cxx11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1;<br>&nbsp;&nbsp;&nbsp; constexpr static bool cxx14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1;<br>&nbsp;&nbsp;&nbsp; constexpr static bool cxx17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1;<br>&nbsp;&nbsp;&nbsp; constexpr static bool cxx20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1;<br>&nbsp;&nbsp;&nbsp; constexpr static bool cxx23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;<br>}&nbsp;&nbsp; print;<br>&nbsp;<br>struct CompilerFeature {<br>&nbsp;&nbsp;&nbsp; CompilerFeature(const char* name = nullptr, const char* value = nullptr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : name(name), value(value) {}<br>&nbsp;&nbsp;&nbsp; const char* name; const char* value;<br>};<br>&nbsp;<br>static CompilerFeature cxx[] = {<br>COMPILER_FEATURE_ENTRY(__cplusplus)<br>COMPILER_FEATURE_ENTRY(__cpp_exceptions)<br>COMPILER_FEATURE_ENTRY(__cpp_rtti)<br>#if 0 <br>COMPILER_FEATURE_ENTRY(__GNUC__)<br>COMPILER_FEATURE_ENTRY(__GNUC_MINOR__)<br>COMPILER_FEATURE_ENTRY(__GNUC_PATCHLEVEL__)<br>COMPILER_FEATURE_ENTRY(__GNUG__)<br>COMPILER_FEATURE_ENTRY(__clang__)<br>COMPILER_FEATURE_ENTRY(__clang_major__)<br>COMPILER_FEATURE_ENTRY(__clang_minor__)<br>COMPILER_FEATURE_ENTRY(__clang_patchlevel__)<br>#endif<br>};<br>static CompilerFeature cxx11[] = {<br>COMPILER_FEATURE_ENTRY(__cpp_alias_templates)<br>COMPILER_FEATURE_ENTRY(__cpp_attributes)<br>COMPILER_FEATURE_ENTRY(__cpp_constexpr)<br>COMPILER_FEATURE_ENTRY(__cpp_decltype)<br>COMPILER_FEATURE_ENTRY(__cpp_delegating_constructors)<br>COMPILER_FEATURE_ENTRY(__cpp_inheriting_constructors)<br>COMPILER_FEATURE_ENTRY(__cpp_initializer_lists)<br>COMPILER_FEATURE_ENTRY(__cpp_lambdas)<br>COMPILER_FEATURE_ENTRY(__cpp_nsdmi)<br>COMPILER_FEATURE_ENTRY(__cpp_range_based_for)<br>COMPILER_FEATURE_ENTRY(__cpp_raw_strings)<br>COMPILER_FEATURE_ENTRY(__cpp_ref_qualifiers)<br>COMPILER_FEATURE_ENTRY(__cpp_rvalue_references)<br>COMPILER_FEATURE_ENTRY(__cpp_static_assert)<br>COMPILER_FEATURE_ENTRY(__cpp_threadsafe_static_init)<br>COMPILER_FEATURE_ENTRY(__cpp_unicode_characters)<br>COMPILER_FEATURE_ENTRY(__cpp_unicode_literals)<br>COMPILER_FEATURE_ENTRY(__cpp_user_defined_literals)<br>COMPILER_FEATURE_ENTRY(__cpp_variadic_templates)<br>};<br>static CompilerFeature cxx14[] = {<br>COMPILER_FEATURE_ENTRY(__cpp_aggregate_nsdmi)<br>COMPILER_FEATURE_ENTRY(__cpp_binary_literals)<br>COMPILER_FEATURE_ENTRY(__cpp_constexpr)<br>COMPILER_FEATURE_ENTRY(__cpp_decltype_auto)<br>COMPILER_FEATURE_ENTRY(__cpp_generic_lambdas)<br>COMPILER_FEATURE_ENTRY(__cpp_init_captures)<br>COMPILER_FEATURE_ENTRY(__cpp_return_type_deduction)<br>COMPILER_FEATURE_ENTRY(__cpp_sized_deallocation)<br>COMPILER_FEATURE_ENTRY(__cpp_variable_templates)<br>};<br>static CompilerFeature cxx14lib[] = {<br>COMPILER_FEATURE_ENTRY(__cpp_lib_chrono_udls)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_complex_udls)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_exchange_function)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_generic_associative_lookup)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_integer_sequence)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_integral_constant_callable)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_is_final)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_is_null_pointer)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_make_reverse_iterator)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_make_unique)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_null_iterators)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_quoted_string_io)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_result_of_sfinae)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_robust_nonmodifying_seq_ops)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_shared_timed_mutex)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_string_udls)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_transformation_trait_aliases)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_transparent_operators)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_tuple_element_t)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_tuples_by_type)<br>};<br>&nbsp;<br>static CompilerFeature cxx17[] = {<br>COMPILER_FEATURE_ENTRY(__cpp_aggregate_bases)<br>COMPILER_FEATURE_ENTRY(__cpp_aligned_new)<br>COMPILER_FEATURE_ENTRY(__cpp_capture_star_this)<br>COMPILER_FEATURE_ENTRY(__cpp_constexpr)<br>COMPILER_FEATURE_ENTRY(__cpp_deduction_guides)<br>COMPILER_FEATURE_ENTRY(__cpp_enumerator_attributes)<br>COMPILER_FEATURE_ENTRY(__cpp_fold_expressions)<br>COMPILER_FEATURE_ENTRY(__cpp_guaranteed_copy_elision)<br>COMPILER_FEATURE_ENTRY(__cpp_hex_float)<br>COMPILER_FEATURE_ENTRY(__cpp_if_constexpr)<br>COMPILER_FEATURE_ENTRY(__cpp_inheriting_constructors)<br>COMPILER_FEATURE_ENTRY(__cpp_inline_variables)<br>COMPILER_FEATURE_ENTRY(__cpp_namespace_attributes)<br>COMPILER_FEATURE_ENTRY(__cpp_noexcept_function_type)<br>COMPILER_FEATURE_ENTRY(__cpp_nontype_template_args)<br>COMPILER_FEATURE_ENTRY(__cpp_nontype_template_parameter_auto)<br>COMPILER_FEATURE_ENTRY(__cpp_range_based_for)<br>COMPILER_FEATURE_ENTRY(__cpp_static_assert)<br>COMPILER_FEATURE_ENTRY(__cpp_structured_bindings)<br>COMPILER_FEATURE_ENTRY(__cpp_template_template_args)<br>COMPILER_FEATURE_ENTRY(__cpp_variadic_using)<br>};<br>static CompilerFeature cxx17lib[] = {<br>COMPILER_FEATURE_ENTRY(__cpp_lib_addressof_constexpr)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_allocator_traits_is_always_equal)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_any)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_apply)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_array_constexpr)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_as_const)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_atomic_is_always_lock_free)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_bool_constant)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_boyer_moore_searcher)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_byte)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_chrono)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_clamp)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_enable_shared_from_this)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_execution)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_filesystem)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_gcd_lcm)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_hardware_interference_size)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_has_unique_object_representations)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_hypot)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_incomplete_container_elements)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_invoke)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_is_aggregate)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_is_invocable)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_is_swappable)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_launder)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_logical_traits)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_make_from_tuple)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_map_try_emplace)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_math_special_functions)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_memory_resource)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_node_extract)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_nonmember_container_access)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_not_fn)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_optional)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_parallel_algorithm)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_raw_memory_algorithms)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_sample)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_scoped_lock)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_shared_mutex)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_shared_ptr_arrays)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_shared_ptr_weak_type)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_string_view)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_to_chars)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_transparent_operators)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_type_trait_variable_templates)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_uncaught_exceptions)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_unordered_map_try_emplace)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_variant)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_void_t)<br>};<br>&nbsp;<br>static CompilerFeature cxx20[] = {<br>COMPILER_FEATURE_ENTRY(__cpp_aggregate_paren_init)<br>COMPILER_FEATURE_ENTRY(__cpp_char8_t)<br>COMPILER_FEATURE_ENTRY(__cpp_concepts)<br>COMPILER_FEATURE_ENTRY(__cpp_conditional_explicit)<br>COMPILER_FEATURE_ENTRY(__cpp_consteval)<br>COMPILER_FEATURE_ENTRY(__cpp_constexpr)<br>COMPILER_FEATURE_ENTRY(__cpp_constexpr_dynamic_alloc)<br>COMPILER_FEATURE_ENTRY(__cpp_constexpr_in_decltype)<br>COMPILER_FEATURE_ENTRY(__cpp_constinit)<br>COMPILER_FEATURE_ENTRY(__cpp_deduction_guides)<br>COMPILER_FEATURE_ENTRY(__cpp_designated_initializers)<br>COMPILER_FEATURE_ENTRY(__cpp_generic_lambdas)<br>COMPILER_FEATURE_ENTRY(__cpp_impl_coroutine)<br>COMPILER_FEATURE_ENTRY(__cpp_impl_destroying_delete)<br>COMPILER_FEATURE_ENTRY(__cpp_impl_three_way_comparison)<br>COMPILER_FEATURE_ENTRY(__cpp_init_captures)<br>COMPILER_FEATURE_ENTRY(__cpp_modules)<br>COMPILER_FEATURE_ENTRY(__cpp_nontype_template_args)<br>COMPILER_FEATURE_ENTRY(__cpp_using_enum)<br>};<br>static CompilerFeature cxx20lib[] = {<br>COMPILER_FEATURE_ENTRY(__cpp_lib_array_constexpr)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_assume_aligned)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_atomic_flag_test)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_atomic_float)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_atomic_lock_free_type_aliases)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_atomic_ref)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_atomic_shared_ptr)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_atomic_value_initialization)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_atomic_wait)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_barrier)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_bind_front)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_bit_cast)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_bitops)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_bounded_array_traits)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_char8_t)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_chrono)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_concepts)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_constexpr_algorithms)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_constexpr_complex)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_constexpr_dynamic_alloc)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_constexpr_functional)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_constexpr_iterator)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_constexpr_memory)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_constexpr_numeric)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_constexpr_string)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_constexpr_string_view)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_constexpr_tuple)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_constexpr_utility)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_constexpr_vector)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_coroutine)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_destroying_delete)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_endian)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_erase_if)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_execution)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_format)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_generic_unordered_lookup)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_int_pow2)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_integer_comparison_functions)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_interpolate)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_is_constant_evaluated)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_is_layout_compatible)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_is_nothrow_convertible)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_is_pointer_interconvertible)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_jthread)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_latch)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_list_remove_return_type)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_math_constants)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_polymorphic_allocator)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_ranges)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_remove_cvref)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_semaphore)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_shared_ptr_arrays)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_shift)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_smart_ptr_for_overwrite)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_source_location)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_span)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_ssize)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_starts_ends_with)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_string_view)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_syncbuf)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_three_way_comparison)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_to_address)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_to_array)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_type_identity)<br>COMPILER_FEATURE_ENTRY(__cpp_lib_unwrap_ref)<br>};<br>&nbsp;<br>static CompilerFeature cxx23[] = {<br>COMPILER_FEATURE_ENTRY(__cpp_cxx23_stub) //&lt; Populate eventually<br>};<br>static CompilerFeature cxx23lib[] = {<br>COMPILER_FEATURE_ENTRY(__cpp_lib_cxx23_stub) //&lt; Populate eventually<br>};<br>&nbsp;<br>static CompilerFeature attributes[] = {<br>COMPILER_ATTRIBUTE_ENTRY(carries_dependency)<br>COMPILER_ATTRIBUTE_ENTRY(deprecated)<br>COMPILER_ATTRIBUTE_ENTRY(fallthrough)<br>COMPILER_ATTRIBUTE_ENTRY(likely)<br>COMPILER_ATTRIBUTE_ENTRY(maybe_unused)<br>COMPILER_ATTRIBUTE_ENTRY(nodiscard)<br>COMPILER_ATTRIBUTE_ENTRY(noreturn)<br>COMPILER_ATTRIBUTE_ENTRY(no_unique_address)<br>COMPILER_ATTRIBUTE_ENTRY(unlikely)<br>};<br>&nbsp;<br>constexpr bool is_feature_supported(const CompilerFeature&amp; x) {<br>&nbsp;&nbsp;&nbsp; return x.value[0] != '_' &amp;&amp; x.value[0] != '0' ;<br>}<br>&nbsp;<br>inline void print_compiler_feature(const CompilerFeature&amp; x) {<br>&nbsp;&nbsp;&nbsp; constexpr static int max_name_length = 44; //&lt; Update if necessary<br>&nbsp;&nbsp;&nbsp; std::string value{ is_feature_supported(x) ? x.value : "------" };<br>&nbsp;&nbsp;&nbsp; if (value.back() == 'L') value.pop_back(); //~ 201603L -&gt; 201603<br>&nbsp;&nbsp;&nbsp; // value.insert(4, 1, '-'); //~ 201603 -&gt; 2016-03<br>&nbsp;&nbsp;&nbsp; if ( (print.supported_features &amp;&amp; is_feature_supported(x))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (print.unsupported_features &amp;&amp; !is_feature_supported(x))) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::left &lt;&lt; std::setw(max_name_length)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; x.name &lt;&lt; " " &lt;&lt; value &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>}<br>&nbsp;<br>template&lt;size_t N&gt;<br>inline void show(char const* title, CompilerFeature (&amp;features)[N]) {<br>&nbsp;&nbsp;&nbsp; if (print.titles) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n' &lt;&lt; std::left &lt;&lt; title &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; if (print.sorted_by_value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::sort(std::begin(features), std::end(features),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](CompilerFeature const&amp; lhs, CompilerFeature const&amp; rhs) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::strcmp(lhs.value, rhs.value) &lt; 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; for (const CompilerFeature&amp; x : features) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_compiler_feature(x);<br>&nbsp;&nbsp;&nbsp; }<br>}<br>&nbsp;<br>int main() {<br>&nbsp;&nbsp;&nbsp; if (print.general_features) show("C++ GENERAL", cxx);<br>&nbsp;&nbsp;&nbsp; if (print.cxx11 &amp;&amp; print.core_features) show("C++11 CORE", cxx11);<br>&nbsp;&nbsp;&nbsp; if (print.cxx14 &amp;&amp; print.core_features) show("C++14 CORE", cxx14);<br>&nbsp;&nbsp;&nbsp; if (print.cxx14 &amp;&amp; print.lib_features ) show("C++14 LIB" , cxx14lib);<br>&nbsp;&nbsp;&nbsp; if (print.cxx17 &amp;&amp; print.core_features) show("C++17 CORE", cxx17);<br>&nbsp;&nbsp;&nbsp; if (print.cxx17 &amp;&amp; print.lib_features ) show("C++17 LIB" , cxx17lib);<br>&nbsp;&nbsp;&nbsp; if (print.cxx20 &amp;&amp; print.core_features) show("C++20 CORE", cxx20);<br>&nbsp;&nbsp;&nbsp; if (print.cxx20 &amp;&amp; print.lib_features ) show("C++20 LIB" , cxx20lib);<br>&nbsp;&nbsp;&nbsp; if (print.cxx23 &amp;&amp; print.core_features) show("C++23 CORE", cxx23);<br>&nbsp;&nbsp;&nbsp; if (print.cxx23 &amp;&amp; print.lib_features ) show("C++23 LIB" , cxx23lib);<br>&nbsp;&nbsp;&nbsp; if (print.attributes) show("ATTRIBUTES", attributes);<br>}</div>
<div class="text">Die Länge des Sourcefiles ist überwältigend. Mehr Information zu jedem Makro gibt es auf der <a alt="%7B%22text%22%3A%22Feature-Testing%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ffeature_test%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ffeature_test%22%2C%22user_params%22%3A%22%22%7D" class="" href="https://en.cppreference.com/w/cpp/feature_test" title="Link auf https://en.cppreference.com/w/cpp/feature_test">Feature-Testing</a>-Seite. Insbesondere steht bei jedem Makro ein Link, der auf mehr Information zum Feature verweist. Zum Beispiel ist das die Tabelle zu den Attributen:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/0/4/3/1/TN_203038882_33877ec99a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Zum Abschluss meiner Vorstellung der Header-Datei <span class="tx_code">&lt;version&gt;</span> und seiner Makros möchte ich gerne noch das Programm auf einem hochaktuellen GCC-, Clang- und Microsoft-Compiler ausführen. Aus verständlichen Gründen stelle ich nur die Ausgabe der C++20-Kernsprachenfeatures vor. Für GCC und Clang habe ich den Compiler Explorer verwendet. Auf Windows musste ich zusätzlich das Präprozessor-Makro mit dem Flag <span class="tx_code">/Zc:__cplusplus</span> freischalten. Auf allen drei Plattformen habe ich mit C++20-Unterstützung kompiliert.<br></div>
<div class="vorspann"><ul><li>GCC 10.2</li></ul></div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/0/4/3/1/TN_203038885_180cc6a539.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="vorspann"><ul><li>Clang 11.0</li></ul></div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/0/4/3/1/TN_203038891_93c05790ef.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="vorspann"><ul><li>MSVC 19.27</li></ul></div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/0/4/3/1/TN_203038901_079a978162.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die drei Screenshots sprechen eine eindeutige Sprache. Die Unterstützung der C++20-Kernsprache ist bereits zu diesem frühen Zeitpunkt recht gut.</div>
<div class="text">Die <a alt="%7B%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Type-Traits-Bibliothek%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22user_params%22%3A%22%22%7D" class="" href="https://en.cppreference.com/w/cpp/header/type_traits" title="Link auf https://en.cppreference.com/w/cpp/header/type_traits">Type-Traits-Bibliothek</a> besitzt eine sehr interessante Funktion: <span class="tx_code">std::is_constant_evaluted</span> bestimmt, ob eine Funktion zur Compilezeit oder Laufzeit ausgeführt wird. Warum benötigen wir diese Funktion der Type-Traits-Bibliothek? In C++20 besitzen wir drei Arten von Funktionen:<br></div>
<div class="text"><ul><li><span class="tx_code">consteval</span> erklärt Funktionen, die zur Compilezeit ausgeführt werden: <span class="tx_code">consteval int alwaysCompiletime();</span></li><li><span class="tx_code">constexpr</span> erklärt Funktionen, die sowohl zur Comilezeit als auch zur Laufzeit ausgeführt werden können: <span class="tx_code">constexpr init itDepends();</span></li><li>gewöhnliche Funktionen, die zur Laufzeit ausgeführt werden: <span class="tx_code">int alwaysRuntime();</span></li></ul></div>
<div class="text">Nun möchte ich mich mit dem komplizierten Fall beschäftigen: <span class="tx_code">constexpr</span>. Eine als <span class="tx_code">constexpr</span> deklarierte Funktion kann sowohl zur Compilerzeit als auch zu Laufzeit ausgeführt werden. Manchmal soll aber die Funktionalität der Funktion davon abhängen, ob sie zur Compilezeit oder Laufzeit ausgeführt wird. Eine <span class="tx_code">constexpr</span>-Funktion wie <span class="tx_code">getSum</span> besitzt lediglich das Potential, zur Compilezeit ausgeführt zu werden:<br></div>
<div class="pre">constexpr int getSum(int l, int r) {<br>&nbsp;&nbsp;&nbsp; return l + r;<br>}<br></div>
<div class="text">Wie kannst du sicherstellen, dass die Funktion <span class="tx_code">getSum</span> zur Compilezeit ausgeführt wird? Im Wesentlichen gibt es drei Möglichkeiten:</div>
<div class="text"><ol><li> Eine <span class="tx_code">constexpr</span>-Funktion wird zur Compilezeit ausgeführt:</li><ol><li>Die Funktion wird in einem sogenannten constant-evaluted context verwendet. Dieser kann zum Beispiel innerhalb einer <span class="tx_code">constexpr</span>-Funktion oder innerhalb eines <span class="tx_code">static_assert</span>-Ausdrucks sein. <br></li><li>Der Aufrufer der Funktion möchte das Ergebnis explizit zur Compilezeit erhalten: <span class="tx_code">constexpr res = getSum(2000, 11</span>) . Damit muss <span class="tx_code">getSum</span> zur Compilezeit ausgeführt werden.</li></ol><li>Eine <span class="tx_code">constexpr</span>-Funktion kann nur zur Laufzeit ausgeführt werden, falls die Argumente keine konstanten Ausdrücke sind. Dies ist der Fall, wenn die Funktion <span class="tx_code">getSum(a, 11)</span> mit einer Variablen aufgerufen wird, die nicht als mit [code]constexpr[/code] definiert war: <span class="tx_code">int a = 2000;</span></li><li>Eine <span class="tx_code">constexpr</span>-Funktion kann sowohl zur Compilezeit als auch zur Laufzeit ausgeführt werden, falls keine der ersten zwei Regeln zum Einsatz kommt. In diesem Fall entscheidet das der Compiler.<br></li></ol></div>
<div class="text">Genau im Punkt 3 der Aufzählung kann <span class="tx_code">std::is_constant_evaluted</span> seine Fähigkeiten ausspielen. Es lässt sich aufspüren, ob eine Funktion zur Compile- oder zu Laufzeit ausgeführt wird, und es lassen sich verschiedene Operationen ausführen. <a alt="%7B%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_constant_evaluated%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22cppreference.com%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_constant_evaluated%22%2C%22type%22%3A%22E%22%7D" class="" href="https://en.cppreference.com/w/cpp/types/is_constant_evaluated" title="Link auf https://en.cppreference.com/w/cpp/types/is_constant_evaluated">cppreference.com</a> bietet dazu einen cleveren Anwendungsfall an. In diesem Beispiel wird zur Compilzeit des Programms die Potenz einer Zahl händisch, hingegen zur Laufzeit des Programms die Potenz einer Zahl mit <span class="tx_code">std::pow</span> berechnet:<br></div>
<div class="pre">// constantEvaluated.cpp<br><br>#include &lt;type_traits&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>&nbsp;<br>constexpr double power(double b, int x) {<br>&nbsp;&nbsp;&nbsp; if (std::is_constant_evaluated() &amp;&amp; !(b == 0.0 &amp;&amp; x &lt; 0)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (x == 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1.0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double r = 1.0, p = x &gt; 0 ? b : 1.0 / b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto u = unsigned(x &gt; 0 ? x : -x);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (u != 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (u &amp; 1) r *= p;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u /= 2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p *= p;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return r;<br>&nbsp;&nbsp;&nbsp; } <br>&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::pow(b, double(x));<br>&nbsp;&nbsp;&nbsp; }<br>}<br>&nbsp;<br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr double kilo1 = power(10.0, 3);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "kilo1: " &lt;&lt; kilo1 &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; int n = 3;<br>&nbsp;&nbsp;&nbsp; double kilo2 = power(10.0, n);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "kilo2: " &lt;&lt; kilo2 &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}<br></div>
<div class="text">Ein interessante Beobachtung möchte ich noch loswerden. <span class="tx_code">std::is_constant_evaluted</span> lässt sich sowohl in einer als <span class="tx_code">consteval</span> deklarieren Funktion als auch in einer Funktion verwenden, die nur zur Laufzeit ausgeführt werden kann. Natürlich gibt sie in diesem Fall immer den gleichen Wert zurück.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Nun bin ich fast fertig mit meiner Vorstellung der neuen C++20-Bibliothek. Zwei Features fehlen aber noch, bevor ich mir die Concurrency in C++20 genauer anschaue: die Bibliothek zur Bitmanipulation und <span class="tx_code">std::source_location</span>.<br></div>