<div class="vorspann">Heute schließe ich meine Miniserie zu Concepts mit der Antwort zur philosophisch angehauchten Frage ab: Stellen Concepts eine Evolution oder eine Revolution in C+++ dar? D</div>
<div class="text">Wir wissen alle, für welche Begrifflichkeit Evolution und Revolution steht. Gerne will ich aber ein wenig genauer sein. Die Definitionen von <a class="" title="Link auf http://www.reinventioninc.com/revolutionvsevolution" alt="%7B%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22re%3Ainvention%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.reinventioninc.com%2Frevolutionvsevolution%22%2C%22href%22%3A%22http%3A%2F%2Fwww.reinventioninc.com%2Frevolutionvsevolution%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22subject%22%3A%22%22%7D" href="http://www.reinventioninc.com/revolutionvsevolution">re:invention</a> sind kurz und bündig:</div>
<div class="text"><ul><li><b>Evolution</b>&nbsp;is defined as gradual change, adaptation, progression, metamorphosis.</li><li><b>Revolution</b>&nbsp;is defined as forcible overthrow for an entirely new system…drastic, disruptive, far-reaching, momentous change.</li></ul></div>
<div class="text">Um es zu vereinfachen: Der entscheidende Unterschied zwischen einer Evolution und einer Revolution ist, ob die Veränderungen fließend (Evolution) oder sprunghaft (Revolution) erfolgen.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/3/9/4/0/1/TN_188278935_1fb8e5bf5b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">In meinen vorherigen Artikel gab es viele Diskussionen zu Concepts. Daher war ich auf eure Meinung zu meiner gestellten Frage sehr neugierig. Interessanterweise hatten die Antwort eine starke Tendenz zur Evolution. Interessanterweise, da ich mehr zur Revolution neige.</div>
<div class="text">Welche Argumente sprechen nun für die Evolution beziehungsweise die Revolution?</div>
<div class="ztitel">Evolution</div>
<div class="ztitel_kleiner">Saubere Abstraktion</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/3/9/4/0/1/TN_188278941_551f37655c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=1>" style="max-height: 25px; max-width: 25px;">Vernünftig eingesetzt sollten Concepts das saubere Arbeiten mit generischem Code auf einer höheren Abstraktionsebene befördern. Auf längere Sicht könnte ich mir auch vorstellen, dass gerade die Standard-Concepts zunehmend idiomatisch werden sollten und dass damit auch die Interoperabilität und das modulare Arbeiten vor allem in größeren Teams robuster und weniger fehleranfällig gemacht werden kann, wenn mehr auf abstrakte Eigenschaften der Parameter-Klassen geprüft wird und weniger auf lediglich rein syntaktische "Ausrollbarkeit" in generischem Code.<br></div>
<div class="ztitel_kleiner">Einfache Definition und sinnvolle Fehlermeldungen</div>
<div class="text">Concepts können nichts, was man bisher [--] wenn auch gegebenenfalls <b>sehr</b>&nbsp;umständlich und aufwendig [--] nicht mit <a alt="%7B%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22text%22%3A%22type-traits%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" class="" href="https://en.cppreference.com/w/cpp/header/type_traits">type-traits</a>, <a alt="%7B%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fsfinae%22%2C%22text%22%3A%22SFINAE%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fsfinae%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%7D" title="Link auf https://en.cppreference.com/w/cpp/language/sfinae" class="" href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a> und <span class="tx_code"> <a class="" title="Link auf https://en.cppreference.com/w/cpp/language/static_assert" alt="%7B%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fstatic_assert%22%2C%22text%22%3A%22static_assert%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fstatic_assert%22%2C%22version%22%3A1%7D" href="https://en.cppreference.com/w/cpp/language/static_assert">static_assert</a></span> hinbekommen hätte. Ihr Vorteil liegt in der einfachen Definition und sinnvollen Fehlermeldungen.</div>
<div class="ztitel_kleiner">Unconstrained Placeholders</div>
<div class="text">Seit C++11 können wir mithilfe von <span class="tx_code">auto</span> den Datentyp einer Variable von seinem Initialisierer ableiten:</div>
<div class="pre">auto integ = add(2000, 11);<br><br>std::vector&lt;int&gt; myVec{1, 2, 3};<br>for (auto v: myVec) std::cout &lt;&lt; v &lt;&lt; std::endl;</div>
<div class="text"><span class="tx_code">auto</span> ist eine Art uneingeschränkter Platzhalter. Mit C++20 ist diese Ableitung des Datentyps auch mit eingeschränkten Platzhaltern (Concepts) möglich:</div>
<div class="pre">template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>concept Integral = std::is_integral&lt;T&gt;::value;<br><br>Integral auto integ = add(2000, 11);<br><br>std::vector&lt;int&gt; myVec{1, 2, 3};<br>for (Integral auto v: myVec) std::cout &lt;&lt; v &lt;&lt; std::endl;</div>
<div class="text">Um prägnant und evolutionär zu argumentieren: Eingeschränkte Platzhalter (Concepts) können überall dort verwendet werden, wo uneingeschränkte Platzhalter (<span class="tx_code">auto</span>) verwendbar sind. </div>
<div class="ztitel_kleiner">Generische Lambdas</div>
<div class="text">Seit C++14 lassen sich generische Lambdas (<span class="tx_code">addLambda</span>) verwenden. Diese sind unter der Decke Funktions-Templates (<span class="tx_code">addTemplate</span>).</div>
<div class="pre">// addLambdaGeneric.pp<br><br>#include &lt;iostream&gt;<br><br>auto addLambda = [](auto fir, auto sec){ return fir + sec; }; <br><br>template &lt;typename T, typename T2&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>auto addTemplate(T fir, T2 sec){ return fir + sec; }<br><br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; addLambda(2000, 11.5);&nbsp;&nbsp;&nbsp; // 2011.5<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; addTemplate(2000, 11.5);&nbsp; // 2011.5<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Die Verwendung von <span class="tx_code">auto</span> in einer Funktionsdeklaration war in C++14 nicht möglich. Seit C++20 kannst du eingeschränkte (Concepts) und uneingeschränkte Platzhalter (<span class="tx_code">auto</span>) in der Funktionsdeklaration verwenden. Intern wird die Funktionsdeklaration zu einem Funktions-Template mit eingeschränkten (Concept) oder uneingeschränkten (<span class="tx_code">auto</span>) Platzhaltern. </div>
<div class="pre">// addUnconstrainedConstrained.cpp<br><br>#include &lt;concepts&gt;<br>#include &lt;iostream&gt;<br><br>auto addUnconstrained(auto fir, auto sec){<br>&nbsp;&nbsp;&nbsp;&nbsp; return fir + sec;<br>}<br><br>std::floating_point auto addConstrained(std::integral auto fir, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::floating_point auto sec){<br>&nbsp;&nbsp;&nbsp;&nbsp; return fir + sec;<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; addUnconstrained(2000, 11.5); // 2011.5<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; addConstrained(2000, 11.5);&nbsp;&nbsp; // 2011.5<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Um meine Argumentation besser auf den Punkt zu bringen, besitzt die Funktion <span class="tx_code">addConstrained</span> eine sehr diskussionswürdige Signatur.<br></div>
<div class="ztitel">Revolution</div>
<div class="ztitel_kleiner">Template Anforderungen prüfen<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/3/9/4/0/1/TN_188278945_2103888059.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=1>" style="max-height: 25px; max-width: 25px;">Zugegeben, Anforderungen an Templates lassen sich in C++11 [--] halbwegs elegant [--] bereits in der Template-Deklaration prüfen:<br></div>
<div class="pre">// requirementsCheckSFINAE.cpp<br><br>#include &lt;type_traits&gt;<br><br>template&lt;typename T,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;:: type = 0&gt;<br>T moduloOf(T t) {<br>&nbsp;&nbsp;&nbsp; return t % 5;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; auto res = moduloOf(5.5);<br><br>}<br></div>
<div class="text">Das Funktions-Template <span class="tx_code">moduloOf</span> fordert, dass [code]T[/code] integral sein soll. Falls <span class="tx_code">T</span> nicht <span class="tx_code">integral</span> ist und daher der Ausdruck <span class="tx_code">std::integral&lt;T&gt;::value false</span> ergibt, ist die fehlerhafte Substitution kein Fehler. Der Compiler entfernt diese konkrete Überladung aus der Menge aller möglichen Überladungen der Funktion <span class="tx_code">moduloOf</span>. Leider gibt es danach keine gültige Überladung mehr. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/3/9/4/0/1/TN_188278952_ded29b634d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Diese Technik ist unter dem Name <a href="https://en.cppreference.com/w/cpp/language/sfinae" class="" alt="%7B%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22SFINAE%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fsfinae%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fsfinae%22%2C%22subject%22%3A%22%22%7D" title="Link auf https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a> bekannt. SFINAE steht für "Substitution Failure Is Not An Error". Auf diese Technik&nbsp; gehe ich nur in fortgeschrittenen Schulungen zu Templates ein. Dies gilt aber nicht für Concepts. Diese drücken ihre Intention direkt aus:<br></div>
<div class="pre">// requirementsCheckConcepts.cpp<br><br>#include &lt;concepts&gt;<br><br>std::integral auto moduloOf(std::integral auto t) {<br>&nbsp;&nbsp;&nbsp; return t % 5;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; auto res = moduloOf(5.5);<br><br>}</div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/3/9/4/0/1/TN_188278957_78d28bf8f0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel_kleiner">Die Definition von Templates ist deutlich einfacher<br></div>
<div class="text">Dank der <i>Abbreviated Funktion-Template Syntax</i>, wird die Definition von Templates in C++20 zum Kinderspiel. Ich habe bereits den neuen Syntactic Sugar in der Funktionsdeklaration von <span class="tx_code">addConstrained</span> und <span class="tx_code">mudolOf</span> vorgestellt. Daher lasse ich das Beispiel in diesem Abschnitt aus.<br></div>
<div class="ztitel_kleiner">Semantische Kategorien<br></div>
<div class="text">Concepts stehen nicht für syntaktische Einschränkungen, sondern für semantische Kategorien.</div>
<div class="text"><span class="tx_code">Addable</span> ist ein Concept, das eine syntaktische Einschränkung repräsentiert. </div>
<div class="pre">template&lt;typename T&gt;<br>concept Addable = has_plus&lt;T&gt;;&nbsp;&nbsp;&nbsp; // bad; insufficient<br><br>template&lt;Addable N&gt; auto algo(const N&amp; a, const N&amp; b) // use two numbers<br>{<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; return a + b;<br>}<br><br>int x = 7;<br>int y = 9;<br>auto z = algo(x, y);&nbsp;&nbsp; // z = 16<br><br>std::string xx = "7";<br>std::string yy = "9";<br>auto zz = algo(xx, yy);&nbsp;&nbsp; // zz = "79"</div>
<div class="text"><span class="tx_code">Addable</span> verhält sich nicht erwartungsgemäß. Das Funktions-Template [code]algo[/code] sollte Argumente annehmen können, die eine Zahl modellieren und nicht lediglich den +-Operator unterstützen. Konsequenterweise lassen sich zwei Strings als Argument verwenden. Dies ist sehr fragwürdig, da die Addition kommutativ sein sollte. String-Konkatenation ist es aber nicht:</div>
<div class="text"> <span class="tx_code">"7" + "9" != "9" + "7"</span>.</div>
<div class="text">Die Lösung liegt auf der Hand. Definiere das Concept <span class="tx_code">Number</span>. <span class="tx_code">Number</span> ist eine semantische Kategorie wie <span class="tx_code">Equal</span>, <span class="tx_code">Callable</span>, <span class="tx_code">Predicate</span> oder <span class="tx_code">Monade</span>.</div>
<div class="ztitel">Meine Antwort</div>
<div class="text">Natürlich lassen sich gewichtige Argumente für die evolutionären Schritte oder einen revolutionären Sprung mit Concepts finden. Dank der semantischen Kategorien tendiere ich deutlich zur Revolution. Concepts wie Number, Equal oder Ordering erinnern mich an die <a href="https://en.wikipedia.org/wiki/Plato" class="" alt="%7B%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPlato%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPlato%22%2C%22text%22%3A%22platonische%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D" title="Link auf https://en.wikipedia.org/wiki/Plato">platonische</a> Welt der Ideen. Für mich ist es revolutionär, dass wir dank Concepts unsere Programme in diesen Kategorien analysieren können.</div>
<div class="ztitel">Wie geht's weiter</div>
<div class="text">Die Ranges-Bibliothek, die ich in meinem nächsten Artikel genauer vorstelle, ist der erste Konsument der Concepts. Ranges unterstützen Algorithmen, die </div>
<div class="text"><ul><li>auf dem ganzen Container arbeiten. <br></li><li>lazy evaluiert werden.</li><li>komponiert werden können.</li></ul> </div>
