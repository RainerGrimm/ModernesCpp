<p>Let me conclude my series to concepts with this meta-post. Are concepts an evolution or a revolution in C++? The answer to this question bothered me quite a time.</p>
<hr id="system-readmore" />
<p>&nbsp;<img style="display: block; margin-left: auto; margin-right: auto;" src="images/blog/Cpp20/ConceptEvolutionOrRevolution/TimelineCpp20Concepts.png" alt="TimelineCpp20Concepts" width="650" height="255" /></p>
<p>I assume we all know what evolution or revolution means but let me be more precise. These definitions from <a href="http://www.reinventioninc.com/revolutionvsevolution">re:invention</a> are quite concise:</p>
<ul>
<li><strong>Evolution</strong>&nbsp;is defined as gradual change, adaptation, progression, metamorphosis.</li>
<li><strong>Revolution&nbsp;</strong>is defined as forcible overthrow for an entirely new system…drastic, disruptive, far-reaching, momentous change.</li>
</ul>
<p>To make it short. The crucial difference between evolution and revolution is if the change is gradual (evolution) or disruptive (revolution).</p>
<p>I had many discussions in the series to concepts. Consequentially, I was curious about what your opinion to concepts is. The answers I got are in German. For your convenience, I paraphrase it in English. Interestingly, my readers have a clear tendency to evolution. Honestly, I'm more on the revolution side.</p>
<p>Which argument speaks for evolution and which argument speaks for revolution?</p>
<h2>Evolution</h2>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="images/blog/Cpp20/ConceptEvolutionOrRevolution/evolution-4107273_1280.jpg" alt="evolution 4107273 1280" width="400" height="276" /></p>
<p>Image by <a href="https://pixabay.com/users/Alexas_Fotos-686414/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4107273">Alexas_Fotos</a> from <a href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4107273">Pixabay</a></p>
<h3>Clear Abstraction&nbsp;</h3>
<p>When used properly, concepts should promote clean working with generic code at a higher level of abstraction.</p>
<p>In the longer term, the standard concepts should become increasingly idiomatic in C++. The interoperability and modular work, especially in larger teams, can be made more robust and less prone to errors, if more on abstract properties of the parameter classes is checked and less for purely syntactic "rollout" in generic code.</p>
<h3>Simple Definition and meaningful Error Messages</h3>
<p>You cannot do anything that you would not have been able to do with <a href="https://en.cppreference.com/w/cpp/header/type_traits">type-traits library</a>, <a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a> and <a href="https://en.cppreference.com/w/cpp/language/static_assert">static_assert</a> so far, even if it was very cumbersome and time-consuming. Their advantages lie in the simple definition and meaningful error messages.</p>
<h3>Unconstrained Placeholders</h3>
<p>Since C++11 we have auto to deduce the type of a variable from its initializer.</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f0f3f3; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #006699; font-weight: bold;">auto</span> integ <span style="color: #555555;">=</span> add(<span style="color: #ff6600;">2000</span>, <span style="color: #ff6600;">11</span>);

std<span style="color: #555555;">::</span>vector<span style="color: #555555;">&lt;</span><span style="color: #007788; font-weight: bold;">int</span><span style="color: #555555;">&gt;</span> myVec{<span style="color: #ff6600;">1</span>, <span style="color: #ff6600;">2</span>, <span style="color: #ff6600;">3</span>};
<span style="color: #006699; font-weight: bold;">for</span> (<span style="color: #006699; font-weight: bold;">auto</span> v<span style="color: #555555;">:</span> myVec) std<span style="color: #555555;">::</span>cout <span style="color: #555555;">&lt;&lt;</span> v <span style="color: #555555;">&lt;&lt;</span> std<span style="color: #555555;">::</span>endl;
</pre>
</div>
<p><span style="color: #000000; font-family: DejaVuSans, 'DejaVu Sans', arial, sans-serif; font-size: 12.8px; font-style: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; background-color: #ffffff; float: none;"></span></p>
<p><span style="font-family: 'courier new', courier;">auto</span> is a kind of unconstrained placeholder. With C++20, we can use concepts as constrained placeholders.</p>
<p>&nbsp;</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f0f3f3; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #006699; font-weight: bold;">template</span><span style="color: #555555;">&lt;</span><span style="color: #006699; font-weight: bold;">typename</span> T<span style="color: #555555;">&gt;</span>                                   
concept Integral <span style="color: #555555;">=</span> std<span style="color: #555555;">::</span>is_integral<span style="color: #555555;">&lt;</span>T<span style="color: #555555;">&gt;::</span>value;

Integral <span style="color: #006699; font-weight: bold;">auto</span> integ <span style="color: #555555;">=</span> add(<span style="color: #ff6600;">2000</span>, <span style="color: #ff6600;">11</span>);

std<span style="color: #555555;">::</span>vector<span style="color: #555555;">&lt;</span><span style="color: #007788; font-weight: bold;">int</span><span style="color: #555555;">&gt;</span> myVec{<span style="color: #ff6600;">1</span>, <span style="color: #ff6600;">2</span>, <span style="color: #ff6600;">3</span>};
<span style="color: #006699; font-weight: bold;">for</span> (Integral <span style="color: #006699; font-weight: bold;">auto</span> v<span style="color: #555555;">:</span> myVec) std<span style="color: #555555;">::</span>cout <span style="color: #555555;">&lt;&lt;</span> v <span style="color: #555555;">&lt;&lt;</span> std<span style="color: #555555;">::</span>endl;
</pre>
</div>
<p>&nbsp;</p>
<p>To make it concise and evolutionary: you can use a constrained placeholder (concept) in each place you could use an unconstrained placeholder (auto).</p>
<h3>Generic Lambdas</h3>
<p>&nbsp;With C++14 you can use a generic lambda (<span style="font-family: 'courier new', courier;">addLambda</span>) which becomes essentially a function template (<span style="font-family: 'courier new', courier;">addTemplate</span>).</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f0f3f3; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #0099ff; font-style: italic;">// addLambdaGeneric.pp</span>

<span style="color: #009999;">#include &lt;iostream&gt;</span>

<span style="color: #006699; font-weight: bold;">auto</span> addLambda <span style="color: #555555;">=</span> [](<span style="color: #006699; font-weight: bold;">auto</span> fir, <span style="color: #006699; font-weight: bold;">auto</span> sec){ <span style="color: #006699; font-weight: bold;">return</span> fir <span style="color: #555555;">+</span> sec; }; 

<span style="color: #006699; font-weight: bold;">template</span> <span style="color: #555555;">&lt;</span><span style="color: #006699; font-weight: bold;">typename</span> T, <span style="color: #006699; font-weight: bold;">typename</span> T2<span style="color: #555555;">&gt;</span>                            
<span style="color: #006699; font-weight: bold;">auto</span> addTemplate(T fir, T2 sec){ <span style="color: #006699; font-weight: bold;">return</span> fir <span style="color: #555555;">+</span> sec; }


<span style="color: #007788; font-weight: bold;">int</span> main(){
    
    std<span style="color: #555555;">::</span>cout <span style="color: #555555;">&lt;&lt;</span> addLambda(<span style="color: #ff6600;">2000</span>, <span style="color: #ff6600;">11.5</span>);    <span style="color: #0099ff; font-style: italic;">// 2011.5</span>
    std<span style="color: #555555;">::</span>cout <span style="color: #555555;">&lt;&lt;</span> addTemplate(<span style="color: #ff6600;">2000</span>, <span style="color: #ff6600;">11.5</span>);  <span style="color: #0099ff; font-style: italic;">// 2011.5</span>
    
}
</pre>
</div>
<p>&nbsp;</p>
<p>Using <span style="font-family: 'courier new', courier;">auto</span> in a function declaration was not possible with C++14. Since C++20 you can use a constrained placeholder (concept) or an unconstrained placeholder (<span style="font-family: 'courier new', courier;">auto</span>) in a function declaration and the function declaration becomes a function template with unconstrained (<span style="font-family: 'courier new', courier;">auto</span>) or constrained (concept) parameters.</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f0f3f3; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #0099ff; font-style: italic;">// addUnconstrainedConstrained.cpp</span>

<span style="color: #009999;">#include &lt;concepts&gt;</span>
<span style="color: #009999;">#include &lt;iostream&gt;</span>

<span style="color: #006699; font-weight: bold;">auto</span> <span style="color: #cc00ff;">addUnconstrained</span>(<span style="color: #006699; font-weight: bold;">auto</span> fir, <span style="color: #006699; font-weight: bold;">auto</span> sec){
     <span style="color: #006699; font-weight: bold;">return</span> fir <span style="color: #555555;">+</span> sec;
}

std<span style="color: #555555;">::</span>floating_point <span style="color: #006699; font-weight: bold;">auto</span> addConstrained(std<span style="color: #555555;">::</span>integral <span style="color: #006699; font-weight: bold;">auto</span> fir, 
                                        std<span style="color: #555555;">::</span>floating_point <span style="color: #006699; font-weight: bold;">auto</span> sec){
     <span style="color: #006699; font-weight: bold;">return</span> fir <span style="color: #555555;">+</span> sec;
}

<span style="color: #007788; font-weight: bold;">int</span> main(){
    
    std<span style="color: #555555;">::</span>cout <span style="color: #555555;">&lt;&lt;</span> addUnconstrained(<span style="color: #ff6600;">2000</span>, <span style="color: #ff6600;">11.5</span>); <span style="color: #0099ff; font-style: italic;">// 2011.5</span>
    std<span style="color: #555555;">::</span>cout <span style="color: #555555;">&lt;&lt;</span> addConstrained(<span style="color: #ff6600;">2000</span>, <span style="color: #ff6600;">11.5</span>);   <span style="color: #0099ff; font-style: italic;">// 2011.5</span>
    
}
</pre>
</div>
<p>&nbsp;</p>
<p>I intentionally used a strange signature for my <span style="font-family: 'courier new', courier;">addConstrained</span> function to make my point.&nbsp;</p>
<h2>Revolution</h2>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="images/blog/Cpp20/ConceptEvolutionOrRevolution/france-63022_1280.jpg" alt="france 63022 1280" width="400" height="317" /></p>
<p>&nbsp;</p>
<p>Image by <a href="https://pixabay.com/users/WikiImages-1897/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=63022">WikiImages</a> from <a href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=63022">Pixabay</a></p>
<h3>Template Requirements are verified</h3>
<p>Admittedly, you can specify template requirements in C++11 in the template declaration.</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f0f3f3; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #0099ff; font-style: italic;">// requirementsCheckSFINAE.cpp</span>

<span style="color: #009999;">#include &lt;type_traits&gt;</span>

<span style="color: #006699; font-weight: bold;">template</span><span style="color: #555555;">&lt;</span><span style="color: #006699; font-weight: bold;">typename</span> T,
         <span style="color: #006699; font-weight: bold;">typename</span> std<span style="color: #555555;">::</span>enable_if<span style="color: #555555;">&lt;</span>std<span style="color: #555555;">::</span>is_integral<span style="color: #555555;">&lt;</span>T<span style="color: #555555;">&gt;::</span>value, T<span style="color: #555555;">&gt;::</span> type <span style="color: #555555;">=</span> <span style="color: #ff6600;">0</span><span style="color: #555555;">&gt;</span>
T moduloOf(T t) {
    <span style="color: #006699; font-weight: bold;">return</span> t <span style="color: #555555;">%</span> <span style="color: #ff6600;">5</span>;
}

<span style="color: #007788; font-weight: bold;">int</span> main() {

    <span style="color: #006699; font-weight: bold;">auto</span> res <span style="color: #555555;">=</span> moduloOf(<span style="color: #ff6600;">5.5</span>);

}
</pre>
</div>
<p>&nbsp;</p>
<p>The function template <span style="font-family: 'courier new', courier;">moduloOf</span>&nbsp;requires, that the&nbsp;<span style="font-family: 'courier new', courier;">T</span>&nbsp;has to be integral. If T is not integral and, therefore, the expression <span style="font-family: 'courier new', courier;">std::is_integral&lt;T&gt;::value</span> evaluates to <span style="font-family: 'courier new', courier;">false</span>, the failed substitution is not an error. The compiler removes the overload from the set of all potential overloads. After that step, there is no valid overload left.</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="images/blog/Cpp20/ConceptEvolutionOrRevolution/SFINAE.png" alt="SFINAE" width="600" height="130" /></p>
<p>This technique is called SFINAE and stands for <strong>S</strong>ubstitution <strong>F</strong>ailure<strong> I</strong>s <strong>N</strong>ot <strong>A</strong>n <strong>E</strong>rror.&nbsp;</p>
<p>Honestly, I only teach this technique in template classes. This does not hold for concepts. The issue becomes immediately obvious.</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f0f3f3; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #0099ff; font-style: italic;">// requirementsCheckConcepts.cpp</span>

<span style="color: #009999;">#include &lt;concepts&gt;</span>

std<span style="color: #555555;">::</span>integral <span style="color: #006699; font-weight: bold;">auto</span> moduloOf(std<span style="color: #555555;">::</span>integral <span style="color: #006699; font-weight: bold;">auto</span> t) {
    <span style="color: #006699; font-weight: bold;">return</span> t <span style="color: #555555;">%</span> <span style="color: #ff6600;">5</span>;
}

<span style="color: #007788; font-weight: bold;">int</span> main() {

    <span style="color: #006699; font-weight: bold;">auto</span> res <span style="color: #555555;">=</span> moduloOf(<span style="color: #ff6600;">5.5</span>);

}
</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;<img style="display: block; margin-left: auto; margin-right: auto;" src="images/blog/Cpp20/ConceptEvolutionOrRevolution/conceptsError.png" alt="conceptsError" width="600" height="226" /></p>
<p>&nbsp;</p>
<h3>Definition of Templates radically improved</h3>
<p>Thanks to the abbreviated function template syntax, the definition of a function template becomes a piece of cake. I already presented the new syntactic sugar in the function declarations of&nbsp;<span style="font-family: 'courier new', courier;">addConstrained</span>, and <span style="font-family: 'courier new', courier;">moduloOf. </span><span>Therefore, I skip the example.</span></p>
<h3>Semantic Categories</h3>
<p>Concepts do not stand for syntactic constraints but for semantic categories.&nbsp;</p>
<p><span style="font-family: 'courier new', courier;">Addable</span> is a concept that stands for a syntactic constraint.</p>
<p>&nbsp;</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f0f3f3; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #006699; font-weight: bold;">template</span><span style="color: #555555;">&lt;</span><span style="color: #006699; font-weight: bold;">typename</span> T<span style="color: #555555;">&gt;</span>
concept Addable <span style="color: #555555;">=</span> has_plus<span style="color: #555555;">&lt;</span>T<span style="color: #555555;">&gt;</span>;    <span style="color: #0099ff; font-style: italic;">// bad; insufficient</span>

<span style="color: #006699; font-weight: bold;">template</span><span style="color: #555555;">&lt;</span>Addable N<span style="color: #555555;">&gt;</span> <span style="color: #006699; font-weight: bold;">auto</span> algo(<span style="color: #006699; font-weight: bold;">const</span> N<span style="color: #555555;">&amp;</span> a, <span style="color: #006699; font-weight: bold;">const</span> N<span style="color: #555555;">&amp;</span> b) <span style="color: #0099ff; font-style: italic;">// use two numbers</span>
{
    <span style="color: #0099ff; font-style: italic;">// ...</span>
    <span style="color: #006699; font-weight: bold;">return</span> a <span style="color: #555555;">+</span> b;
}

<span style="color: #007788; font-weight: bold;">int</span> x <span style="color: #555555;">=</span> <span style="color: #ff6600;">7</span>;
<span style="color: #007788; font-weight: bold;">int</span> y <span style="color: #555555;">=</span> <span style="color: #ff6600;">9</span>;
<span style="color: #006699; font-weight: bold;">auto</span> z <span style="color: #555555;">=</span> algo(x, y);   <span style="color: #0099ff; font-style: italic;">// z = 16</span>

std::string xx <span style="color: #555555;">=</span> <span style="color: #cc3300;">"7"</span>;
std::string yy <span style="color: #555555;">=</span> <span style="color: #cc3300;">"9"</span>;
<span style="color: #006699; font-weight: bold;">auto</span> zz <span style="color: #555555;">=</span> algo(xx, yy);   <span style="color: #0099ff; font-style: italic;">// zz = "79"</span>
</pre>
</div>
<p>&nbsp;</p>
<p>I assume <span style="font-family: 'courier new', courier;">Addable</span> behaves not like expected. The function template <code>algo</code> should accept arguments which model numbers and not just support the + operator.&nbsp;Consequentially, two strings can be used as arguments. This is bad because addition is commutative, but not string concatenation: <span style="font-family: 'courier new', courier;">"7" + "9" != "9" + "7".</span></p>
<p>The solution is quite simple. Define the concept <code>Number.&nbsp;</code><span style="font-family: 'courier new', courier;">Number</span> is a semantic category such as <span style="font-family: 'courier new', courier;">Equal</span>, <span style="font-family: 'courier new', courier;">Callable</span>, <span style="font-family: 'courier new', courier;">Predicate</span>,&nbsp;or <span style="font-family: 'courier new', courier;">Monad</span>&nbsp;are.</p>
<h2>My Conclusion</h2>
<p>Of course, many arguments speak for an evolutionary step or a revolutionary jump with concepts. Mainly because of the semantic categories I'm on the revolution side. Concepts such as Number, Equality, or Ordering remind me of&nbsp;<a href="https://en.wikipedia.org/wiki/Plato">Platon's </a>word of ideas.&nbsp;It is revolutionary for me that we can now reason about programming in such categories.&nbsp;</p>
<h2>What's next?</h2>
<p>The ranges library, that I present in the next post, is the first customer of concepts. Ranges supports algorithms which can</p>
<ul>
<li>operate directly on the container</li>
<li>be evaluated lazily</li>
<li>be composed</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>Thanks a lot to my <a href="https://www.patreon.com/rainer_grimm">Patreon Supporters</a></strong><strong>: Meeting C++, Matt Braun, Roman Postanciuc, Venkata Ramesh Gudpati, Tobias Zindl, Marko, </strong><span class="sc-kpOJdX fDWXFa" title="Emyr Williams"><strong>G Prvulovic, Reinhold Dröge, Abernitzke,</strong> </span><strong><span title="Emyr Williams">Richard Ohnemus, Frank Grimm</span></strong><span title="Emyr Williams"><strong>, Sakib, Broeserl, </strong></span><strong><span title="Emyr Williams">António Pina, Markus Falkner, Darshan Mody, Sergey Agafyin, <span class="sc-gZMcBi hdSbOl" data-tag="user-details-full-name">Андрей Бурмистров, Jake, GS, Lawton Shoemake, and Animus24.</span></span><span title="Emyr Williams"><span class="sc-htpNat dEZjR" style="color: #241e12; font-family: aktiv-grotesk, sans-serif; margin: 0px; position: relative; font-weight: 400; font-size: 1rem; line-height: 1.5;"><span class="sc-htpNat ebhhXb" style="color: #241e12; font-family: aktiv-grotesk, sans-serif; margin: 0px; position: relative; font-weight: bold; font-size: 1rem; line-height: 1.5;"><br /></span></span></span></strong></p>
<p>&nbsp;</p>
<table style="width: 490px; height: 103px;">
<tbody>
<tr>
<td><strong>Thanks in particular to:</strong></td>
<td>&nbsp;</td>
<td><a href="https://cranepay.io/"><img src="images/patreon/crp4.png" alt="crp4" width="150" height="96" /></a></td>
</tr>
</tbody>
</table>
<p><strong>&nbsp;</strong></p>
<p><strong>&nbsp;&nbsp;<a href="https://www.takeupcode.com/">&nbsp; </a></strong></p>
<table style="width: 800px; height: 250px;" border="0" cellpadding="8"><caption>
<h2>Get your e-book at Leanpub:</h2>
</caption>
<tbody>
<tr>
<td>
<h4><strong>The C++ Standard Library</strong></h4>
</td>
<td>&nbsp;</td>
<td>
<h4><strong>Concurrency With Modern C++</strong></h4>
</td>
<td style="width: 5px;">&nbsp;</td>
<td>
<h4><strong>Get Both as one Bundle</strong></h4>
</td>
</tr>
<tr>
<td style="text-align: center;"><a href="https://leanpub.com/cpplibrary"><img style="border: medium none #000000;" src="images/books/cover.png" alt="cover" width="173" height="220" /></a></td>
<td style="text-align: center;">&nbsp;</td>
<td style="text-align: center;"><a href="https://leanpub.com/concurrencywithmodernc"><img src="images/books/ConcurrencyCoverFrame.png" alt="ConcurrencyCoverFrame" width="173" height="223" /></a></td>
<td style="width: 5px; text-align: center;">&nbsp;</td>
<td style="width: 5px; text-align: center;"><a href="https://leanpub.com/b/thecstandardlibraryandconcurrencywithmodernc"><img src="images/books/bundle.png" alt="bundle" width="300" height="192" /></a><a href="https://leanpub.com/cpplibrary"></a></td>
</tr>
<tr>
<td>With <strong>C++11,</strong> <strong>C++14, and C++17</strong> we got a lot of new C++ libraries. In addition, the existing ones are greatly improved. The key idea of my book is to give you the necessary information to the current C++ libraries in about 200 pages. I also included more than 120 source files.</td>
<td style="width: 15px;">&nbsp;</td>
<td>
<p style="text-align: justify;"><strong>C++11</strong> is the first C++ standard that deals with concurrency. The story goes on with <strong>C++17</strong> and will continue with <strong>C++20</strong>.</p>
<p style="text-align: justify;">I'll give you a detailed insight in the current and the upcoming concurrency in C++. This insight includes the theory and a lot of practice with more than 140 source files.</p>
</td>
<td style="width: 15px;">&nbsp;</td>
<td>
<div class="about-bundle__blurb" data-reactid=".bi7877yjsc.2.1.0.5.0.1.0">
<p>Get my books "<strong>The C++ Standard Library</strong>" (including C++17) and "<strong>Concurrency with Modern C++</strong>" in a bundle.</p>
<p>In sum, you get more than 700 pages full of modern C++ and more than 260 source files presenting concurrency in practice.</p>
</div>
&nbsp;</td>
</tr>
</tbody>
</table>
<p></p>
<table style="width: 800px;">
<tbody>
<tr>
<td colspan="2">
<h2>Get your interactive course</h2>
&nbsp;</td>
</tr>
<tr>
<td>
<h4 class="_3fBEwsM053hx2mPd0uV0nT" style="text-align: center;">Modern C++ Concurrency in Practice</h4>
</td>
<td>
<h4>C++ Standard Library including C++14 &amp; C++17</h4>
</td>
</tr>
<tr>
<td><a href="https://goo.gl/2qWUkK"><img style="display: block; margin-left: auto; margin-right: auto;" src="images/blog/news/InteractiveCourseConcurrency/educative.png" alt="educative" width="300" height="152" /></a></td>
<td><a href="https://www.educative.io/collection/10370001/5712008708096000?authorName=Rainer%20Grimm"><img style="display: block; margin-left: auto; margin-right: auto;" src="images/blog/news/InteractiveCourseLibrary/CLibrary.png" alt="CLibrary" width="300" height="150" /></a></td>
</tr>
<tr>
<td>
<p>Based on my book "Concurrency with Modern C++" educative.io created an interactive course.</p>
<p>What's Inside?</p>
<ul>
<li>140 lessons</li>
<li>110 code playgrounds =&gt; Runs in the browser</li>
<li>78 code snippets</li>
<li>55 illustrations</li>
</ul>
</td>
<td>
<p>Based on my book "The C++ Standard Library" educative.io created an interactive course.</p>
<p>What's Inside?</p>
<ul>
<li>149 lessons</li>
<li>111 code playgrounds =&gt; Runs in the browser</li>
<li>164 code snippets</li>
<li>25 illustrations</li>
</ul>
</td>
</tr>
</tbody>
</table>
