<div class="vorspann">Ein neuer Datentyp der Kalender- und Zeitzonenerweiterung in C++20 ist der Kalendertag. C++20 bietet viele Möglichkeiten an, Kalendertage zu erzeugen und mit ihnen zu interagieren.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/9/4/4/8/6/TN_201778371_681bdb5645.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Ich habe einige Zeit benötigt, die nahezu zwanzig neuen Datentypen rund um die Kalenderdaten zu verstehen. Genau aus dem Grund beginne ich den Artikel mit dem Kalendertag. Entsprechend meinem letzten Artikel "<a title="Link auf https://heise.de/-4937418" alt="%7B%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4937418%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4937418%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Kalender%20und%20Zeitzonen%20in%20C%2B%2B20%3A%20Tageszeit%22%7D" class="" href="https://heise.de/-4937418">Kalender und Zeitzonen in C++20: Tageszeit</a>" verwende ich die <a title="Link auf https://github.com/HowardHinnant/date" alt="%7B%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2FHowardHinnant%2Fdate%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2FHowardHinnant%2Fdate%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22text%22%3A%22date%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%7D" class="" href="https://github.com/HowardHinnant/date">date</a>-Bibliothek von Howard Hinnant als Prototyp der neuen <a alt="%7B%22text%22%3A%22chrono%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fchrono%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fchrono%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%7D" title="Link auf https://en.cppreference.com/w/cpp/chrono" href="https://en.cppreference.com/w/cpp/chrono" class="">chrono</a>-Erweiterung.<br></div>
<div class="ztitel">Kalendertag<br></div>
<div class="text">Ein Kalendertag ist ein Tag, der aus einem Jahr, einem Monat und einem Tag besteht. Dementsprechend besitzt C++20 den Datentyp <span class="tx_code">std::chrono_year_month_day</span>. C++20 bietet aber deutlich mehr an. Die beiden Tabelle geben den ersten Überblick:<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/9/4/4/8/6/TN_201778378_0ef1a3765f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/9/4/4/8/6/TN_201778386_db3dcee80e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Ich möchte mit einem einfachen Programm beginnen. <span class="tx_code">createCalender.cpp</span> stellt verschiedene Möglichkeiten vor, Kalenderdaten zu erzeugen:</div>
<div class="pre">// createCalendar.cpp<br><br>#include &lt;iostream&gt;<br>#include "date.h"<br>&nbsp;<br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; using namespace date;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto yearMonthDay{year(1940)/month(6)/day(26)};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; yearMonthDay &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; date::year_month_day(1940_y, June, 26_d) &lt;&lt; std::endl;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto yearMonthDayLast{year(2010)/March/last};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; yearMonthDayLast &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; date::year_month_day_last(2010_y, month_day_last(month(3))) &lt;&lt;&nbsp; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto yearMonthWeekday{year(2020)/March/Thursday[2]};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; yearMonthWeekday &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; date::year_month_weekday(2020_y, month(March), Thursday[2]) &lt;&lt;&nbsp; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto yearMonthWeekdayLast{year(2010)/March/Monday[last]};&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; yearMonthWeekdayLast &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; date::year_month_weekday_last(2010_y, month(March), weekday_last(Monday)) &lt;&lt;&nbsp; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto day_{day(19)};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; day_&nbsp; &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; date::day(19) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto month_{month(1)};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; month_&nbsp; &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; date::month(1) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto year_{year(1988)};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; year_&nbsp; &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; date::year(1988) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto weekday_{weekday(5)};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; weekday_&nbsp; &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; date::weekday(5) &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr auto yearMonth{year(1988)/1};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; yearMonth&nbsp; &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; date::year_month(year(1988), January) &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr auto monthDay{10/day(22)};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; monthDay &lt;&lt;&nbsp; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; date::month_day(October, day(22)) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto monthDayLast{June/last};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; monthDayLast &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; date::month_day_last(month(6)) &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr auto monthWeekday{2/Monday[3]};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; monthWeekday &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; date::month_weekday(February, Monday[3]) &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr auto monthWeekDayLast{June/Sunday[last]};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; monthWeekDayLast &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; date::month_weekday_last(June, weekday_last(Sunday)) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">C++20 bietet im Wesentlichen zwei Wege an, ein Kalenderdatum zu erzeugen. Einerseits gibt es die sogenannte Cute-Syntax <span class="tx_code">yearMonthDay{year(1940)/month(6)/day(26)}</span> (Zeile 1), andererseits lässt sich ein expliziter Datentyp verwenden: <span class="tx_code">date::year_month_day(1940_y, June, 26_d)</span> (Zeile 2). Ich verschiebe die Erklärung der Cute-Syntax auf den nächsten Abschnitt dieses Artikels und konzentriere mich zuerst auf die expliziten Datentypen. Sie sind sehr praktisch, denn sie können Zeitliterale <span class="tx_code">(1940_y</span>, <span class="tx_code">26_d</span>) und vordefinierte Konstante (<span class="tx_code">June</span>) verwenden. Mit C++20 werden die Zeitliterale wie <span class="tx_code">1940_y</span> und <span class="tx_code">26_d</span> ohne Unterstrich zur Verfügung stehen: <span class="tx_code">1940y</span>&nbsp; und <span class="tx_code">26d</span>. Dies war wohl der eingängige Teil meiner Erklärung.</div>
<div class="text">Die Zeilen (3), (4) und (5) bieten weitere angenehme Möglichkeiten an, Kalenderdaten zu definieren.</div>
<div class="text"><ul><li>Line (3): der letzte Tag des März 2010: 2010: <span class="tx_code">{year(2010)/March/last}</span> oder <span class="tx_code">year_month_day_last(2010_y, month_day_last(month(3))</span></li><li>Line (4): der zweite Donnerstag des März 2020: <span class="tx_code">{year(2020)/March/Thursday[2]}</span> oder <span class="tx_code">year_month_weekday(2020_y, month(March), Thursday[2])</span></li><li>Line (5): der letzte Montag des März 2010: <span class="tx_code">{year(2010)/March/Monday[last]}</span> oder <span class="tx_code">year_month_weekday_last(2010_y, month(March), weekday_last(Monday))</span></li></ul></div>
<div class="text">Die verbleibenden Kalenderdaten stehen für einen Tag (Zeile 6), einen Monat (Zeile 7) oder ein Jahr (Zeile 8). Du kannst diese Kalenderdaten als elementare Bausteine verwenden, um Kalendertage wie in den Zeilen (3) oder (4) zu erzeugen.</div>
<div class="text">Bevor ich noch weiter in den Kalenderdaten abtauche, ist hier die Ausgabe des Programms:<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/9/4/4/8/6/TN_201778389_137e8a0e73.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Wie angekündigt, schaue ich mir jetzt die Cute-Syntax genauer an.</div>
<div class="ztitel">Cute-Syntax</div>
<div class="text">Die Cute-Syntax besteht aus einem überladenen Teile-Operator, mit dem sich ein Kalendertag spezifizieren lässt. Der überladene Operator unterstützt die Zeitliterale (zum Beispiel <span class="tx_code">2020_y</span> und <span class="tx_code">31_d</span>) und die folgenden Konstanten: <span class="tx_code">January, February, March, April, May, June, July, August, September, October, November, December. </span></div>
<div class="text">Die folgenden drei Kombinationen von Jahr, Monat und Tag sind beim Einsatz der Cute-Syntax zulässig.</div>
<div class="text"><ol><li> Jahr/Monat/Tag</li><li>Tag/Monat/Jahr</li><li>Monat/Tag/Jahr</li></ol></div>
<div class="text">Diese drei Kombinationen sind aus dem naheliegenden Grund die einzigen, denn sie werden weltweit verwendet. Jede andere Kombination ist nicht zulässig.</div>
<div class="text">Durch den ersten Datentyp der Cute-Syntax werden die zwei verbleibenden Datentypen vorgegeben. Daher ist es für die zwei verbleibenden Datentypen ausreichend, ein Integral zu verwenden:</div>
<div class="pre">// cuteSyntax.cpp<br><br>#include &lt;iostream&gt;<br>#include "date.h"<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; using namespace date;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto yearMonthDay{year(1966)/6/26};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; yearMonthDay &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto dayMonthYear{day(26)/6/1966};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; dayMonthYear &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto monthDayYear{month(6)/26/1966};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; monthDayYear &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto yearDayMonth{year(1966)/month(26)/6};&nbsp; //(1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; yearDayMonth &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Die Kombination year/month/day in Zeile (1) ist nicht zulässig und führt zu einer Laufzeitnachricht.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/9/4/4/8/6/TN_201778395_7c28d04e23.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Ich denke, du willst ein Kalenderdatum wie <span class="tx_code">{year(2010)/March/last}</span> in einem lesbaren Format wie 2020-03-31 darstellen? Dies ist der Job des <span class="tx_code">local_days</span>-&nbsp; oder <span class="tx_code">sys_days</span>-Operators. </div>
<div class="ztitel">Kalenderdatum darstellen</div>
<div class="text">Dank <span class="tx_code">std::chrono::local_days</span> oder <span class="tx_code">std::chrono::sys_days</span> lassen sich Kalenderdaten zu einem <span class="tx_code">std::chrono::time_point</span> konvertieren. Dieser repräsentiert dann dasselbe Datum wie <span class="tx_code">year_month_day</span>.&nbsp;Ich verwende in meinem Beispiel <span class="tx_code">std::chrono::sys_days. std::chrono::sys_days</span> basiert auf der <span class="tx_code"><a href="https://en.cppreference.com/w/cpp/chrono/system_clock" class="" title="Link auf https://en.cppreference.com/w/cpp/chrono/system_clock" alt="%7B%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fchrono%2Fsystem_clock%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fchrono%2Fsystem_clock%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22std%3A%3Achrono%3A%3Asystem_clock%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D">std::chrono::system_clock</a></span>. Im folgenden Programm <span class="tx_code">sysDays.cpp</span> konvertiere ich die Kalenderdaten (Zeile (3) bis Zeile (5)) auf dem vorherigen Programm <span class="tx_code">createCalendar.cpp</span>:</div>
<div class="pre">// sysDays.cpp<br><br>#include &lt;iostream&gt;<br>#include "date.h"<br>&nbsp;<br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; using namespace date;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto yearMonthDayLast{year(2010)/March/last};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sys_days(yearMonthDayLast): " &lt;&lt; sys_days(yearMonthDayLast)&nbsp; &lt;&lt;&nbsp; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto yearMonthWeekday{year(2020)/March/Thursday[2]};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sys_days(yearMonthWeekday): " &lt;&lt;&nbsp; sys_days(yearMonthWeekday) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto yearMonthWeekdayLast{year(2010)/March/Monday[last]};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sys_days(yearMonthWeekdayLast): " &lt;&lt; sys_days(yearMonthWeekdayLast) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto leapDate{year(2012)/February/last};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sys_days(leapDate): " &lt;&lt; sys_days(leapDate) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto noLeapDate{year(2013)/February/last};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sys_day(noLeapDate): " &lt;&lt; sys_days(noLeapDate) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}&nbsp;&nbsp; <br></div>
<div class="text">Dank <span class="tx_code">std::chrono::last</span> kann ich sehr einfach herausfinden, wie viele Tage ein Monat besitzt. Die Ausgabe zeigt, dass das Jahr 2012 im Gegensatz zum Jahr 2013 ein Schaltjahr war:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/9/4/4/8/6/TN_201778406_574845f485.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Das Arbeiten mit Kalenderdaten wird sehr mächtig, wenn sich diese auf ihre Gültigkeit prüfen lassen oder mit Zeitdauern modifiziert werden können.</div>
<div class="ztitel">Neue Online-Seminare </div>
<div><ul><li><a title="Link auf https://www.modernescpp.de/index.php/c/2-c/29-embedded-programmierung-mit-modernem-c20201029102414" alt="%7B%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Embedded-Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F29-embedded-programmierung-mit-modernem-c20201029102414%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F29-embedded-programmierung-mit-modernem-c20201029102414%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/29-embedded-programmierung-mit-modernem-c20201029102414" class="">Embedded-Programmierung mit modernem C++</a> (Deutsch):&nbsp; 26. bis 28. Januar 2021 (9 bis 17 Uhr CEST)</li><li><a href="https://www.modernescpp.net/index.php/c/2-c/31-c-20" class="" alt="%7B%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%20%5B--%5D%20A%20Deep%20Insight%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.net%2Findex.php%2Fc%2F2-c%2F31-c-20%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.net%2Findex.php%2Fc%2F2-c%2F31-c-20%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D" title="Link auf https://www.modernescpp.net/index.php/c/2-c/31-c-20">C++20 [--] A Deep Insight</a> (English): 1. bis 3. Februar 2021 (16 bis 20 Uhr UTC)</li></ul></div>