<div class="vorspann">Mit diesem Artikel schließe ich meine Miniserie zum Drei-Weg-Vergleichsoperator mit ein paar subtilen Feinheiten ab. Sie betreffen den durch den Compiler erzeugten Operator == und != sowie das Zusammenspiel der klassischen Vergleichsoperatoren mit dem Drei-Weg-Vergleichsoperator.</div>
<div class="text">Ich beendete meinen letzten Artikel "<a alt="%7B%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C%2B%2B20%3A%20Mehr%20Details%20zum%20Spaceship%20Operator%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4790117%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4790117%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%7D" href="https://heise.de/-4790117" title="Link auf https://heise.de/-4790117" class="">C++20: Mehr Details zum Spaceship Operator</a>" mit der Klasse <span class="tx_code">MyInt</span>. In ihm hatte ich angekündigt, den Unterschied zwischen einem expliziten und nichtexpliziten Konstruktor für <span class="tx_code">MyIn</span><span class="tx_code">t</span> genauer herausarbeiten zu wollen. Der Faustregel lautet, dass Konstruktoren, die nur ein Argument erhalten, explizit sein sollen. </div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/1/9/2/3/2/TN_195406604_62cebf4a70.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Expliziter Konstruktor</div>
<div class="text">Zur Erinnerung: Hier ist der benutzerdefinierte Datentyp <span class="tx_code">MyInt</span> meines letzten Artikels:<br></div>
<div class="pre">// threeWayComparisonWithInt2.cpp<br><br>#include &lt;compare&gt;<br>#include &lt;iostream&gt;<br><br>class MyInt {<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; constexpr explicit MyInt(int val): value{val} { }&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto operator&lt;=&gt;(const MyInt&amp; rhs) const = default;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; constexpr auto operator&lt;=&gt;(const int&amp; rhs) const {&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return value &lt;=&gt; rhs;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;private: <br>&nbsp;&nbsp;&nbsp; int value;<br>};<br><br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; constexpr MyInt myInt2011(2011);<br>&nbsp;&nbsp;&nbsp; constexpr MyInt myInt2014(2014);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "myInt2011 &lt; myInt2014: " &lt;&lt; (myInt2011 &lt; myInt2014) &lt;&lt; std::endl; // (4)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "myInt2011 &lt; 2014: " &lt;&lt; (myInt2011 &lt; 2014) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "myInt2011 &lt; 2014.5: " &lt;&lt; (myInt2011 &lt; 2014.5) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "myInt2011 &lt; true: " &lt;&lt; (myInt2011 &lt; true) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Konstruktoren, die nur ein Argument wie (1) annehmen, werden gerne Konvertierungskonstruktoren genannt. Er heißt so, da er wie in in dem konkreten Fall ein <span class="tx_code">int</span> annehmen um damit ein <span class="tx_code">MyInt</span> erzeugen kann.<br></div>
<div class="text"><span class="tx_code">MyInt</span> besitzt einen expliziten Konstruktor (1), einen durch den Compiler erzeugten Drei-Weg-Vergleichsoperator (2) und einen benutzerdefinierten Vergleichsoperator für <span class="tx_code">int</span> (3). (4) verwendet den Compiler-erzeugten Vergleichsoperator für <span class="tx_code">MyInt</span>; (5, 6 und 7) nutzen hingegen den benutzerdefinierten Vergleichsoperator für <span class="tx_code">int</span>. Dank impliziter Verengung nach <span class="tx_code">int</span> (6) und der integralen Promotion nach <span class="tx_code">int</span> lassen sich Instanzen von <span class="tx_code">Myint</span> mit <span class="tx_code">double</span>- oder <span class="tx_code">bool</span><span class="tx_code">-</span>Werten vergleichen. <br></div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/1/9/2/3/2/TN_195406611_12b3e32e86.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Wenn ich <span class="tx_code">MyInt</span> einem <span class="tx_code">int</span> ähnlich entwerfe, wird der Vorteil eines expliziten Konstruktors (1) offensichtlich. Im folgenden Beispiel bietet <span class="tx_code">MyInt</span> grundlegende Arithmetik an: </div>
<div class="pre">// threeWayComparisonWithInt4.cpp<br><br>#include &lt;compare&gt;<br>#include &lt;iostream&gt;<br><br>class MyInt {<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; constexpr explicit MyInt(int val): value{val} { }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; auto operator&lt;=&gt;(const MyInt&amp; rhs) const = default; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr auto operator&lt;=&gt;(const int&amp; rhs) const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return value &lt;=&gt; rhs;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr friend MyInt operator+(const MyInt&amp; a, const MyInt&amp; b){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyInt(a.value + b.value);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr friend MyInt operator-(const MyInt&amp; a,const MyInt&amp; b){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyInt(a.value - b.value);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr friend MyInt operator*(const MyInt&amp; a, const MyInt&amp; b){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyInt(a.value * b.value);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr friend MyInt operator/(const MyInt&amp; a, const MyInt&amp; b){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyInt(a.value / b.value);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; friend std::ostream&amp; operator&lt;&lt; (std::ostream &amp;out, const MyInt&amp; myInt){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out &lt;&lt; myInt.value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return out;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;private: <br>&nbsp;&nbsp;&nbsp; int value;<br>};<br><br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr MyInt myInt2011(2011);<br>&nbsp;&nbsp;&nbsp; constexpr MyInt myInt2014(2014);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "myInt2011 &lt; myInt2014: " &lt;&lt; (myInt2011 &lt; myInt2014) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "myInt2011 &lt; 2014: " &lt;&lt; (myInt2011 &lt; 2014) &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "myInt2011 &lt; 2014.5: " &lt;&lt; (myInt2011 &lt; 2014.5) &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "myInt2011 &lt; true: " &lt;&lt; (myInt2011 &lt; true) &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr MyInt res1 = (myInt2014 - myInt2011) * myInt2011;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "res1: " &lt;&lt; res1 &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr MyInt res2 = (myInt2014 - myInt2011) * 2011;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "res2: " &lt;&lt; res2 &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr MyInt res3 = (false + myInt2011 + 0.5)&nbsp; / true;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "res3: " &lt;&lt; res3 &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text"><span class="tx_code">MyInt</span> bietet nun grundlegende Arithmetik mit Objekten vom Datentyp <span class="tx_code">MyInt</span> (1) an; <span class="tx_code">MyInt</span> stellt aber keine Arithmetik für Built-in-Daten wie <span class="tx_code">int</span> (2), <span class="tx_code">double</span> oder <span class="tx_code">bool</span> (3) zur Verfügung. Die Fehlermeldung des Compilers bringt das direkt auf den Punkt: <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/1/9/2/3/2/TN_195406617_c45551390d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Der Compiler kennt im Fall (2) keine Konvertierung von <span class="tx_code">int</span> nach <span class="tx_code">const MyInt</span> und in (3) keine Konvertierung von <span class="tx_code">bool</span> nach <span class="tx_code">const MyIn</span>t. Ein möglicher Weg, aus einem <span class="tx_code">int</span>, <span class="tx_code">double</span> oder <span class="tx_code">bool</span> eine <span class="tx_code">const MyInt</span> zu erzeugen, ist ein nichtexpliziter Konstruktor. Daher lässt sich das Programm übersetzen und ausführen, wenn ich das Schlüsselwort <span class="tx_code">explicit</span> des Konstruktors (1) entferne, da nun implizite Konvertierung einsetzt. Das Ergebnis mag überraschen. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/1/9/2/3/2/TN_195406620_f3b962372b.png" title="<ir_inline itemname=bilder_mvp_bild:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die durch den Compiler erzeugten Operatoren <span class="tx_code">== </span>und <span class="tx_code">!=</span>&nbsp; sind aus Performanzgründen besonders.</div>
<div class="ztitel">Optimierte Operatoren == und != <br></div>
<div class="text">In meinem Artikel "<a href="https://heise.de/-4782690" alt="%7B%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4782690%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4782690%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22text%22%3A%22C%2B%2B20%3A%20Der%20Drei-Weg-Vergleichsoperator%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D" class="" title="Link auf https://heise.de/-4782690">C++20: Der Drei-Weg-Vergleichsoperator</a>" stellte ich vor, dass die Compiler-erzeugten Vergleichsoperatoren lexikographisches Vergleichen anwenden. Das bedeutet in diesem Fall, dass alle Basisklassen von links nach rechts verglichen werden und alle nichtstatischen Mitglieder der Klasse in ihrer Deklarationsreihenfolge.</div>
<div class="text"><a alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Andrew%20Koenig%20%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAndrew_Koenig_%28programmer%29%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAndrew_Koenig_%28programmer%29%22%2C%22anchor%22%3A%22%22%7D" href="https://en.wikipedia.org/wiki/Andrew_Koenig_(programmer)" title="Link auf https://en.wikipedia.org/wiki/Andrew_Koenig_(programmer)" class="">Andrew Koenig </a>schrieb zu meinem letzten Artikel ﻿"<a title="Link auf https://bit.ly/MoreDetailsToSpaceship" class="" alt="%7B%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C%2B%2B20%3A%20More%20Details%20to%20the%20Spaceship%20Operator%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fbit.ly%2FMoreDetailsToSpaceship%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fbit.ly%2FMoreDetailsToSpaceship%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%7D" href="https://bit.ly/MoreDetailsToSpaceship">C++20: More Details to the Spaceship Operator</a>" einen Kommentar auf der Facebook-Gruppe "C++ Enthusiast", den ich zitieren möchte. </div>
<div class="einrueckung"><span class="_3l3x _1n4g">There’s a potential performance problem with &lt;=&gt; that might be worth mentioning: for some types, it is often possible to implement == and != in a way that potentially runs much faster than &lt;=&gt;.<br>For example, for a vectorlike or stringlike class, == and != can stop after determining that the two values being compared have different lengths, whereas &lt;=&gt; has to examine elements until it finds a difference. If one value is a prefix of the other, that makes the difference between O(1) and O(n).</span></div>
<div class="text">Ich habe nichts zu Andrews Kommentar hinzuzufügen außer eine kleine Beobachtung. Das Standardisierungkomitee war sich dieses Performanzproblems bewusst und hat es mit dem Proposal <a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1185r2.html" class="" alt="%7B%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2019%2Fp1185r2.html%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2019%2Fp1185r2.html%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22P1185R2%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1185r2.html">P1185R2</a> adressiert. Konsequenterweise vergleichen die Compiler-erzeugten Operatoren <span class="tx_code">==</span> und <span class="tx_code">!=</span>&nbsp; im Fall des Strings oder Vektors zuerst deren Länge und dann, falls es notwendig ist, ihren Inhalt</div>
<div class="ztitel">Benutzerdefinierte und Compiler-erzeugte Vergleichsoperatoren</div>
<div class="text">Falls du einen der sechs Vergleichsoperatoren definierst und auch alle sechs durch den Compiler erzeugen lässt, stellt sich die Frage: Welcher Operator wird verwendet? So besitzt zum Beispiel meine neue Klasse <span class="tx_code">MyInt</span> einen benutzerdefinierten Kleiner-als-Operator und einen Gleichheitsoperator. Dazu lasse ich mir alle sechs Operatoren vom Compiler erzeugen:</div>
<div class="pre">// threeWayComparisonWithInt5.cpp<br><br>#include &lt;compare&gt;<br>#include &lt;iostream&gt;<br><br>class MyInt {<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; constexpr explicit MyInt(int val): value{val} { }<br>&nbsp;&nbsp;&nbsp; bool operator == (const MyInt&amp; rhs) const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "==&nbsp; " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return value == rhs.value;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; bool operator &lt; (const MyInt&amp; rhs) const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&lt;&nbsp; " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return value &lt; rhs.value;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto operator&lt;=&gt;(const MyInt&amp; rhs) const = default;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp;&nbsp; int value;<br>};<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MyInt myInt2011(2011);<br>&nbsp;&nbsp;&nbsp; MyInt myInt2014(2014);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; myInt2011 == myInt2014;<br>&nbsp;&nbsp;&nbsp; myInt2011 != myInt2014;<br>&nbsp;&nbsp;&nbsp; myInt2011 &lt; myInt2014;<br>&nbsp;&nbsp;&nbsp; myInt2011 &lt;= myInt2014;<br>&nbsp;&nbsp;&nbsp; myInt2011 &gt; myInt2014;<br>&nbsp;&nbsp;&nbsp; myInt2011 &gt;= myInt2014;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Um nachvollziehen zu können, wann meine benutzerdefinierten Operatoren <span class="tx_code">==</span> und <span class="tx_code">&lt;</span> zum Zuge kommen, lasse ich eine entsprechende Nachricht auf <span class="tx_code">std::cout</span> schreiben. Dadurch kann ich beide Operatoren nicht mehr als <span class="tx_code">constexpr</span> deklarieren, denn <span class="tx_code">std::cout</span> wird zur Laufzeit des Programms ausgeführt. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/1/9/2/3/2/TN_195406627_8d6b66356b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">In diesem Fall verwendet der Compiler den benutzerdefinierten Operator <span class="tx_code">==</span> und <span class="tx_code">&lt;</span>. Darüber hinaus erzeugt er den <span class="tx_code">!=</span>- aus dem <span class="tx_code">==</span>-Operator. Der Compiler erzeugt aber nicht den <span class="tx_code">==</span>- aus dem <span class="tx_code">!=-</span>Operator. </div>
<div class="text">Diese Ausgabe hat mich nicht überrascht, da sich hier C++ ähnlich wie Python verhält. In Python 3 erzeugt der Compiler den Operator <span class="tx_code">!=</span>&nbsp; aus dem Operator <span class="tx_code">==</span>. Der umgekehrte Automatismus gilt in Python 3 auch nicht. In Python 2 besitzt die sogenannte<i> rich comparison (</i>die benutzerdefinierten sechs Vergleichsoperatoren) eine höhere Priorität als der Drei-Weg-Vergleichsoperator <span class="tx_code">__cmp__</span>. Ich habe im letzten Satz explizit von Python 2 gesprochen, da der Drei-Weg-Vergleichsoperator nicht mehr Bestandteil von Python 3 ist. </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Designated Initialization ist ein Spezialfall der Aggregat Initialization und erlaubt es, die Mitglieder einer Klasse direkt mithilfe ihres Namens zu initialisieren. Genau darum geht es in meinem nächsten Artikel zu C++20. <br></div>