<div class="vorspann">Der Compiler führt beim Erzeugen der sechs Vergleichsoperatoren einen sehr smarten Job aus. Letztlich erzeugt er gratis intuitive und effiziente Vergleichsoperatoren. Eine genauere Betrachtung des Spaceship Operator.</div>
<div class="text">Zuerst möchte ich in dem Artikel auf einen Punkt eingehen, den ich wohl schon in meinem letzten Artikel "<a class="" title="Link auf https://heise.de/-4782690" alt="%7B%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4782690%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4782690%22%2C%22text%22%3A%22C%2B%2B20%3A%20Der%20Drei-Weg-Vergleichsoperator%20%26lt%3B%3D%26gt%3B%22%2C%22type%22%3A%22E%22%7D" href="https://heise.de/-4782690">C++20: Der Drei-Weg-Vergleichsoperator &lt;=&gt;</a>" hätte vorstellen sollen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/1/5/2/1/4/TN_195094607_f5b3f64616.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Direkte Anwendung des Drei-Weg-Vergleichsoperators</div>
<div class="text">Der Drei-Weg-Vergleichsoperator lässt sich auch direkt anwenden:</div>
<div class="pre">// spaceship.cpp<br><br>#include &lt;compare&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; int a(2011);<br>&nbsp;&nbsp;&nbsp; int b(2014);<br>&nbsp;&nbsp;&nbsp; auto res = a &lt;=&gt; b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; if (res &lt; 0) std::cout &lt;&lt; "a &lt; b" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; else if (res == 0) std::cout &lt;&lt; "a == b" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; else if (res &gt; 0) std::cout &lt;&lt; "a &gt; b" &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::string str1("2014");<br>&nbsp;&nbsp;&nbsp; std::string str2("2011");<br>&nbsp;&nbsp;&nbsp; auto res2 = str1 &lt;=&gt; str2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; if (res2 &lt; 0) std::cout &lt;&lt; "str1 &lt; str2" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; else if (res2 == 0) std::cout &lt;&lt; "str1 == str2" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; else if (res2 &gt; 0) std::cout &lt;&lt; "str1 &gt; str2" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; vec1{1, 2, 3};<br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; vec2{1, 2, 3};<br>&nbsp;&nbsp;&nbsp; auto res3 = vec1 &lt;=&gt; vec2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; if (res3 &lt; 0) std::cout &lt;&lt; "vec1 &lt; vec2" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; else if (res3 == 0) std::cout &lt;&lt; "vec1 == vec2" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; else if (res3 &gt; 0) std::cout &lt;&lt; "vec1 &gt; vec2" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Der Spaceship Operator lässt sich direkt für ints (1), Strings (2) und Vektoren (3) anwenden. Dank des Wandbox-Online-Compilers und des neuesten GCC folgt hier auch schon die Ausgabe des Programms: </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/1/5/2/1/4/TN_195094613_e57d1d7925.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Jetzt stelle ich aber etwas Neues vor. C++20 führt das Konzept von "Rewritten Expressions" ein.</div>
<div class="ztitel">Ausdrücke umschreiben</div>
<div class="text">Wenn der Compiler einen Ausdruck wie <span class="tx_code">a &lt; </span><span class="tx_code">b</span> parst, schreibt er ihn in einen Ausdruck <span class="tx_code">(a &lt;=&gt; b) &lt; 0</span> um und wendet dabei den Spacehip Operator an. Natürlich gilt diese Regel für alle sechs Vergleichsoperatoren: <b><span class="tx_code">a OP b</span></b> wird zu <b><span class="tx_code">(a &lt;=&gt; b) OP 0</span></b>. Das ist noch nicht die ganze Magie. Falls es keine Konvertierung von <span class="tx_code">Datentyp(a)</span> zu <span class="tx_code">Datentyp(b)</span> gibt, erzeugt der Compiler den Ausdruck <span class="tx_code"><b>0 OP (b &lt;=&gt; a)</b></span>.</div>
<div class="text">Das heißt zum Beispiel für den Kleiner-als Operator, dass der Compiler <span class="tx_code">0 &lt; (b &lt;=&gt; a)</span> erzeugt, falls <span class="tx_code">(a &lt;=&gt; b) &lt; 0</span> nicht möglich ist. Damit kümmert sich der Compiler automatisch um die Symmetrie der Vergleichsoperatoren. Das folgende Beispiel zeigt dieses Umschreiben der Ausdrücke in Aktion:</div>
<div class="pre">// rewrittenExpressions.cpp<br><br>#include &lt;compare&gt;<br>#include &lt;iostream&gt;<br><br>class MyInt {<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; constexpr MyInt(int val): value{val} { }<br>&nbsp;&nbsp;&nbsp; auto operator&lt;=&gt;(const MyInt&amp; rhs) const = default;&nbsp; <br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; int value;<br>};<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; constexpr MyInt myInt2011(2011);<br>&nbsp;&nbsp;&nbsp; constexpr MyInt myInt2014(2014);<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; constexpr int int2011(2011);<br>&nbsp;&nbsp;&nbsp; constexpr int int2014(2014);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; if (myInt2011 &lt; myInt2014) std::cout &lt;&lt; "myInt2011 &lt; myInt2014" &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; if ((myInt2011 &lt;=&gt; myInt2014) &lt; 0) std::cout &lt;&lt; "myInt2011 &lt; myInt2014" &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; if (myInt2011 &lt; int2014) std:: cout &lt;&lt; "myInt2011 &lt; int2014" &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; if ((myInt2011 &lt;=&gt; int2014) &lt; 0) std:: cout &lt;&lt; "myInt2011 &lt; int2014" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; if (int2011 &lt; myInt2014) std::cout &lt;&lt; "int2011 &lt; myInt2014" &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; if (0 &lt; (myInt2014 &lt;=&gt; int2011)) std:: cout &lt;&lt; "int2011 &lt; myInt2014" &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">An den Stellen (1), (2) und (3) habe ich den Kleiner-als Operator und den entsprechenden Ausdruck für den Spaceship Operator verwendet. (4) ist besonders interessant. Das Beispiel veranschaulicht, wie der <br>Vergleich (<span class="tx_code">int2011 &lt; myInt2014</span>) das Erzeugen des Spaceship-Ausdrucks (<span class="tx_code">0 &lt; (myInt2014 &lt;=&gt; int2011</span>) anstößt.</div>
<div class="text">Um ehrlich zu sein, besitzt <span class="tx_code">MyInt</span> ein Designproblem. Konstruktoren, die ein Argument annehmen, sollten explizit deklariert werden.</div>
<div class="ztitel">Explizite Konstruktoren</div>
<div class="text">Konstruktoren, die wie <span class="tx_code">MyInt(int val)</span> nur ein Argument annehmen, sind Konvertierungskonstruktoren. Das heißt in dem konkreten Fall, dass <span class="tx_code">MyInt</span> mit jeder Ganzzahl oder Gleitkommazahl erzeugt werden kann. Der Grund ist, dass jede Ganzzahl oder Gleitkommazahl sich in ein <span class="tx_code">int</span> konvertieren lässt. Diese implizite Konvertierung nach <span class="tx_code">int</span> ist in der Regel nicht im Sinne des Klassendesigners.</div>
<div class="ztitel_kleiner">Erster Versuch<br></div>
<div class="text">Um die implizite Konvertierung zu unterbinden, annotiere ich den Konstruktor mit dem <span class="tx_code">explicit</span>-Schlüsselwort und folge damit Metaregel von Python: "explicit is better than implicit". Im folgenden Beispiel kommt der explizite Konstruktor zum Einsatz: </div>
<div class="pre">// threeWayComparisonWithInt1.cpp<br><br>#include &lt;compare&gt;<br>#include &lt;iostream&gt;<br><br>class MyInt {<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; constexpr explicit MyInt(int val): value{val} { }<br>&nbsp;&nbsp;&nbsp; auto operator&lt;=&gt;(const MyInt&amp; rhs) const = default;&nbsp; <br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; int value;<br>};<br><br>template &lt;typename T, typename T2&gt;<br>constexpr bool isLessThan(const T&amp; lhs, const T2&amp; rhs) {<br>&nbsp;&nbsp;&nbsp; return lhs &lt; rhs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; constexpr MyInt myInt2011(2011);<br>&nbsp;&nbsp;&nbsp; constexpr MyInt myInt2014(2014);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; constexpr int int2011(2011);<br>&nbsp;&nbsp;&nbsp; constexpr int int2014(2014);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isLessThan(myInt2011, myInt2014): "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; isLessThan(myInt2011, myInt2014) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isLessThan(int2011, myInt2014): "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; isLessThan(int2011, myInt2014) &lt;&lt; std::endl;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isLessThan(myInt2011, int2014): "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; isLessThan(myInt2011, int2014) &lt;&lt; std::endl;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; constexpr auto res = isLessThan(myInt2011, int2014);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Das war einfach. Dank des expliziten Konstruktors ist die implizite Konvertierung von <span class="tx_code">int</span> nach <span class="tx_code">MyInt</span> in (1) nicht mehr zulässig. Der Compiler gibt mir das deutlich zu verstehen:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/1/5/2/1/4/TN_195094620_21e24b09e9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Wenn du sorgfältig die Fehlermeldung liest, fällt auf, dass es keinen Operator <span class="tx_code">&lt;</span> für einen rechten <span class="tx_code">int</span>-Operanden gibt. Darüber hinaus kann der Compiler keine Konvertierung von <span class="tx_code">int</span> nach <span class="tx_code">MyInt</span> anwenden. Interessanterweise beschwert sich der Compiler zuerst über den Ausdruck (2) und nicht (3). Beide Ausdrücke sind nicht zulässig.<br></div>
<div class="ztitel">Zweiter Versuch</div>
<div class="text">Um Vergleiche von <span class="tx_code">MyInt</span> und <span class="tx_code">int</span>s zu ermöglichen, benötigt <span class="tx_code">MyInt</span> einen zusätzlichen Drei-Weg-Vergleichsoperator:</div>
<div class="pre">#include &lt;compare&gt;<br>#include &lt;iostream&gt;<br><br>class MyInt {<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; constexpr explicit MyInt(int val): value{val} { }<br>&nbsp;&nbsp;&nbsp; auto operator&lt;=&gt;(const MyInt&amp; rhs) const = default; // (4) <br>&nbsp;&nbsp;&nbsp; constexpr auto operator&lt;=&gt;(const int&amp; rhs) const {&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return value &lt;=&gt; rhs;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;private: <br>&nbsp;&nbsp;&nbsp; int value;<br>};<br><br>template &lt;typename T, typename T2&gt;<br>constexpr bool isLessThan(const T&amp; lhs, const T2&amp; rhs) {<br>&nbsp;&nbsp;&nbsp; return lhs &lt; rhs;<br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; constexpr MyInt myInt2011(2011);<br>&nbsp;&nbsp;&nbsp; constexpr MyInt myInt2014(2014);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; constexpr int int2011(2011);<br>&nbsp;&nbsp;&nbsp; constexpr int int2014(2014);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isLessThan(myInt2011, myInt2014): "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; isLessThan(myInt2011, myInt2014) &lt;&lt; std::endl; // (3) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isLessThan(int2011, myInt2014): "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; isLessThan(int2011, myInt2014) &lt;&lt; std::endl;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isLessThan(myInt2011, int2014): "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; isLessThan(myInt2011, int2014) &lt;&lt; std::endl;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; constexpr auto res = isLessThan(myInt2011, int2014);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">In (1) habe ich den Drei-Weg-Vergleichsoperator definiert und ihn als <span class="tx_code">constexpr</span> deklariert. Der benutzerdefinierte Drei-Weg-Vergleichsoperator ist im Gegensatz zu dem Compiler-erzeugten nicht <span class="tx_code">constexpr</span>. Konsequenterweise kann ich die Funktion <span class="tx_code">isLessThan</span> (4) zur Compile-Zeit ausführen. Die Vergleiche von <span class="tx_code">MyInt</span>s und <span class="tx_code">int</span>s sind nun in allen Kombinationen möglich:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/1/5/2/1/4/TN_195094625_e977adc9b7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Ich muss gestehen, dass ich die Implementierung der verschiedenen Drei-Weg-Vergleichsoperatoren sehr elegant finde. Der Compiler erzeugt den Vergleich mit <span class="tx_code">MyI</span><span class="tx_code">nt</span>s, der Benutzer definiert den Vergleich mit <span class="tx_code">int</span>s. In diesem Fall ist es ausreichend, zwei Operatoren zu definieren und damit 18 = 3 * 6 Kombinationen von Vergleichsoperatoren zu erhalten. 3 steht für die Kombination für <span class="tx_code">int</span>s und <span class="tx_code">MyInt</span>s, in der zumindest ein <span class="tx_code">MyInt</span> beteiligt ist und 6 für die Vergleichsoperatoren. In meinem letzten Artikel "<a title="Link auf https://heise.de/-4782690" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4782690%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C%2B%2B20%3A%20Der%20Drei-Weg-Vergleichsoperator%20%26lt%3B%3D%26gt%3B%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4782690%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%7D" class="" href="https://heise.de/-4782690">C++20: Der Drei-Weg-Vergleichsoperator &lt;=&gt;</a>" ging ich auf die 18 Vergleichsoperatoren ein, die es vor C++20 in diesem Fall zu implementieren galt. </div>
<div class="text">Ein Punkt muss ich noch hervorheben: Mit der jetzigen Implementierung lässt sich immer <span class="tx_code">MyInt</span> mit jedem Datentyp vergleichen, der sich zu <span class="tx_code">int</span> konvertieren lässt. </div>
<div class="text">Stopp! Du magst dich jetzt fragen, warum die aktuelle Implementierung, die auf einem expliziten Konstruktor basiert,</div>
<div class="pre">class MyInt {<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; constexpr explicit MyInt(int val): value{val} { }<br>&nbsp;&nbsp;&nbsp; auto operator&lt;=&gt;(const MyInt&amp; rhs) const = default; &nbsp;<br>&nbsp;&nbsp;&nbsp; constexpr auto operator&lt;=&gt;(const int&amp; rhs) const {&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return value &lt;=&gt; rhs;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;private: <br>&nbsp;&nbsp;&nbsp; int value;<br>};<br></div>
<div class="text">besser ist als die ursprüngliche Implementierung. Diese Implementierung verwendet einen Konstruktor, der implizite Konvertierungen erlaubt? Beide Implementierung erlauben den Vergleich mit Ganzzahlen und Gleitkommazahlen:</div>
<div class="pre">class MyInt {<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; constexpr MyInt(int val): value{val} { }<br>&nbsp;&nbsp;&nbsp; auto operator&lt;=&gt;(const MyInt&amp; rhs) const = default;&nbsp; <br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; int value;<br>};<br></div>
<div class="ztitel">Wie geht's weiter?<br></div>
<div class="text">Es gibt einen feinen Unterschied zwischen dem expliziten und dem nicht expliziten Konstruktor im Fall von <span class="tx_code">MyInt</span>. Dieser Unterschied wird deutlich, wenn ich in meinem nächsten Artikel <span class="tx_code">MyInt int</span> ähnlich entwerfe. Die sind aber nicht alle Punkte: Der Compiler erzeugt aus Performanzgründen spezielle<span class="tx_code"> ==</span>- und <span class="tx_code">!=</span>-Operatoren. Darüber hinaus verdient das Zusammenspiel der klassischen und der Drei-Weg-Vergleichsoperatoren einen eigenen Artikel.<br></div>
