<div class="vorspann">Nun schließe ich meine Artikelserie zu Features der C++20-Bibliothek ab. Den Abschluss bilden die Klasse std::source_location und die Funktionen zur Bit-Manipulation.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/4/8/2/4/TN_203383736_5e313761de.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">std::source_location</div>
<div class="text"><span class="tx_code">std::source_location</span> bietet Informationen zum Sourcecode an. Diese umfassen den Dateinamen, die Zeilennummer und den Funktionsnamen. Diese Werte sind zum Debuggen, Loggen oder Testen sehr wertvoll. Damit ist die Klasse <span class="tx_code">std::source_location</span> die deutliche bessere Alternative zu den vordefinierten Makros <span class="tx_code">__FILE__</span> und <span class="tx_code">__LINE__</span> in C++11. Das heißt natürlich, dass<span class="tx_code"> std::source_location</span> in C++20 zum Einsatz kommen sollte.<br></div>
<div class="text">Die folgende Tabelle stellt das Interface von <span class="tx_code">std::source_location</span> kompakt dar.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/4/8/2/4/TN_203383739_2d136bbce7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Der Aufruf <span class="tx_code">std::source_location::current()</span> erzeugt eine neues <span class="tx_code">source_location</span>-Objekt <span class="tx_code">src. </span>Escstellt die Information des Aufrufers bereit. Zum jetzigen Zeitpunkt unterstützt noch kein C++-Compiler <span class="tx_code">std::source_location</span>. Konsequenterweise ist das folgende Beispiel <span class="tx_code">sourceLocation.cpp</span> direkt von der Online-Ressource <a title="Link auf https://en.cppreference.com/w/cpp/utility/source_location" alt="%7B%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fsource_location%22%2C%22type%22%3A%22E%22%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fsource_location%22%2C%22text%22%3A%22cppreference.com%2Fsource_location%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%7D" href="https://en.cppreference.com/w/cpp/utility/source_location" class="">cppreference.com/source_location</a>:</div>
<div class="pre">// sourceLocation.cpp<br>// from cppreference.com<br><br>#include &lt;iostream&gt;<br>#include &lt;string_view&gt;<br>#include &lt;source_location&gt;<br>&nbsp;<br>void log(std::string_view message,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::source_location&amp; location = std::source_location::current())<br>{<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "info:"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; location.file_name() &lt;&lt; ':'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; location.line() &lt;&lt; ' '<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; message &lt;&lt; '\n';<br>}<br>&nbsp;<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; log("Hello world!");&nbsp; // info:main.cpp:19 Hello world!<br>}<br></div>
<div class="text">Die Ausgabe des Programms ist Bestandteil des Sourcecodes.</div>
<div class="text">Durch C++20 wird es sehr einfach, auf Bits oder Bit-Sequenzen zuzugreifen oder sie zu modifizieren.</div>
<div class="ztitel">Bit-Manipulationen</div>
<div class="text">Dank des neuen Datentyps <span class="tx_code">std::endia</span>n ist es einfach, die Byte-Reihenfolge eines skalaren Datentyps zu ermitteln. </div>
<div class="text"><b>Byte-Reihenfolge</b><br></div>
<div class="text"><ul><li>Die Byte-Reihenfolge kann big-endian order little-endian sein. Ersteres bedeutet, dass das höchstwertige Byte zuerst gespeichert wird, das zweite, dass das kleinstwertige Byte zuerst gespeichert wird.<br></li><li>Ein skalarer Datentyp ist ein arithmetischer Datentyp, eine <span class="tx_code">enum</span>, ein Zeiger, ein Zeiger auf ein Mitglied oder ein <span class="tx_code">std::nullptr_t</span>.<br></li></ul></div>
<div class="text">Die Klasse <span class="tx_code">endian</span> bietet die Byte-Reihenfolge für skalare Datentypen an:</div>
<div class="pre">enum class endian<br>{<br>&nbsp;&nbsp;&nbsp; little = /*implementation-defined*/,<br>&nbsp;&nbsp;&nbsp; big&nbsp;&nbsp;&nbsp; = /*implementation-defined*/,<br>&nbsp;&nbsp;&nbsp; native = /*implementation-defined*/<br>};<br><br></div>
<div class="text"><ul><li>Wenn alle skalare Datentypen little-endian sind, dann ist der Wert von <span class="tx_code">std::endian::native std::endian::little.</span></li></ul><ul><li>Wenn alle skalare Datentypen big-endian sind, dann ist der Wert von <span class="tx_code">std::endian::native std::endian::big.</span></li></ul></div>
<div class="text">Selbst Sonderfälle werden unterstützt:</div>
<div class="text"><ul><li>Wenn alle skalare Daten <span class="tx_code">sizeof 1</span> besitzen und damit die Byte-Reihenfolge irrelevant ist, sind die Werte aller Aufzähler <span class="tx_code">std::endian::little</span>, <span class="tx_code">std::endian::big</span> und <span class="tx_code">std::endian::native</span> identisch.<br></li><li>Falls eine Plattform verschiedene Byte-Reihenfolgen verwendet, dann besitzt <span class="tx_code">std::endian::native</span> einen anderen Wert als <span class="tx_code">std::endian::big</span> oder <span class="tx_code">std::endian::little</span>.</li></ul></div>
<div class="text">Das Ausführen des Programms <span class="tx_code">getEndianness.cpp</span> auf einer x86-Architektur gibt mir die Antwort <span class="tx_code">little-endian</span> zurück:<br></div>
<div class="pre">// getEndianness.cpp<br><br>#include &lt;bit&gt;<br>#include &lt;iostream&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; if constexpr (std::endian::native == std::endian::big) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "big-endian" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else if constexpr (std::endian::native == std::endian::little) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "little-endian"&nbsp; &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // little-endian<br>&nbsp;&nbsp;&nbsp; }<br><br>}</div>
<div class="text"><span class="tx_code">constexpr if</span> erlaubt es, Sourcecode bedingt zu kompilieren. Das heißt in dem konkreten Fall, dass die Kompilierung von der Byte-Reihenfolge der Architektur abhängt. Mehr Information zur Byte-Reihenfolge gibt die <a title="Link auf https://de.wikipedia.org/wiki/Byte-Reihenfolge" alt="%7B%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FByte-Reihenfolge%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FByte-Reihenfolge%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22text%22%3A%22gleichnamige%20Wikipedia-Seite%22%7D" href="https://de.wikipedia.org/wiki/Byte-Reihenfolge" class="">gleichnamige Wikipedia-Seite</a>.<br></div>
<div class="ztitel">Bits oder Bit-Sequenzen manipulieren<br></div>
<div class="text">Die folgenden Tabellen zeigen alle Funktionen im Überblick.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/4/8/2/4/TN_203383747_86b779de3d.png" title="<ir_inline itemname=bilder_mvp_bild:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die Funktionen benötigen mit Ausnahme der Funktion <span class="tx_code">std::bit_cast</span> eine vorzeichenlose Ganzzahl (<span class="tx_code">unsigned char</span>,<span class="tx_code"> unsigned short</span>,<span class="tx_code"> unsigned int</span>, <span class="tx_code">unsigned long</span> oder <span class="tx_code">unsigned long long</span>).</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/4/8/2/4/TN_203383754_4c2156f544.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die Funktion <span class="tx_code">bit.cpp</span> zeigt die Anwendung der Funktionen:</div>
<div class="pre">// bit.cpp<br><br>#include &lt;bit&gt;<br>#include &lt;bitset&gt;<br>#include &lt;iostream&gt;<br>&nbsp;<br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::uint8_t num= 0b00110010;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::has_single_bit(0b00110010): " <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::has_single_bit(num) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::bit_ceil(0b00110010): " <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::bitset&lt;8&gt;(std::bit_ceil(num)) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::bit_floor(0b00110010): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::bitset&lt;8&gt;(std::bit_floor(num)) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::bit_width(5u): " <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::bit_width(5u) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::rotl(0b00110010, 2): " <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::bitset&lt;8&gt;(std::rotl(num, 2)) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::rotr(0b00110010, 2): " <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::bitset&lt;8&gt;(std::rotr(num, 2)) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::countl_zero(0b00110010): " <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::countl_zero(num) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::countl_one(0b00110010): " <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::countl_one(num) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::countr_zero(0b00110010): " <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::countr_zero(num) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::countr_one(0b00110010): " <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::countr_one(num) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::popcount(0b00110010): " <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::popcount(num) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Die folgende Ausgabe erzeugt das Programm:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/4/8/2/4/TN_203383760_22f699e68a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Das nächste Programm zeigt den Einsatz und die Ausgabe der Funktionen <span class="tx_code">std::bit_floor</span>, <span class="tx_code">std::bit_ceil</span>, <span class="tx_code">std::bit_width</span> und <span class="tx_code">std::bit_popcoun</span>t für die Zahlen 2 bis 7:</div>
<div class="pre">// bitFloorCeil.cpp<br><br>#include &lt;bit&gt;<br>#include &lt;bitset&gt;<br>#include &lt;iostream&gt;<br>&nbsp;<br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; for (auto i = 2u; i &lt; 8u; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "bit_floor(" &lt;&lt; std::bitset&lt;8&gt;(i) &lt;&lt; ") = " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::bit_floor(i) &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "bit_ceil(" &lt;&lt; std::bitset&lt;8&gt;(i) &lt;&lt; ") = " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::bit_ceil(i) &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "bit_width(" &lt;&lt; std::bitset&lt;8&gt;(i) &lt;&lt; ") = " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::bit_width(i) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "bit_popcount(" &lt;&lt; std::bitset&lt;8&gt;(i) &lt;&lt; ") = " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::popcount(i) &lt;&lt; '\n';&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/4/8/2/4/TN_203383765_ca2904054d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Neben Coroutinen hat C++20 viele weitere Concurrency-Features anzubieten. Die neuen atomaren Variablen gibt es für Gleitkommazahlen und Smart Pointer. Atomare Variablen erlauben es darüber hinaus, auf Benachrichtigungen zu warten. Zur Koordination von Threads wird C++20 um Sempaphoren, Latches und Barriers erweitert. Zusätzlich wurde <span class="tx_code">std::thread</span> mit <span class="tx_code">std::jthread</span> verbessert. Die Ausführung eines <span class="tx_code">std::jthread</span> kann unterbrochen werden. Zusätzlich ruft ein <span class="tx_code">std::jthread</span> automatisch <span class="tx_code">join</span> in seinem Destruktor auf. <br></div>