<div class="vorspann">Dank C++20-Standard werden Lambda-Ausdrücke mächtiger. Von den vielen Verbesserungen rund um Lambda-Ausdrücke sind Template-Parameter mein Favorit.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/4/6/0/4/0/TN_197709866_c5a98b605a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Lamba-Ausdrücke (Lambdas) unterstützen mit C++20 Template-Parameter, besitzen einen Default-Konstruktor und einen Copy-Zuweisungsoperator, wenn sie keinen Zustand besitzen und können in nicht evaluierten Kontexten verwendet werden. Zusätzlich stellen sie fest, wenn der <span class="tx_code">this</span>-Zeiger implizit kopiert wird. Das heißt, dass eine häufige Ursache von undefinierten Verhalten mit Lambdas der Vergangenheit angehört.</div>
<div class="text">Der Artikel beginnt mit Template-Parametern für Lambdas.<br></div>
<div class="ztitel">Template-Parameter für Lambdas<br></div>
<div class="text">Zugegeben, die Unterschiede zwischen typisierten Lambdas, generischen Lambdas und Template Lambas (Template-Parameter für Lambdas) sind subtil.</div>
<div class="ztitel_kleiner">Vier Lambda Variationen<br></div>
<div class="text">Das folgende Programm verwendet vier Variationen der <span class="tx_code">add</span> Funktion, die mit Lambdas implementiert ist.<br></div>
<div class="pre">// templateLambda.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>// only to int convertible types&nbsp;&nbsp;&nbsp; (C++11):<br>auto sumInt = [](int fir, int sec) { return fir + sec; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>// arbitrary types&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (C++14):<br>auto sumGen = [](auto fir, auto sec) { return fir + sec; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>// arbitrary, but convertible types (C++14):<br>auto sumDec = [](auto fir, decltype(fir) sec) { return fir + sec; }; <br>// arbitrary, but identical types&nbsp;&nbsp; (C++20):<br>auto sumTem = []&lt;typename T&gt;(T fir, T sec) { return fir + sec; };&nbsp;&nbsp;&nbsp; <br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; std::cout &lt;&lt; "sumInt(2000, 11): " &lt;&lt; sumInt(2000, 11) &lt;&lt; std::endl;&nbsp; <br>&nbsp; std::cout &lt;&lt; "sumGen(2000, 11): " &lt;&lt; sumGen(2000, 11) &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "sumDec(2000, 11): " &lt;&lt; sumDec(2000, 11) &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "sumTem(2000, 11): " &lt;&lt; sumTem(2000, 11) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; std::string hello = "Hello ";<br>&nbsp; std::string world = "world"; <br>&nbsp; // std::cout &lt;&lt; "sumInt(hello, world): " <br>&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; sumInt(hello, world) &lt;&lt; std::endl; ERROR<br>&nbsp; std::cout &lt;&lt; "sumGen(hello, world): " &lt;&lt; sumGen(hello, world) &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "sumDec(hello, world): " &lt;&lt; sumDec(hello, world) &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "sumTem(hello, world): " &lt;&lt; sumTem(hello, world) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; std::cout &lt;&lt; "sumInt(true, 2010): " &lt;&lt; sumInt(true, 2010) &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "sumGen(true, 2010): " &lt;&lt; sumGen(true, 2010) &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "sumDec(true, 2010): " &lt;&lt; sumDec(true, 2010) &lt;&lt; std::endl; &nbsp; <br>&nbsp; // std::cout &lt;&lt; "sumTem(true, 2010): " <br>&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; sumTem(true, 2010) &lt;&lt; std::endl; ERROR<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Bevor ich die wohl überraschende Ausgabe des Programms vorstelle, möchte ich die vier Lambdas kurz vergleichen.</div>
<div class="text"><b><span class="tx_code">sumInt</span></b></div>
<div class="text"><ul><li>C++11</li><li>typisierte Lambda</li><li>nimmt nur nach <span class="tx_code">int</span> konvertierbare Datentypen an<br></li></ul></div>
<div class="text"><b><span class="tx_code">sumGen</span></b></div>
<div class="text"><ul><li>C++14</li><li>generische Lambda</li><li>nimmt alle Datentypen an<br></li></ul></div>
<div class="text"><b><span class="tx_code">sumDec</span></b></div>
<div class="text"><ul><li>C++14</li><li>generische Lambda</li><li>der zweite Datentyp muss sich zum ersten Daten konvertieren lassen</li></ul></div>
<div class="text"><b><span class="tx_code">sumTem</span></b><br></div>
<div class="text"><ul><li>C++20</li><li>Template Lambda</li><li>der erste und der zweite Datentyp müssen identisch sein<br></li></ul></div>
<div class="text">Was bedeutet, wenn die Template-Argumente verschiedene Datentypen besitzen? Klar, jedes Lambda nimmt<span class="tx_code"> int</span> an (1) und das typisierte Lambda <span class="tx_code">sumInt</span> nimmt keinen <span class="tx_code">std::string</span> an (2).</div>
<div class="text">Der Aufruf der Lambdas mit dem <span class="tx_code">bool</span> <span class="tx_code">true</span> und dem <span class="tx_code">int </span>2020 <span class="tx_code">birgt</span> einiges Überraschungspotential (3). </div>
<div class="text"><ul><li> <span class="tx_code">sumInt</span> gibt <span class="tx_code">2011</span> zurück, da <span class="tx_code">true</span> zu <span class="tx_code">int</span> erweitert wird (integral promotion).</li><li><span class="tx_code">sumGen</span> gibt <span class="tx_code">2011</span> zurück, da <span class="tx_code">true</span> zu <span class="tx_code">int</span> erweitert wird. Es gibt aber einen feinen Unterschied zwischen <span class="tx_code">sumInt</span> und <span class="tx_code">sumGen</span>, dazu unten mehr.<br></li><li><span class="tx_code">sumDec</span> gibt 2 zurück. Warum? Der Datentyp des zweiten Parameters <span class="tx_code">sec</span> erhält den Datentyp des ersten Parameter<span class="tx_code">s fir.</span> Dank <span class="tx_code">decltype(fir) sec</span> ermittelt der Compiler den Datentyp von <span class="tx_code">fir</span> und wendet den gleichen Datentyp auf <span class="tx_code">sec</span> an. Daher wird 2010 zu <span class="tx_code">true</span>. In dem Ausdruck <span class="tx_code">fir + </span><span class="tx_code">sec</span> wird <span class="tx_code">fir </span>zur <span class="tx_code">1</span> erweitert und somit ist das Ergebnis <span class="tx_code">2</span>. <br></li><li><span class="tx_code">sumTem</span> ist nicht gültig. <br></li></ul></div>
<div class="text">Dank dem <a class="" alt="%7B%22text%22%3A%22Compiler%20Explorer%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%7D" href="https://godbolt.org/" title="Link auf https://godbolt.org/">Compiler Explorer</a> und GCC lässt sich das Programm ausführen.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/4/6/0/4/0/TN_197709876_0df3b44388.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Zwischen den Funktionen <span class="tx_code">sumInt</span> und <span class="tx_code">sumGen</span> besteht ein feiner Unterschied. Die Erweiterungen des <span class="tx_code">true</span> Werts passiert im Falle der <span class="tx_code">sumInt</span> Funktion beim Aufrufenden. Jedoch findet die Erweiterung des true Wertes bei der Funktion <span class="tx_code">sumGen</span> in dem arithmetischen Ausdruck <span class="tx_code">fir + sec</span> statt. Hier ist der entscheidende Teil des Programms nochmals.</div>
<div class="pre">auto sumInt = [](int fir, int sec) { return fir + sec; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>auto sumGen = [](auto fir, auto sec) { return fir + sec; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>int main() {<br>&nbsp; <br>&nbsp; sumInt(true, 2010);<br>&nbsp; sumGen(true, 2010);<br>&nbsp; <br>}</div>
<div class="text">Wenn ich den <a title="Link auf https://cppinsights.io/s/3ec92b0b" href="https://cppinsights.io/s/3ec92b0b" alt="%7B%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F3ec92b0b%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F3ec92b0b%22%2C%22text%22%3A%22Code-Schnipsel%20in%20C%2B%2B%20Insights%20verwende%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" class="">Code-Schnipsel in C++ Insights verwende</a>, lässt sich der Unterschied genau studieren. Ich stelle in dem folgenden Code nur den entscheidenden Teil des vom Compiler erzeugten Codes dar.</div>
<div class="pre">class __lambda_1_15<br>{<br>&nbsp; public: <br>&nbsp; inline /*constexpr */ int operator()(int fir, int sec) const<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>&nbsp; }<br>&nbsp; <br>};<br><br>__lambda_1_15 sumInt = __lambda_1_15{};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>class __lambda_2_15<br>{<br>&nbsp; public: <br>&nbsp; template&lt;class type_parameter_0_0, class type_parameter_0_1&gt;<br>&nbsp; inline /*constexpr */ auto operator()(type_parameter_0_0 fir, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type_parameter_0_1 sec) const<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>&nbsp; }<br>&nbsp; <br>&nbsp; #ifdef INSIGHTS_USE_TEMPLATE<br>&nbsp; template&lt;&gt;<br>&nbsp; inline /*constexpr */ int operator()(bool fir, int sec) const<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; return static_cast&lt;int&gt;(fir) + sec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; }<br>&nbsp; #endif<br>&nbsp; <br>};<br><br>__lambda_2_15 sumGen = __lambda_2_15{};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>int main()<br>{<br>&nbsp; sumInt.operator()(static_cast&lt;int&gt;(true), 2010);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; sumGen.operator()(true, 2010);<br>}</div>
<div class="text">Vermutlich ist bekannt, dass der Compiler automatisch ein Funktionsobjekt aus einem Lambda-Ausdruck erzeugt. Falls nicht, möchte ich auf Andreas Fertigs Artikel zu seinem Werkzeug C++ Insights auf meinem Blog verweisen. Ein Artikel beschäftigt sich explizit mit Lambdas: <a class="" href="https://www.grimm-jaud.de/index.php/blog/category/c-insights" title="Link auf https://www.grimm-jaud.de/index.php/blog/category/c-insights" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fc-insights%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fc-insights%22%2C%22text%22%3A%22C%2B%2B%20Insights%20Artikel%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%7D">C++ Insights Artikel</a>.</div>
<div class="text">Sorgfältiges Studieren des Codeschnipsels enthüllt den Unterschied: <span class="tx_code">sumInt</span> führt die Erweiterung zu<span class="tx_code"> int </span>beim Aufruf der Funktion (1) aus. Hingegen findet die Erweiterung auf <span class="tx_code">sumGen</span> in dem arithmetischen Ausdruck statt (2).</div>
<div class="text">Die Beispiele dieses Abschnitts zu Lambdas haben das eine oder andere sehr überraschende Detail zur Konvertierungen von Datentypen vorgestellt. Ein typischer Einsatz von Template Lambdas besteht in der Verwendung von Containern in Lambas.</div>
<div class="ztitel_kleiner">Template-Parameter für Container</div>
<div class="text">Das folgenden Programm stellt Lambdas vor, die einen Container annehmen. Jede Lambda gibt die Länge des Containers zurück.</div>
<div class="pre">// templateLambdaVector.cpp<br><br>#include &lt;concepts&gt;<br>#include &lt;deque&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>auto lambdaGeneric = [](const auto&amp; container) { return container.size(); };&nbsp; <br>auto lambdaVector = []&lt;typename T&gt;(const std::vector&lt;T&gt;&amp; vec)<br>&nbsp; { return vec.size(); };<br>auto lambdaVectorIntegral = []&lt;std::integral T&gt;(const std::vector&lt;T&gt;&amp; vec) <br>&nbsp; { return vec.size(); };<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::deque deq{1, 2, 3};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector vecDouble{1.1, 2.2, 3.3, 4.4};&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::vector vecInt{1, 2, 3, 4, 5};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "lambdaGeneric(deq): " &lt;&lt; lambdaGeneric(deq) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; // std::cout &lt;&lt; "lambdaVector(deq): " &lt;&lt; lambdaVector(deq) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::endl; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR<br>&nbsp;&nbsp;&nbsp; // std::cout &lt;&lt; "lambdaVectorIntegral(deq): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; lambdaVectorIntegral(deq) &lt;&lt; std::endl;&nbsp; ERROR<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "lambdaGeneric(vecDouble): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; lambdaGeneric(vecDouble) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "lambdaVector(vecDouble): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; lambdaVector(vecDouble) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; // std::cout &lt;&lt; "lambdaVectorIntegral(vecDouble): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; lambdaVectorIntegral(vecDouble) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "lambdaGeneric(vecInt): " &lt;&lt; lambdaGeneric(vecInt)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "lambdaVector(vecInt): " &lt;&lt; lambdaVector(vecInt) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "lambdaVectorIntegral(vecInt): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; lambdaVectorIntegral(vecInt) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text"><span class="tx_code">lambdaGeneric</span> lässt sich mit jedem Datentyp aufrufen, der die Methode <span class="tx_code">size()</span> unterstützt. <span class="tx_code">lambdaVector</span> ist hingegen spezifischer: Sie nimmt nur einen<span class="tx_code"> std::vector</span> an. <span class="tx_code">lambdaVector</span> verwendet das C++20 Concept <span class="tx_code">std::integral</span>. Damit lässt sich nur ein <span class="tx_code">std::vector</span> mit integralen Datentypen wie <span class="tx_code">int</span> verwenden. Um es einzusetzen, muss die Headerdatei <span class="tx_code">&lt;concepts&gt;</span> inkludiert werden. Ich denke, das kleine Programm erklärt sich selbst. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/4/6/0/4/0/TN_197709883_0f2664eced.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Das Programm<span class="tx_code"> templateLambdaVector.cpp</span> enthält ein leicht zu übersehendes Feature: Seit C++17 kann der Compiler den Datentyp eines Klassen-Templates von seinen Funktionsargumenten ableiten (1). Daher kann ich statt einem wortreichen <span class="tx_code">std::vector&lt;int&gt; myVec{1, 2, 3}</span> einfach <span class="tx_code">std::vector myVec{1, 2, 3}</span> schreiben. </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">In meinem nächsten Artikel geht es um weitere C++20 Verbesserung rund um Lambdas. <br></div>
