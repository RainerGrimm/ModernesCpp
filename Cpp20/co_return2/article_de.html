<div class="vorspann">Beginnend mit der Coroutinen-basierten Implementierung eines einfaches Futures im letzten Artikel "C++20: Einfache Futures mit Coroutinen implementieren", möchte ich nun einen Schritt weiter gehen. In diesem Artikel steht die Analyse der einfachen Coroutine an. Dazu soll die Coroutine eine Bedarfsauswertung umsetzen.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/6/7/9/4/4/TN_207763161_5d97c15db4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Bevor ich eine Variation des Futures vorstelle, sollte man seinen einfachen Programmablauf verstehen. Daher setze ich die Kenntnis des vorherigen Artikels "<a title="Link auf https://heise.de/-5066861" alt="%7B%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-5066861%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-5066861%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%3A%20Einfache%20Futures%20mit%20Coroutinen%20implementieren%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" href="https://heise.de/-5066861" class="">C++20: Einfache Futures mit Coroutinen implementieren</a>" voraus. Viele Kommentare im Programm sollen helfen, seinen Arbeitsablauf offenzulegen. Darüber hinaus befindet sich bei jedem Programm ein Link zum ausführbaren Programm auf einem Online-Compiler.&nbsp; <br></div>
<div class="ztitel">Der transparente Arbeitsablauf</div>
<div class="pre">// eagerFutureWithComments.cpp<br><br>#include &lt;coroutine&gt;<br>#include &lt;iostream&gt;<br>#include &lt;memory&gt;<br><br>template&lt;typename T&gt;<br>struct MyFuture {<br>&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;T&gt; value<br>&nbsp;&nbsp;&nbsp; MyFuture(std::shared_ptr&lt;T&gt; p): value(p) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp; MyFuture::MyFuture" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; ~MyFuture() { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp; MyFuture::~MyFuture" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; T get() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp; MyFuture::get" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *value;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; struct promise_type {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;T&gt; ptr = std::make_shared&lt;T&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (11)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::promise_type" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~promise_type() { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::~promise_type" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyFuture&lt;T&gt; get_return_object() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::get_return_object" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ptr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void return_value(T v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::return_value" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ptr = v;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_never initial_suspend() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::initial_suspend" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_never final_suspend() noexcept {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::final_suspend" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void unhandled_exception() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::exit(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>};<br><br>MyFuture&lt;int&gt; createFuture() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "createFuture" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; co_return 2021;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; auto fut = createFuture();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; auto res = fut.get();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (8)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "res: " &lt;&lt; res &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (12)<br></div>
<div class="text">Der Aururf <span class="tx_code">createFuture</span> (Zeile 1) stößt das Erzeugen einer Instanz vom Datentyp <span class="tx_code">MyFuture</span> (Zeile 2) an. Bevor der Konstruktoraufruf von <span class="tx_code">MyFuture</span> (Zeile 3) vollständig ausgeführt wird, ist der Promise bereits erzeugt, aufgeführt und zerstört worden (Zeilen 4 bis 5). Der Promise wendet in jedem Schritt seines Ablaufs die Awaitable <span class="tx_code">std::suspend_never</span> (Zeilen 6 und 7) an. Daher wird die Coroutine nicht pausiert. Um das Ergebnis für einen späteren <span class="tx_code">fut.get()</span>-Aufruf (Zeile 8) zu sichern, ist der Promise zu allokieren. Darüber hinaus sichert der <span class="tx_code">std::shared_ptr</span> zu (Zeilen 3 und 10), dass das Programm kein Speicherleck verursacht. Als lokale Variable endet der Gültigkeitsbereich von <span class="tx_code">fut</span> in der Zeile 12. Daher ruft die C++-Laufzeit seinen Destruktor auf.&nbsp;</div>
<div class="text">Das Programm lässt sich direkt mit dem <a title="Link auf https://godbolt.org/z/Y9naEx" alt="%7B%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FY9naEx%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FY9naEx%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Compiler%20Explorer%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%7D" href="https://godbolt.org/z/Y9naEx" class="">Compiler Explorer</a> ausführen.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/6/7/9/4/4/TN_207763174_9a083487c5.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die präsentierte Coroutine wird sofort im Thread des Aufrufers ausgeführt.</div>
<div class="text">Nun werde ich die Coroutine "lazy" ausführen. <br></div>
<div class="ztitel">Ein Lazy Future<br></div>
<div class="text">Ein Lazy Future wird nur ausgeführt, wenn nach seinem Wert gefragt wird. Mit ein paar kleinen Anpassungen lässt sich die vorherige Coroutine in einen Lazy Future transformieren:<br></div>
<div class="pre">// lazyFuture.cpp<br><br>#include &lt;coroutine&gt;<br>#include &lt;iostream&gt;<br>#include &lt;memory&gt;<br><br>template&lt;typename T&gt;<br>struct MyFuture {<br>&nbsp;&nbsp;&nbsp; struct promise_type;<br>&nbsp;&nbsp;&nbsp; using handle_type = std::coroutine_handle&lt;promise_type&gt;;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; handle_type coro;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br><br>&nbsp;&nbsp;&nbsp; MyFuture(handle_type h): coro(h) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp; MyFuture::MyFuture" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; ~MyFuture() { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp; MyFuture::~MyFuture" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( coro ) coro.destroy();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (8)<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; T get() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp; MyFuture::get" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coro.resume();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return coro.promise().result;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; struct promise_type {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; T result;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::promise_type" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~promise_type() { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::~promise_type" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto get_return_object() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::get_return_object" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyFuture{handle_type::from_promise(*this)};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void return_value(T v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::return_value" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = v;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_always initial_suspend() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::initial_suspend" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_always final_suspend() noexcept {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type::final_suspend" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void unhandled_exception() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::exit(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; };<br>};<br><br>MyFuture&lt;int&gt; createFuture() {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "createFuture" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; co_return 2021;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; auto fut = createFuture();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; auto res = fut.get();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "res: " &lt;&lt; res &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}<br></div>
<div class="text">Zuerst möchte ich mir den Promise anschauen. Er pausiert immer an seinem Beginn (Zeile 1) und seinem Ende (Zeile 2). Darüber hinaus erzeugt die Funktion <span class="tx_code">get_return_object</span> (Zeile 3) das Objekt, das an den Aufrufer der Coroutine <span class="tx_code">createFuture</span> (Zeile 4) zurückgegeben wird. Der Future <span class="tx_code">MyFuture</span> ist deutlich interessanter. Er besitzt ein Handle <span class="tx_code">coro</span> (Zeile 5) auf den Promise. <span class="tx_code">MyFuture</span> verwendet den Handle, um den Promise zu verwalten. Er weckt den Promise auf (Zeile 6), fragt ihn nach seinem Ergebnis (Zeile 7) und zerstört ihn letztlich (Zeile 8). Das Aufwecken der Coroutine ist notwendig, da sie nicht automatisch ausgeführt wird (Zeile 1). Wenn der Klient <span class="tx_code">fut.get()</span> (Zeile 7) aufruft, um das Ergebnis zu erhalten, wird die Ausführung der Coroutine fortgesetzt (Zeile 6).</div>
<div class="text">Das Programm lässt sich direkt mit dem<a title="Link auf https://godbolt.org/z/EejWcj" alt="%7B%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FEejWcj%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FEejWcj%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22%20Compiler%20Explorer%20%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%7D" href="https://godbolt.org/z/EejWcj" class=""> Compiler Explorer </a>ausführen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/6/7/9/4/4/TN_207763180_3b00f137ec.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Was passiert, wenn der Klient am Ergebnis nicht interessiert ist und somit die Coroutine nicht aufweckt? Das lässt sich einfach ausprobieren:</div>
<div class="pre">int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; auto fut = createFuture();<br>&nbsp;&nbsp;&nbsp; // auto res = fut.get();<br>&nbsp;&nbsp;&nbsp; // std::cout &lt;&lt; "res: " &lt;&lt; res &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div>
<div class="text">Wie vermutet, werden der Promise und somit die Funktionen <span class="tx_code">return_value</span> und <span class="tx_code">final_suspend</span>&nbsp; nicht ausgeführt.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/6/7/9/4/4/TN_207763186_2c75008abb.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Lebenszeitherausforderungen von Coroutinen<br></div>
<div class="text">Ein der Herausforderungen beim Umgang von Coroutinen ist es, ihre Lebenszeit richtig zu verwalten. Im ersten Programm <span class="tx_code">eagerFuture.cpp</span> speichert die Coroutine ihr Ergebnis im <span class="tx_code">std::shared_ptr</span>. Dies ist notwendig, denn die Coroutine wird sofort ausgeführt.</div>
<div class="text">Im Programm <span class="tx_code">lazyFuture.cpp</span> pausiert der Aufruf <span class="tx_code">final_suspend</span> (Zeile 2) immer: <span class="tx_code">std::suspend_always final_suspend()</span>. Konsequenterweise lebt der Promise länger als sein Klient, und ein <span class="tx_code">std::shared_ptr</span> ist nicht notwendig. Wenn die Funktion <span class="tx_code">final_suspend</span> aber <span class="tx_code">std::suspend_never</span> verwendet, ist das Verhalten des Programms undefiniert, denn der Klient lebt in diesem Fall länger als der Promise. Damit endet die Gültigkeit von <span class="tx_code">result</span>, bevor der Klient danach fragt. </div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Mein letzter Schritt in der Variation des Futures fehlt noch. Im nächsten Artikel werde ich die Ausführung der Coroutine auf einem separaten Thread fortsetzen.</div>
<div class="ztitel">C++ Schulungen </div>
<div class="text">Ich freue mich darauf, modernes C++ schulen zu dürfen. Dies sind meine offenen Schulungen im nächsten halben Jahr. Zum jetzigen Zeitpunkt gehe ich davon aus, dass alle Schulungen online stattfinden werden. <br></div>
<div class="text"><ul><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/30-embedded-programmierung-mit-modernem-c20210126195655" alt="%7B%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Embedded-Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F30-embedded-programmierung-mit-modernem-c20210126195655%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F30-embedded-programmierung-mit-modernem-c20210126195655%22%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/30-embedded-programmierung-mit-modernem-c20210126195655" class="">Embedded-Programmierung mit modernem C++</a>: 12. bis 14. April 2022, Termingarantie</li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/31-clean-code-mit-modernem-c" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F31-clean-code-mit-modernem-c%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F31-clean-code-mit-modernem-c%22%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Clean%20Code%20mit%20modernem%20C%2B%2B%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/31-clean-code-mit-modernem-c" class="">Clean Code mit modernem C++</a>: 22. bis 24. Juni 2021</li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/32-c-20" alt="%7B%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F32-c-20%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F32-c-20%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%7D" href="https://www.modernescpp.de/index.php/c/2-c/32-c-20" class="">C++20</a>: 10. bis 12. August 2021</li></ul> </div>
<div class="text">Mehr Informationen gibt es hier: <a title="Link auf https://www.modernescpp.de/" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22mediasync_id%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22www.ModernesCpp.de%22%2C%22anchor%22%3A%22%22%7D" href="https://www.modernescpp.de/" class="">www.ModernesCpp.de</a> </div>