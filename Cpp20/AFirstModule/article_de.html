<div class="vorspann">Module sind eines der prominenten vier Features von C++20. Sie überwinden die Einschränkungen von Header-Dateien und versprechen noch mehr: schnellere Kompilierungszeiten, weniger Verletzungen der One Definition Rule und den selteneren Einsatz von Makros. Im heutigen Artikel erzeuge ich ein einfaches Modul <span class="tx_code">math</span>. </div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/5/8/7/8/TN_193569760_056d92f63e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Die lange Geschichte der Module in C++<br></div>
<div class="text">2004 schrieb Daveed Vandevoorde das Proposal<a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1736.pdf" class="" alt="%7B%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2004%2Fn1736.pdf%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2004%2Fn1736.pdf%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22%20N1736%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%7D" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1736.pdf"> N1736</a>. In ihm brachte er das erste Mal die Idee von Modulen. Es dauert aber bis 2012, bis der C++-Standard eine eigene Study Group (SG2, Modules) zu Modulen erhielt. 2017 boten Clang 5.0 und MSVC 19.1 erste Implementierungen von Modulen an. Ein Jahr später war das Module TS (Technical Specification) fertig. Parallel dazu schlug Google das sogenannte ATOM-Proposal (Another Take on Modules) vor: <a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0947r1.html" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0947r1.html" class="" alt="%7B%22text%22%3A%22PO947%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0947r1.html%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0947r1.html%22%7D">PO947</a>. 2019 wurden beide Proposals im Entwurf zum C++20-Standard zusammengeführt: <a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0947r1.html" alt="%7B%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0947r1.html%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0947r1.html%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22N4842%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%7D" class="" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0947r1.html">N4842</a>. Auf diesem Entwurf basieren meine Artikel zu Modulen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/5/8/7/8/TN_193569767_f36fbe3839.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Der C++-Standardisierungsprozess ist durch und durch demokratisch. Der Abschnitt <a href="https://isocpp.org/std/" class="" alt="%7B%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Standardization%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.org%2Fstd%2F%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.org%2Fstd%2F%22%7D" title="Link auf https://isocpp.org/std/">Standardization</a> gibt mehr Details zum Standard und seinem Standardisierungsprozess. Das Bild stellt die verschiedenen Study Groups vor. </div>
<div class="text">Module aus der Sicht von Anwendern vorzustellen ist einfach. Diese Beobachtung gilt [--] wie fast immer in C++ [--] nicht für die Sicht der Implementierer. Mein Plan für diesen und die folgenden Artikel ist es, mit einem einfachen Modul [code]math[/code] zu starten und sukzessive neue Features zu dem Modul hinzuzufügen. <br></div>
<div class="ztitel">Das math-Modul<br></div>
<div class="text">Hier ist mein erstes Modul:</div>
<div class="pre">// math.ixx<br><br>export module math;<br><br>export int add(int fir, int sec){<br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>}<br></div>
<div class="text">Der Ausdruck&nbsp;<span class="tx_code">export module math</span>&nbsp;steht für die Moduldeklaration. Dank des Schlüsselworts&nbsp;<span class="tx_code">export</span>&nbsp;vor der Funktion&nbsp;<span class="tx_code">add</span>&nbsp;wird diese Funktion exportiert und lässt sich damit von den Anwendern verwenden:</div>
<div class="pre">// client.cpp<br><br>import math;<br><br>int main() {<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; add(2000, 20);<br>&nbsp;&nbsp; <br>}<br></div>
<div class="text"><span class="tx_code">import math</span>&nbsp;importiert das Modul&nbsp;<span class="tx_code">math</span>&nbsp;und bewirkt, dass die exportierten Namen des Moduls in der Datei <span class="tx_code">client.cpp</span>&nbsp;sichtbar werden. Das war der einfache Teil meiner Aufgabe. Die Herausforderung beginnt, wenn ich das Programm übersetze.</div>
<div class="ztitel">Die Modul-Deklarationsdatei</div>
<div class="text">Ist dir der eigentümliche Name <span class="tx_code">math.ixx</span> des Moduls aufgefallen?</div>
<div class="text"><ul><li>cl.exe (Microsoft) verwendet das Suffix <span class="tx_code">ixx</span>. Es steht für Modul Interface Source.<br></li><li>Clang verwendet das Suffix cppm. Es steht wohl für Modul-Deklaration. Falsch!!! Die Dokumentation zu Clang führt in die falsche Richtung. Verwende nicht die Erweiterung <span class="tx_code">cppm</span>, bis du meinen nächsten Artikel gelesen hast. Nutze einfach die Erweiterung <span class="tx_code">cpp</span>. Du wirst nicht die gleiche Odyssee wie ich durchleben wollen.&nbsp;<b>&nbsp; </b><br></li><li>Ich kenne kein Suffix für den GCC. <br></li></ul></div>
<div class="ztitel">Das Modul math kompilieren</div>
<div class="text">Um das Modul zu übersetzen, benötigst du einen aktuellen Clang-, GCC- oder cl.exe-Compiler. Ich werde in diesem Artikel den cl.exe-Compiler von Windows einsetzen. Der Microsoft-Blog besitzt zwei exzellente Einführungsartikel zu Modulen: "<a class="" alt="%7B%22text%22%3A%22Overview%20of%20modules%20in%20C%2B%2B%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fcpp%2Fmodules-cpp%3Fview%3Dvs-2019%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fcpp%2Fmodules-cpp%3Fview%3Dvs-2019%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%7D" href="https://docs.microsoft.com/en-us/cpp/cpp/modules-cpp?view=vs-2019" title="Link auf https://docs.microsoft.com/en-us/cpp/cpp/modules-cpp?view=vs-2019">Overview of modules in C++</a>" und "<a title="Link auf https://devblogs.microsoft.com/cppblog/c-modules-conformance-improvements-with-msvc-in-visual-studio-2019-16-5/" href="https://devblogs.microsoft.com/cppblog/c-modules-conformance-improvements-with-msvc-in-visual-studio-2019-16-5/" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fdevblogs.microsoft.com%2Fcppblog%2Fc-modules-conformance-improvements-with-msvc-in-visual-studio-2019-16-5%2F%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fdevblogs.microsoft.com%2Fcppblog%2Fc-modules-conformance-improvements-with-msvc-in-visual-studio-2019-16-5%2F%22%2C%22text%22%3A%22C%2B%2B%20Modules%20conformance%20improvements%20with%20MSVC%20in%20Visual%20Studio%202019%2016.5%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%7D" class="">C++ Modules conformance improvements with MSVC in Visual Studio 2019 16.5</a>". Im Gegensatz dazu stellen die fehlenden Einführungen zu Clang und GCC eine hohe Hürde für den Einsatz von Modulen dar. </div>
<div class="text">Hier sind mehr Details zu meinem Microsoft-Compiler:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/5/8/7/8/TN_193569776_044dd8e737.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Dieses sind die Schritte, um das Modul mit dem Microsoft-Compiler zu übersetzen und zu verwenden. Ich stelle nur die minimale Kommandozeile dar. Mit einem älteren Microsoft-Compiler muss man zumindest noch das Flag <span class="tx_code">/std:cpplatest</span> verwenden.<br></div>
<div class="text">cl.exe /experimental:module /c math.ixx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br>cl.exe /experimental:module client.cpp math.obj&nbsp;&nbsp; // 2</div>
<div class="text">Zuerst erzeuge eine Objektdatei<span class="tx_code"> math.obj</span> und eine <i>IFC</i>-Datei <span class="tx_code">math.if</span>c. Die <i>IFC-</i>Datei enthält die Metadaten zur Beschreibung des Modul-Interfaces. Das binäre Format der<i> IFC-</i>Datei folgt der <a title="Link auf http://www.stroustrup.com/gdr-bs-macis09.pdf" class="" alt="%7B%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.stroustrup.com%2Fgdr-bs-macis09.pdf%22%2C%22href%22%3A%22http%3A%2F%2Fwww.stroustrup.com%2Fgdr-bs-macis09.pdf%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Internal%20Program%20Representation%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%7D" href="http://www.stroustrup.com/gdr-bs-macis09.pdf">Internal Program Representation</a>, die Gabriel Dos Reis und Bjarne Stroustrup bereits 2004/2005 definiert haben.</div>
<div class="text">Dann erzeuge die ausführbare Datei <span class="tx_code">client.exe</span>. Ohne die implizit verwendete <span class="tx_code">math.ifc-</span>Datei des ersten Schritts findet der Linker das Modul nicht.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/5/8/7/8/TN_193569782_43e41d3c59.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Aus verständlichen Gründen zeige ich nicht die Ausführung des Programms. Das ändert sich aber sofort.</div>
<div class="ztitel_kleiner">Globales Modul-Fragment</div>
<div class="text">Dank des Global Modul Fragment lassen sich Module einfach zusammenstellen. Damit kann man <span class="tx_code">#include</span>-Direktiven direkt im Modul verwenden. Der Code im Global Modul Fragment wird durch das Modul nicht exportiert.</div>
<div class="text">Meine zweite Version des Moduls <span class="tx_code">math</span> bietet die Funktionen <span class="tx_code">add</span> und <span class="tx_code">getProduct</span> an: </div>
<div class="pre">// math1.ixx<br>module;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // global module fragment (1)<br><br>#include &lt;numeric&gt;<br>#include &lt;vector&gt;<br><br>export module math;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // module declartion (2)<br><br>export int add(int fir, int sec){<br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>}<br><br>export int getProduct(const std::vector&lt;int&gt;&amp; vec) {<br>&nbsp;&nbsp;&nbsp; return std::accumulate(vec.begin(), vec.end(), 1, std::multiplies&lt;int&gt;());<br>}</div>
<div class="text">Ich habe die notwendigen Header-Dateien zwischen dem Global Modul Fragment (Zeile 1) und der Modul-Deklaration (Zeile 2) inkludiert:</div>
<div class="pre">// client1.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>import math;<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;&nbsp; &nbsp;<br>&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "add(2000, 20): " &lt;&lt; add(2000, 20) &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; myVec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getProduct(myVec): " &lt;&lt; getProduct(myVec) &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; &nbsp;<br>}</div>
<div class="text">Das Programm importiert das Modul <span class="tx_code">math</span> und verwendet seine Funktionalität:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/9/5/8/7/8/TN_193569787_8440a50b11.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Ich nehme an, du willst die Header-Dateien der Standard Template Library nicht mehr verwenden. Microsoft bietet bereits Module für alle STL-Header-Dateien an. Hier sind die Details aus dem Blogartikel "<a href="https://devblogs.microsoft.com/cppblog/cpp-modules-in-visual-studio-2017/" alt="%7B%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fdevblogs.microsoft.com%2Fcppblog%2Fcpp-modules-in-visual-studio-2017%2F%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fdevblogs.microsoft.com%2Fcppblog%2Fcpp-modules-in-visual-studio-2017%2F%22%2C%22text%22%3A%22Using%20C%2B%2B%20Modules%20in%20Visual%20Studio%202017%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%7D" class="" title="Link auf https://devblogs.microsoft.com/cppblog/cpp-modules-in-visual-studio-2017/">Using C++ Modules in Visual Studio 2017</a>" des Microsoft-C++-Team-Blogs:</div>
<div class="text"><ul><li><span class="tx_code">std.regex&nbsp;</span>bietet den Inhalt der Header-Datei&nbsp;&lt;<span class="tx_code">regex</span>&gt;&nbsp;an.</li><li><span class="tx_code">std.filesystem</span> offeriert&nbsp; den Inhalt der Header-Datei&nbsp;&lt;<span class="tx_code">experimental/filesystem</span>&gt;&nbsp;an.<br></li><li><span class="tx_code">std.memory</span> zeigt den Inhalt der Head-Datei&nbsp;&lt;<span class="tx_code">memory</span>&gt;&nbsp;an.<br></li><li><span class="tx_code">std.threading</span>&nbsp;bietet den Inhalt der Header-Dateien&nbsp;&lt;<span class="tx_code">atomic</span>&gt;, &lt;<span class="tx_code">condition_variable</span>&gt;, &lt;<span class="tx_code">future</span>&gt;, &lt;<span class="tx_code">mutex</span>&gt;, &lt;<span class="tx_code">shared_mutex</span>&gt; und &lt;<span class="tx_code">thread</span>&gt;&nbsp;an.<br></li><li><span class="tx_code">std.core</span> umfasst den Rest der C++-Standard-Bibliothek.</li></ul></div>
<div class="text">Um die Microsoft Standard Library Module zu verwenden, musst du Exception Handling (<span class="tx_code">/EHsc</span>) und die Multithreading-Bibliothek (<span class="tx_code">/MD</span>) einsetzen. Darüber hinaus benötigst du noch das Flag <span class="tx_code">/std:c++latest</span>.</div>
<div class="text">Hier sind die leicht modifizierten Dateien der Interface-Datei <span class="tx_code">math2.ixx</span> und der Source-Datei <span class="tx_code">client2.cpp</span>.</div>
<div class="text"><ul><li><span class="tx_code">math2.ixx</span></li></ul></div>
<div class="pre">// math2.ixx<br>module;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>import std.core;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>export module math;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>export int add(int fir, int sec){<br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>}<br><br>export int getProduct(const std::vector&lt;int&gt;&amp; vec) {<br>&nbsp;&nbsp;&nbsp; return std::accumulate(vec.begin(), vec.end(), 1, std::multiplies&lt;int&gt;());<br>}<br></div>
<div class="text"><ul><li><span class="tx_code">client2.cpp</span></li></ul></div>
<div class="pre">// client2.cpp<br><br>import std.core;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>import math;<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;&nbsp;&nbsp; <br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "add(2000, 20): " &lt;&lt; add(2000, 20) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; myVec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getProduct(myVec): " &lt;&lt; getProduct(myVec) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; <br>}<br></div>
<div class="text">Beide Dateien verwenden in der Zeile (1) das Modul <span class="tx_code">std.core.</span><br></div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Meine ersten Module <span class="tx_code">math.ixx</span>, [code]math1.ixx[/code] und <span class="tx_code">math2.ixx</span> definieren ihre Funktionalität in einer Datei. In meinem nächsten Artikel werde ich die Definition der Module in eine sogenannte Module Interface Unit und eine Modul Implementation Unit aufteilen.<br></div>
