<div class="vorspann">Dank der Ranges-Bibliothek in C++20 wird der Umgang mit der Standard Template Library deutlich angenehmer und mächtiger. Ihre Algorithmen sind lazy, agieren direkt auf den Containern und können verknüpft werden. Um es kurz zu machen: Die Bequemlichkeit und Mächtigkeit der Ranges-Bibliothek beruht auf ihren funktionalen Ideen. <br></div>
<div class="text">Bevor ich auf die Details eingehe, möchte ich ein erstes Beispiel zur Ranges-Bibliothek vorstellen:</div>
<div class="pre">// rangesFilterTransform.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;ranges&gt;<br>#include &lt;vector&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6};<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; auto results = numbers | std::view::filter([](int n){ return n % 2 == 0; })<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | std::view::transform([](int n){ return n * 2; });<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (auto v: results) std::cout &lt;&lt; v &lt;&lt; " ";&nbsp;&nbsp;&nbsp;&nbsp; // 4 8 12<br><br>}<br></div>
<div class="text">Du musst den Ausdruck von links nach rechts lesen. Das Pipe-Symbol steht für die Verknüpfung von Funktionen: Zuerst werden alle Elemente akzeptiert, die gerade sind (<span class="tx_code">std::view::filter([](int n){ return n % 2 == 0; })</span>). Danach wird jedes verbleibende Element auf sein Quadrat abgebildet (<span class="tx_code">std::view::transform([](int n){ return n * 2; }</span>)). Dieses kleine Beispiel zeigt bereits zwei neue Feature der Ranges-Bibliothek: zum einen die Funktionskomposition, und zum anderen agiert diese Funktionskomposition direkt auf dem Container.&nbsp;</div>
<div class="text">Jetzt solltest du für die Details gewappnet sein. Damit sind wir wieder am Startpunkt angelangt: Ranges und Views sind Concepts.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/4/4/0/4/1/TN_188691612_ef06ae353e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Range</div>
<div class="text"><ul><li><span class="tx_code"><b>std::range</b></span>: Ein Range ist eine Menge von Elementen, über die iteriert werden kann. Dieser Range verfügt über einen Begin-Iterator und ein Sentinel (Abschlusselement). Selbstverständlich sind die Container der Standard Template Library (STL) Ranges.</li></ul></div>
<div class="text">Es gibt einige Verfeinerungen von <b><span class="tx_code">std::range</span></b>:</div>
<div class="text"><ul><li><b><span class="tx_code">std::ranges::input_range</span></b>: steht für einen Range, dessen Iteratoren einem Input-Iterator genügen (damit lässt sich zumindest einmal über den Range iterieren)</li><li><b><span class="tx_code">std::ranges::output_range</span></b>: steht für einen Range, dessen Iteratoren einem Output-Iterator genügen <br></li><li><b><span class="tx_code">std::ranges::forward_range</span></b>: steht für einen Range, dessen Iteratoren einem Forward-Iterator genügen (damit lässt sich mehr als einmal über den Range iterieren)</li><li><span class="tx_code"><b>std::ranges::bidirectional_range</b>:</span> steht für einen Range, dessen Iteratoren einem Birdectional-Iterator genügen (damit lässt sich mehr als einmal über den Range vorwärts und rückwärts iterieren)</li><li><span class="tx_code"><b>std::ranges::random_access_range</b>:</span> steht für einen Range, dessen Iteratoren einem Random-Access-Iterator genügen (damit lässt sich in konstanter Zeit auf ein beliebiges Element des Ranges mithilfe des Indexoperators [] zugreifen)</li><li><span class="tx_code"><b>std::ranges::contiguous_range</b>:</span> steht für einen Range, dessen Iteratoren einem Contiguous-Iterator genügen (die Elemente des Ranges sind kontinuierlich im Speicher angeordnet)</li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/4/4/0/4/1/TN_188691616_7264b8d780.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die Container der STL und der <span class="tx_code">std::string</span> setzen verschiedene Concepts um: Ein Containter, der das Concept <span class="tx_code">std::ranges::contiguous_range</span> unterstützt, unterstützt auch alle vorherigen Concepts in der Tabelle wie <span class="tx_code">std::ranges::random_access_range</span>, <span class="tx_code">std::ranges::bidirectional_range</span> und <span class="tx_code">std::ranges::input_range</span>. Diese Beobachtung gilt natürlich auch für die anderen Ranges der Tabelle.<br></div>
<div class="ztitel">View</div>
<div class="text"><ul><li>Ein <b>View</b> lässt sich auf einen Range anwenden. Dabei wird eine Operation ausgeführt. Views besitzen keine Daten. Konsequenterweise sind seine Copy-, Move- oder Zuweisungsoperationen konstant. Eric Niebler, Autor der <a href="https://github.com/ericniebler/range-v3" alt="%7B%22text%22%3A%22ranges-v3%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fericniebler%2Frange-v3%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fericniebler%2Frange-v3%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%7D" title="Link auf https://github.com/ericniebler/range-v3" class="">ranges-v3</a>-Implementierung, die Grundlage für die Ranges-Bibliothek in C++20 ist, beschreibt Ranges mit folgenden Worten: "Views are composable adaptations of ranges where the adaptation happens lazily as the view is iterated."</li></ul></div>
<div class="pre">std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6};<br><br>auto results = numbers | std::view::filter([](int n){ return n % 2 == 0; })<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | std::view::transform([](int n){ return n * 2; });<br></div>
<div class="text">In dem Codebeispiel ist <span class="tx_code">numbers</span> die Range, während<span class="tx_code"> std::view::filter</span> und <span class="tx_code">std::view::transform</span> für die Views stehen. </div>
<div class="text">Dank der Mächtigkeit der Views erlaubt die Ranges-Bibliothek das Programmieren im funktionalen Stil. <b>Views lassen sich verknüpfen und sind lazy.</b> Ich habe bereits zwei Views vorgestellt<b>. </b>Natürlich enthält C++20 deutlich mehr:</div>
<div class="pre">std::all_view, std::views::all // takes all elements<br><br>std::ref_view // takes all elements of another view<br><br>std::filter_view, std::views::filter // takes the elements which satisfies the predicate<br><br>std::transform_view, std::views::transform // transforms each element<br><br>std::take_view, std::views::take // takes the first N elements of another view<br><br>std::take_while_view, std::views::take_while // takes the elements of another view as long as the predicate returns true<br><br>std::drop_view, std::views::drop // skips the first N elements of another view<br><br>std::drop_while_view, std::views::drop_while // skips the initial elements of another view until the predicate returns false<br><br>std::join_view, std::views::join // joins a view of ranges<br><br>std::split_view, std::views::split // splits a view by using a delimiter<br><br>std::common_view, std::views::common // converts a view into a std::common_range<br><br>std::reverse_view, std::views::reverse // iterates in reverse order<br><br>std::basic_istream_view, std::istream_view // applies operator&gt;&gt; on the view<br><br>std::elements_view, std::views::elements // creates a view on the N-th element of tuples<br><br>std::keys_view, std::views::keys // creates a view on the first element of a pair-like values<br><br>std::values_view, std::views::values // creates a view on the second elements of a pair-like values<br></div>
<div class="text">Im Allgemeinen lässt sich ein View wie <span class="tx_code">std::views::transform</span> mit dem alternativen Namen <span class="tx_code">stdd::transform_view</span> verwenden. Bei meiner weiteren Vorstellung der Ranges-Bibliothek werde ich die Views anwenden.<br></div>
<div class="ztitel">Implementierungsstatus</div>
<div class="text">Soweit ich weiß, gibt es zum jetzigen Zeitpunkt (Februar 2020) keine Implementierung der Ranges-Bibliothek. Das ist aber kein Problem, da die bereits erwähnte&nbsp; <a title="Link auf https://github.com/ericniebler/range-v3" href="https://github.com/ericniebler/range-v3" alt="%7B%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fericniebler%2Frange-v3%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22ranges-v3%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fericniebler%2Frange-v3%22%2C%22user_params%22%3A%22%22%7D" class="">ranges-v3</a>-Implementierung verfügbar ist. Am einfachsten ist es, den Online-Compiler <a href="https://wandbox.org/" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwandbox.org%2F%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwandbox.org%2F%22%2C%22text%22%3A%22Wandbox%22%7D" title="Link auf https://wandbox.org/" class="">Wandbox</a> oder den <a class="" title="Link auf https://godbolt.org/" href="https://godbolt.org/" alt="%7B%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22Compiler%20Explorer%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22user_params%22%3A%22%22%7D">Compiler Explorer</a> mit dem HEAD GCC zu verwenden. Dazu müssen meine Beispiele wie <span class="tx_code">rangesFilterExample.cpp</span> leicht modifiziert werden:</div>
<div class="text"><ul><li>Ersetze den Namensraum <span class="tx_code">std::view</span> mit <span class="tx_code">ranges::view.</span></li><li>Ersetze die Headerdatei <span class="tx_code">&lt;ranges&gt;</span> mit <span class="tx_code">&lt;ranges/v3/all.hpp&gt;</span>. Mehr Details dazu gibt es in der <a class="" href="https://github.com/ericniebler/range-v3" title="Link auf https://github.com/ericniebler/range-v3" alt="%7B%22text%22%3A%22ranges-v3%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fericniebler%2Frange-v3%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fericniebler%2Frange-v3%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D">ranges-v3</a>-Implementierung. </li><li>Übersetze das Programm mit C++20-Unterstützung: <span class="tx_code">-std=c++2a.</span></li><li>Wenn du den Compiler Explorer verwendest, solltest du die trunk-Version der <a class="" title="Link auf https://github.com/ericniebler/range-v3" href="https://github.com/ericniebler/range-v3" alt="%7B%22text%22%3A%22ranges-v3%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fericniebler%2Frange-v3%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fericniebler%2Frange-v3%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D">ranges-v3</a>-Implementierung einsetzen. Der folgende Screenshot sollte helfen, die notwendige Option zu finden:</li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/4/4/0/4/1/TN_188691620_963cc4b23b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Wende ich die Transformationsschritte auf das Programm <span class="tx_code">rangesFilterTransform.cpp </span>an, erhalte ich das folgende Programm:</div>
<div class="pre">// rangesV3FilterTransform.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;range/v3/all.hpp&gt;<br>#include &lt;vector&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6};<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; auto results = numbers | ranges::view::filter([](int n){ return n % 2 == 0; })<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::view::transform([](int n){ return n * 2; });<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (auto v: results) std::cout &lt;&lt; v &lt;&lt; " ";&nbsp;&nbsp;&nbsp; <br><br>}</div>
<div class="text">Dank der <a class="" href="https://wandbox.org/" alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwandbox.org%2F%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fwandbox.org%2F%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Wandbox%22%7D" title="Link auf https://wandbox.org/">Wandbox</a> muss ich dieses Mal die Ausgabe nicht vortäuschen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/4/4/0/4/1/TN_188691625_bbe582b333.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">In diesem Artikel ging ich auf die Grundlagen zur Ranges-Bibliothek ein. Dank ihnen kann ich mich in meinem nächsten Artikel auf die Mächtigkeit der Ranges fokussieren. Die Ranges-Bibliothek erweitert C++20 mit zwei neuen Konzepten: Funktionskomposition und Lazy Evaluation. Diese Erweiterung ist genau der Grund dafür, dass die Ranges-Bibliothek zu den <a href="https://heise.de/-4568956" alt="%7B%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4568956%22%2C%22text%22%3A%22gro%C3%9Fen%20Vier%20in%20C%2B%2B20%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4568956%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" title="Link auf https://heise.de/-4568956" class="">großen Vier in C++20</a> gezählt werden muss. Jede ihrer Komponenten ändert die Art und Weise, wie wir C++ verwenden werden.<br></div>
