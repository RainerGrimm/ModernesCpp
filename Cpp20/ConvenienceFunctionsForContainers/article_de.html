<div class="vorspann">Elemente aus einem Container zu entfernen oder einen assoziativen Container zu fragen, ob er ein Element besitzt, war bislang zu kompliziert. Mit C++20 ändert sich das.<br></div>
<div class="text">Mein Artikel beginnt mit einer einfachen Aufgabe. Ich möchte Elemente eines Containers entfernen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/7/5/8/9/3/TN_199957749_c7fa86def1.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Das erase-remove-Idiom<br></div>
<div class="text">Das Entfernen der Elemente eines Containers ist eine einfache Aufgabe. Im Fall eines <span class="tx_code">std::vector</span> bietet es sich an, die Funktion <span class="tx_code">std::remove</span> einzusetzen:<br></div>
<div class="pre">// removeElements.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::vector myVec{-2, 3, -5, 10, 3, 0, -5 };<br><br>&nbsp;&nbsp;&nbsp; for (auto ele: myVec) std::cout &lt;&lt; ele &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp;&nbsp;&nbsp; std::remove_if(myVec.begin(), myVec.end(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int ele){ return ele &lt; 0; }); <br>&nbsp;&nbsp;&nbsp; for (auto ele: myVec) std::cout &lt;&lt; ele &lt;&lt; " ";<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>}<br></div>
<div class="text">Das Programm <span class="tx_code">removeElements.cpp</span> entfernt alle Elemente des <span class="tx_code">std::vector</span>, die kleiner als null sind. Einfach, oder? Nein, du bist in die Falle getappt, die wohl schon jeder professionelle C++-Entwickler kennengelernt hat.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/7/5/8/9/3/TN_199957752_9e224a0a21.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><span class="tx_code">std::remove</span> und <span class="tx_code">std::remove_if</span> in Zeile (1) entfernen nichts aus dem Vektor. <span class="tx_code">std::vector</span> besitzt immer noch dieselbe Anzahl an Elementen. Beide Algorithmen geben das neue logische Ende des veränderten Containers zurück. Um einen Container zu verändern, musst du das neue logische Ende auf den Container anwenden:<br></div>
<div class="pre">// eraseRemoveElements.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::vector myVec{-2, 3, -5, 10, 3, 0, -5 };<br><br>&nbsp;&nbsp;&nbsp; for (auto ele: myVec) std::cout &lt;&lt; ele &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp;&nbsp;&nbsp; auto newEnd = std::remove_if(myVec.begin(), myVec.end(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int ele){ return ele &lt; 0; });<br>&nbsp;&nbsp;&nbsp; myVec.erase(newEnd, myVec.end());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; // myVec.erase(std::remove_if(myVec.begin(), myVec.end(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int ele){ return ele &lt; 0; }), myVec.end());<br>&nbsp;&nbsp;&nbsp; for (auto ele: myVec) std::cout &lt;&lt; ele &lt;&lt; " ";<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>}<br></div>
<div class="text">Zeile (1) gibt das neue logische Ende <span class="tx_code">newEnd</span> des Containers <span class="tx_code">myVec</span> zurück. Das neue logische Ende wird daraufhin in Zeile (2) angewendet, um alle Elemente von <span class="tx_code">myVec</span> zu löschen, die bei <span class="tx_code">newEnd</span> beginnen. Wenn nun die Funktionen <span class="tx_code">remove</span> und <span class="tx_code">erase</span> wie in Zeile (3) angewendet werden, wird klar, warum dieses Konstrukt erase-remove-Idiom genannt wird.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/7/5/8/9/3/TN_199957761_05a8cf5447.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Dank der neuen Funktionen <span class="tx_code">erase</span> und <span class="tx_code">erase_if</span> wird das Entfernen von Elementes eines Containers deutlich einfacher.<br></div>
<div class="ztitel"><span class="tx_code">erase</span> und <span class="tx_code">erase_if</span> in C++20<br></div>
<div class="text">Mit <span class="tx_code">erase</span> und <span class="tx_code">erase_if</span> können die Elemente des Containers direkt gelöscht werden. Im Gegensatz dazu ist das vorgestellte erase-remove-Idiom (Zeile 3 in <span class="tx_code">eraseRemovElements.cpp</span>) sehr umständlich: <span class="tx_code">erase</span> benötigt zwei Iteratoren, die durch <span class="tx_code">std::remove_if</span> erzeugt werden.&nbsp; </div>
<div class="text">Lass mich zeigen, wie sich die zwei neuen Funktionen <span class="tx_code">erase</span> und <span class="tx_code">erase_if</span> in der Anwendung schlagen. Das folgende Programm entfernt Elemente von verschiedenen Containern:</div>
<div class="pre">// eraseCpp20.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;numeric&gt;<br>#include &lt;deque&gt;<br>#include &lt;list&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>template &lt;typename Cont&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>void eraseVal(Cont&amp; cont, int val) {<br>&nbsp;&nbsp;&nbsp; std::erase(cont, val);<br>}<br><br>template &lt;typename Cont, typename Pred&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (8)<br>void erasePredicate(Cont&amp; cont, Pred pred) {<br>&nbsp;&nbsp;&nbsp; std::erase_if(cont, pred);<br>}<br><br>template &lt;typename Cont&gt;<br>void printContainer(Cont&amp; cont) {<br>&nbsp;&nbsp;&nbsp; for (auto c: cont) std::cout &lt;&lt; c &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>}<br><br>template &lt;typename Cont&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>void doAll(Cont&amp; cont) {<br>&nbsp;&nbsp;&nbsp; printContainer(cont);<br>&nbsp;&nbsp;&nbsp; eraseVal(cont, 5);<br>&nbsp;&nbsp;&nbsp; printContainer(cont);<br>&nbsp;&nbsp;&nbsp; erasePredicate(cont, [](auto i) { return i &gt;= 3; } );<br>&nbsp;&nbsp;&nbsp; printContainer(cont);<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::string str{"A Sentence with an E."};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "str: " &lt;&lt; str &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::erase(str, 'e');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "str: " &lt;&lt; str &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::erase_if( str, [](char c){ return std::isupper(c); });&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "str: " &lt;&lt; str &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\nstd::vector " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::vector vec{1, 2, 3, 4, 5, 6, 7, 8, 9};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; doAll(vec);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\nstd::deque " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::deque deq{1, 2, 3, 4, 5, 6, 7, 8, 9};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; doAll(deq);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\nstd::list" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::list lst{1, 2, 3, 4, 5, 6, 7, 8, 9};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; doAll(lst);<br>&nbsp;&nbsp; &nbsp;<br>}<br></div>
<div class="text">Die Zeile (1) entfernt alle Buchstaben <span class="tx_code">e</span> des Strings <span class="tx_code">str</span>. Zeile (2) wendet den Lambda-Ausdruck auf denselben String an und entfernt alle Großbuchstaben.</div>
<div class="text">Im verbleibenden Programm werden Elemente der Sequenz-Container <span class="tx_code">std::vector</span> (Zeile 3),<span class="tx_code"> std::deque</span> (Zeile 4) und <span class="tx_code">std::list</span> (Zeile 5) entfernt. Auf jeden Container wird das Funktions-Template <span class="tx_code">doAll</span> (line 6) angewandt. <span class="tx_code">doAll</span> entfernt das Element 5 und anschließend alle Elemente größer als 3. Das Funktions-Template <span class="tx_code">erase</span> setzt die neue Funktion <span class="tx_code">erase</span> (Zeile 7) ein, und das Funktions-Template <span class="tx_code">erasePredicate</span> (Zeile 8) greift auf die neue Funktion <span class="tx_code">erase_if</span> zurück.<br></div>
<div class="text">Dank des Microsoft Compiler kann ich die Ausgabe des Programms präsentieren:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/7/5/8/9/3/TN_199957768_02259c84d7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Die vorgestellten neuen Funktionen <span class="tx_code">erase</span> und <span class="tx_code">erase_if</span> lassen sich auf alle Container der Standard Template Library anwenden. Das gilt nicht für die nächste praktische Funktion <span class="tx_code">contains</span>. </div>
<div class="ztitel">Prüfen, ob ein assoziativer Container ein Element enthält<br></div>
<div class="text">Dank der Funktion <span class="tx_code">contains</span> kannst du einfach prüfen, ob ein assoziativer Container ein bestimmtes Element enthält. Ich höre schon die ersten Einsprüche, denn dies ist doch bereits mit den Funktionen <span class="tx_code">find</span> oder <span class="tx_code">count</span> möglich. Nein. Beide Funktionen sind nicht benutzerfreundlich und besitzen weitere Nachteile:<br></div>
<div class="pre">// checkExistens.cpp<br><br>#include &lt;set&gt;<br>#include &lt;iostream&gt;<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::set mySet{3, 2, 1};<br>&nbsp;&nbsp;&nbsp; if (mySet.find(2) != mySet.end()) {&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "2 inside" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; std::multiset myMultiSet{3, 2, 1, 2};<br>&nbsp;&nbsp;&nbsp; if (myMultiSet.count(2)) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "2 inside" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; } <br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Die Funktionen liefern das erwartete Ergebnis:<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/7/5/8/9/3/TN_199957770_c7636be6e7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das sind die Probleme der beiden Funktionen. Der <span class="tx_code">find</span>-Aufruf in Zeile (1) ist zu wortreich. Derselbe Punkt gilt natürlich auch für den <span class="tx_code">count</span>-Aufruf in Zeile (2). Der <span class="tx_code">count</span>-Aufruf besitzt dazu noch ein Performanzproblem. Wenn du wissen willst, ob ein Container ein Element enthält, solltest du deine Suche dann beenden, wenn du das Element gefunden hast. <span class="tx_code">count</span> zählt aber tapfer bis zum Ende des Containers weiter. In der konkreten Anwendung gibt der Aufruf <span class="tx_code">myMultSet.count(2)</span> die 2 zurück. </div>
<div class="text">Im Gegensatz dazu ist die <span class="tx_code">contains</span>-Methode sehr angenehm zu verwenden:</div>
<div class="pre">// containsElement.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;unordered_set&gt;<br>#include &lt;unordered_map&gt;<br><br>template &lt;typename AssozCont&gt;<br>bool containsElement5(const AssozCont&amp; assozCont) {&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; return assozCont.contains(5);<br>}<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::set&lt;int&gt; mySet{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "containsElement5(mySet): " &lt;&lt; containsElement5(mySet);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::unordered_set&lt;int&gt; myUnordSet{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "containsElement5(myUnordSet): " &lt;&lt; containsElement5(myUnordSet);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::map&lt;int, std::string&gt; myMap{ {1, "red"}, {2, "blue"}, {3, "green"} };<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "containsElement5(myMap): " &lt;&lt; containsElement5(myMap);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::unordered_map&lt;int, std::string&gt; myUnordMap{ {1, "red"}, {2, "blue"}, {3, "green"} };<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "containsElement5(myUnordMap): " &lt;&lt; containsElement5(myUnordMap);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}<br></div>
<div class="text">Das Beispiel benötigt keine wortreiche Erklärung. Das Funktions-Template <span class="tx_code">containsElement5</span> gibt <span class="tx_code">true</span> zurück, wenn der assoziative Container den Schlüssel 5 besitzt. In meinem Beispiel habe ich nur die assoziativen Container <span class="tx_code">std::se</span><span class="tx_code">t</span>,<span class="tx_code"> std::unordered_set</span>,<span class="tx_code"> std::map</span> und <span class="tx_code">std::unordered_set</span> verwendet, die einen Schlüssel nicht mehrmals enthalten können.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Mein nächster Artikel dreht sich weiter um die praktischen Funktionen. In C++20 lässt sich der Mittelpunkt zweier Werte berechnen, prüfen, ob ein String mit einem Teilstring beginnt oder endet, und ein Funktionsobjekt mit der Funktion <span class="tx_code">std::bind_front</span> erzeugen.<br></div>