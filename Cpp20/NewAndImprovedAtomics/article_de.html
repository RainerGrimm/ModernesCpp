<div class="vorspann">Atomare Variablen erhalten wichtige Erweiterungen in C++20. Im heutigen Artikel stelle ich den neuen Datentyp<span class="tx_code"> std::atomic_ref </span>genauer vor. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/9/0/9/4/TN_203698014_0a2b94fcc6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Der Datentyp <span class="tx_code">std::atomic_ref</span> wendet atomare Operationen auf sein referenziertes Objekt an.<br></div>
<div class="ztitel">std::atomic_ref</div>
<div class="text">Gleichzeitiges Schreiben und Lesen einer <span class="tx_code">std::atomic_ref</span> ist kein Data Race. Die Lebenszeit des referenzierten Objekts muss über die Lebenszeit der <span class="tx_code">std::atomic_ref</span> hinausgehen. Der Zugriff auf das Unterobjekt des referenzierten Objekts ist nicht wohldefiniert.</div>
<div class="ztitel_kleiner">Motivation<br></div>
<div class="text">Ist es nicht ausreichend, eine Referenz in einer atomaren Variable zu verwenden? Leider nicht.</div>
<div class="text">Im folgenden Programm verwende ich die Klasse <span class="tx_code">ExpensiveToCopy</span>, die einen Zähler <span class="tx_code">counter</span> enthält. Dieser <span class="tx_code">counter</span> wird gleichzeitig von mehreren Threads inkrementiert. Konsequenterweise muss der Zähler daher geschützt werden:</div>
<div class="pre">// atomicReference.cpp<br><br>#include &lt;atomic&gt;<br>#include &lt;iostream&gt;<br>#include &lt;random&gt;<br>#include &lt;thread&gt;<br>#include &lt;vector&gt;<br><br>struct ExpensiveToCopy {<br>&nbsp;&nbsp;&nbsp; int counter{};<br>};<br>&nbsp;<br>int getRandom(int begin, int end) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br><br>&nbsp;&nbsp;&nbsp; std::random_device seed;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // initial seed<br>&nbsp;&nbsp;&nbsp; std::mt19937 engine(seed());&nbsp;&nbsp;&nbsp; // generator<br>&nbsp;&nbsp;&nbsp; std::uniform_int_distribution&lt;&gt; uniformDist(begin, end);<br><br>&nbsp;&nbsp;&nbsp; return uniformDist(engine);<br>}<br>&nbsp;<br>void count(ExpensiveToCopy&amp; exp) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::thread&gt; v;<br>&nbsp;&nbsp;&nbsp; std::atomic&lt;int&gt; counter{exp.counter};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; for (int n = 0; n &lt; 10; ++n) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.emplace_back([&amp;counter] {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto randomNumber = getRandom(100, 200);&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; randomNumber; ++i) { ++counter; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; for (auto&amp; t : v) t.join();<br><br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; ExpensiveToCopy exp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; count(exp);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "exp.counter: " &lt;&lt; exp.counter &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}<br></div>
<div class="text"><span class="tx_code">exp</span> (1) ist ein teuer zu kopierendes Objekt. Aus Performancegründen nimmt die Funktion <span class="tx_code">count</span> (2) daher <span class="tx_code">exp</span> per Referenz an. <span class="tx_code">count</span> initialisiert den <span class="tx_code">std::atomic&lt;int&gt;</span> mit <span class="tx_code">exp.counter</span> (3). Die anschließenden Zeilen erzeugen zehn Threads (4). Jeder der Threads führt den Lambda-Ausdruck aus, der <span class="tx_code">counter</span> per Referenz annimmt. Der Lambda-Ausdruck erhält eine Zufallszahl zwischen 100 und 200 (5) und inkrementiert <span class="tx_code">counter</span> genau diese Anzahl. Die Funktion <span class="tx_code">getRandom</span> (6) ermittelt eine initiale Zufälligkeit und erzeugt den Zufallszahlengenerator <a title="Link auf https://de.wikipedia.org/wiki/Mersenne-Twister" alt="%7B%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Mersenne-Twister%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FMersenne-Twister%22%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FMersenne-Twister%22%7D" href="https://de.wikipedia.org/wiki/Mersenne-Twister" class="">Mersenne-Twister</a>, der gleich verteilte Zufallszahlen erzeugt. <br></div>
<div class="text">Letztlich sollte der <span class="tx_code">exp.counter</span> (7) ungefähr einen Wert von 1500 haben, den jeder der zehn Threads inkrementiert den Zähler 150 Mal. Die Ausführung des Programms auf den Wandbox Online-Compiler überrascht mich. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/9/0/9/4/TN_203698018_acbe6e8a4d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Der Zähler ist 0. Was ist passiert? Das Problem verbirgt sich in der Zeile (3). Die Initialisierung des Ausdrucks <span class="tx_code">std::atomic&lt;int&gt; counter{exp.counter</span>} erzeugt eine Copy. Das folgende kleine Programm bringt das Problem auf den Punkt: <br></div>
<div class="pre">// atomicRefCopy.cpp<br><br>#include &lt;atomic&gt;<br>#include &lt;iostream&gt;<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; int val{5};<br>&nbsp;&nbsp;&nbsp; int&amp; ref = val;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::atomic&lt;int&gt; atomicRef(ref);<br>&nbsp;&nbsp;&nbsp; ++atomicRef;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "ref: " &lt;&lt; ref &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "atomicRef.load(): " &lt;&lt; atomicRef.load() &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Die Inkrementoperation (1) besitzt keine Auswirkung auf den referenzierten Wert <span class="tx_code">ref</span> (2). Der Wert von <span class="tx_code">ref</span> verändert sich nicht.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/9/0/9/4/TN_203698026_252696aef8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Wird <span class="tx_code">std::atomic&lt;int&gt; counter{exp.counter}</span> durch <span class="tx_code">std::atomic_ref&lt;int&gt; counter{exp.counter}</span> ersetzt, behebt das das Problem:<br></div>
<div class="pre">// atomicReference.cpp<br><br>#include &lt;atomic&gt;<br>#include &lt;iostream&gt;<br>#include &lt;random&gt;<br>#include &lt;thread&gt;<br>#include &lt;vector&gt;<br><br>struct ExpensiveToCopy {<br>&nbsp;&nbsp;&nbsp; int counter{};<br>};<br>&nbsp;<br>int getRandom(int begin, int end) {<br><br>&nbsp;&nbsp;&nbsp; std::random_device seed;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // initial randomness<br>&nbsp;&nbsp;&nbsp; std::mt19937 engine(seed());&nbsp;&nbsp;&nbsp; // generator<br>&nbsp;&nbsp;&nbsp; std::uniform_int_distribution&lt;&gt; uniformDist(begin, end);<br><br>&nbsp;&nbsp;&nbsp; return uniformDist(engine);<br>}<br>&nbsp;<br>void count(ExpensiveToCopy&amp; exp) {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::thread&gt; v;<br>&nbsp;&nbsp;&nbsp; std::atomic_ref&lt;int&gt; counter{exp.counter};<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; for (int n = 0; n &lt; 10; ++n) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.emplace_back([&amp;counter] {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto randomNumber = getRandom(100, 200);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; randomNumber; ++i) { ++counter; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; for (auto&amp; t : v) t.join();<br><br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; ExpensiveToCopy exp;<br>&nbsp;&nbsp;&nbsp; count(exp);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "exp.counter: " &lt;&lt; exp.counter &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Nun besitzt <span class="tx_code">counter</span> den erwarteten Wert.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/9/0/9/4/TN_203698031_a159dffe4f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">To be Atomic or not to be Atomic</div>
<div class="text">Du magst dich fragen, warum ich den Zähler als atomare Variable erklärt habe:</div>
<div class="pre">struct ExpensiveToCopy {<br>&nbsp;&nbsp;&nbsp; std::atomic&lt;int&gt; counter{};<br>};</div>
<div class="text">Das ist eine mögliche Strategie. Sie hat aber einen großen Nachteil. Jeder Zugriff auf den atomaren Zähler muss synchronisiert werden. Synchronisation gibt es aber nicht zum Nulltarif. Im Gegensatz dazu lässt sich dank <span class="tx_code">std::atomic_ref&lt;int&gt;</span> explizit steuern, wann der Zugriff auf den Zähler atomar sein muss. Eventuell wird der Zähler während der Programmausführung meist nur gelesen. Ihn in diesem Fall atomar zu erklären, ist das Gegenteil von Optimierung.</div>
<div class="text">Nun möchte ich noch ein paar Details zum Klassen-Template <span class="tx_code">std::atomic_ref</span> hinzufügen.</div>
<div class="ztitel">Spezialisierungen für std::atomic_ref</div>
<div class="text"><span class="tx_code">std::atomic_ref</span> lässt sich für benutzerdefinierte Datentypen definieren. Teilweise Spezialisierung für Zeiger, vollständige Spezialisierungen sind für arithmetische Datentypen wie Ganzzahlen oder Gleitkommazahlen möglich </div>
<div class="ztitel_kleiner">Primäre Template</div>
<div class="text">Das primäre Template <span class="tx_code">std::atomic_ref</span> lässt sich für einen trivial kopierbaren Datentyp <span class="tx_code">T</span> instanziieren. Trivial kopierbare Daten sind entweder skalare Datentypen (Arithmetische Datentypen, <span class="tx_code">enum</span>s, Zeiger, Zeiger auf Klassenmitglieder oder <span class="tx_code">std::nullptr_t</span>)&nbsp; oder trivial kopierbare Klassen oder Arrays von skalaren Datentypen. </div>
<div class="ztitel_kleiner">Teilweise Spezialisierungen für Zeigerdatentypen</div>
<div class="text">Der Standard bietet teilweise Spezialisierungen für Zeigertypen an: <span class="tx_code">std::atomic_ref&lt;t*&gt;.</span></div>
<div class="ztitel_kleiner">Spezialisierungen für arithmetische Datentypen</div>
<div class="text">Der Standard bietet Spezialisierungen für Ganzzahl und Gleitkommazahl Datentypen an: <span class="tx_code">std::atomic_ref&lt;arithmetic type&gt;</span>.</div>
<div class="text"><ul><li>Zeichentypen: <span class="tx_code">char, char8_t (</span>C++20), <span class="tx_code">char16_t</span>, <span class="tx_code">char32_t</span> und <span class="tx_code">wchar_t</span></li><li>vorzeichenbehaftete Ganzzahlen: <span class="tx_code">signed char</span>, <span class="tx_code">short</span>, <span class="tx_code">int</span>, <span class="tx_code">long</span> und<span class="tx_code"> long long</span></li><li>vorzeichenlose Ganzzahlen: <span class="tx_code">unsigned char</span>,<span class="tx_code"> unsigned short</span>, <span class="tx_code">unsigned int</span>, <span class="tx_code">unsigned long</span>, und <span class="tx_code">unsigned long long</span></li><li>zusätzliche Ganzzahlen, die in der Headerdatei <span class="tx_code">&lt;cstdint&gt;</span> definiert sind<br></li><li>Standard-Gleitkommazahlen: <span class="tx_code">float</span>, <span class="tx_code">double</span> und<span class="tx_code"> long double</span></li></ul></div>
<div class="ztitel">All-atomare Operationen</div>
<div class="text">Zuerst einmal zeigt die folgende Tabelle die Liste aller atomaren Operationen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/9/0/9/4/TN_203698061_ba00b9fa05.png" title="<ir_inline itemname=bilder_mvp_bild_var2:9 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die zusammengesetzten Zuweisungsoperatoren (<span class="tx_code">+=</span>,<span class="tx_code"> -=</span>,<span class="tx_code"> |=</span>, <span class="tx_code">&amp;=</span> oder <span class="tx_code">^=</span>) geben den neuen Wert zurück; die <span class="tx_code">fetch</span>-Varianten den alten. Jede Funktion unterstützt ein weiteres Argument zur <a title="Link auf https://en.cppreference.com/w/cpp/atomic/memory_orde" alt="%7B%22mediasync_id%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Speicherordnung%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fatomic%2Fmemory_orde%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fatomic%2Fmemory_orde%22%7D" href="https://en.cppreference.com/w/cpp/atomic/memory_orde" class="">Speicherordnung</a>. Der Default ist die sequentielle Konsistenz. </div>
<div class="text">Natürlich stehen nicht alle Funktionen für alle von<span class="tx_code"> std::atomic_ref</span> referenzierten Objekte zur Verfügung. Die nächste Tabelle zeigt die Liste der atomaren Operationen, die von dem jeweiligen Datentyp unterstützt werden.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/0/1/9/0/9/4/TN_203698056_7d7520add2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:8 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Beim sorgfältigen Studium der letzten zwei Tabellen fällt auf, dass sich Objekte vom Typ <span class="tx_code">std::atomic_ref</span> auch zur Synchronisation von Threads verwenden lassen.</div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text"><span class="tx_code">std::atomic</span> und <span class="tx_code">std::atomic_ref</span> unterstützen in C++20 die neuen Funktionen <span class="tx_code">notify_one</span>, <span class="tx_code">notify_all </span>und <span class="tx_code">wait</span>. Dank dieser Funktion lassen sich Threads einfach synchronisieren. <span class="tx_code">std::atomic</span> und insbesondere Threadsynchronisation mit atomaren Variablen werde ich mir in meinem nächsten Artikel genauer anschauen. </div>
<div class="ztitel">Neue Online-Seminare </div>
<div class="text"><ul><li><a title="Link auf https://www.modernescpp.de/index.php/c/2-c/29-embedded-programmierung-mit-modernem-c20201029102414" alt="%7B%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F29-embedded-programmierung-mit-modernem-c20201029102414%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F29-embedded-programmierung-mit-modernem-c20201029102414%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Embedded-Programmierung%20mit%20modernem%20C%2B%2B%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/29-embedded-programmierung-mit-modernem-c20201029102414" class="">Embedded-Programmierung mit modernem C++</a> (Deutsch):&nbsp; 26. bis 28. Januar 2021 (9 bis 17 Uhr CEST; Durchführungsgarantie)</li><li><a title="Link auf https://www.modernescpp.net/index.php/c/2-c/31-c-20" alt="%7B%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C%2B%2B20%20%5B--%5D%20A%20Deep%20Insight%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.net%2Findex.php%2Fc%2F2-c%2F31-c-20%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.net%2Findex.php%2Fc%2F2-c%2F31-c-20%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%7D" href="https://www.modernescpp.net/index.php/c/2-c/31-c-20" class="">C++20 [--] A Deep Insight</a> (English): 1. bis 3. Februar 2021 (16 bis 20 Uhr UTC)</li></ul></div>