<div class="vorspann">Der dritte und letzte Artikel der Miniserie zu Lewis Bakers Coroutinen-Abstraktion <a alt="%7B%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Flewissbaker%2Fcppcoro%22%2C%22text%22%3A%22cppcoro%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Flewissbaker%2Fcppcoro%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%7D" title="Link auf https://github.com/lewissbaker/cppcoro" class="" href="https://github.com/lewissbaker/cppcoro">cppcoro</a> führt Thread-Pools ein.<br></div>
<div class="text">Der heutige Artikel baut auf meinen zwei vorherigen Artikeln zu cppcoro auf:</div>
<div class="text"><ul><li> <a class="" href="https://heise.de/-4705161" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%3A%20Coroutinen%20mit%20cppcoro%3A%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4705161%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4705161%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%7D" title="Link auf https://heise.de/-4705161">C++20: Coroutinen mit cppcoro:</a> Einführung in cppcoro inklusive der elementaren Coroutinen-Tasks und -Generatoren<br></li><li> <a alt="%7B%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4708995%22%2C%22text%22%3A%22C%2B%2B20%3A%20M%C3%A4chtige%20Coroutinen%20mit%20cppcoro%3A%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4708995%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%7D" title="Link auf https://heise.de/-4708995" class="" href="https://heise.de/-4708995">C++20: Mächtige Coroutinen mit cppcoro:</a> Mächtigere Coroutinen dank Threads <br></li></ul></div>
<div class="text">Zusätzlich zuer <span class="tx_code">cppcoro::sync_wait</span>-Funktion, mit der sich einfach auf die vollständige Ausführung eines <i>Awaitable</i> warten lässt, bietet cppcoro die interessante <span class="tx_code">cppcoro::when_all</span>-Funktion an. </div>
<div class="ztitel">when_all<br></div>
<div class="text"><span class="tx_code">when_all</span>: erzeugt ein <i>Awaitable</i>, das auf alle<i> Input-Awaitable</i> wartet und das Aggregat der einzelnen Ergebnisse zurückgibt.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/8/8/6/4/3/TN_192913852_a89ff30445.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Ich habe die Definition <span class="tx_code">cppcoro::when_all</span> ein wenig vereinfacht. Das folgende Beispiel soll einen ersten Eindruck geben: <br></div>
<div class="pre">// cppcoroWhenAll.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>#include &lt;cppcoro/sync_wait.hpp&gt;<br>#include &lt;cppcoro/task.hpp&gt;<br>#include &lt;cppcoro/when_all.hpp&gt;<br><br>using namespace std::chrono_literals;<br><br>cppcoro::task&lt;std::string&gt; getFirst() {<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; co_return "First";<br>}<br><br>cppcoro::task&lt;std::string&gt; getSecond() {<br>&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; co_return "Second";<br>}<br><br>cppcoro::task&lt;std::string&gt; getThird() {<br>&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; co_return "Third";<br>}<br><br><br>cppcoro::task&lt;&gt; runAll() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; auto[fir, sec, thi] = co_await cppcoro::when_all(getFirst(), getSecond(), getThird());<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; fir &lt;&lt; " " &lt;&lt; sec &lt;&lt; " " &lt;&lt; thi &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto start = std::chrono::steady_clock::now();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; cppcoro::sync_wait(runAll());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto end = std::chrono::high_resolution_clock::now();<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; elapsed = end - start;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Execution time " &lt;&lt; elapsed.count() &lt;&lt; " seconds." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Der Top-Level Task <span class="tx_code">cppcoro::sync_wait(runAll())</span> (Zeite 1) wartet auf das <i>Awaitable</i> <span class="tx_code">runAll</span>. Dieses wiederum wartet auf die <i>Awaitables</i> <span class="tx_code">getFirst</span>, <span class="tx_code">getSecond</span> und <span class="tx_code">getThird</span> (Zeile 2). Die <i>Awaitables</i> <span class="tx_code">runAll</span>, <span class="tx_code">getFirst</span>, <span class="tx_code">getSecond</span> und <span class="tx_code">getThird</span> sind Coroutinen. Jede der <span class="tx_code">get</span>-Funktionen schläft für eine Sekunde (Zeite 3). Drei mal eins macht drei. Diese drei Sekunden sind genau die Zeit, die der Aufruf <span class="tx_code">cppcoro::sync_wait(runAll())</span> auf alle Coroutinen wartet. Zeile 4 gibt die Zeitdauer aus:<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/8/8/6/4/3/TN_192913862_97a1604264.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das waren die Grundlagen zur Funktion <span class="tx_code">cppcoro::when_all</span>. Jetzt erweitere ich das Beispiel um einen Thread-Pool.<br></div>
<div class="ztitel">static_thread_pool</div>
<div class="text"><span class="tx_code">static_thread_pool</span> verwaltet (<i>schedule</i>) Arbeitspakete auf einem Thread-Pool fester Länge<span class="tx_code">. cppcoro::static_thread_pool</span> kann mit und ohne Angabe einer Anzahl aufgerufen werden. Die Anzahl steht für die Anzahl der Threads, die erzeugt werden. Falls du die Anzahl nicht angibst, kommt die Funktion <a alt="%7B%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fthread%2Fthread%2Fhardware_concurrency%22%2C%22text%22%3A%22%5Bcode%5Dstd%3A%3Athread%3A%3Ahardware_concurrency%28%29%5B%2Fcode%5D%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fthread%2Fthread%2Fhardware_concurrency%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D" title="Link auf https://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency" class="" href="https://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency">[code]std::thread::hardware_concurrency()[/code]</a> zum Einsatz. Sie gibt einen Hinweis darauf, wie viele Hardware-Threads auf dem System unterstützt werden. Dies ist meist die Anzahl der Prozessoren oder Kerne, die zur Verfügung stehen. </div>
<div class="text">Das folgende Programm basiert auf dem vorherigen Programm, lediglich die Coroutinen <span class="tx_code">getFirst</span>, <span class="tx_code">getSecond</span> und <span class="tx_code">getThird</span> werden gleichzeitig ausgeführt:</div>
<div class="pre">// cppcoroWhenAllOnThreadPool.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>#include &lt;cppcoro/sync_wait.hpp&gt;<br>#include &lt;cppcoro/task.hpp&gt;<br>#include &lt;cppcoro/static_thread_pool.hpp&gt;<br>#include &lt;cppcoro/when_all.hpp&gt;<br><br><br>using namespace std::chrono_literals;<br><br>cppcoro::task&lt;std::string&gt; getFirst() {<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);<br>&nbsp;&nbsp;&nbsp; co_return "First";<br>}<br><br>cppcoro::task&lt;std::string&gt; getSecond() {<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);<br>&nbsp;&nbsp;&nbsp; co_return "Second";<br>}<br><br>cppcoro::task&lt;std::string&gt; getThird() {<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);<br>&nbsp;&nbsp;&nbsp; co_return "Third";<br>}<br><br>template &lt;typename Func&gt;<br>cppcoro::task&lt;std::string&gt; runOnThreadPool(cppcoro::static_thread_pool&amp; tp, Func func) {<br>&nbsp;&nbsp;&nbsp; co_await tp.schedule();<br>&nbsp;&nbsp;&nbsp; auto res = co_await func();<br>&nbsp;&nbsp;&nbsp; co_return res;<br>}<br><br>cppcoro::task&lt;&gt; runAll(cppcoro::static_thread_pool&amp; tp) {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto[fir, sec, thi] = co_await cppcoro::when_all(&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; runOnThreadPool(tp, getFirst),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; runOnThreadPool(tp, getSecond), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; runOnThreadPool(tp, getThird));<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; fir &lt;&lt; " " &lt;&lt; sec &lt;&lt; " " &lt;&lt; thi &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br>&nbsp;&nbsp;&nbsp; <br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto start = std::chrono::steady_clock::now();<br><br>&nbsp;&nbsp;&nbsp; cppcoro::static_thread_pool tp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; cppcoro::sync_wait(runAll(tp));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto end = std::chrono::high_resolution_clock::now();<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; elapsed = end - start;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Execution time " &lt;&lt; elapsed.count() &lt;&lt; " seconds." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Dieses sind die entscheidenden Unterschiede zum vorherigen Programm <span class="tx_code">cppcoroWhenAll</span>.<span class="tx_code">cpp</span>. Ich erzeuge in Zeile (1) einen Thread-Pool <span class="tx_code">tp</span> und verwende diesen als Argument der Funktion <span class="tx_code">runAll(tp)</span> (Zeile 2). Die Funktionen <span class="tx_code">runAll</span> verwendet den Thread-Pool, um die Coroutinen gleichzeitig zu starten. Dank <i>Structured Binding</i> (Zeile 3) lassen sich die Werte aller Coroutinen einfach einsammeln und Variablen zuweisen. Das Ausführen des Programms benötigt jetzt eine statt bisher drei Sekunden.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/8/8/6/4/3/TN_192913866_ef5ad331c0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Du weißt es eventuell bereits, dass wir mit C++20 Latches und Barriers erhalten. Beise sind einfache Synchronisationsmechanismen, die es erlauben, Threads zu blockieren, bis ein Zähler den Wert null besitzt. cppcoro bietet auch Latches und Barriers an.<br></div>
<div class="ztitel">async_latch<br></div>
<div class="text"><span class="tx_code">async_latch</span> erlaubt es, Coroutinen asynchron zu warten, bis ein Zähler den Wert null besitzt. Das folgende Programm <span class="tx_code">cppcoroLatch.cp</span><span class="tx_code">p</span> stellt Thread-Synchronisation mit <span class="tx_code">cppcoro::async_latch</span> vor:<br></div>
<div class="pre">// cppcoroLatch.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br>#include &lt;future&gt;<br><br>#include &lt;cppcoro/sync_wait.hpp&gt;<br>#include &lt;cppcoro/async_latch.hpp&gt;<br>#include &lt;cppcoro/task.hpp&gt;<br><br>using namespace std::chrono_literals; <br><br>cppcoro::task&lt;&gt; waitFor(cppcoro::async_latch&amp; latch) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Before co_await" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; co_await latch;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "After co_await" &lt;&lt; std::endl;<br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; cppcoro::async_latch latch(3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; auto waiter = std::async([&amp;latch]{ cppcoro::sync_wait(waitFor(latch)); }); <br><br>&nbsp;&nbsp;&nbsp; auto counter1 = std::async([&amp;latch] {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(2s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "counter1: latch.count_down() " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; latch.count_down();<br>&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto counter2 = std::async([&amp;latch] {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "counter2: latch.count_down(2) " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; latch.count_down(2);<br>&nbsp;&nbsp;&nbsp; });<br><br>&nbsp;&nbsp;&nbsp; waiter.get(), counter1.get(), counter2.get();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">In Zeile (1) habe ich einen <span class="tx_code">cppcoro::asynch_latch</span> erzeugt und seinen Zähler mit drei initialisiert. Dieses Mal verwende ich <span class="tx_code">std::async</span> (Zeile 2), um die drei Coroutinen gleichzeitig auszuführen. Jeder <span class="tx_code">std::async</span>-Aufruf erhält den Latch per Referenz. Die <span class="tx_code">waitFor-</span>Coroutine warten in Zeile 3, bis der Zähler den Wert null besitzt. Die Coroutine <span class="tx_code">counter1</span> schläft für zwei Sekunden, bevor sie den Zähler um zwei reduziert. Im Gegensatz dazu schläft <span class="tx_code">counter2</span> eine Sekunde und reduziert den Zähler um zwei. Der Screenshot zeigt das wechselnde Ausführen der Threads:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/8/8/6/4/3/TN_192913871_caf4824106.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Wie geht's weiter? <br></div>
<div class="text">Bisher habe ich über drei der <a class="" href="https://heise.de/-4568956" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4568956%22%2C%22text%22%3A%22vier%20gro%C3%9Fen%20Neuerungen%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4568956%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%7D" title="Link auf https://heise.de/-4568956">vier großen Neuerungen</a> in C++20 geschrieben: Concepts, Ranges und Coroutinen. Module fehlen noch in meiner Tour durch die großen Vier in C++20 und werden daher Thema der nächsten Artikel sein.</div>
<div class="text">Eine kleine Anmerkung möchte ich noch loswerden. Wenn du gerne einen Artikel zu einem C++20-Feature schreiben möchtest, das ich noch vorstellen werde, schreibe mir eine E-Mail. Ich freue mich auf den Artikel und werde ihn gegebenenfalls in Englisch/Deutsch übersetzen, falls dies notwendig ist.<br></div>
