<div class="vorspann">Heute endet das kleine Experiment, beliebte Funktionen aus Python in C++ umzusetzen. Bisher habe ich mir die Funktionen <span class="tx_code">filter</span>, <span class="tx_code">range</span> und <span class="tx_code">xrange</span> genauer angeschaut. Nun geht es um die <span class="tx_code">map</span>-Funktion.</div>
<div class="text">In meinem letzten Artikel "<a href="https://heise.de/-4678264" title="Link auf https://heise.de/-4678264" alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4678264%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4678264%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22C%2B%2B20%3A%20Pythons%20range-Funktion%22%7D" class="">C++20: Pythons range-Funktion</a>" setzte ich eine "lazy" Variante der <span class="tx_code">range</span>-Funktion um: <span class="tx_code">xrange</span>. Einige deutschsprachige Leser haben zurecht moniert, dass meine Implementierung sich nicht wie Pythons <span class="tx_code">xrange</span>-Funktion verhalte. Meine Implementierung setze konstante Ausdrücke für den Anfang und das Ende der erzeugten Zahlen vor:</div>
<div class="pre">auto res = xrange&lt;1, 10&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>for (auto i: res) std::cout &lt;&lt; i &lt;&lt; " ";&nbsp; // 1 2 3 4 5 6 7 8 9<br></div>
<div class="text">In dem Beispiel sind die Zahlen 1 und 10 die konstanten Ausdrücke. Das bedeutet, dass der folgende Ausdruck nicht gültig ist:</div>
<div class="text"><span class="tx_code">int begin = 1;<br>int end = 10;<br><br>auto res = xrange&lt;begin, end&gt;();</span><br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/6/2/3/0/9/TN_190520479_d91f08e8d2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Pythons range-Funktion, die dritte<br></div>
<div class="text">Dank des Lesers Clocktown kann ich heute die finale Version von <span class="tx_code">xrange</span> vorstellen. Sie ist lazy und nimmt auch Argumente für die Grenzen an, die nicht notwendigerweise konstante Ausdrücke sein müssen:<br></div>
<div class="pre">// xrange2.hpp<br><br>#include &lt;stdio.h&gt;<br>#include &lt;range/v3/all.hpp&gt;<br>&nbsp;<br>namespace view = ranges::views;<br><br>auto xrange(long long begin, long long end, long long step = 1) {<br>&nbsp;&nbsp;&nbsp; if(step == 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw std::invalid_argument("Step cannot be 0");<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; auto Step = begin &lt; end ? step : -step;<br>&nbsp;&nbsp;&nbsp; auto Begin = std::min(begin, end);<br>&nbsp;&nbsp;&nbsp; auto End = Step &lt; 0 ? Begin : std::max(begin, end);<br>&nbsp;&nbsp;&nbsp; return view::iota(Begin, End)<br>&nbsp;&nbsp;&nbsp; | view::stride(std::abs(Step))<br>&nbsp;&nbsp;&nbsp; | view::transform([begin, end](std::size_t i){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return begin &lt; end ? i : end - (i - begin);<br>&nbsp;&nbsp;&nbsp; });<br>}<br><br>auto xrange(long long end) {<br>&nbsp;&nbsp;&nbsp; return xrange(0, end, 1);<br>}&nbsp;&nbsp; <br> <br></div>
<div class="text">Die entscheidende Idee dieser Implementierung ist es, dass <span class="tx_code">view::transform</span> die Berechnung gegebenenfalls in eine umgedrehte Berechnung transformiert. <span class="tx_code">xrange</span> lässt sich mit ein, zwei oder drei Argumenten aufrufen. Der Default-Wert für das erste Argument ist 0 und der für das dritte Argument ist 1. Natürlich möchte ich die <span class="tx_code">xrange</span>-Funktion jetzt einsetzen. Ich habe einfach in meinem Beispiel des letzten Artikels die <span class="tx_code">xrange</span>-Funktion mit dieser verbesserten <span class="tx_code">xrange</span>-Implementierung ausgetauscht:<br></div>
<div class="pre">// range2.cpp<br><br>#include "xrange2.hpp"<br><br>#include &lt;iostream&gt;<br>#include &lt;range/v3/all.hpp&gt;<br>#include &lt;vector&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; auto res = xrange(1, 10);<br>&nbsp;&nbsp;&nbsp; for (auto i: res) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; res = xrange(1, 50, 5);<br>&nbsp;&nbsp;&nbsp; for (auto i: res) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto res2 = xrange(20, 10, -1);<br>&nbsp;&nbsp;&nbsp; for (auto i: res2) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; res2 = xrange(50, 10, -5);<br>&nbsp;&nbsp;&nbsp; for (auto i: res2) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; res = xrange(1, 1'000'000'000'000'000'000);<br>&nbsp;&nbsp;&nbsp; // for (auto i: res) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (auto i: res | ranges::views::take(10)) std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (auto i: res | ranges::views::drop_while([](int i){ return i &lt; 1'000'000; })<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::take_while([](int i){ return i &lt; 1'000'010; })){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; i &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>}<br> <br></div>
<div class="text">Wie zu erwarten, erhalte ich die gleiche Ausgabe:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/6/2/3/0/9/TN_190520487_375710c1ec.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Bisher gibt es nichts Neues. Nun folgen aber die Anwendungsfälle, die nur die neue, verbesserte Implementierung unterstützten: <span class="tx_code">begin</span> und <span class="tx_code">end</span> sind keine konstanten Ausdrücke und <span class="tx_code">xrange</span> lässt sich mit einem Argument verwenden: <br></div>
<div class="pre">int main() {<br><br>&nbsp; int begin = 3;<br>&nbsp; int end = 7;<br><br>&nbsp; for(auto x: xrange(end)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; x &lt;&lt; " ";&nbsp; // 0 1 2 3 4 5 6<br>&nbsp; }<br><br>&nbsp; for(auto x: xrange(begin, end)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; x &lt;&lt; " ";&nbsp; // 3 4 5 6<br><br>&nbsp; for(auto x: xrange(end, begin, -2)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; x &lt;&lt; " ";&nbsp; // 7 5<br>&nbsp; }<br>&nbsp; <br>}<br></div>
<div class="text">Jetzt kann ich endlich die Fortsetzung zur Funktion <span class="tx_code">range</span> abschließen. Dafür geht es jetzt in diesem Artikel mit der Funktion <span class="tx_code">map</span> weiter.<br></div>
<div class="ztitel">map<br></div>
<div class="text">Zuerst einmal meine vereinfachte Definition der <span class="tx_code">map</span>-Funktion in Python 2. Ich schränkte sie auf eine Sequenz sein. </div>
<div class="text"><ul><li> <span class="tx_code">map(func, seq</span>): gibt eine Liste zurück, indem die Funktion <span class="tx_code">func</span> auf jedes Element der Sequenz <span class="tx_code">seq</span> angewandt wird. <br></li></ul></div>
<div class="text">Wenn du darüber nachdenkst, lauert in dieser Funktion eine Herausforderung. Im Gegensatz zur <span class="tx_code">filter</span>-Funktion von Python (s. <a href="https://heise.de/-4671777" alt="%7B%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22C%2B%2B20%3A%20Pythonisch%20mit%20der%20Ranges-Bibliothek%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4671777%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4671777%22%2C%22alias%22%3A%22%22%7D" title="Link auf https://heise.de/-4671777" class="">C++20: Pythonisch mit der Ranges-Bibliothek</a>) kann die <span class="tx_code">map</span>-Funktion den Typ der Eingabesequenz ändern: <br></div>
<div class="pre">// map.cpp<br><br>#include "range.hpp"<br><br>#include &lt;algorithm&gt;<br>#include &lt;fstream&gt;<br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;range/v3/all.hpp&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;utility&gt;<br><br><br>template &lt;typename Func, typename Seq&gt;<br>auto map(Func func, Seq seq) {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; typedef typename Seq::value_type value_type;<br>&nbsp;&nbsp;&nbsp; using return_type = decltype(func(std::declval&lt;value_type&gt;()));&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;return_type&gt; result{};<br>&nbsp;&nbsp;&nbsp; for (auto i :seq | ranges::views::transform(func)) result.push_back(i);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; return result;<br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; // map(lambda i: i * i, range(1, 10))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; auto res = map([](int i){ return i * i; }, range(1, 10) );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (auto v: res) std::cout &lt;&lt; v &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; // map(lambda word: (len(word), word), ["Only", "for", "testing", "purpose."])<br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; myStrings{"Only", "for", "testing", "purpose"};<br>&nbsp;&nbsp;&nbsp; auto res2 = map([](const std::string&amp; s){ return std::make_pair(s.size(), s); }, myStrings);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (auto p: res2) std::cout &lt;&lt; "(" &lt;&lt;&nbsp; p.first &lt;&lt; ", " &lt;&lt; p.second &lt;&lt; ") " ;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; // freqWord = map(lambda word: (len(word), word), open("/etc/services").read().split("\n"))<br>&nbsp;&nbsp;&nbsp; // freqWord.sort(reverse = True)<br>&nbsp;&nbsp;&nbsp; // freqWord[:3]&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::ifstream file("/etc/services", std::ios::in);<br>&nbsp;&nbsp;&nbsp; std::stringstream buffer;<br>&nbsp;&nbsp;&nbsp; buffer &lt;&lt; file.rdbuf();<br>&nbsp;&nbsp;&nbsp; std::string text = buffer.str();<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; words = text | ranges::views::split('\n');&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; auto lengthWords = map([](const std::string&amp; s){ return std::make_pair(s.size(), s); }, words);<br>&nbsp;&nbsp;&nbsp; std::sort(std::begin(lengthWords), std::end(lengthWords), std::greater);<br>&nbsp;&nbsp;&nbsp; std::for_each(std::begin(lengthWords), std::begin(lengthWords) + 3, [](const auto&amp; p) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; p.first &lt;&lt; " " &lt;&lt; p.second &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Die Zeile (4) deduziert den Rückgabetyp <span class="tx_code">return_type</span>. Dieser ist der Datentyp, in dem alle Elemente der Eingabesequenz transformiert werden, wenn die Funktion <span class="tx_code">func</span> auf sie angewandt wird. <span class="tx_code">std::declval&lt;value_type&gt;()</span> gibt eine Rvalue-Referenz zurück, die <span class="tx_code">decltype</span> verwendet, um den Rückgabetyp zu deduzieren. </div>
<div class="text">Die auskommentierten Zeilen entsprechen wieder dem Python-Code.</div>
<div class="text"><ol><li>bildet jedes Element auf sein Quadrat ab.</li><li>bildet jedes Wort auf ein Paar Länge des Worts und das Wort ab.</li><li>liest jede Zeile aus der Datei "<span class="tx_code">/etc/services</span>", bildet jede Zeile auf ein Paar bestehend aus Länge und Zeile ab, sortiert die Sequenz in umgekehrter Reihenfolge und gibt die drei längsten Zeilen aus.</li></ol></div>
<div class="text">Der Screenshot zeigt die Ausgabe des Programms: <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/6/2/3/0/9/TN_190520491_98685ef2d7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Jetzt habe ich fast vergessen, einen zusätzlichen Punkt zu erwähnen, der mich vor ein größeres Problem gestellt hat, die Funktion <span class="tx_code">map</span> zu implementieren. Der Aufruf <span class="tx_code">std::vector&lt;std::string&gt; words = text | ranges::views::split('\n');</span> (Zeile 4) ist "deprecated". Stattdessen sollte ich den Konvertierungsoperator <span class="tx_code">ranges::t</span><span class="tx_code">o</span> anwenden. <span class="tx_code">ranges::to</span> ist aber kein Bestandteil von C++20. Daher fragte ich Eric Niebler, den Autor der Ranges-Bibliothek. Er schlug mir eine recht wortreiche Lösung vor, die einen GCC Bugrepot triggert (<a title="Link auf https://gcc.gnu.org/bugzilla/show_bug.cgi?id=93936" alt="%7B%22text%22%3A93936%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgcc.gnu.org%2Fbugzilla%2Fshow_bug.cgi%3Fid%3D93936%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fgcc.gnu.org%2Fbugzilla%2Fshow_bug.cgi%3Fid%3D93936%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%7D" href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=93936" class="">93936</a>). Letztlich habe ich die Deprecated-Variante im Beispiel verwendet.</div>
<div class="text">Die Funktion <span class="tx_code">map</span> stellt nicht das Ende meiner Experimente dar. Die Funktionen <span class="tx_code">map</span> und <span class="tx_code">filter</span> lassen sich einfach in einer Funktion kombinieren. Das Ergebnis ist dann eine Funktion, die sich ähnlich wie List Comprehension in Python verwenden lässt. Ehrlich gesagt, bin ich nicht hunderprozentig zufrieden mit meinem Ergebnis.</div>
<div class="ztitel">Ein Hauch von List Comprehension</div>
<div class="text">Meine Funktion <span class="tx_code">mapFilter</span> kann im Gegensatz zum Python-Pendant nur mit einer Sequenz umgehen:</div>
<div class="pre">// mapFilter.cpp<br><br>#include "range.hpp"<br><br>#include &lt;algorithm&gt;<br>#include &lt;cctype&gt;<br>#include &lt;fstream&gt;<br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;range/v3/all.hpp&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;utility&gt;<br><br>template &lt;typename T&gt;<br>struct AlwaysTrue {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; constexpr bool operator()(const T&amp;) const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>&nbsp;&nbsp;&nbsp; }<br>};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>template &lt;typename Map, typename Seq, typename Filt = AlwaysTrue&lt;typename Seq::value_type&gt;&gt;<br>auto mapFilter(Map map, Seq seq, Filt filt = Filt()) {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; typedef typename Seq::value_type value_type;<br>&nbsp;&nbsp;&nbsp; using return_type = decltype(map(std::declval&lt;value_type&gt;()));&nbsp; <br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;return_type&gt; result{};<br>&nbsp;&nbsp;&nbsp; for (auto i :seq | ranges::views::filter(filt) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ranges::views::transform(map)) result.push_back(i);<br>&nbsp;&nbsp;&nbsp; return result;<br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; // [ i * i for i in range(1, 10) ] <br>&nbsp;&nbsp;&nbsp; auto res = mapFilter([](int i){ return i * i; }, range(1, 10) );<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; // [ i * i for i in range(1, 10) if i % 2 == 1 ]<br>&nbsp;&nbsp;&nbsp; res = mapFilter([](int i){ return i * i; }, range(1, 10) , <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](auto i){ return i % 2 == 1; });<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (auto v: res) std::cout &lt;&lt; v &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)&nbsp; <br>&nbsp;&nbsp;&nbsp; // [(len(word), word) for word in ["Only", "for", "testing", "purpose."]]<br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; myStrings{"Only", "for", "testing", "purpose"};<br>&nbsp;&nbsp;&nbsp; auto res2 = mapFilter([](const std::string&amp; s){ return std::make_pair(s.size(), s); }, myStrings);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; // [(len(word), word) for word in ["Only", "for", "testing", "purpose."] if word[0].isupper()]<br>&nbsp;&nbsp;&nbsp; myStrings = {"Only", "for", "testing", "purpose"};<br>&nbsp;&nbsp;&nbsp; res2 = mapFilter([](const std::string&amp; s){ return std::make_pair(s.size(), s); }, myStrings, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](const std::string&amp; word){ return std::isupper(word[0]); });<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (auto p: res2) std::cout &lt;&lt; "(" &lt;&lt;&nbsp; p.first &lt;&lt; ", " &lt;&lt; p.second &lt;&lt; ") " ;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3) <br>&nbsp;&nbsp;&nbsp; // freqWord = [(len(line), line) for line in open("/etc/services").read().split("\n")]<br>&nbsp;&nbsp;&nbsp; // freqWord = map(lambda word: (len(word), word), open("/etc/services").read().split("\n"))<br>&nbsp;&nbsp;&nbsp; // freqWord.sort(reverse = True)<br>&nbsp;&nbsp;&nbsp; // freqWord[:3]&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::ifstream file("/etc/services", std::ios::in);<br>&nbsp;&nbsp;&nbsp; std::stringstream buffer;<br>&nbsp;&nbsp;&nbsp; buffer &lt;&lt; file.rdbuf();<br>&nbsp;&nbsp;&nbsp; std::string text = buffer.str();<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; words = text | ranges::views::split('\n');<br>&nbsp;&nbsp;&nbsp; auto lengthWords = mapFilter([](const std::string&amp; s){ return std::make_pair(s.size(), s); }, words);<br>&nbsp;&nbsp;&nbsp; std::sort(std::begin(lengthWords), std::end(lengthWords), std::greater());<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp; // len([line for line in open("/etc/services").read().split("\n") if 100 &lt; len(line) &lt; 150])<br>&nbsp;&nbsp;&nbsp; words = text | ranges::views::split('\n');<br>&nbsp;&nbsp;&nbsp; auto allLines = mapFilter([](const std::string&amp; line){ return line; }, words, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](const std::string&amp; line){ return 100 &lt; line.size() &amp;&amp; line.size() &lt; 150; });<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Number of lines: " &lt;&lt; allLines.size();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>}</div>
<div class="text">Das Default-Prädikat, das die <span class="tx_code">filter</span>-Funktion anwendet (Zeile 2), gibt immer <span class="tx_code">true</span> zurück (Zeile 1). "Immer <span class="tx_code">true</span>" bedeutet, das die <span class="tx_code">mapFilter</span>-Funktion sich per Default wie die <span class="tx_code">map</span>-Funktion verhält. Wenn du die Zeilen (3) studierst, fällt dir kein Unterschied zum vorherigen Programm <span class="tx_code">map.cpp</span> auf. Nun beginnt aber der Unterschied. Den entsprechenden Python-Code, der List Comprehension verwendet, habe ich auskommentiert. <br></div>
<div class="text"><ul><li>Zeile (4) berechnet die Quadrate der Zahlen, die ungerade sind.</li><li>Zeile (5) gibt die Paare (Länge des Worts, Wort) für die Wörter zurück, die mit einem Großbuchstaben beginnen.</li><li>Zeile (6) gibt einen Vektor aller Zeilen der Datei "<span class="tx_code">/etc/services</span>" zurück, die zwischen 100 und 150 Zeichen besitzen.</li></ul></div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/6/2/3/0/9/TN_190520500_9bd31927fc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Dieser Artikel war länger als gewöhnlich. In meinem nächsten geht es um verallgemeinerte Funktionen, die unterbrochen und wieder gestartet werden können. Um es kurz zu machen: Mein nächster Artikel behandelt das nächste Feature aus C++20: Coroutinen.<br></div>