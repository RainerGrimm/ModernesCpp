<div class="vorspann">Meine Geschichte zu Coroutinen in C++20 geht weiter. Heute tauche ich in das Coroutinen-Framework ein, um einen unendlichen Datenstrom zu erzeugen. Konsequenterweise solltest du meine zwei vorherigen Artikel "<a title="Link auf https://heise.de/-468745" href="https://heise.de/-468745" alt="%7B%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-468745%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-468745%22%2C%22text%22%3A%22C%2B%2B20%3A%20Coroutinen%20%5B--%5D%20ein%20erster%20%C3%9Cberblick%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" class="">C++20: Coroutinen [--] ein erster Überblick</a>" und "<a title="Link auf https://heise.de/-4692662" alt="%7B%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%3A%20Mehr%20Details%20zu%20Coroutinen%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4692662%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4692662%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D" href="https://heise.de/-4692662" class="">C++20: Mehr Details zu Coroutinen</a>" kennen.<br></div>
<div class="text">Das Framework zum Schreiben von Coroutinen besteht aus mehr als 20 Funktionen, die du teilweise implementieren oder teilweise überschreiben kannst. Damit lässt sich das Verhalten der Coroutinen sehr feingranular steuern. Am Ende lässt sich zum Beispiel eine Coroutine erzeugen, die einen Generator <span class="tx_code">Generator&lt;int&gt;</span> für einen unendlichen Datenstrom erzeugt:</div>
<div class="pre">Generator&lt;int&gt; getNext(int start = 0, int step = 1) {<br>&nbsp;&nbsp;&nbsp; auto value = start;<br>&nbsp;&nbsp;&nbsp; for (int i = 0;; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; co_yield value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value += step;<br>&nbsp;&nbsp;&nbsp; }<br>}<br></div>
<div class="text">Nun habe ich das Ziel des heutigen Artikels vorgestellt. Jetzt beginnt die Arbeit.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/7/4/4/2/1/TN_191615991_ac3bff89f2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Das Framework<br></div>
<div class="text">Eine Coroutine besteht aus drei Komponenten: Promise-Objekt, Coroutinen-Handle und Coroutinen-Frame.</div>
<div class="text"><ul><li> <b>Promise-Objekt</b>: Es wird innerhalb der Coroutine verändert und gibt ihr Ergebnis mithilfe des Promise-Objekts zurück.<br></li><li><b>Coroutinen-Handle</b>: Er ist ein nichtbesitzender Verweis, der außerhalb der Coroutine erlaubt, die Coroutine wieder auszuführen oder zu zerstören.<br></li><li><b>Coroutinen-Frame</b>: Er ist ein interner, Heap-basierter Zustand. Dieser besteht aus dem Promise-Objekt, den kopierten Argumenten der Coroutine, den Anhaltepunkten der Coroutine (suspension points) und den lokalen Objekten, deren Gültigkeit vor oder nach dem Anhaltepunkt enden. <br></li></ul></div>
<div class="ztitel_kleiner">Ein vereinfachter Workflow<br></div>
<div class="text">Wenn du <span class="tx_code">co_yield</span>, <span class="tx_code">co_await</span> oder <span class="tx_code">co_return</span> in einer Funktion einsetzt, wird diese Funktion zur Coroutine. Dadurch transformiert der Compiler den Funktionskörper in eine Funktion, die die folgende Struktur besitzt:</div>
<div class="pre">{<br>&nbsp; Promise promise;<br>&nbsp; co_await promise.initial_suspend();<br>&nbsp; try<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; &lt;function body&gt;<br>&nbsp; }<br>&nbsp; catch (...)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; promise.unhandled_exception();<br>&nbsp; }<br>&nbsp; FinalSuspend:<br>&nbsp;&nbsp;&nbsp; co_await promise.final_suspend();<br>}</div>
<div class="text"><span class="tx_code">&lt;function body&gt;</span> steht für den ursprünglichen Funktionskörper. Der vereinfachte Workflow besteht aus den folgenden Phasen:</div>
<div class="text">Die Coroutine startet ihre Ausführung:</div>
<div class="text"><ul><li> Der Coroutinen-Frame wird allokiert.</li><li>Alle Funktionsparameter werden in den Coroutinen-Frame kopiert,</li><li>Das Promise-Objekt <span class="tx_code">promise</span> wird erzeugt,</li><li>Der Aufruf <span class="tx_code">promise.get_return_object()</span> erzeugt den Coroutinen-Handle, der in einer lokalen Variable gespeichert wird. Das Ergebnis des Aufrufs wird an den Aufrufer zurückgegeben, falls die Coroutine angehalten wird.</li><li><span class="tx_code">promise.initial_suspend()</span> wird mithilfe von <span class="tx_code">co_await</span> ausgeführt. Das Promise-Objekt gibt <span class="tx_code">std::suspend_never</span> für eine Coroutine zurück, die sofort ausgeführt wird und <span class="tx_code">std::suspend_always</span> für eine Coroutine, die erst auf Bedarf (lazy) ausgeführt wird.</li><li>Der Körper der Coroutine wird dann ausgeführt, wenn <span class="tx_code">co_await promise.inital_suspend() </span>fortgesetzt wird.<br></li></ul></div>
<div class="text">Die Coroutine erreicht einen Anhaltepunkt:</div>
<div class="text"><ul><li> Der Coroutinen-Handle (<span class="tx_code">promise.get_return_object()</span>) wird an den Aufrufer zurückgegeben, der die Couroutine fortsetzt.<br></li></ul></div>
<div class="text">Die Coroutine erreicht <span class="tx_code">co_return</span>. Sie</div>
<div class="text"><ul><li>ruft <span class="tx_code">promise.return_void()</span> für <span class="tx_code">co_return</span> oder <span class="tx_code">co_return expression</span> auf, falls <span class="tx_code">expression</span> den Datentyp <span class="tx_code">void</span> besitzt.</li><li>ruft <span class="tx_code">promise.return_value(expression)</span> für <span class="tx_code">co_return expression</span> auf, falls <span class="tx_code">expression</span> nicht den Datentyp <span class="tx_code">void</span> besitzt.</li><li>zerstört alle auf dem Stack erzeugten Variablen.</li><li>ruft <span class="tx_code">promise.final_suspend()</span> mithilfe von <span class="tx_code">co_await</span> auf.<br></li></ul></div>
<div class="text">Die Coroutine wird zerstört (<span class="tx_code">co_return</span>, eine nicht gefangene Ausnahme oder durch den Coroutinen-Handle). Sie </div>
<div class="text"><ul><li> ruft den Destruktor des Promise-Objekts auf.</li><li>ruft die Destruktoren der Funktionsparameter auf.</li><li>gibt den Speicher der Coroutine wieder frei.</li><li>gibt die Ausführung an den Aufrufenden zurück.<br></li></ul></div>
<div class="text">Jetzt gilt es, die Theorie in die Praxis umzusetzen.</div>
<div class="ztitel_kleiner">Ein unendlicher Datenstrom mit co_yield<br></div>
<div class="text">Das folgende Programm erzeugt einen unendlichen Datenstrom. Die Coroutine <span class="tx_code">getNext</span> verwendet <span class="tx_code">co_yield</span> dafür. <span class="tx_code">getNext</span> erzeugt einen Datenstrom, der mit <span class="tx_code">start</span> beginnt und auf Anfrage jeweils den um <span class="tx_code">step</span> inkrementierten nächsten Wert zurückgibt:<br></div>
<div class="pre">// infiniteDataStream.cpp<br><br>#include &lt;coroutine&gt;<br>#include &lt;memory&gt;<br>#include &lt;iostream&gt;<br><br>template&lt;typename T&gt;<br>struct Generator {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; struct promise_type;<br>&nbsp;&nbsp;&nbsp; using handle_type = std::coroutine_handle&lt;promise_type&gt;;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Generator(handle_type h): coro(h) {}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; handle_type coro;<br>&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;T&gt; value;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ~Generator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( coro ) coro.destroy();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; Generator(const Generator&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; Generator&amp; operator = (const Generator&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; Generator(Generator&amp;&amp; oth): coro(oth.coro) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oth.coro = nullptr;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; Generator&amp; operator = (Generator&amp;&amp; oth) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coro = oth.coro;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oth.coro = nullptr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; int getValue() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return coro.promise().current_value;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; bool next() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coro.resume();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return not coro.done();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; struct promise_type {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; promise_type()&nbsp; = default;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~promise_type() = default;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto initial_suspend() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::suspend_always{};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto final_suspend() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::suspend_always{};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto get_return_object() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Generator{handle_type::from_promise(*this)};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto return_void() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::suspend_never{};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto yield_value(int value) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_value = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::suspend_always{};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void unhandled_exception() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::exit(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T current_value;<br>&nbsp;&nbsp;&nbsp; };<br><br>};<br><br>Generator&lt;int&gt; getNext(int start = 0, int step = 1){<br>&nbsp;&nbsp;&nbsp; auto value = start;<br>&nbsp;&nbsp;&nbsp; for (int i = 0;; ++i){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; co_yield value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value += step;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getNext():";<br>&nbsp;&nbsp;&nbsp; auto gen = getNext();<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt;= 10; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen.next();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; " " &lt;&lt; gen.getValue();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getNext(100, -10):";<br>&nbsp;&nbsp;&nbsp; auto gen2 = getNext(100, -10);<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt;= 20; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen2.next();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; " " &lt;&lt; gen2.getValue();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Die <span class="tx_code">main</span>-Funktion erzeugt zwei Coroutinen. Die erste Coroutine<span class="tx_code"> gen</span> gibt die Werte von 0 bis 10 zurück und die zweite Coroutine <span class="tx_code">gen2</span> von 100 bis -100. Bevor ich den Workflow genauer vorstelle, möchte ich mithilfe des <a alt="%7B%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FjTS9BR%22%2C%22text%22%3A%22Compiler%20Explorer%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FjTS9BR%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%7D" href="https://godbolt.org/z/jTS9BR" class="" title="Link auf https://godbolt.org/z/jTS9BR">Compiler Explorer</a> und des GCC 10 die Ausgabe des Programms präsentieren.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/8/7/4/4/2/1/TN_191615998_b550852804.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Zahlen im Programm <span class="tx_code">infiniteDataStream.cpp</span> stehen für die Schritte in der ersten Iteration des Workflows.</div>
<div class="text"><ol><li>Erzeugt den Promise.</li><li>Ruft <span class="tx_code">promise.get_return_object()</span> auf und speichert das Ergebnis des Aufrufs in einer lokalen Variable.</li><li>Erzeugt den Generator.</li><li>Ruft <span class="tx_code">promise.inital_suspend() </span>auf. Der Generator ist lazy und pausiert damit automatisch.</li><li>Frägt nach dem nächsten Wert und gibt zurück, ob die Werte des Generators bereits konsumiert sind. <br></li><li>Wird durch <span class="tx_code">co_yield</span> angestoßen. Danach ist der nächste Wert verfügbar. <br></li><li>Fordert den nächsten Wert an.</li></ol></div>
<div class="text">In weiteren Iterationen werden nur die Schritte 5 bis 7 wiederholt. </div>
<div class="text">Es ist anspruchsvoll, das den Coroutinen zugrunde liegende Framework zu verstehen. Der einfachste Zugang ist es meines Erachtens, mit existieren Coroutinen zu experimentieren und ihr Verhalten zu beobachten. Die vorgestellte Coroutine, die einen unendlichen Datenstrom erzeugt, ist ein guter Startpunkt für deine Experimente: Verwende dazu den Link auf das ausführbare Programm im <a href="https://godbolt.org/z/jTS9BR" alt="%7B%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Compiler%20Explorer%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FjTS9BR%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FjTS9BR%22%7D" class="" title="Link auf https://godbolt.org/z/jTS9BR">Compiler Explorer</a>.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Im heutigen Artikel habe ich dank <span class="tx_code">co_yield</span> einen Generator für einen unendlichen Datenstrom vorgestellt. Mein nächster Artikel beschäftigt sich mit der Thread-Synchronisation und <span class="tx_code">co_await</span>.<br></div>
