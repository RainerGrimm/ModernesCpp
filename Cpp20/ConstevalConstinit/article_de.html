<div class="vorspann">Mit C++20 erhalten wir zwei neue Schlüsselwörter: <span class="tx_code">consteval</span> und <span class="tx_code">constinit</span>. Das erste erzeugt eine Funktion, die zur Compilezeit ausgeführt wird, das zweite sichert zu, dass eine Variable zur Compilezeit initialisiert wird.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/3/5/1/0/0/TN_196823349_3741db1fc8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Beim Lesen meiner kurzen Einleitung zu <span class="tx_code">consteval</span> und <span class="tx_code">constinit</span> mag der Eindruck entstehen, dass beide Spezifizierer sehr ähnlich zu <span class="tx_code">constexpr</span> sind. Diese Beobachtung trifft zu. Bevor ich aber die Schlüsselwörter <span class="tx_code">consteval</span>, <span class="tx_code">constinit</span>, <span class="tx_code">constexpr</span> und das gute alte <span class="tx_code">const</span> genauer unter die Lupe nehmen, möchte ich <span class="tx_code">consteval</span> und <span class="tx_code">constinit</span> vorstellen.</div>
<div class="ztitel">consteval<br></div>
<div class="pre">consteval int sqr(int n) {<br>&nbsp;&nbsp;&nbsp; return n * n;<br>}<br></div>
<div class="text"><span class="tx_code">consteval</span> erzeugt eine sogenannte immediate-Funktion. Jeder Aufruf einer solchen Funktion erzeugt eine Compilezeit-Konstante. Dies lässt sich auch einfacher ausdrücken. Eine <span class="tx_code">consteval-</span> (immediate-)Funktion wird zur Compilezeit ausgeführt.</div>
<div class="text"><span class="tx_code">consteval</span> kann nicht auf Destruktoren oder Funktionen angewandt werden, die Speicher allokieren oder freigeben. In einer Deklaration lässt sich nur maximal eines der Schlüsselwörter <span class="tx_code">consteval</span>, <span class="tx_code">constexpr</span> oder <span class="tx_code">constinit</span> einsetzen. Eine immediate-Funktion (<span class="tx_code">consteval</span>) ist implizit <span class="tx_code">inline</span> und muss dieselben Anforderungen wie eine <span class="tx_code">constexpr</span>-Funktion erfüllen. </div>
<div>Die Anforderungen an eine <span class="tx_code">constexpr</span>-Funktion in C++14 und damit eine <span class="tx_code">consteval</span>-Funktion sind die folgenden: Eine <span class="tx_code">constexpr</span>-Funktion kann<br></div>
<div class="text"><ul><li>bedingte Sprung- und Iterationsanweisungen enthalten.</li><li>mehrere Anweisungen umfassen.</li><li><span class="tx_code">constexpr</span>-Funktionen aufrufen. Eine <span class="tx_code">consteval</span>-Funktion kann eine <span class="tx_code">constexpr</span>-Funktion aufrufen. Eine <span class="tx_code">constexpr</span>-Funktion kann aber nicht eine <span class="tx_code">consteval</span>-Funktion aufrufen.</li><li>fundamentale Datentypen verwenden, die mit einem konstanten Ausdruck zu initialisieren sind.</li></ul></div>
<div class="text"><span class="tx_code">constexpr</span>-Funktionen können keine statischen oder&nbsp;<span class="tx_code">thread_local</span>-Daten verwenden. Auch ist ein&nbsp;<span class="tx_code">try</span>-Block oder eine&nbsp;<span class="tx_code">goto</span>-Anweisungen nicht möglich. Das folgende Programm <span class="tx_code">constevalSqr.cpp</span> stellt die <span class="tx_code">consteval</span>-Funktion <span class="tx_code">sqr</span> vor.<br></div>
<div class="pre">// constevalSqr.cpp<br><br>#include &lt;iostream&gt;<br><br>consteval int sqr(int n) {<br>&nbsp;&nbsp;&nbsp; return n * n;<br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sqr(5): " &lt;&lt; sqr(5) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; const int a = 5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sqr(a): " &lt;&lt; sqr(a) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; int b = 5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; // std::cout &lt;&lt; "sqr(b): " &lt;&lt; sqr(b) &lt;&lt; std::endl; ERROR<br><br>}<br></div>
<div class="text">5 ist ein konstanter Ausdruck und lässt sich damit als Argument der Funktion <span class="tx_code">sqr</span> (1) einsetzen. Dasselbe gilt die für Variable <span class="tx_code">a</span> (2). Eine Konstante wie <span class="tx_code">a</span> lässt sich in einem konstanten Ausdruck verwenden, wenn sie mit einem konstanten Ausdruck initialisiert wird. b (3) ist kein konstanter Ausdruck. Konsequenterweise ist der Aufruf <span class="tx_code">sqr(5)</span> nicht gültig.</div>
<div class="text">Dank des neuen GCC11-Compilers und dem <a alt="%7B%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Compiler%20Explorer%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%7D" title="Link auf https://godbolt.org/" class="" href="https://godbolt.org/">Compiler Explorer</a> kann ich das Programm ausführen.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/3/5/1/0/0/TN_196823351_80c8aacdc7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">constinit<br></div>
<div class="text"><span class="tx_code">constinit</span> kann auf Variablen mit statischer Speicherdauer (static storage duration) oder Thread-Speicherdauer (thread storage duration) angewandt werden.</div>
<div class="text"><ul><li> Globale oder statische Variablen oder statische Mitglieder einer Klasse besitzen <b>statische Speicherdauer</b>. Diese Objekte werden allokiert, wenn das Programm startet, und deallokiert, wenn das Programm endet.</li><li><span class="tx_code">thread_loca</span>l-Variablen besitzen <b>Thread-Speicherdauer</b>. Thread-lokale Daten werden bei Bedarf für jeden Thread erzeugt. Sie gehören exklusiv einem Thread, werden bei ihrer ersten Verwendung erzeugt und ihre Lebenszeit ist an die Lebenszeit ihres Threads gebunden. Gerne werden Thread-lokale Daten auch Thread-lokaler Speicher genannt.</li></ul></div>
<div class="text"><span class="tx_code">constinit</span> sichert für diese Variablen (statische Speicherdauer und Thread-Speicherdauer) zu, dass sie zur Compilezeit initialisiert werden: <br></div>
<div class="pre">// constinitSqr.cpp<br><br>#include &lt;iostream&gt;<br><br>consteval int sqr(int n) {<br>&nbsp;&nbsp;&nbsp; return n * n;<br>}<br><br>&nbsp;&nbsp;&nbsp; constexpr auto res1 = sqr(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; constinit auto res2 = sqr(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sqr(5): " &lt;&lt; res1 &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sqr(5): " &lt;&lt; res2 &lt;&lt; std::endl;<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; constinit thread_local auto res3 = sqr(5);&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sqr(5): " &lt;&lt; res3 &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text"><span class="tx_code">res1</span> und <span class="tx_code">res2</span> besitzen statische Speicherdauer. <span class="tx_code">res3</span> besitzt Thread-Speicherdauer.<br></div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/3/5/1/0/0/TN_196823360_0af90e9405.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Nun ist es an der Zeit, auf die Unterschiede von <span class="tx_code">const</span>, <span class="tx_code">constexpr</span>, <span class="tx_code">consteval</span> und <span class="tx_code">constinit</span> genauer einzugehen. Diese Unterschiede werde ich anhand des Ausführens einer Funktion und des Initialisierens einer Variable vorstellen.</div>
<div class="ztitel">Ausführen einer Funktion</div>
<div class="text">Das Programm <span class="tx_code">consteval.cpp</span> besitzt drei Versionen der <i>square</i>-Funktion:</div>
<div class="pre">// consteval.cpp<br><br>#include &lt;iostream&gt;<br><br>int sqrRunTime(int n) {<br>&nbsp;&nbsp;&nbsp; return n * n;<br>}<br><br>consteval int sqrCompileTime(int n) {<br>&nbsp;&nbsp;&nbsp; return n * n;<br>}<br><br>constexpr int sqrRunOrCompileTime(int n) {<br>&nbsp;&nbsp;&nbsp; return n * n;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; // constexpr int prod1 = sqrRunTime(100); ERROR (1)<br>&nbsp;&nbsp;&nbsp; constexpr int prod2 = sqrCompileTime(100);<br>&nbsp;&nbsp;&nbsp; constexpr int prod3 = sqrRunOrCompileTime(100);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; int x = 100;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; int prod4 = sqrRunTime(x); <br>&nbsp;&nbsp;&nbsp; // int prod5 = sqrCompileTime(x); ERROR (2)<br>&nbsp;&nbsp;&nbsp; int prod6 = sqrRunOrCompileTime(x);<br><br>}<br></div>
<div class="text">Die Namen deuten es bereits an: Die gewöhnliche Funktion <span class="tx_code">sqrRunTime</span> wird zur Laufzeit ausgeführt; die <span class="tx_code">consteval</span>-Funktion <span class="tx_code">sqrCompileTime</span> zur Compilezeit; die <span class="tx_code">constexpr</span> Funktion <span class="tx_code">sqrRunOrCompileTime</span> zur Laufzeit oder Compilezeit. Konsequenterweise führt der Aufruf der Funktion <span class="tx_code">sqrRunTime</span> (1) zur Compilezeit zu einem Fehler. Ein Fehler ergibt sich, wenn ein nichtkonstaner Ausdruck als Argument der Funktion <span class="tx_code">sqrCompileTime</span> (2) verwendet wird.</div>
<div class="text">Der Unterschied zwischen <span class="tx_code">constexpr</span>-Funktion <span class="tx_code">sqrRunOrCompileTime</span> und der <span class="tx_code">consteval</span>-Funktion <span class="tx_code">sqrCompileTime</span> ist, dass die erste nur dann zur Compilezeit ausgeführt werden muss, wenn das ihr Aufrufkontext erfordert:</div>
<div class="pre">static_assert(sqrRunOrCompileTime(100) == 100);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // compile-time (1)<br>int arrayNewWithConstExpressioFunction[sqrRunOrCompileTime(100)]; // compile-time (1)<br>constexpr int prod = sqrRunOrCompileTime(100);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // compile-time (1)<br><br>int a = 100;<br>int runTime = sqrRunOrCompileTime(a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // run-time (2)<br><br>int runTimeOrCompiletime = sqrRunOrCompileTime(100);&nbsp; // run-time or compile-time (3)<br><br>int allwaysCompileTime = sqrCompileTime(100);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // compile-time (4)<br></div>
<div class="text">Die ersten drei Zeilen (1) fordern die Ausführung zur Compilezeit. Zeile (2) lässt sich nur zur Laufzeit ausführen. <span class="tx_code">a</span> ist kein konstanter Ausdruck. Die kritische Zeile ist die Zeile (3). Die Funktion kann zur Compilezeit oder zur Laufzeit ausgeführt werden. Ob sie zur Compilezeit oder Laufzeit ausgeführt wird, hängt von dem verwendeten Compiler und dem Optimierungsstufen des Programms ab. Die Beobachtung gilt nicht für die Zeile (4). Eine <span class="tx_code">consteval</span>-Funktion wird immer zur Compilezeit ausgeführt.</div>
<div class="ztitel">Initialisierung einer Variable</div>
<div class="text">In dem folgenden Programm <span class="tx_code">constexprConstinit.cpp</span> vergleiche ich <span class="tx_code">const</span>, <span class="tx_code">constexpr</span> und <span class="tx_code">constint</span>:</div>
<div class="pre">// constexprConstinit.cpp<br><br>#include &lt;iostream&gt;<br><br>constexpr int constexprVal = 1000;<br>constinit int constinitVal = 1000;<br><br>int incrementMe(int val){ return ++val;}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; auto val = 1000;<br>&nbsp;&nbsp;&nbsp; const auto res = incrementMe(val);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "res: " &lt;&lt; res &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; // std::cout &lt;&lt; "res: " &lt;&lt; ++res &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR (2)<br>&nbsp;&nbsp;&nbsp; // std::cout &lt;&lt; "++constexprVal++: " &lt;&lt; ++constexprVal &lt;&lt; std::endl; ERROR (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "++constinitVal++: " &lt;&lt; ++constinitVal &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>&nbsp;&nbsp;&nbsp; constexpr auto localConstexpr = 1000;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; // constinit auto localConstinit = 1000; ERROR<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Lediglich die <span class="tx_code">const</span>-Variable&nbsp; (1) wird zur Laufzeit initialisiert. <span class="tx_code">constexpr</span>- und <span class="tx_code">constinit</span>-Variablen werden zur Compilezeit initialisiert. <span class="tx_code">constinit</span> (3) impliziert nicht die Konstantheit der Variable wie im Falle von <span class="tx_code">const</span> (2) oder <span class="tx_code">constexpr</span> (2). Eine als <span class="tx_code">constexpr</span> (4) oder <span class="tx_code">const</span> (1) deklarierte Variable kann als eine lokale Variable erzeugt werden. Das gilt aber nicht für eine <span class="tx_code">constinit</span>-Variable.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//2/9/3/5/1/0/0/TN_196823363_68236265a3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Die Initialisierung von statischen Variablen in verschieden Übersetzungseinheiten besitzt ein ernsthaftes Problem: Es ist nicht definiert, in welcher Reihenfolge statische Variablen initialisiert werden, deren Initialisierung voneinander abhängt. Um es kurz zu machen: In meinem nächsten Artikel geht es um das <i>Static Initialization Order Fiasc</i>o und wie sich dies dank <span class="tx_code">constinit</span> in Wohlgefallen auflöst. <br></div>
