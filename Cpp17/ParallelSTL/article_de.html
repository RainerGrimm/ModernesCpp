<div class="vorspann">Der GCC-Compiler unterstützt nun mein liebstes C++17-Feature: die parallelen Algorithmen der Standard Template Library (STL). Das habe ich vor ein paar Tagen bemerkt und ich freue mich, einen Beitrag darüber schreiben zu können und meine Begeisterung zu teilen.</div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/4/0/4/1/4/TN_213946160_8b61e47571.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Im Gegensatz zum GCC- und Clang-Compiler unterstützt der Microsoft-Compiler die parallelen Algorithmen seit ihren Anfängen. Das ändert sich nun mit GCC 9. Ab dieser Compiler-Version lassen sich die parallelen Algorithmen verwenden. Bevor ich in meinem nächsten Artikel Performanzzahlen&nbsp; präsentiere, möchte ich über die parallelen Algorithmen der STL berichten und die dafür nötigen Informationen teilen.</div>
<div class="ztitel">Parallele Algorithmen der Standard Template Library</div>
<div class="text">Die Standard Template Library besitzt mehr als 100 Algorithmen zum Suchen, Zählen und Manipulieren von Bereichen und deren Elementen. Mit C++17 erhalten 69 von ihnen neue Überladungen, und neue Algorithmen kommen hinzu. Die überladenen und neuen Algorithmen können mit einer sogenannten Execution Policy aufgerufen werden. Mit einer Execution Policy lässt sich festlegen, ob der Algorithmus sequentiell, parallel oder parallel mit Vektorisierung laufen soll. Um die Execution Policy zu verwenden, braucht es den Header<span class="tx_code"> &lt;execution&gt;</span>.<br></div>
<div class="ztitel_kleiner">Execution Policy<br></div>
<div class="text">Der C++17-Standard definiert drei Execution Policies:</div>
<div class="text"><ul><li><span class="tx_code">std::execution::sequenced_policy</span></li><li><span class="tx_code">std::execution::parallel_policy</span></li><li><span class="tx_code">std::execution::parallel_unsequenced_policy</span></li></ul></div>
<div class="text">Das entsprechende Policy-Tag gibt an, ob ein Programm sequentiell, parallel oder parallel mit Vektorisierung ausgeführt werden soll.<br></div>
<div class="text"><ul><li><span class="tx_code">std::execution::seq</span>: führt das Programm sequentiell aus</li><li><span class="tx_code">std::execution::par</span>: führt das Programm parallel auf mehreren Threads aus</li><li><span class="tx_code">std::execution::par_unseq:</span> führt das Programm parallel auf mehreren Threads aus und erlaubt das verschränkte Ausführen einzelner Schleifen. Diese Policy ist unter dem Namen <a title="Link auf https://en.wikipedia.org/wiki/SIMD" alt="%7B%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSIMD%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSIMD%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22SIMD%22%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D" href="https://en.wikipedia.org/wiki/SIMD" class="">SIMD</a> (Single Instruction Multiple Data) bekannt.</li></ul></div>
<div class="text">Das Verwenden der Execution Policies<span class="tx_code"> std::execution::par</span> oder<span class="tx_code"> std::execution::par_unseq</span> erlaubt es, den Algorithmus parallel oder parallel und vektorisiert auszuführen. Diese Policy ist aber nur ein Hinweis, den der Compiler nicht umsetzen muss.</div>
<div class="text">Der folgende Codeschnipsel wendet alle Execution Policies an.</div>
<div class="pre">std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9};<br><br>// standard sequential sort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>std::sort(v.begin(), v.end());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>// sequential execution<br>std::sort(std::execution::seq, v.begin(), v.end());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>// permitting parallel execution<br>std::sort(std::execution::par, v.begin(), v.end());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>// permitting parallel and vectorized execution<br>std::sort(std::execution::par_unseq, v.begin(), v.end());&nbsp; // (4)</div>
<div class="text">Wie das Beispiel zeigt, lässt sich jederzeit auch weiterhin die klassische Variante von<span class="tx_code"> std::sort</span> (4) verwenden. Außerdem lässt sich in C++17 explizit angeben, ob die sequentielle (2), parallele (3) oder die parallele und vektorisierte (4) Version zum Einsatz kommen soll.</div>
<div class="ztitel_kleiner">Parallele und vektorisierte Ausführung</div>
<div class="text">Ob ein Algorithmus parallel und vektorisiert ausgeführt wird, hängt von vielen Faktoren ab; zum Beispiel davon, ob die CPU und das Betriebssystem SIMD-Instruktionen unterstützen. Außerdem hängt es vom Compiler und der Optimierungsstufe ab, die für die Übersetzung des Codes verwendet wurde.</div>
<div class="text">Das folgende Beispiel zeigt eine einfache Schleife zum Füllen eines Vektors:</div>
<div class="pre">const int SIZE = 8;<br>&nbsp;<br>int vec[] = {1, 2, 3, 4, 5, 6, 7, 8};<br>int res[] = {0, 0, 0, 0, 0, 0, 0, 0, 0};<br>&nbsp;<br>int main( {<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; SIZE; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res[i] = vec[i]+5;<br>&nbsp;&nbsp;&nbsp; }<br>}</div>
<div class="text">Der Ausdruck<span class="tx_code"> res[i] = vec[i] + 5 </span>ist hier die entscheidende Zeile. Dank des Compiler Explorers können wir uns die von clang 3.6 generierten Assembleranweisungen genauer ansehen.</div>
<div class="text"><ul><li><b>Ohne Optimierung</b></li></ul></div>
<div class="text">Hier sind die Assembleranweisungen. Jede Addition wird sequentiell durchgeführt.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/4/0/4/1/4/TN_213946166_d30b2512ff.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><ul><li><b>Mit maximaler Optimierung</b></li></ul></div>
<div class="text">Durch Verwenden der höchsten Optimierungsstufe<span class="tx_code"> -O3</span> kommen spezielle Register wie<span class="tx_code"> xmm0 </span>zum Einsatz, die 128 Bit oder 4<span class="tx_code"> int</span>'s aufnehmen können. Dieses spezielle Register bedeutet, dass die Addition parallel auf vier Elemente des Vektors erfolgt.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/4/0/4/1/4/TN_213946168_12b8d32697.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das Überladen eines Algorithmus ohne Execution Policy und das Überladen eines Algorithmus mit einer sequenziellen Execution Policy <span class="tx_code">std::execution::seq</span> unterscheiden sich in einem Aspekt: Exceptions.<br></div>
<div class="ztitel_kleiner">Exceptions<br></div>
<div class="text">Wenn eine Exception während der Verwendung eines Algorithmus mit einer Execution Policy auftritt, wird <a title="Link auf https://en.cppreference.com/w/cpp/error/terminate" alt="%7B%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Fterminate%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Fterminate%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22std%3A%3Aterminate%22%2C%22ir_link%22%3A1%7D" href="https://en.cppreference.com/w/cpp/error/terminate" class="">std::terminate</a> aufgerufen. <span class="tx_code">std::terminate</span> ruft den installierten <a title="Link auf https://en.cppreference.com/w/cpp/error/terminate_handler" alt="%7B%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Fterminate_handler%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Fterminate_handler%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22std%3A%3Aterminate_handler%22%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" href="https://en.cppreference.com/w/cpp/error/terminate_handler" class="">std::terminate_handler</a> auf. Die Konsequenz ist, dass standardmäßig <a title="Link auf https://en.cppreference.com/w/cpp/utility/program/abort" alt="%7B%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fprogram%2Fabort%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fprogram%2Fabort%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22text%22%3A%22std%3A%3Aabort%22%2C%22ir_link%22%3A1%7D" href="https://en.cppreference.com/w/cpp/utility/program/abort" class="">std::abort</a> aufgerufen wird, was zu einem anormalen Programmabbruch führt. Die Behandlung von Exceptions ist der Unterschied zwischen dem Aufruf eines Algorithmus ohne Execution Policy und einem Algorithmus mit einer sequenziellen <span class="tx_code">std::execution::seq</span> Execution Policy. Der Aufruf des Algorithmus ohne Execution Policy propagiert die Exception. Dadurch lässt sich die Exception abfangen.</div>
<div class="text">Mit C++17 erhielten 69 der STL-Algorithmen neue Überladungen, und neue Algorithmen wurden hinzugefügt.</div>
<div class="ztitel_kleiner">Algorithmen</div>
<div class="text">Hier sind die 69 Algorithmen mit parallelisierten Versionen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/4/0/4/1/4/TN_213946179_64ab9d51d9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel_kleiner">Die neuen Algorithmen</div>
<div class="text">Die neuen Algorithmen in C++17, die für die parallele Ausführung konzipiert sind, befinden sich im <span class="tx_code">std</span> Namensraum und benötigen die Headerdatei <span class="tx_code">&lt;numeric&gt;</span>.<br></div>
<div class="text"><ul><li><span class="tx_code">std::exclusive_scan</span>: Wendet von links ein binäres Callable auf das i-te (exklusive) Element des Bereichs an. Das linke Argument des Callables ist das vorherige Ergebnis. Speichert die Zwischenergebnisse.</li><li><span class="tx_code">std::inclusive_scan</span>: Wendet von links ein binäres Callable bis zum i-ten (inklusiven) Element des Bereichs an. Das linke Argument der Callable ist das vorherige Ergebnis. Speichert die Zwischenergebnisse.</li><li><span class="tx_code">std::transform_exclusive_scan</span>: Wendet zuerst eine unäres Callable auf den Bereich an und wendet anschließend<span class="tx_code"> std::exclusive_scan</span> an.</li><li><span class="tx_code">std::transform_inclusive_scan</span>: Wendet zuerst eine unäres Callable auf den Bereich an und wendet anschließend <span class="tx_code">std::inclusive_scan </span>an <br></li><li><span class="tx_code">std::reduce</span>: Wendet ein binäres Callable auf den Bereich an.</li><li><span class="tx_code">std::transform_reduce:</span> Wendet zuerst ein unäres Callable auf einen oder einen binäres Callable auf zwei Bereiche an und dann<span class="tx_code"> std::reduce </span>auf den resultierenden Bereich.</li></ul></div>
<div class="text">Ein Callable ist eine Entität, die sich aufrufen lässt. Prominente Beispiele für Callables sind Funktion, Funktionsobjekte oder Lambda-Ausdrücke.<br></div>
<div class="text">Zugegebenermaßen ist diese Beschreibung nicht leicht zu verdauen, aber wer<span class="tx_code"> std::accumulate</span> und<span class="tx_code"> std::partial_sum</span> bereits kennt, dem sollten die reduce- und scan-Varianten vertraut sein. <span class="tx_code">std::reduce</span> ist das parallele Pendant zu <span class="tx_code">std::accumulate</span> und scan das parallele Pendant zu partial_sum. Die parallele Ausführung ist der Grund dafür, dass <span class="tx_code">std::reduce</span> einen assoziativen und kommutativen Callable benötigt. Die entsprechende Aussage gilt für die scan-Varianten im Gegensatz zu den partial_sum-Varianten. Wer die vollständigen Details nachlesen möchte, sollte <a title="Link auf https://en.cppreference.com/w/cpp/algorithm" alt="%7B%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22cppreferenc.com%2Falgorithm%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Falgorithm%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Falgorithm%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%7D" href="https://en.cppreference.com/w/cpp/algorithm" class="">cppreferenc.com/algorithm</a> besuchen.</div>
<div class="text">Warum brauchen wir<span class="tx_code"> std::reduce</span> für die parallele Ausführung, wenn wir doch bereits <span class="tx_code">std::accumulate</span> besitzen? Der Grund ist einfach: <span class="tx_code">std::accumulate</span> verarbeitet seine Elemente in einer Reihenfolge, die nicht parallelisiert werden kann.</div>
<div class="text"><ul><li><span class="tx_code">std::accumulate</span><b> versus</b><span class="tx_code"> std::reduce</span></li></ul></div>
<div class="text">Während<span class="tx_code"> std::accumulate</span> seine Elemente von links nach rechts abarbeitet, wendet <span class="tx_code">std::reduce</span> keine definierte Reihenfolge an. Lass mich mit einem kleinen Codeschnipsel beginnen, der<span class="tx_code"> std::accumulate</span> und <span class="tx_code">std::reduce</span> verwendet. Der Callable ist die Lambda-Funktion<span class="tx_code"> [](int a, int b){ return a * b; }.</span></div>
<div class="pre">std::vector&lt;int&gt; v{1, 2, 3, 4};<br><br>std::accumulate(v.begin(), v.end(), 1, [](int a, int b){ return a * b; });<br>std::reduce(std::execution::par, v.begin(), v.end(), 1 , [](int a, int b){ return a * b; });</div>
<div class="text">Die beiden folgenden Diagramme zeigen die unterschiedlichen Verarbeitungsstrategien von <span class="tx_code">std::accumulate</span> und<span class="tx_code"> std::reduce</span>.</div>
<div class="text"><ul><li> <span class="tx_code">std::accumulate</span> beginnt links und wendet nacheinander den binären Operator an.</li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/4/0/4/1/4/TN_213946185_e5fa3c7d48.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><ul><li>Im Gegensatz dazu wendet<span class="tx_code"> std::reduce</span> den binären Operator auf eine nichtdeterministische Weise an.</li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/4/0/4/1/4/TN_213946186_b58240d849.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die Assoziativität des Callables erlaubt es dem<span class="tx_code"> std::reduce</span> Algorithmus, den Reduktionsschritt auf beliebige benachbarte Paare von Elementen zu anzuwenden. Dank der Kommutativität können die Zwischenergebnisse in beliebiger Reihenfolge berechnet werden.</div>
<div class="ztitel">Wie geht's weiter? <br></div>
<div class="text">Wie eingangs versprochen, wird mein nächster Beitrag die parallelen Algorithmen der STL verwenden und liefert Performanzzahlen für den Microsoft- und den GCC-Compiler.</div>
<div class="ztitel">C++ Seminare</div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/4/0/4/1/4/TN_213946192_99ed349a54.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=3>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">In den nächsten Monaten biete ich die folgenden Seminare an. Falls es die Covid-19 Situation zulässt, werde ich die Seminare nach Rücksprache als Präsenzseminare durchführen.</div>
<div class="text"><ul><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/32-c-20" alt="%7B%22text%22%3A%22C%2B%2B20%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F32-c-20%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F32-c-20%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/32-c-20" class="">C++20</a>: 10.08.2021 - 12.08.2021 (Termingarantie, Online)</li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/33-embedded-programmierung-mit-modernem-c20210421085111" alt="%7B%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22text%22%3A%22Embedded%20Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F33-embedded-programmierung-mit-modernem-c20210421085111%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F33-embedded-programmierung-mit-modernem-c20210421085111%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/33-embedded-programmierung-mit-modernem-c20210421085111" class="">Embedded Programmierung mit modernem C++</a>: 21.09.2021 - 23.09.2021</li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/34-clean-code-best-practices-fuer-modernes-c" alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F34-clean-code-best-practices-fuer-modernes-c%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F34-clean-code-best-practices-fuer-modernes-c%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22Clean%20Code%3A%20Best%20Practices%20f%C3%BCr%20modernes%20C%2B%2B%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/34-clean-code-best-practices-fuer-modernes-c" class="">Clean Code: Best Practices für modernes C++</a>: 14.12.2021 - 16.12.2021</li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/35-concurrency-mit-modernem-c" alt="%7B%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22text%22%3A%22Concurrency%20mit%20modernem%20C%2B%2B%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F35-concurrency-mit-modernem-c%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F35-concurrency-mit-modernem-c%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/35-concurrency-mit-modernem-c" class="">Concurrency mit modernem C++</a>: 08.02.2022 - 09.02.2022</li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/36-design-pattern-und-architekturpattern-mit-c" alt="%7B%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F36-design-pattern-und-architekturpattern-mit-c%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F36-design-pattern-und-architekturpattern-mit-c%22%2C%22text%22%3A%22Design%20Pattern%20und%20Architekturpattern%20mit%20C%2B%22%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/36-design-pattern-und-architekturpattern-mit-c" class="">Design Pattern und Architekturpattern mit C+</a>+: 05.04.2022 - 07.04.2022</li></ul></div>