<p>Based on my last poll, "Which mentoring program should I implement next?" I recognized that there is a significant demand for writing about "Design Patterns and Architectural Patterns with C++". Today, I would like to present to you my plan for the future post.</p>
<hr id="system-readmore" />
<p>&nbsp;</p>
<p><img src="https://www.modernescpp.com/images/blog/Patterns/AFirstOverview/patterns.png" alt="patterns" width="650" height="332" style="display: block; margin-left: auto; margin-right: auto;" /></p>
<p>Although I call this introduction post "Design Patterns and Architectural Patterns with C++", the focus of this article series is way broader. I also write about basic terminology, idioms, and concurrency patterns. The image serves two purposes.</p>
<ul>
<li>It gives you the first idea of my plan. This means you know what you can expect.</li>
<li>You may miss one of your topics in my overview. Consequentially, write me an e-mail or, even better, write a guest post.</li>
</ul>
<p>I refine my plan as I go. Here is my first refinement.</p>
<h2>Terminology</h2>
<h3>Design Pattern</h3>
<p>The term design patterns go back to Christoph Alexander, who wrote about architecture and urban planning: "<em>Each pattern is a three part rule, which expresses a relation between a certain context, a problem, and a solution</em>." The classic "<a href="https://en.wikipedia.org/wiki/Design_Patterns">Design Patterns: Elements of Reusable Object-Oriented Software</a>" by Eric Gamma, Richard Helm, Ralph Johnson, and John Vlissides (short GOF) coined this term for software development.</p>
<p>Roughly said, there are three types of patterns: architectural patterns, design patterns, and idioms.</p>
<h3>Types of Patterns</h3>
<p>Architectural patterns describe the fundamental structure of a software system and are often based on design patterns. An idiom is an implementation of an architecture or design pattern in a concrete programming language. This classification of patterns goes back to the second classic that is also a must-read:&nbsp;<a href="http://www.cs.wustl.edu/~schmidt/POSA/">Pattern-Oriented Software Architecture: A System of Patterns"</a> Frank Buschmann, Regine Meunier, Hans Rohnert, Peter Sommerlad, and Michael Stal (short PODSA).</p>
<h3>Anti-Patterns</h3>
<p>We have Patterns and Anti-Patterns. Anti-Patterns are a proven way to shoot yourself into the foot.</p>
<p>These are only the main parts of the terminology I will write about. I also will write about additional aspects of patterns, such as their advantages and disadvantages, history, and structure.</p>
<h2>Design Patterns</h2>
<p>I make it short. The seminal book "<a href="https://en.wikipedia.org/wiki/Design_Patterns">Design Patterns: Elements of Reusable Object-Oriented Software</a>" has 23 patterns. They are classified in two ways:</p>
<ul>
<li>Creational, structural, and behavioral</li>
<li>Class patterns and object patterns</li>
</ul>
<p>The classification of class patterns and object patterns is essentially a classification in inheritance versus composition as a means to build abstractions out of existing abstractions. Not all of the 23 patterns are highly relevant today. Therefore, I will give a concise overview and code examples in modern C++ about the following patterns written in bold letters:</p>
<p><img src="https://www.modernescpp.com/images/blog/Patterns/AFirstOverview/15DesignPattern.jpg" alt="15DesignPattern" width="650" height="282" style="display: block; margin-left: auto; margin-right: auto;" /></p>
<p>Okay, both classics GOF (1994) and POSA (1996) are a bit dated. What does this mean for modern C++? This is precisely the question I tackle in the next series of posts.</p>
<h2>Idioms</h2>
<p>An idiom is an implementation of an architecture or design pattern in a concrete programming language. We have many idioms in C++ such as</p>
<ul>
<li><strong>Copy-and-swap</strong></li>
<li><strong>The rule of zero, fix, or six</strong></li>
<li><strong>Hidden friends</strong></li>
<li><strong>Resource acquisition is initialization (RAII)<br /></strong></li>
<li><strong>Dynamic polymorphism and static polymorphism</strong></li>
<li><strong>Templates (curiously recurring template pattern (CRTP), expression templates, police and traits, tag dispatching, type erasure, ... )</strong></li>
</ul>
<p><strong>This is probably the part of my tour through patterns where I could benefit the most from your comments. Which other idioms do you know in C++?</strong></p>
<h2>Architectural Patterns</h2>
<p>Architectural patterns describe the fundamental structure of a software system and are often based on design patterns. I will present at least the following ones.</p>
<ul>
<li><strong>Pipes-and-Filters</strong>: Decomposes a complex task into a series of elementary tasks that can be composed</li>
<li><strong>Layers</strong>: Split the software system into layers, where each layer has a certain responsibility and provides a service to a higher layer.</li>
<li><strong>Model View Controller (MVC)</strong>: Decompose a (user) interface into the three components model, view, and controller
<ul>
<li>Model: the core of the application that registers views and controls; updates the view and the controller</li>
<li>View: Presents the information to the user; get the data from the model</li>
<li>Controller: Interacts with the user and updates the data</li>
</ul>
</li>
<li><strong>Reactor</strong>: An event-driven application that can accept multiple client requests simultaneously and distribute them to different service providers.</li>
</ul>
<h2>Concurrency Patterns</h2>
<p>A necessary requirement for a data race is a shared mutable state. Consequentially, the synchronization patterns deal with both issues. Here are the synchronization patterns I want to write about:</p>
<ul>
<li>Sharing<br />
<ul>
<li><strong>Copied value</strong>: Copied data cannot be a victim of a data race.</li>
<li><strong>Thread-specific storage</strong>: Enables global state within a thread.</li>
<li><strong>Futures</strong>: Non-modifiable placeholder for a value set by a promise.</li>
</ul>
</li>
<li>Mutation
<ul>
<li><strong>Scoped locking</strong>: RAII applied to locking.</li>
<li><strong>Strategized locking</strong>: Use different locking strategies.</li>
<li><strong>Thread-safe interface</strong>: Extends the critical section to an object.</li>
<li><strong>Guarded suspension</strong>: Combine a lock to be acquired and a precondition to be satisfied before an operation can be executed.</li>
</ul>
</li>
</ul>
<p>Furthermore, we have to think about concurrent architecture.&nbsp;</p>
<ul>
<li><strong>Active object</strong>: Separates the method execution from the method call.</li>
<li><strong>Monitor object</strong>: Synchronizes access to an object so that only one member function can be executed at any moment in time.</li>
</ul>
<h2>What's next?</h2>
<p>In my next post, I start my journey through the "Design Patterns and Architectural Patterns with C++". First, I will write about design patterns' origins and history.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>{loadmoduleid 153}</p>
<p>&nbsp;</p>