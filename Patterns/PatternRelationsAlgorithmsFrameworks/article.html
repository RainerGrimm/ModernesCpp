<p>Patterns don't live in isolation, they are in relation to each other. A relation can mean they are in contrast to each other, connected, build a sequence of patterns, build a repository of patter, or even a pattern language. Let's dive deeper into these relations.</p>
<hr id="system-readmore" />
<p>&nbsp;</p>
<p>&nbsp;<img src="https://www.modernescpp.com/images/blog/Patterns/PatternsRelationsAlgorithmsFrameworks/patternRelationsAlgorithmsFrameworks.png" alt="patternRelationsAlgorithmsFrameworks" width="650" height="330" style="display: block; margin-left: auto; margin-right: auto;" /></p>
<p>The terms design pattern, algorithm, and framework have something in common. Let me differentiate them.</p>
<h2>About Design Patterns, Algorithms, and Frameworks</h2>
<p>Before I write about the difference between these three terms, here are their compact definitions.</p>
<ul>
<li><strong>Design Pattern</strong>: "<em>Each pattern is a three part rule, which expresses a relation between a certain context, a problem, and a solution</em>." (<a href="https://en.wikipedia.org/wiki/Christopher_Alexander">Christopher Alexander</a>)</li>
<li><strong>Algorithm</strong>: "<em>In mathematics and computer science, an algorithm is a finite sequence of rigorous instructions, typically used to solve a class of specific problems or to perform computation.</em>" (<a href="https://en.wikipedia.org/wiki/Algorithm">https://en.wikipedia.org/wiki/Algorithm</a>)</li>
<li><strong>Framework</strong>: "<em>In computer programming, a software framework is an abstraction in which software, providing generic functionality, can be selectively changed by additional user-written code, thus providing application-specific software</em>." (<a href="https://en.wikipedia.org/wiki/Software_framework">https://en.wikipedia.org/wiki/Software_framework</a>)</li>
</ul>
<p>Okay, let's dive deeper.</p>
<h3>Design Patterns versus Algorithms</h3>
<p>Based on the definitions, an algorithm is a finite sequence of steps to solve a specific problem, but a design pattern is a general solution to solve a problem in a specific context.</p>
<h3>Design Patterns Versus Frameworks</h3>
<p>First, a framework is based on the Hollywood Principle ("Don't call us, we call you"). The Hollywood Principe means that the control flow is dictated by the framework but not by the caller when he would use a library. The framework provides a minimal application that can only be extended by the user by overriding specific methods.</p>
<p>Finally, here is the differentiation of design patterns and frameworks from the book "<a href="https://en.wikipedia.org/wiki/Design_Patterns">Design Patterns: Elements of Reusable Object-Oriented Software</a>" (Design Patterns):</p>
<p><em>Because patterns and frameworks have some similarities, people often wonder how or even if they differ. They are different in three major ways:</em></p>
<ol>
<li><em>Design patterns are more abstract than frameworks. Frameworks can be embodied in code, but only examples of patterns can be embodied in code. A strength of frameworks is that they can be written down in programming languages and not only studied but executed and reused directly. In contrast, the design patterns in this book have to be implemented each time they're used. Design patterns also explain the intent, trade-offs, and consequences of a design.</em></li>
<li><em>Design patterns are smaller architectural elements than frameworks. A typical framework contains several design patterns, but the reverse is never true.<br /></em></li>
<li><em> Design patterns are less specialized than frameworks. Frameworks always have a particular application domain. A graphical editor framework might be used in a factory simulation, but it won't be mistaken for a simulation framework. In contrast, the design patterns in this catalog can be used in nearly any kind of application. While more specialized design patterns than ours are certainly possible (say, design patterns for distributed systems or concurrent programming), even these wouldn't dictate an application architecture like a framework would.</em></li>
</ol>
<p>The following more theoretical observations about the relations of patterns are based on the book "<a href="https://www.wiley.com/en-us/Pattern+Oriented+Software+Architecture%2C+Volume+5%2C+On+Patterns+and+Pattern+Languages-p-9780470512579">Pattern-Oriented Software Architecture, Volume 5</a>" (POSA 5). The authors of the book are Frank Buschmann, Kevlin Henny, and Douglas C. Schmidt.</p>
<h2>Pattern Relations</h2>
<p>Patterns are not islands. They are often in relation to each other. Consequentially, there are various ways to describe their relations.&nbsp;</p>
<h3>Pattern Complements</h3>
<p>Patterns typically complement each other. One pattern makes the design process started with another pattern more complete. This process also includes patterns that solve a similar design challenge.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Strategy_pattern">strategy pattern</a> and the<a href="https://en.wikipedia.org/wiki/Template_method_pattern"> template method</a> are patterns complements. Both are behavioral patterns from the classic "<a href="https://en.wikipedia.org/wiki/Design_Patterns">Design Patterns</a>" book. They serve a similar purpose: variations of algorithms should be handled in a uniform way. The main difference is that the strategy pattern provides its implementation on the object level and uses object composition and delegation; the template method provides its implementation on the class level based on virtuality.</p>
<h3>Pattern Compounds</h3>
<p>Often, compound patterns build a new pattern.</p>
<p>A typical example of a pattern compound is the architectural pattern Model-View-Controler (MVC). The MVC in <a href="https://en.wikipedia.org/wiki/Pattern-Oriented_Software_Architecture"><span id="productTitle" class="a-size-extra-large">POSA 1</span></a><span id="productTitle" class="a-size-extra-large"> </span>divides the program logic of a user interface into the separate components model, view, and controller. The model manages the data and rules of the application. The view represents the data, and the controller interacts with the user.</p>
<p>Here are a few patterns from the "<a href="https://en.wikipedia.org/wiki/Design_Patterns">Design Patterns</a>" book used in the MVC.</p>
<ul>
<li>The view observes (<a href="https://en.wikipedia.org/wiki/Observer_pattern">observer pattern</a>) the model for changes.</li>
<li>The controller is a strategy for handling user input (<a href="https://en.wikipedia.org/wiki/Strategy_pattern">strategy pattern</a>).</li>
<li>Views can have subviews and are, therefore, components of the <a href="https://en.wikipedia.org/wiki/Composite_pattern">composite pattern</a>.</li>
</ul>
<h3>Pattern Sequences</h3>
<p>A pattern sequence is a typical sequence of patterns that can be applied in another design challenge.</p>
<p>Imagine you want to iterate through a tree and perform various operations on leaf nodes, such as <code>show</code> or <code>count</code>.</p>
<p>First, you need an iterator through this tree (<a href="https://en.wikipedia.org/wiki/Iterator_pattern">iterator pattern</a>).&nbsp;Of course, you have to distinguish between nodes having children or not. Nodes having children delegates the operations <code></code>just to their children. Nodes having no children display themselves (<a href="https://en.wikipedia.org/wiki/Composite_pattern">composite pattern</a>). The<a href="https://en.wikipedia.org/wiki/Visitor_pattern"> visitor pattern</a> comes into play to support various operations on the tree. All three patterns are often used in sequence.</p>
<h3>Pattern Collections</h3>
<p>A pattern collection is an organized repository of patterns.</p>
<p>In the end, there are thousands of patterns, and the need arises to collect and find them if necessary.</p>
<p>There are various ways to organize patterns. For example, you can collect them by their level (architectural pattern, design pattern, idioms), by their domain (avionic, finance, healthcare, .. ), or by their intent: The Design Patterns book and the POSA books are ordered by intent. For example, the following paragraph about pattern languages shows the ordering of <a href="https://www.wiley.com/en-us/Pattern+Oriented+Software+Architecture,+Volume+4,+A+Pattern+Language+for+Distributed+Computing-p-9780470059029">POSA 4</a>.<span id="productTitle" class="a-size-extra-large"> </span></p>
<h3>Pattern Languages</h3>
<p>A pattern language describes a complete set of patterns for a specific domain. Its intention is to solve any design challenge in this specific domain. The book <span id="productTitle" class="a-size-extra-large"><a href="https://www.wiley.com/en-us/Pattern+Oriented+Software+Architecture,+Volume+4,+A+Pattern+Language+for+Distributed+Computing-p-9780470059029">Pattern-Oriented Software Architecture, Volume 4</a>: A Pattern Language for Distributed Programming by Frank Buschmann, Kevlin Henney, and Douglas C. Schmidt presents such a pattern language. To make it short, the book presents more than 120 patterns grouped in the following way:</span></p>
<ul>
<li>From Mud to Structure</li>
<li>Distributed Infrastructure</li>
<li>Event Demultiplexing and Dispatching</li>
<li>Interface Partitioning</li>
<li>Component Partitioning</li>
<li>Application Control</li>
<li>Concurrency</li>
<li>Synchronization</li>
<li>Object Interaction</li>
<li>Adaption and Extension</li>
<li>Modal Behavior</li>
<li>Resource Management</li>
<li>Database Access<br /><br /></li>
</ul>
<p>I will write about many of these patterns in future posts.</p>
<h2>What's next?</h2>
<p>An anti-pattern is a proven way to shoot yourself into your foot. The term anti-pattern was coined by<a href="https://en.wikipedia.org/wiki/Andrew_Koenig_(programmer)"> Andrew Koenig</a> and is the topic of my next post about patterns.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>{loadmoduleid 153}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>