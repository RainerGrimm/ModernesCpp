<div class="vorspann">Mit diesem Beitrag endet die Miniserie zu dem Dining Philiosophers Problem von Andre Adrian. Heute wendet der Autor mächtige Locks und Semaphoren an.</div><div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/6/2/2/2/6/TN_224273606_797a0ccb7a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="einrueckung"><span class="tx_smaller">By Benjamin D. Esham / Wikimedia Commons, CC BY-SA 3.0, <a title="Link auf https://commons.wikimedia.org/w/index.php?curid=56559" alt="%7B%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fcommons.wikimedia.org%2Fw%2Findex.php%3Fcurid%3D56559%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fcommons.wikimedia.org%2Fw%2Findex.php%3Fcurid%3D56559%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22text%22%3A%22https%3A%2F%2Fcommons.wikimedia.org%2Fw%2Findex.php%3Fcurid%3D56559%22%7D" href="https://commons.wikimedia.org/w/index.php?curid=56559">https://commons.wikimedia.org/w/index.php?curid=56559</a> </span></div><div class="text">&nbsp;Hier eine kurze Erinnerung, wo die Analyse des Autors beim letzten Mal endete.<br></div><div class="ztitel"><span class="tx_code">std::lock_guard</span> mit synchronisierter Ausgabe und Resourcenhierarchie<br></div><div class="pre">// dp_10.cpp<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br>#include &lt;chrono&gt;<br>#include &lt;mutex&gt;<br><br>int myrand(int min, int max) {<br>&nbsp; return rand()%(max-min)+min;<br>}<br><br>std::mutex mo;<br><br>void phil(int ph, std::mutex&amp; ma, std::mutex&amp; mb) {<br>&nbsp; while(true) {<br>&nbsp;&nbsp;&nbsp; int duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;ph&lt;&lt;" thinks "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br><br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; ga(ma);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got ma\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(1000));<br><br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; gb(mb);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got mb\n";<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t\t\t"&lt;&lt;ph&lt;&lt;" eats "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br>&nbsp; }<br>}<br><br>int main() {<br>&nbsp; std::cout&lt;&lt;"dp_10\n";<br>&nbsp; srand(time(nullptr));<br><br>&nbsp; std::mutex m1, m2, m3, m4;<br><br>&nbsp; std::thread t1([&amp;] {phil(1, m1, m2);});<br>&nbsp; std::thread t2([&amp;] {phil(2, m2, m3);});<br>&nbsp; std::thread t3([&amp;] {phil(3, m3, m4);});<br>&nbsp; std::thread t4([&amp;] {phil(4, m1, m4);});<br><br>&nbsp; t1.join();<br>&nbsp; t2.join();<br>&nbsp; t3.join();<br>&nbsp; t4.join();<br>}<br></div><div class="text">Der globale Mutex <span class="tx_code">mo</span> kontrolliert die Ressource für die Konsolenausgabe. Jede<span class="tx_code"> cout</span>-Anweisung befindet sich in ihrem Block und der <span class="tx_code">lock_guard() </span>sorgt dafür, dass die Konsolenausgabe nicht verstümmelt wird.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/6/2/2/2/6/TN_224273614_392b2a1d1d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="ztitel"><span class="tx_code">std::unique_lock</span> mit verzögertem Locken<br></div><div class="text">C++ bietet neben dem Ressourcenhierarchie-Ansatz weitere Umsetzungen an. Im Moment haben wir zwei separate Operationen, um die beiden Ressourcen zu erwerben. Wenn es nur eine Operation gibt, um die beiden Ressourcen zu beschaffen, besteht keine Deadlock-Gefahr mehr. Die erste "alles oder nichts"-Lösung verwendet <span class="tx_code">unique_lock()</span> mit <span class="tx_code">defer_lock</span>. Der eigentliche Ressourcenerwerb erfolgt in der <span class="tx_code">lock()</span>-Anweisung. Siehe <span class="tx_code">dp_12.cpp</span>: </div><div class="pre">int myrand(int min, int max) {<br>&nbsp; static std::mt19937 rnd(std::time(nullptr));<br>&nbsp; return std::uniform_int_distribution&lt;&gt;(min,max)(rnd);<br>}<br><br>std::mutex mo;<br><br>void phil(int ph, std::mutex&amp; ma, std::mutex&amp; mb) {<br>&nbsp; while(true) {<br>&nbsp;&nbsp;&nbsp; int duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;ph&lt;&lt;" thinks "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br><br>&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; ga(ma, std::defer_lock);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got ma\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(1000));<br><br>&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; gb(mb,std::defer_lock);<br>&nbsp;&nbsp;&nbsp; std::lock(ga, gb);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got mb\n";<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t\t\t"&lt;&lt;ph&lt;&lt;" eats "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br>&nbsp; }<br>}<br></div><div class="text">Bis jetzt haben wir die Zufallszahlen mit der Funktion <span class="tx_code">rand()</span> erzeugt. Diese Funktion ist nicht reentrant, also nicht für Threads geeignet. Das ist bei Programmstart gut zu sehen. Die ersten vier Zufallszahlen nach "thinks" sind gleich. Mit einer geänderten <span class="tx_code">myrand() </span>Funktion wird dieser Fehler behoben. Das static Funktionsobjekt rnd ist ein Mersenne-Twister-Zufallszahlengenerator. Durch static vermeiden wir ein globales Funktionsobjekt. Die Skalierung auf einen Wert zwischen <span class="tx_code">min</span> und <span class="tx_code">max</span> erfolgt nun mit <span class="tx_code">uniform_int_distribution&lt;&gt;</span>. Die Bibliothek zu benutzen ist besser als eigenen Quelltext zu schreiben.</div><div class="text">Wer hätte gedacht das so einfache Sachen wie <span class="tx_code">cout</span> Ausgabe und Zufallszahl bei Thread Programmen so schwierig sind?</div><div class="ztitel"><span class="tx_code">std::scoped_lock</span> <br></div><div class="text">Die zweite "alles oder nichts"-Lösung ist noch einfacher: Die C++17-Funktion<span class="tx_code"> scoped_lock() </span>ermöglicht den Erwerb mehrerer Ressourcen. Diese leistungsstarke Funktion bietet uns die kürzeste Lösung für das speidende Philosophen Problem. Siehe<span class="tx_code"> dp_13.cpp</span>: </div><div class="pre">void phil(int ph, std::mutex&amp; ma, std::mutex&amp; mb) {<br>&nbsp; while(true) {<br>&nbsp;&nbsp;&nbsp; int duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;ph&lt;&lt;" thinks "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br><br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(1000));<br>&nbsp;&nbsp;&nbsp; std::scoped_lock(ma, mb);<br><br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got ma, mb\n";<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t\t\t"&lt;&lt;ph&lt;&lt;" eats "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br>&nbsp; }<br>}</div><div class="text">Es gibt mehrere Lösungen. Die ursprüngliche Dijkstra-Umsetzung verwendet einen Mutex, einen Semaphor pro Philosoph und eine Zustandsvariable pro Philosoph. [ref Dijkstra; 1971; EWD310 Hierarchical Ordering of Sequential Processes;<a title="Link auf https://www.cs.utexas.edu/users/EWD/transcriptions/EWD03xx/EWD310.html" alt="%7B%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.cs.utexas.edu%2Fusers%2FEWD%2Ftranscriptions%2FEWD03xx%2FEWD310.html%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22%20https%3A%2F%2Fwww.cs.utexas.edu%2Fusers%2FEWD%2Ftranscriptions%2FEWD03xx%2FEWD310.html%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.cs.utexas.edu%2Fusers%2FEWD%2Ftranscriptions%2FEWD03xx%2FEWD310.html%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%7D" href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD03xx/EWD310.html"> https://www.cs.utexas.edu/users/EWD/transcriptions/EWD03xx/EWD310.html</a>]<br>Andrew S. Tanenbaum lieferte eine Lösung in C. [ref Tanenbaum; 1990; Betriebssysteme Entwurf und Realisierung, Kapitel 2.3.1 Das Problem der speisenden Philosophen]</div><div class="ztitel">Das ursprüngliche Dining Philosphers Problem mit Semaphoren<br></div><div class="text">Die Datei <span class="tx_code">dp_14.cpp</span> ist die in C++20 umgeschriebene Tanenbaum-Lösung: </div><div class="pre">// dp_14.cpp<br>#include &lt;iostream&gt;<br>#include &lt;chrono&gt;<br>#include &lt;thread&gt;<br>#include &lt;mutex&gt;<br>#include &lt;semaphore&gt;<br>#include &lt;random&gt;<br><br>int myrand(int min, int max) {<br>&nbsp; static std::mt19937 rnd(std::time(nullptr));<br>&nbsp; return std::uniform_int_distribution&lt;&gt;(min,max)(rnd);<br>}<br><br>enum {<br>&nbsp; N=5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number of philosophers<br>&nbsp; THINKING=0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // philosopher is thinking<br>&nbsp; HUNGRY=1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // philosopher is trying to get forks<br>&nbsp; EATING=2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // philosopher is eating<br>};<br><br>#define LEFT (i+N-1)%N&nbsp; // number of i's left neighbor<br>#define RIGHT (i+1)%N&nbsp;&nbsp; // number of i's right neighbor<br><br>int state[N];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // array to keep track of everyone's state<br>std::mutex mutex_;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // mutual exclusion for critical regions<br>std::binary_semaphore s[N]{0, 0, 0, 0, 0};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // one semaphore per philosopher<br><br>void test(int i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // i: philosopher number, from 0 to N-1<br>{<br>&nbsp; if (state[i] == HUNGRY<br>&nbsp;&nbsp; &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING) {<br>&nbsp;&nbsp;&nbsp; state[i] = EATING;<br>&nbsp;&nbsp;&nbsp; s[i].release();<br>&nbsp; }<br>}<br><br>void take_forks(int i)&nbsp; // i: philosopher number, from 0 to N-1<br>{<br>&nbsp; mutex_.lock();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // enter critical region<br>&nbsp; state[i] = HUNGRY;&nbsp;&nbsp;&nbsp; // record fact that philosopher i is hungry<br>&nbsp; test(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // try to acquire 2 forks<br>&nbsp; mutex_.unlock();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exit critical region<br>&nbsp; s[i].acquire();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // block if forks were not acquired<br>}<br><br>void put_forks(int i)&nbsp;&nbsp; // i: philosopher number, from 0 to N-1<br>{<br>&nbsp; mutex_.lock();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // enter critical region<br>&nbsp; state[i] = THINKING;&nbsp; // philosopher has finished eating<br>&nbsp; test(LEFT);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // see if left neighbor can now eat<br>&nbsp; test(RIGHT);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // see if right neighbor can now eat<br>&nbsp; mutex_.unlock();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exit critical region<br>}<br><br>std::mutex mo;<br><br>void think(int i) {<br>&nbsp; int duration = myrand(1000, 2000);<br>&nbsp; {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::cout&lt;&lt;i&lt;&lt;" thinks "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp; }<br>&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br>}<br><br>void eat(int i) {<br>&nbsp; int duration = myrand(1000, 2000);<br>&nbsp; {<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::cout&lt;&lt;"\t\t\t\t"&lt;&lt;i&lt;&lt;" eats "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp; }<br>&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br>}<br><br>void philosopher(int i) // i: philosopher number, from 0 to N-1<br>{<br>&nbsp; while (true) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // repeat forever<br>&nbsp;&nbsp;&nbsp; think(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // philosopher is thinking<br>&nbsp;&nbsp;&nbsp; take_forks(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // acquire two forks or block<br>&nbsp;&nbsp;&nbsp; eat(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // yum-yum, spaghetti<br>&nbsp;&nbsp;&nbsp; put_forks(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // put both forks back on table<br>&nbsp; }<br>}<br><br>int main() {<br>&nbsp; std::cout&lt;&lt;"dp_14\n";<br><br>&nbsp; std::thread t0([&amp;] {philosopher(0);});<br>&nbsp; std::thread t1([&amp;] {philosopher(1);});<br>&nbsp; std::thread t2([&amp;] {philosopher(2);});<br>&nbsp; std::thread t3([&amp;] {philosopher(3);});<br>&nbsp; std::thread t4([&amp;] {philosopher(4);});<br>&nbsp; t0.join();<br>&nbsp; t1.join();<br>&nbsp; t2.join();<br>&nbsp; t3.join();<br>&nbsp; t4.join();<br>}</div><div class="text">Übrigens ist der Semaphor das älteste Primitiv für die Thread-Synchronisation. Dijkstra definierte die Operationen <span class="tx_code">P()</span> und<span class="tx_code"> V()</span> im Jahr 1965: "Es ist die P-Operation, die die potentielle Verzögerung darstellt, d.h. wenn ein Prozess eine P-Operation an einem Semaphor initiiert, der in diesem Moment den Wert = 0 hat, kann diese P-Operation in diesem Fall nicht abgeschlossen werden, bis ein anderer Prozess eine V-Operation an demselben Semaphor durchgeführt hat und ihm den Wert '1' gegeben hat." Heute heißt <span class="tx_code">P() </span><span class="tx_code">release()</span> und <span class="tx_code">V()</span> heißt <span class="tx_code">acquire()</span>. [ref Dijkstra; 1965; EWD123 Cooperating sequential processes; <a title="Link auf https://www.cs.utexas.edu/users/EWD/transcriptions/EWD01xx/EWD123.html" alt="%7B%22alias%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22text%22%3A%22https%3A%2F%2Fwww.cs.utexas.edu%2Fusers%2FEWD%2Ftranscriptions%2FEWD01xx%2FEWD123.html%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.cs.utexas.edu%2Fusers%2FEWD%2Ftranscriptions%2FEWD01xx%2FEWD123.html%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.cs.utexas.edu%2Fusers%2FEWD%2Ftranscriptions%2FEWD01xx%2FEWD123.html%22%2C%22anchor%22%3A%22%22%7D" href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD01xx/EWD123.html">https://www.cs.utexas.edu/users/EWD/transcriptions/EWD01xx/EWD123.html</a>]</div><div class="ztitel">Ein C++20-kompatible Semaphore<br></div><div class="text">Ein C++20-Compiler wie LLVM (clang++) Version 13.0.0 oder neuer ist erforderlich, um <span class="tx_code">dp14.cpp</span> zu kompilieren. Alternativ kann man <span class="tx_code">#include &lt;semaphore&gt;</span> in <span class="tx_code">#include "semaphore.h"</span> ändern und die folgende Header-Datei benutzen. In dem Fall genügt ein C++11-Compiler.</div><div class="pre">// semaphore.h<br>#include &lt;mutex&gt;<br>#include &lt;condition_variable&gt;<br>#include &lt;limits&gt;<br><br>namespace std {<br>&nbsp; template &lt;std::ptrdiff_t least_max_value <br>&nbsp;&nbsp; = std::numeric_limits&lt;std::ptrdiff_t&gt;::max()&gt;<br>&nbsp; class counting_semaphore {<br>&nbsp; public:<br>&nbsp;&nbsp;&nbsp; counting_semaphore(std::ptrdiff_t desired) : counter(desired) {}<br><br>&nbsp;&nbsp;&nbsp; counting_semaphore(const counting_semaphore&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; counting_semaphore&amp; operator=(const counting_semaphore&amp;) = delete;<br><br>&nbsp;&nbsp;&nbsp; inline void release(ptrdiff_t update = 1) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; lock(mutex_);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; counter += update;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cv.notify_one();<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; inline void acquire() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; lock(mutex_);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (0 == counter) cv.wait(lock);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --counter;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp; private:<br>&nbsp;&nbsp;&nbsp; ptrdiff_t counter;<br>&nbsp;&nbsp;&nbsp; std::mutex mutex_;<br>&nbsp;&nbsp;&nbsp; std::condition_variable cv;<br>&nbsp; };<br><br>&nbsp; using binary_semaphore = counting_semaphore&lt;1&gt;;<br>}</div><div class="text">Das C++-Semaphor besteht aus einem Zähler, einem Mutex und einer Bedingungsvariablen. Nach 14 Programmversionen verlassen wir dieses Thema. Die Programmversionen 1 bis 6 haben Probleme. Ich habe sie vorgestellt, um schlechte Multi-Thread-Programmierung zu zeigen. Bitte nicht kopieren!! </div><div class="ztitel">Wie geht's weiter? </div><div class="text"><span class="tx_code">constexpr</span>-Funktionen haben viel mit Template gemeinsam und werden mit C++20 noch mächtiger. Ich werde sie in meinem nächsten Artikel genauer vorstellen.<br></div>