<div class="vorspann">Zur Weihnachtszeit hatte ich einige nette Gespräche mit Andre Adrian. Er hat das klassische Dining Philosophers Problem auf verschiedene Weise mit modernem C++ gelöst. Ich habe ihn leicht dazu gewinnen können, einen Artikel über dieses klassische Synchronisationsproblem zu schreiben. Nun&nbsp; freue ich mich, diesen Artikel in drei aufeinanderfolgenden Beiträgen zu veröffentlichen.</div><div class="ztitel">Das Dining Philosophers Problem von Andre Adrian</div><div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/5/2/9/7/6/TN_223508206_dce05e76e8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="einrueckung">B<span class="tx_smaller">y Benjamin D. Esham / Wikimedia Commons, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=56559</span><br></div><div class="text">Das Problem der speisenden Philosophen wurde von Edsger W. Dijkstra beschrieben: "Fünf Philosophen, die von 0 bis 4 nummeriert sind, leben in einem Haus, in dem der Tisch für sie gedeckt ist, wobei jeder Philosoph seinen eigenen Platz am Tisch hat. Ihr einziges Problem - neben denen der Philosophie - ist, dass das Gericht eine schwierige Art von Spaghetti ist, die mit zwei Gabeln gegessen werden müssen. Es gibt zwei Gabeln neben jedem Teller, sodass das kein Problem darstellt. Folglich dürfen jedoch keine zwei Nachbarn gleichzeitig essen." [ref Dijkstra; 1971; EWD310 Hierarchical Ordering of Sequential Processes; <a title="Link auf https://www.cs.utexas.edu/users/EWD/transcriptions/EWD03xx/EWD310.html%5D" alt="%7B%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.cs.utexas.edu%2Fusers%2FEWD%2Ftranscriptions%2FEWD03xx%2FEWD310.html%255D%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22https%3A%2F%2Fwww.cs.utexas.edu%2Fusers%2FEWD%2Ftranscriptions%2FEWD03xx%2FEWD310.html%5D%22%2C%22href%22%3A%22https%3A%2F%2Fwww.cs.utexas.edu%2Fusers%2FEWD%2Ftranscriptions%2FEWD03xx%2FEWD310.html%255D%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%7D" href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD03xx/EWD310.html%5D">https://www.cs.utexas.edu/users/EWD/transcriptions/EWD03xx/EWD310.html]</a> </div><div class="text">Wir verwenden folgende geänderte Problembeschreibung: 4 Philosophen leben ein einfaches Leben. Jeder Philosoph führt die gleiche Routine durch: Er denkt für eine zufällige Dauer, holt sich seine erste Gabel, holt sich seine zweite Gabel, isst für eine zufällige Dauer, legt die Gabeln hin und beginnt wieder zu denken. Um das Problem interessant zu machen, haben die 4 Philosophen nur 4 Gabeln. Philosoph Nummer 1 muss zum Essen Gabeln Nummer 1 und 2 nehmen. Philosoph 2 braucht Gabeln 2 und 3, und so weiter bis Philosoph 4, der Gabeln 4 und 1 zum Essen braucht. Nach dem Essen legt der Philosoph die Gabeln wieder auf den Tisch.</div><div class="ztitel_kleiner">Verwendung mehrerer Ressourcen<br></div><div class="text">Auf dem Weg von der Problembeschreibung zur Programmierung übersetzen wir Philosophen in Threads und Gabeln in Ressourcen. In unserem ersten Programm - <span class="tx_code">dp_1.cpp</span> - erstellen wir 4 "Philosophen"-Threads und 4 "Gabeln"-Ressourcen als Ganzzahlen. </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/5/2/9/7/6/TN_223508213_4c5ec9b95c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Die Funktion <span class="tx_code">main()</span> erstellt Zufallszahlen in Zeile 42. Wir setzen den Seed-Wert des Zufallszahlengenerators auf die Anzahl der Sekunden seit dem 1. Januar 1970. Wir definieren unsere Gabel-Ressourcen in Zeile 44. Dann starten wir vier Threads beginnend in Zeile 46. Um eine vorzeitige Thread-Beendigung zu vermeiden, rufen wir ab Zeile 51<span class="tx_code"> join()</span> auf.</div><div class="text">Die Thread-Funktion<span class="tx_code"> phil()</span> hat eine Endlosschleife. Die <span class="tx_code">while(true)</span>-Anweisung ist immer wahr, daher wird der Thread nie beendet.<br> </div><div class="text">Die Problembeschreibung sagt "er denkt für eine zufällige Dauer". Zunächst berechnen wir mit der Funktion <span class="tx_code">myrand()</span> eine zufällige Dauer, siehe Zeile 20 und Zeile 6. Die Funktion <span class="tx_code">myrand()</span> liefert einen pseudozufälligen Rückgabewert im Bereich von [min, max). Für die Programmverfolgung protokollieren wir die Nummer des Philosophen, seinen aktuellen Zustand von "<span class="tx_code">thinks</span>" und die Dauer auf der Konsole. Die <span class="tx_code">sleep_for()</span>-Anweisung lässt den Scheduler den Thread für die Dauer in den Wartezustand versetzen. In einem "echten" Programm verbraucht der Quellcode der Anwendung Zeit anstelle von <span class="tx_code">sleep_for()</span>. Nachdem die Denkzeit des Philosophen vorbei ist, bekommt er "seine erste Gabel". Siehe Zeile 24. Wir verwenden eine Funktion<span class="tx_code"> lock()</span>, um die "Gabel bekommen"-Sache durchzuführen. Im Moment ist die Funktion <span class="tx_code">lock() </span>sehr einfach, weil wir es nicht besser wissen. Wir setzen einfach die Gabel-Ressource auf den Wert 1 (Zeile 10). Nachdem der Philosophen-Thread seine erste Gabel erhalten hat, verkündet er stolz den neuen Zustand mit einer "<span class="tx_code">got ma</span>"-Konsolenausgabe. Jetzt bekommt der Thread "seine zweite Gabel". Siehe Zeile 28. Die entsprechende Konsolenausgabe ist "<span class="tx_code">got mb</span>".<br></div><div class="text">Der nächste Zustand ist "<span class="tx_code">eats</span>". Wieder bestimmen wir die Dauer, erzeugen eine Konsolenausgabe und beschäftigen den Thread mit <span class="tx_code">sleep_for()</span>. Siehe Zeile 31. Nach dem Zustand "<span class="tx_code">eats</span>" legt der Philosoph seine Gabeln hin. Siehe Zeilen 35 und 14. Die Funktion <span class="tx_code">unlock()</span> ist wieder ganz einfach und setzt die Ressource auf 0 zurück.</div><div class="text">Das Programm muss ohne Compiler-Optimierung kompiliert werden. Den Grund werden wir später sehen. Die Konsolenausgabe unseres Programms sieht vielversprechend aus:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/5/2/9/7/6/TN_223508219_02f60ca837.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Haben wir das Problem der Speisephilosophen schon gelöst? Nun, die Programmausgabe ist nicht detailliert genug, um diese Frage zu beantworten. </div><div class="ztitel">Verwendung mehrerer Ressourcen mit Logging<br></div><div class="text">Wir sollten etwas mehr Protokollierung hinzufügen. Im Moment prüft die Funktion<span class="tx_code"> lock()</span> nicht, ob die Gabel verfügbar ist, bevor die Ressource verwendet wird. Die verbesserte Version von<span class="tx_code"> lock() </span>im Programm <span class="tx_code">dp_2.cpp</span> ist: </div><div class="pre">void lock(int&amp; m) {<br>&nbsp; if (m) {<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t\t\t\t\tERROR lock\n";<br>&nbsp; }<br>&nbsp; m=1;<br>}</div><div class="text">Programmversion 2 erzeugt folgende Ausgabe:<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/5/2/9/7/6/TN_223508222_353c41c1b6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Wir sehen die Konsolenausgabe "<span class="tx_code">ERROR lock</span>". Diese Ausgabe sagt uns, dass zwei Philosophen gleichzeitig dieselbe Ressource verwenden. Was können wir tun? </div><div class="ztitel_kleiner">Fehlerhaftes Busy Waiting ohne Ressourcehierarchien<br></div><div class="text">Wir können die if-Anweisung in <span class="tx_code">lock()</span> in eine<span class="tx_code"> while</span>-Anweisung ändern. Diese <span class="tx_code">while</span>-Anweisung erzeugt einen Spinlock. Ein Spinlock ist ein schickes Wort für busy waiting (geschäftiges Warten). Während die Gabel-Ressource verwendet wird, ist der Thread damit beschäftigt, auf eine Änderung von Zustand "in Benutzung" auf den Zustand "frei" zu warten. In diesem Moment setzen wir die Gabel-Ressource wieder auf den Zustand Status "in Benutzung". Im Programm <span class="tx_code">dp_3.cpp</span> haben wir: </div><div class="pre">void lock(int&amp; m) {<br>&nbsp; while (m)<br>&nbsp;&nbsp;&nbsp; ; // busy waiting<br>&nbsp; m=1;<br>}</div><div class="text">Allerdings ist diese kleine Änderung immer noch keine KORREKTE Lösung für das Problem der Speisephilosophen. Wir haben keine falsche Ressourcennutzung mehr, aber wir haben ein anderes Problem. Siehe Ausgabe der Programmversion 3:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/5/2/9/7/6/TN_223508226_8a76766832.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Jeder Philosophen-Thread nimmt seine erste Gabel-Ressource und kann dann die zweite Gabel nicht nehmen. Was können wir tun? Andrew S. Tanenbaum schrieb: "Ein anderer Weg zur Vermeidung der geschlossenen Kette besteht in der globalen Nummerierung. </div><div class="text">Die Regel: Prozesse können Betriebsmittel anfordern, wann immer sie es wünschen, aber alle Anforderungen müssen gemäß der numerischen Anordnung erfolgen." [ref Tanenbaum; 1990; Betriebssysteme Entwurf und Realisierung, Kapitel 3.3.5 Verhinderung von Verklemmungen]</div><div class="ztitel_kleiner">Falsches Busy Waiting mit Ressourcehierarchien</div><div class="text">Diese Lösung wird als Ressourcenhierarchie (resource hierarchy) oder Halbordnung (partial ordering) bezeichnet. Für das Problem der speisenden Philosophen ist Halbordnung einfach. Die erste genommene Gabel muss diejenige mit der niedrigeren Nummer sein. Bei den Philosophen 1 bis 3 werden die Ressourcen in der richtigen Reihenfolge genommen. Nur Philosophenthread 4 benötigt eine Änderung für eine korrekte Halbordnung. Holen Sie zuerst die Gabel-Ressource 1, dann die Gabel-Ressource 4. Siehe Zeile 51 in der Datei <span class="tx_code">dp_4.cpp</span>: </div><div class="pre">int main() {<br>&nbsp; std::cout&lt;&lt;"dp_4\n";<br>&nbsp; srand(time(nullptr));<br><br>&nbsp; int m1{0}, m2{0}, m3{0}, m4{0};<br><br>&nbsp; std::thread t1([&amp;] {phil(1, m1, m2);});<br>&nbsp; std::thread t2([&amp;] {phil(2, m2, m3);});<br>&nbsp; std::thread t3([&amp;] {phil(3, m3, m4);});<br>&nbsp; std::thread t4([&amp;] {phil(4, m1, m4);});<br><br>&nbsp; t1.join();<br>&nbsp; t2.join();<br>&nbsp; t3.join();<br>&nbsp; t4.join();<br>}</div><div class="text">Die Ausgabe der Programmversion 4 sieht gut aus:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/5/2/9/7/6/TN_223508232_1b9ffc00f3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Jetzt gibt es keine falsche Ressourcennutzung mehr und auch keine Verklemmung (deadlock). Wir werden mutig und setzen die Compiler-Optimierung ein. Wir wollen ein gutes Programm haben, das schnell ausgeführt wird! Dies ist die Ausgabe der Programmversion 4 mit Compiler-Optimierung:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/5/2/9/7/6/TN_223508241_2ff56bfe19.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Es ist immer der gleiche Philosophen-Thread, der isst. Kann die Einstellung der Compileroptimierung das Verhalten eines Programms verändern? Ja, es ist möglich: Die Philosopher-Threads lesen den Wert der Gabel-Ressource aus dem Speicher. Die Compiler-Optimierung optimiert einige dieser Speicher-Lese-Zugriffe weg. Alles hat seinen Preis!</div><div class="ztitel_kleiner">Immer noch falsches Busy Waiting mit Ressourcehierarchien</div><div class="text">Die Programmiersprache C++ hat das atomic Template, um einen atomaren Typ zu definieren. Wenn ein Thread in ein atomares Objekt schreibt, während ein anderer Thread daraus liest, ist das Verhalten klar definiert. In der Datei<span class="tx_code"> dp_5.cpp</span> verwenden wir <span class="tx_code">atomic&lt;int&gt;</span> für die Gabel-Ressourcen. Siehe Zeilen 11, 17, 21 und 47. Wir fügen <span class="tx_code">#include &lt;atomic&gt;</span> in Zeile 5 ein: </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/5/2/9/7/6/TN_223508244_2ea14f6205.png" title="<ir_inline itemname=bilder_mvp_bild_var2:8 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Die Ausgabe der Programmversion 5 ist:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/5/2/9/7/6/TN_223508250_4e81ed10af.png" title="<ir_inline itemname=bilder_mvp_bild_var2:9 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Diese Ausgabe sieht toll aus. Jetzt sind wir an die Grenzen unserer Testmethodik gestoßen. Es gibt immer noch eine <i>winzige Chance für Fehlverhalten</i>. Die beiden Operationen "ist eine Ressource verfügbar" und "Ressource als in Gebrauch markieren" in der Funktion<span class="tx_code"> lock()</span> sind atomar, aber sie sind immer noch zwei Operationen. Zwischen diesen beiden Operationen kann der Scheduler einen Threadwechsel platzieren. Und dieser Threadwechsel zu diesem ungünstigsten Zeitpunkt kann sehr schwer zu findende Fehler im Programm erzeugen.<br></div><div class="ztitel">Wie geht's weiter? <br></div><div class="text">Die Fortsetzung des Dining Philosophers Problems im nächsten Artikel löst diese w<i>inzige Chance für Fehlverhalten </i>auf. Bisher war noch kein Programm korrekt.<br></div><div class="text">Zum Abschluss möchte ich noch mein neues, englisches Mentoring Programm vorstellen.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/5/2/9/7/6/TN_223508261_4495ec75b2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:10 type=2>" style="max-height: 25px; max-width: 25px;"> <i><br></i></div><div class="ztitel">My Mentoring Program "Fundamentals for C++ Professionals"</div><div class="text">The general idea of the mentoring program is straightforward. I will teach you what you should know about modern C++. Modern C++ includes the core language and the library based on C++17 in 28 stations. Each week, I publish a new station. To master a station, you have to invest about three hours a week. Therefore, you can integrate my program into your workday. </div><div class="text">After my general idea, here are more details: <a title="Link auf https://www.modernescpp.com/index.php/my-mentoring-program-fundamentals-for-c-professionals" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fmy-mentoring-program-fundamentals-for-c-professionals%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22Fundamentals%20for%20C%2B%2B%20Professionals%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fmy-mentoring-program-fundamentals-for-c-professionals%22%7D" href="https://www.modernescpp.com/index.php/my-mentoring-program-fundamentals-for-c-professionals">Fundamentals for C++ Professionals</a>.<br></div>