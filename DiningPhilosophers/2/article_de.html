<div class="vorspann">Im letzten Beitrag "<a title="Link auf https://heise.de/-6320973" alt="%7B%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6320973%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6320973%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Dining%20Philosophers%20Problem%20I%22%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D" href="https://heise.de/-6320973">Dining Philosophers Problem I</a>" begann Andre Adrian seine Analyseder klassischen Problemstellung. Heute verwendet er Atomics, Mutexe und Locks.</div><div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/5/7/3/0/5/TN_223842981_cb639191f4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text"><span class="tx_smaller">By Benjamin D. Esham / Wikimedia Commons, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=56559</span></div><div class="text">Ich möchte kurz daran erinnern, wo Andres Analyse beim letzten Mal endete.</div><div class="pre">// dp_5.cpp<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br>#include &lt;chrono&gt;<br>#include &lt;atomic&gt;<br><br>int myrand(int min, int max) {<br>&nbsp; return rand()%(max-min)+min;<br>}<br><br>void lock(std::atomic&lt;int&gt;&amp; m) {<br>&nbsp; while (m)<br>&nbsp;&nbsp;&nbsp; ; // busy waiting<br>&nbsp; m=1;<br>}<br><br>void unlock(std::atomic&lt;int&gt;&amp; m) {<br>&nbsp; m=0;<br>}<br><br>void phil(int ph, std::atomic&lt;int&gt;&amp; ma, std::atomic&lt;int&gt;&amp; mb) {<br>&nbsp; while(true) {<br>&nbsp;&nbsp;&nbsp; int duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;ph&lt;&lt;" thinks "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br><br>&nbsp;&nbsp;&nbsp; lock(ma);<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got ma\n";<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(1000));<br><br>&nbsp;&nbsp;&nbsp; lock(mb);<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got mb\n";<br><br>&nbsp;&nbsp;&nbsp; duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t\t\t"&lt;&lt;ph&lt;&lt;" eats "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br><br>&nbsp;&nbsp;&nbsp; unlock(mb);<br>&nbsp;&nbsp;&nbsp; unlock(ma);<br>&nbsp; }<br>}<br><br>int main() {<br>&nbsp; std::cout&lt;&lt;"dp_5\n";<br>&nbsp; srand(time(nullptr));<br><br>&nbsp; std::atomic&lt;int&gt; m1{0}, m2{0}, m3{0}, m4{0};<br><br>&nbsp; std::thread t1([&amp;] {phil(1, m1, m2);});<br>&nbsp; std::thread t2([&amp;] {phil(2, m2, m3);});<br>&nbsp; std::thread t3([&amp;] {phil(3, m3, m4);});<br>&nbsp; std::thread t4([&amp;] {phil(4, m1, m4);});<br><br>&nbsp; t1.join();<br>&nbsp; t2.join();<br>&nbsp; t3.join();<br>&nbsp; t4.join();<br>}</div><div class="text">Das Programm sieht richtig aus. Es gibt immer noch eine&nbsp;winzige Chance für Fehlverhalten. Die beiden Operationen "ist eine Ressource verfügbar" und "Ressource als in Gebrauch markieren" in der Funktion&nbsp;<span class="tx_code">lock()</span>&nbsp;sind atomar, aber sie sind immer noch zwei Operationen. Zwischen diesen beiden Operationen kann der Scheduler einen Threadwechsel platzieren. Und dieser Threadwechsel zu diesem ungünstigsten Zeitpunkt kann sehr schwer zu findende Fehler im Programm erzeugen.</div><div class="ztitel">Richtiges Busy Waiting mit Resourcehierarchie<br></div><div class="text">Glücklicherweise verfügen alle aktuellen Computer über eine atomare Operation "Ressource testen und bei positivem Test Ressource als verwendet markieren". In der Programmiersprache C++ stellt uns der Typ <span class="tx_code">atomic_flag</span> diese spezielle Operation "test and set" zur Verfügung. Die Datei <span class="tx_code">dp_6.cpp </span>ist die erste richtige Lösung für das Problem der Restaurantphilosophen: </div><div class="pre">// dp_6.cpp<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br>#include &lt;chrono&gt;<br>#include &lt;atomic&gt;<br><br>int myrand(int min, int max) {<br>&nbsp; return rand()%(max-min)+min;<br>}<br><br>void lock(std::atomic_flag&amp; m) {<br>&nbsp; while (m.test_and_set())<br>&nbsp;&nbsp;&nbsp; ; // busy waiting<br>}<br><br>void unlock(std::atomic_flag&amp; m) {<br>&nbsp; m.clear();<br>}<br><br>void phil(int ph, std::atomic_flag&amp; ma, std::atomic_flag&amp; mb) {<br>&nbsp; while(true) {<br>&nbsp;&nbsp;&nbsp; int duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;ph&lt;&lt;" thinks "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br><br>&nbsp;&nbsp;&nbsp; lock(ma);<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got ma\n";<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(1000));<br><br>&nbsp;&nbsp;&nbsp; lock(mb);<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got mb\n";<br><br>&nbsp;&nbsp;&nbsp; duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t\t\t"&lt;&lt;ph&lt;&lt;" eats "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br><br>&nbsp;&nbsp;&nbsp; unlock(mb);<br>&nbsp;&nbsp;&nbsp; unlock(ma);<br>&nbsp; }<br>}<br><br>int main() {<br>&nbsp; std::cout&lt;&lt;"dp_6\n";<br>&nbsp; srand(time(nullptr));<br><br>&nbsp; std::atomic_flag m1, m2, m3, m4;<br>&nbsp; unlock(m1);<br>&nbsp; unlock(m2);<br>&nbsp; unlock(m3);<br>&nbsp; unlock(m4);<br><br>&nbsp; std::thread t1([&amp;] {phil(1, m1, m2);});<br>&nbsp; std::thread t2([&amp;] {phil(2, m2, m3);});<br>&nbsp; std::thread t3([&amp;] {phil(3, m3, m4);});<br>&nbsp; std::thread t4([&amp;] {phil(4, m1, m4);});<br><br>&nbsp; t1.join();<br>&nbsp; t2.join();<br>&nbsp; t3.join();<br>&nbsp; t4.join();<br>}<br></div><div class="text">Die Ausgabe der Programmversion 6 ist der letzten Ausgabe ähnlich. Das Problem der speisenden Philosophen ist gutmütig. Eine Ressource wird nur von zwei Threads gemeinsam genutzt. Der <span class="tx_code">atomic_flag</span>-Spinlock wird nur dann wirklich benötigt, wenn mehrere Threads dieselbe Ressource erhalten wollen.</div><div class="ztitel">Optimiertes Busy Waiting mit Resourcehierarchie</div><div class="text">Der Nachteil von Spinlock ist das beschäftigte Warten (busy waiting). Die while-Schleife in <span class="tx_code">lock()</span> ist eine Verschwendung von CPU-Ressourcen. Eine Lösung für dieses Problem besteht darin, eine <span class="tx_code">sleep_for()</span>-Funktion in den Rumpf dieser while-Schleife einzufügen. Die Funktion <span class="tx_code">sleep_for()</span> führt das Warten im Scheduler durch. Dieses Warten ist viel besser als das Warten in der Anwendung. Wie immer gibt es einen Preis. Das <span class="tx_code">sleep_for() </span>verlangsamt den Programmfortschritt, weil nur noch alle 8 Millisekunden der Zustand der Ressource geprüft wird. Datei <span class="tx_code">dp_7.cpp</span> ist die zweite richtige Lösung:</div><div class="pre">// dp_7.cpp<br>void lock(std::atomic_flag&amp; m) {<br>&nbsp; while (m.test_and_set())<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(8));<br>}</div><div class="text">Hinweis: Ein <span class="tx_code">std::this_thread::yield()</span> anstelle von <span class="tx_code">sleep_for()</span> reduziert die CPU-Last auf dem Computer des Autors nicht. Die Auswirkung von <span class="tx_code">yield()</span> ist implementierungsabhängig.</div><div class="ztitel"><span class="tx_code">std::mutex</span> mit Resourcehierarchie</div><div class="text">Um geschäftiges Warten vollständig zu vermeiden, brauchen wir mehr Hilfe vom Scheduler. Wenn der Scheduler einen "Ressource belegen"-Aufruf erhält und diese Ressource ist schon belegt, schiebt der Scheduler den Thread in die Scheduler wait-Queue. Nachdem der Scheduler einen "Ressource ist verfügbar"-Aufruf erhalten hat, wird der wartende Thread von der wait-Queue wieder in die ready-Queue verschoben.</div><div class="text">Der Informationsaustausch zwischen Thread und Scheduler ist teuer. Aus diesem Grund bietet C++ sowohl Spinlock als auch Mutex. Spinlock wartet im Thread und Mutex wartet im Scheduler.</div><div class="text">Die Datei <span class="tx_code">dp_8.cpp </span>zeigt die Mutex-Lösung. Bitte beachte das <span class="tx_code">#include &lt;mutex&gt; </span>: </div><div class="pre">// dp_8.cpp<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br>#include &lt;chrono&gt;<br>#include &lt;mutex&gt;<br><br>int myrand(int min, int max) {<br>&nbsp; return rand()%(max-min)+min;<br>}<br><br>void phil(int ph, std::mutex&amp; ma, std::mutex&amp; mb) {<br>&nbsp; while(true) {<br>&nbsp;&nbsp;&nbsp; int duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;ph&lt;&lt;" thinks "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br><br>&nbsp;&nbsp;&nbsp; ma.lock();<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got ma\n";<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(1000));<br><br>&nbsp;&nbsp;&nbsp; mb.lock();<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got mb\n";<br><br>&nbsp;&nbsp;&nbsp; duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t\t\t"&lt;&lt;ph&lt;&lt;" eats "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br>&nbsp;&nbsp;&nbsp; mb.unlock(); // (9)<br>&nbsp;&nbsp;&nbsp; ma.unlock();<br>&nbsp; }<br>}<br><br>int main() {<br>&nbsp; std::cout&lt;&lt;"dp_8\n";<br>&nbsp; srand(time(nullptr));<br><br>&nbsp; std::mutex m1, m2, m3, m4;<br><br>&nbsp; std::thread t1([&amp;] {phil(1, m1, m2);});<br>&nbsp; std::thread t2([&amp;] {phil(2, m2, m3);});<br>&nbsp; std::thread t3([&amp;] {phil(3, m3, m4);});<br>&nbsp; std::thread t4([&amp;] {phil(4, m1, m4);});<br><br>&nbsp; t1.join();<br>&nbsp; t2.join();<br>&nbsp; t3.join();<br>&nbsp; t4.join();<br>}<br></div><div class="text">Programmversion 8 ist korrekt und verbraucht sehr wenig CPU-Ressourcen. C++ bietet einen Wrapper für Mutex, um Programmierern das Leben zu erleichtern. </div><div class="ztitel"><span class="tx_code">std::lock_guard</span> mit Resourcehierarchie<br></div><div class="text">Wenn wir das <span class="tx_code">lock_guard</span>-Template verwenden, müssen wir ihm nur den Mutex übergeben. </div><div class="text">Die Anweisung <span class="tx_code">lock</span> wird im automatisch im Konstruktor des Locks und die&nbsp; Anweisung <span class="tx_code">unlock</span> automatisch in seinem Destruktor am Ende des Blocks aufgerufen, also an der nächsten schließenden Klammer<span class="tx_code"> }</span>. Durch <span class="tx_code">lock_guard</span> wird <span class="tx_code">unlock</span> auch dann ausgeführt, wenn der Block durch eine Exception verlassen wird.</div><div class="text">Die bequeme Version ist <span class="tx_code">dp_9.cpp</span>:</div><div class="pre">// dp_9.cpp<br>void phil(int ph, std::mutex&amp; ma, std::mutex&amp; mb) {<br>&nbsp; while(true) {<br>&nbsp;&nbsp;&nbsp; int duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;ph&lt;&lt;" thinks "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br><br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; ga(ma);<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got ma\n";<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(1000));<br><br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; gb(mb);<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got mb\n";<br><br>&nbsp;&nbsp;&nbsp; duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t\t\t"&lt;&lt;ph&lt;&lt;" eats "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br>&nbsp; }<br>}</div><div class="text">Wir werden immer besser. Die Programmversionen 8 und 9 sind korrekt und haben geringe CPU-Auslastung. Aber achten Sie auf die Programmausgabe:</div><div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/5/7/3/0/5/TN_223842984_48e83670f5.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Die Programmausgabe ist leicht verstümmelt. Vielleicht haben Sie diese Ausgabeverzerrung schon bei anderen Programmversionen gesehen. An den Spinlock-Programmversionen 6 und 7 oder den Mutex-Programmversionen 8 und 9 ist nichts auszusetzen. <br></div><div class="ztitel"><span class="tx_code">std::lock_guard</span> mit synchronisierter Ausgabe und Resourcenhierarchie</div><div class="text">Die Konsolenausgabe selbst ist eine Ressource. Dies ist der Grund für die verstümmelte Ausgabe in Multithread-Programmen. Die Lösung besteht darin, jede Konsolenausgabe mit einem <span class="tx_code">lock_guard</span> zu versehen. Siehe <span class="tx_code">dp_10.cpp</span>: </div><div class="pre">// dp_10.cpp<br><br>std::mutex mo;<br><br>void phil(int ph, std::mutex&amp; ma, std::mutex&amp; mb) {<br>&nbsp; while(true) {<br>&nbsp;&nbsp;&nbsp; int duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;ph&lt;&lt;" thinks "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br><br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; ga(ma);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got ma\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(1000));<br><br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; gb(mb);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got mb\n";<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t\t\t"&lt;&lt;ph&lt;&lt;" eats "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br>&nbsp; }<br>}</div><div class="text">Der globale Mutex <span class="tx_code">mo</span> schützt die Konsolenausgabe-Ressource. Jede<span class="tx_code"> cout</span>-Anweisung befindet sich in ihrem Block und das <span class="tx_code">lock_guard()</span>-Template stellt sicher, dass die Konsolenausgabe nicht mehr verstümmelt wird.</div><div class="ztitel"><span class="tx_code">std::lock_guard</span> mit synchronisierter Ausgabe und Resourcenhierarchie und einem Zähler<br></div><div class="text">Als kleinen Bonus habe ich <span class="tx_code">dp_11.cpp</span> hinzugefügt. Diese Programmversion zählt die Anzahl der Philosophen-Threads, die gleichzeitig essen. Da wir vier Gabeln haben, sollte es Zeiten geben, in denen zwei Philosophen-Thread gleichzeitig im Zustand essen sind. Bitte beachten Sie, dass Sie erneut<span class="tx_code"> #include &lt;atomic&gt;</span> benötigen. Siehe <span class="tx_code">dp_11.cpp</span>: </div><div class="pre">// dp_11.cpp<br><br>std::mutex mo;<br>std::atomic&lt;int&gt; cnt = 0;<br><br>void phil(int ph, std::mutex&amp; ma, std::mutex&amp; mb) {<br>&nbsp; while(true) {<br>&nbsp;&nbsp;&nbsp; int duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;ph&lt;&lt;" thinks "&lt;&lt;duration&lt;&lt;"ms\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br><br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; ga(ma);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got ma\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(1000));<br><br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; gb(mb);<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t"&lt;&lt;ph&lt;&lt;" got mb\n";<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; duration=myrand(1000, 2000);<br>&nbsp;&nbsp;&nbsp; ++cnt;<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; g(mo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout&lt;&lt;"\t\t\t\t"&lt;&lt;ph&lt;&lt;" eats "&lt;&lt;duration&lt;&lt;"ms "&lt;&lt;cnt&lt;&lt;"\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(duration));<br>&nbsp;&nbsp;&nbsp; --cnt;<br>&nbsp; }<br>}<br></div><div class="text">Die Ausgabe der Programmversion 11 ist:</div><div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/5/7/3/0/5/TN_223842995_4d45a779ef.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Der Zusatz ist die Nummer 1 oder 2 am Ende der "eats"-Protokollierung.</div><div class="utitel">Wie geht's weiter? </div><div class="text">In seiner nächsten Folge des Dining Philosoher Problems verwendet Andre <span class="tx_code">std::unique_lock</span> (C++11), <span class="tx_code">std::scoped_lock</span> (C++17) und <span class="tx_code">std::semaphore</span> (C++20).<br></div>