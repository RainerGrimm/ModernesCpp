<p>The future of C++ speaks templates, and so does my blog Modernes C++. Based on the poll of my last post "Quo Vadis - Modernes C++", my next presumably 50 - 100 posts explain the details to templates. In this post, I want to give you an idea of the upcoming posts.</p>
<hr id="system-readmore" />
<p><img src="https://www.modernescpp.com/images/blog/news/QuoVadisModernesCpp/result.png" alt="result" width="500" height="264" style="display: block; margin-left: auto; margin-right: auto;" /></p>
<p>Let me first write a few words about the poll because its result surprised me in two ways.</p>
<h2>The Poll</h2>
<p>First, about 400 people voted in the poll. This is a number I would not have expected. Thanks for the many votes.</p>
<p>Second, I assumed that "C++23" will probably win the poll, followed by "Templates"&nbsp; or "Extending and embedding Python with C/C++". My assumption was so wrong. I'm happy that I made the poll.</p>
<p>When I'm done with this "Templates",&nbsp; I make the next poll. Now, let's tear the wheel to templates.</p>
<h2>Templates</h2>
<p>First of all: What are templates? Templates (class templates or function templates) are families of classes or functions.</p>
<p>Before I present my plan, I want to encourage you to write me an e-mail if I forgot a template-related feature you are interested in. Here is my e-mail address: <a href="mailto:Rainer.Grimm@modernescpp.de">Rainer.Grimm@modernescpp.de</a>.</p>
<p>These are the upcoming topics with a few additional words:</p>
<h3>Basics</h3>
<p>Of course, my tour starts with the basics.</p>
<ul>
<li>Presenting the instantiation of&nbsp;<strong>function templates </strong>provides you the first intuition about templates. This holds in particular if function overloading, or explicit template arguments are given.<strong><br /></strong></li>
<li>In contrast to function templates, only the C++17-compiler can deduce the template arguments for<strong> class templates</strong>. Meaning, before C++17, you have to specify the template arguments such as <code>int</code> in <code>std::vector&lt;int&gt;</code>.</li>
<li><strong>Template parameters</strong> can be types, non-types, and templates. In particular, floating-point values can be used in C++20 as non-type template parameters.</li>
<li>The compiler can automatically deduce the<strong> template arguments</strong> of templates. It makes a big difference if the template parameter is a reference/pointer, a universal reference (&amp;&amp;), or a value. Templates can also have default template arguments.</li>
<li>Class templates allow partial and full<strong> template specialization</strong>, function template only partial template specialization.</li>
</ul>
<h3>Details</h3>
<p>After the basics, I want to provide you more details.</p>
<ul>
<li>In general,<strong> template instantiati</strong>on happens implicitly but can also be done explicitly.</li>
<li>A <strong>variadic template</strong> is a template that can have an arbitrary number of parameters. Hence, templates can take an arbitrary number of arguments of any value category.</li>
<li>Based on variadic templates in C++11, we got<strong> fold expressions</strong> in C++17. Fold expressions reduce parameter packs on binary operators.</li>
<li><strong>Friendship</strong> of templates is special. A class or class template can grand general friendship to each instance of a class template or function template. The friendship can also be granted to specific instances of a class template or function template,&nbsp; and also to a specific type.</li>
<li>Names can be dependent on template parameters. For <strong>dependent names</strong>, you have to help the compiler to decide if the name is a type, a non-type, or a template. If ambiguous, the compiler assumes that a name is a non-type.</li>
</ul>
<h3>Techniques</h3>
<p>There are many techniques and features related to templates and template instantiation.</p>
<ul>
<li>When you use a function template with at least two template parameters, you cannot decide in general, what should be the return type of the function template. Here, the <strong>automatic return typ</strong>e comes to our rescue.&nbsp;</li>
<li><strong>Template metaprogramming</strong> is <a href="https://en.wikipedia.org/wiki/Turing_completeness">turning complete</a>. This means all that is calculable can be calculated at compile time. Template metaprogramming is a pure functional language embedded into the imperative language C++. Libraries such as many of the <a href="https://www.boost.org/">boost </a>libraries use heavily template metaprogramming.</li>
<li>The <strong>type traits</strong> library is applied template metaprogramming. Thanks to the type traits library, you can perform type checks, type comparisons, and type modifications at compile time.</li>
<li><strong><code>constexpr </code></strong>is the convenients way to program at compile time. In contrast to programming in a functional style using template metaprogramming, you can program with <code>constexpr</code> in an imperative style.<code><br /></code></li>
<li><strong>constexpr if</strong> enables it to compile source code conditionally.</li>
</ul>
<h3>Design</h3>
<p>Templates open C++ to new ways to design software.</p>
<ul>
<li>Beside <strong>dynamic polymorphism</strong> (object orientation), we have&nbsp;<strong>static polymorphism</strong> (templates).</li>
<li>CRTP (curiously recurring template pattern) is a mind-blowing but very powerful technique. Thanks to CRTP, we can move the virtuality from run time to compile time.</li>
<li><strong>Expression templates</strong> create structures, which stand for calculations. They are only evaluated when needed and spare, therefore, time and memory.</li>
<li>There are many<strong> idioms and patterns</strong> related to templates. For example, we have policies and traits, tag dispatching, and type erasure.</li>
</ul>
<h3>C++20</h3>
<ul>
<li><b>Concepts</b> are an extension to the <a href="https://en.wikipedia.org/wiki/Template_(C%2B%2B)" title="Template (C++)">templates</a> feature provided by the <a href="https://en.wikipedia.org/wiki/C%2B%2B" title="C++">C++</a> programming language. Concepts are named <a href="https://en.wikipedia.org/wiki/Boolean_value" class="mw-redirect" title="Boolean value">Boolean</a> predicates on template parameters, evaluated at <a href="https://en.wikipedia.org/wiki/Compile_time" title="Compile time">compile time</a>. A concept may be associated with a template (<a href="https://en.wikipedia.org/wiki/Class_(C%2B%2B)" class="mw-redirect" title="Class (C++)">class</a> template, <a href="https://en.wikipedia.org/wiki/Function_(computer_programming)" class="mw-redirect" title="Function (computer programming)">function</a> template, or <a href="https://en.wikipedia.org/wiki/Member_function" class="mw-redirect" title="Member function">member function</a> of a class template), in which case it serves as a <i>constraint</i>: it limits the set of arguments that are accepted as template parameters.(<a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)">Wikipedia</a>)</li>
</ul>
<h2>What's next?</h2>
<p>In my next post, I introduce function templates using the online compiler<a href="https://www.google.com/search?client=firefox-b-d&amp;q=C%2B%2B+Insights"> C++ Insights</a>.</p>
<p>&nbsp;</p>
<p>{loadmoduleid 153}</p>