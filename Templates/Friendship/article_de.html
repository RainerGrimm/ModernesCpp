<div class="vorspann">Ein Freund hat uneingeschränkten Zugang zu den Mitgliedern einer Klasse. Deshalb sollte die Freundschaft mit Bedacht vergeben werden. In Bezug auf Templates verhält sich die Freundschaft besonders.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/7/8/3/1/9/TN_217624294_981de32ecc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="text">Bevor ich über die Regeln zu <span class="tx_code">friend</span> für Templates schreibe, möchte ich die allgemeinen Regeln zur Freundschaft vorstellen.</div><div class="text"><ul><li>Die <span class="tx_code">friend</span> Deklaration kann an jeder beliebigen Stelle in der Klasse erfolgen.</li><li>Bei der <span class="tx_code">friend</span> Deklaration werden die Zugriffsrechte in der Klasse nicht berücksichtigt.</li><li>Freundschaft wird nicht vererbt. Wenn eine Klasse <span class="tx_code">Base</span> einer Klasse <span class="tx_code">Derived</span> Freundschaft gewährt, ist eine von <span class="tx_code">Derived</span> abgeleitete Klasse nicht automatisch ein Freund von <span class="tx_code">Base</span>.</li><li>Freundschaft ist nicht transitiv. Wenn die Klasse<span class="tx_code"> B</span> mit der Klasse <span class="tx_code">A</span> befreundet ist und die Klasse<span class="tx_code"> C</span> mit der Klasse<span class="tx_code"> B</span> befreundet ist, ist die Klasse <span class="tx_code">C</span> nicht automatisch mit der Klasse <span class="tx_code">A</span> befreundet.<br></li></ul></div><div class="text">Eine Klasse oder ein Klassen-Template kann mit einer Klasse oder einem Klassen-Template, einer Funktion oder einem Funktions-Template oder einem Typ befreundet sein.<br> </div><div class="ztitel">Allgemeine Freundschaft<br></div><div class="text">Eine Klasse oder ein Klassen-Template kann jeder Instanz eines Klassen-Templates oder Funktions-Template Freundschaft gewähren.</div><div class="pre">// generalFriendship.cpp<br><br>#include &lt;iostream&gt;<br><br>template &lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>void myFriendFunction(T);<br><br>template &lt;typename U&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>class MyFriend;<br><br>class GrantingFriendshipAsClass {<br><br>&nbsp; template &lt;typename U&gt; friend void myFriendFunction(U);<br>&nbsp; template &lt;typename U&gt; friend class MyFriend;<br><br>&nbsp; std::string secret{"Secret from GrantingFriendshipAsClass."};<br><br>};<br><br>template &lt;typename T&gt;<br>class GrantingFriendshipAsClassTemplate{<br><br>&nbsp; template &lt;typename U&gt; friend void myFriendFunction(U);<br>&nbsp; template &lt;typename U&gt; friend class MyFriend;<br><br>&nbsp; std::string secret{"Secret from GrantingFriendshipAsClassTemplate."};<br><br>};<br><br>template &lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>void myFriendFunction(T){<br>&nbsp; GrantingFriendshipAsClass myFriend;<br>&nbsp; std::cout &lt;&lt; myFriend.secret &lt;&lt; '\n';<br><br>&nbsp; GrantingFriendshipAsClassTemplate&lt;double&gt; myFriend1;<br>&nbsp; std::cout &lt;&lt; myFriend1.secret &lt;&lt; '\n';<br>}<br><br>template &lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>class MyFriend{<br>public:<br>&nbsp; MyFriend(){<br>&nbsp;&nbsp;&nbsp; GrantingFriendshipAsClass myFriend;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; myFriend.secret &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; GrantingFriendshipAsClassTemplate&lt;T&gt; myFriend1;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; myFriend1.secret &lt;&lt; '\n';<br>&nbsp; }<br>};<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp; int a{2011};<br>&nbsp; myFriendFunction(a);<br><br>&nbsp; MyFriend&lt;double&gt; myFriend;<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text">(1) und (2) deklarieren das Funktions-Template <span class="tx_code">myFriendFunction</span> und das Klassen-Template <span class="tx_code">MyFriend</span>. Das Funktions-Template <span class="tx_code">myFriendFunction</span> wird in (3) und das Klassen-Template <span class="tx_code">MyFriend</span> in (4) definiert. Die Klassen <span class="tx_code">GrantingFriendshipAsClass</span> und <span class="tx_code">GrantingFriendshipAsClassTemplate</span> gewähren dem Funktions-Template <span class="tx_code">myFriendFunction</span> und dem Klassen-Template <span class="tx_code">MyFriend</span> Freundschaft. Aufgrund der Freundschaft können beide Templates die private Variable <span class="tx_code">secrete</span> der Klasse und des Klassen-Templates direkt aufrufen.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/7/8/3/1/9/TN_217624285_cd1dc7b231.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="text">Bei dem Klassen-Template <span class="tx_code">GrantingFriendShipAsClassTemplate</span> gibt es einen Fallstrick: Normalerweise heißt der erste Typparameter eines Templates <span class="tx_code">T</span>. Wer - wie im folgenden Codeschnipsel - denselben Typparameternamen für das Klassen-Template und das Funktions-Template <span class="tx_code">myFriendFunction</span> oder das Klassen-Template <span class="tx_code">MyFriend</span> verwendet, erhält eine Fehlermeldung. Der Bezeichner<span class="tx_code"> T</span> von <span class="tx_code">myFriendFunction</span> oder <span class="tx_code">MyFriend</span> verdeckt den Bezeichner <span class="tx_code">T </span>des Klassen-Templates <span class="tx_code">GrantingFriendshipAsClassTemplate</span>. </div><div class="text">Das folgende Codeschnipsel stellt den Fallstrick dar.<br></div><div class="pre">template &lt;typename T&gt;<br>class GrantingFriendshipAsClassTemplate{<br><br>&nbsp; template &lt;typename T&gt; friend void myFriendFunction(T);<br>&nbsp; template &lt;typename T&gt; friend class MyFriend;<br><br>&nbsp; std::string secret{"Secret from GrantingFriendshipAsClassTemplate."};<br><br>};</div><div class="ztitel">Besondere Freundschaft</div><div class="text">Eine besondere Freundschaft ist eine Freundschaft, die vom Typ des Template-Parameter abhängt.</div><div class="pre">// specialFriendship.cpp<br><br>#include &lt;iostream&gt;<br><br>template &lt;typename T&gt; void myFriendFunction(T);<br>template &lt;typename U&gt; class MyFriend;<br><br><br>class GrantingFriendshipAsClass {<br><br>&nbsp; friend void myFriendFunction&lt;&gt;(int);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; friend class MyFriend&lt;int&gt;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>private:<br>&nbsp; std::string secret{"Secret from GrantingFriendshipAsClass."};<br><br>};<br><br>template &lt;typename T&gt;<br>class GrantingFriendshipAsClassTemplate {<br><br>&nbsp; friend void myFriendFunction&lt;&gt;(int);<br>&nbsp; friend class MyFriend&lt;int&gt;;<br>&nbsp; friend class MyFriend&lt;T&gt;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>private:<br>&nbsp; std::string secret{"Secret from GrantingFriendshipAsClassTemplate."};<br><br>};<br><br>template &lt;typename T&gt;<br>void myFriendFunction(T) {<br>&nbsp; GrantingFriendshipAsClass myFriend;<br>&nbsp; std::cout &lt;&lt; myFriend.secret &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br><br>&nbsp; GrantingFriendshipAsClassTemplate&lt;T&gt; myFriend1;<br>&nbsp; std::cout &lt;&lt; myFriend1.secret &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>}<br><br>template &lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>class MyFriend {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>public:<br>&nbsp; MyFriend() {<br>&nbsp;&nbsp;&nbsp; GrantingFriendshipAsClass myFriend;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; myFriend.secret &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; GrantingFriendshipAsClassTemplate&lt;int&gt; myFriendInt;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; myFriendInt.secret &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; GrantingFriendshipAsClassTemplate&lt;T&gt; myFriendT;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; myFriendT.secret &lt;&lt; '\n';<br>&nbsp; }<br>};<br><br>int main() {<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp; int a{2011};<br>&nbsp; myFriendFunction(a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp; MyFriend&lt;int&gt; myFriend;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text">Die Klasse <span class="tx_code">GrantingFriendshipAsClass</span> gewährt Freundschaft für die vollständige Spezialisierung des Funktions-Template <span class="tx_code">myFriendFunction</span> für <span class="tx_code">int</span> (1) und des Klassen-Template <span class="tx_code">MyFriend</span> für int (2). Dasselbe gilt für das Klassen-Template <span class="tx_code">GrantingFrandshipAsClassTemplate</span>. (3) ist besonders, weil sie der vollständigen Spezialisierung für <span class="tx_code">MyFriend</span> Freundschaft gewährt, die denselben Typparameter hat wie das Klassen-Template <span class="tx_code">GrantingFrandshipAsClassTemplate</span>. Folglich kann das Funktions-Template <span class="tx_code">myFriendFunction</span>&nbsp; <span class="tx_code">secret</span> der Klasse <span class="tx_code">GrantingFriendshipAsClass</span> aufrufen, wenn <span class="tx_code">myFriendFunctions</span> eine vollständige Spezialisierung für <span class="tx_code">int</span> ist (4) oder <span class="tx_code">GrantingFriendshipAsClassTemplate</span> den gleichen Typ wie <span class="tx_code">myFriendFunction</span> besitzt (5). Die entsprechende Argumentation gilt für das Klassen-Template <span class="tx_code">MyFriend</span> (6).</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/7/8/3/1/9/TN_217624298_8fb1e5f751.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br> </div><div class="ztitel">Freund zu Typen<br></div><div class="text">Ein Klassen-Template kann seine Freundschaft auch an einen Typparameter vergeben.</div><div class="pre">// typeFriendship.cpp<br><br>#include &lt;iostream&gt;<br><br>template &lt;typename T&gt;<br>class Bank {<br>&nbsp;&nbsp;&nbsp; std::string secret{"Secret from the bank."};<br>&nbsp;&nbsp;&nbsp; friend T;<br>};<br><br>class Account{<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; Account() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bank&lt;Account&gt; bank;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; bank.secret &lt;&lt; '\n';&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; Account acc;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text">Die Klasse <span class="tx_code">Bank</span> gewährt ihrem Typparameter<span class="tx_code"> T</span> Freundschaft. Daher kann ein <span class="tx_code">Account</span> auf das <span class="tx_code">secret</span> der Bankinstanz zugreifen: <span class="tx_code">Bank&lt;Account&gt; </span>(1).</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/7/8/3/1/9/TN_217624304_b7236f36b6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel">Wie geht's weiter?<br> </div><div class="text">In meinem nächsten Beitrag schreibe ich über einen der anspruchsvollen Bereiche von Templates: dependent names.</div>