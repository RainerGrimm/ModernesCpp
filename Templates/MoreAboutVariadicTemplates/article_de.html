<div class="vorspann">Es steckt eine Menge Power in den eigentümlich aussehenden drei Punkten, die in der Standard Template Library häufig verwendet werden. Aufschluss gibt eine Visualisierung der Pack-Expansion inklusive einiger Anwendungsfälle.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/5/3/8/7/4/TN_215529308_6f8727afe9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Beginnen möchte ich diesen Post mit einer Analyse der Pack Expansion in Variadic Templates.</div><div class="ztitel">Pack-Expansion</div><div class="text">Hier ist eine kleine Erinnerung:&nbsp; Ein variadisches Template kann eine beliebige Anzahl von Template-Parametern besitzen.</div><div class="pre">template &lt;typename ... Args&gt;<br>void variadicTemplate(Args ... args) { <br>&nbsp;&nbsp;&nbsp; . . . . // four dots<br>}</div><div class="text">Dank der Ellipse (<span class="tx_code">...</span>) wird <span class="tx_code">Args</span> bzw. <span class="tx_code">args</span> zu einem sogenannten Parameter-Pack. Genauer gesagt ist <span class="tx_code">Args</span> ein Template-Parameterpaket und <span class="tx_code">args</span> ein Funktionsparameterpaket. Mit Parameter-Packs sind zwei Operationen möglich. Sie können gepackt und entpackt werden. Wenn die Ellipse links von <span class="tx_code">Args</span> ist, wird das Parameter-Pack gepackt, wenn sie rechts von <span class="tx_code">Args</span> ist, wird es entpackt. Aufgrund der Function Template Argument Deduction kann der Compiler die Template-Argumente automatisch ableiten.</div><div class="text">Bevor ich über die Pack-Erweiterung schreibe, muss ich einen kurzen Disclaimer machen. Normalerweise wendet man die Pack Expansion nicht direkt an, sondern verwendet Variadic Templates, die das automatisch erledigen, oder <a title="Link auf https://en.cppreference.com/w/cpp/language/fold" alt="%7B%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Ffold%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Fold%20Expressions%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Ffold%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D" href="https://en.cppreference.com/w/cpp/language/fold">Fold Expressions</a> beziehungsweise <a title="Link auf https://en.cppreference.com/w/cpp/language/if" alt="%7B%22version%22%3A1%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fif%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22text%22%3A%22constexpr%20if%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fif%22%2C%22anchor%22%3A%22%22%7D" href="https://en.cppreference.com/w/cpp/language/if">constexpr if</a> in C++17. Ich werde über Fold Expressions und constexpr if in zukünftigen Beiträgen schreiben. Die Visualisierung von Pack-Expansionen ist sehr hilfreich für ein besseres Verständnis von Variadic Templates und Fold Expressions.</div><div class="text">Die Verwendung von Parameterpacks folgt einem typischen Muster.</div><div class="text"><ul><li>Führe eine Operation auf dem ersten Element des Parameter-Pack aus und rufe die Operation rekursiv auf den restlichen Elementen auf. Dieser Schritt reduziert das Parameter-Pack sukzessive um sein erstes Element.</li><li>Die Rekursion endet nach einer endlichen Anzahl von Schritten.&nbsp;&nbsp;&nbsp; <br></li><li>Die Randbedingung ist typischerweise ein vollständig spezialisiertes Template.</li></ul></div><div class="text">Dank dieses funktionalen Musters für die Verarbeitung von Listen, lässt sich das Produkt von Zahlen zur Compile-Zeit berechnen. In Lisp wird der Kopf der Liste car und den Rest cdr genannt. In Haskell haben sich die Namen head und tail etabliert.</div><div class="pre">// multVariadicTemplates.cpp<br><br>#include &lt;iostream&gt;<br><br>template&lt;int ...&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>struct Mult;<br><br>template&lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>struct Mult&lt;&gt; {<br>&nbsp;&nbsp;&nbsp; static const int value = 1;<br>};<br><br>template&lt;int i, int ... tail&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>struct Mult&lt;i, tail ...&gt; {<br>&nbsp;&nbsp;&nbsp; static const int value = i * Mult&lt;tail ...&gt;::value;<br>};<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Mult&lt;10&gt;::value: " &lt;&lt; Mult&lt;10&gt;::value &lt;&lt; '\n';&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Mult&lt;10,10,10&gt;::value: " &lt;&lt; Mult&lt;10, 10, 10&gt;::value <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Mult&lt;1,2,3,4,5&gt;::value: " &lt;&lt; Mult&lt;1, 2, 3, 4, 5&gt;::value <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text">Das Klassen-Template <span class="tx_code">Mult</span> besteht aus einem primären Template und zwei Spezialisierungen. Da das primäre Template (1) nicht benötigt wird, genügt in diesem Fall eine Deklaration: <span class="tx_code">template&lt;int ...&gt; struct Mult</span>. Die Spezialisierungen des Klassen-Template gibt es für kein Element (2) und für mindestens ein Element (3). Beim Aufruf von <span class="tx_code">Mult&lt;10,10,10&gt;::value</span> wird das Template mit mindestens einem Element verwendet, indem das erste Element mit dem Rest des Parameterpakets nacheinander aufgerufen wird, sodass <span class="tx_code">value</span> zum Produkt <span class="tx_code">10*10*10</span> expandiert. In der letzten Rekursion enthält das Parameterpaket keine Elemente und die Randbedingung tritt in Aktion:<span class="tx_code"> template&lt;&gt; struct Mult&lt;&gt; </span>(1). Dies liefert das Ergebnis von <span class="tx_code">Mult&lt;10,10,10&gt;::value= 10*10*10*1 </span>zur Compile-Zeit.</div><div class="text">&nbsp;<img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/5/3/8/7/4/TN_215529319_b38f87ddfb.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=1>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Nun zum interessanten Teil: Was passiert unter der Haube. Schauen wir uns den Aufruf <span class="tx_code">Mult&lt;10,10,10&gt;::value </span>genauer an. Dieser Aufruf löst keine Rekursion aus, sondern eine rekursive Instanziierung. Hier sind die wesentlichen Teile aus C++ Insights:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/5/3/8/7/4/TN_215529324_38a4dd2c5c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Der Compiler erzeugt vollständige Spezialisierungen für drei (<span class="tx_code">Mult&lt;10, 10, 10&gt;</span>) und zwei Argumente (<span class="tx_code">Mult&lt;10, 10&gt;</span>). Das wirft die Frage auf: Wo sind die Instanziierungen für ein Argument (<span class="tx_code">Mult&lt;10</span>&gt;) und kein Argument (<span class="tx_code">Mult&lt;&gt;</span>)? <span class="tx_code">Mult&lt;10&gt;</span> wurde bereits in (4) gefordert und<span class="tx_code"> Mult&lt;&gt;</span> (1) ist die Randbedingung.<br> </div><div class="text">Dazu eine kleine Anekdote: Wenn ich Variadic Templates in einer Schulung einführe, frage ich meine Teilnehmer gerne: Wer von Ihnen hat schon mal eine Ellipse benutzt? Die Hälfte meiner Teilnehmer antwortet: noch nie. Ich antworte ihnen, dass ich ihnen das nicht glaube und sie vielleicht schon von der <span class="tx_code">printf</span>-Familie gehört haben.</div><div class="ztitel_kleiner">Eine typsichere printf-Funktion</div><div class="text">Wohl jeder kennt die C-Funktion<span class="tx_code"> printf: int printf( const char* format, ... );. printf </span>ist eine Funktion, die eine beliebige Anzahl von Argumenten erhalten kann. Ihre Mächtigkeit basiert auf dem Makro<span class="tx_code"> va_arg</span> und ist daher nicht typsicher. Lasse mich eine vereinfachte <span class="tx_code">printf</span> Funktion mit Variadic Templates implementieren. Diese Funktion ist das Hello-World der Variadic Templates.</div><div class="pre">// myPrintf.cpp<br><br>#include &lt;iostream&gt;<br>&nbsp;<br>void myPrintf(const char* format){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; format;<br>}<br>&nbsp;<br>template&lt;typename T, typename ... Args&gt;<br>void myPrintf(const char* format, T value, Args ... args){&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; for ( ; *format != '\0'; format++ ) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( *format == '%' ) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myPrintf(format + 1, args ... );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; *format;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (8)<br>&nbsp;&nbsp;&nbsp; }<br>}<br>&nbsp;<br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; myPrintf("\n");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; myPrintf("% world% %\n", "Hello", '!', 2011);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; myPrintf("\n");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>}</div><div class="text">Wie ist der Kontrollfluss des Codes? Wenn <span class="tx_code">myPrintf</span> ohne Formatstring aufgerufen wird (1), wird (3) in diesem Fall verwendet. (2) verwendet das Funktions-Template. Das Funktions-Template prozessiert die Schleife (5) solange, wie das Formatsymbol nicht gleich `\0` ist. Wenn das Formatsymbol ungleich `\0` ist, sind zwei Kontrollflüsse möglich. Wenn das Format mit '<span class="tx_code">%</span>' beginnt (6), wird der erste Argumentwert angezeigt und<span class="tx_code"> myPrintf</span> wird erneut aufgerufen, aber diesmal mit einem neuen Formatsymbol und einem Argument weniger (7). Wenn dagergen der Formatstring nicht mit <span class="tx_code">'%</span>' beginnt, wird nur das Formatsymbol angezeigt (Zeile 8). Die Funktion<span class="tx_code"> myPrintf</span> (3) ist die Randbedingung für die rekursiven Aufrufe.</div><div class="text">Die Ausgabe des Programms ist erwartungsgemäß.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/5/3/8/7/4/TN_215529328_bf0ac442aa.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Wie zuvor hilft C++ Insights sehr, um einen tieferen Einblick in den Template-Instanzierungsprozess zu erhalten. Hier sind die drei Instanziierungen, die durch <span class="tx_code">myPrintf("% world% %\n", "Hello", '!', 2011)</span>; verursacht werden:</div><div class="text"><ul><li>Vier Argumente:</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/5/3/8/7/4/TN_215529333_ad52138eb5.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>Drei Argumente:</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/5/3/8/7/4/TN_215529341_c0ce58e2da.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>Zwei Argumente:</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/5/3/8/7/4/TN_215529344_c761117621.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="ztitel">Kurze zweiwöchige Pause</div><div class="text">Aufgrund meines Urlaubs und wahrscheinlich eingeschränkter Konnektivität, werde ich in den nächsten zwei Wochen keinen Beitrag veröffentlichen. Wer einen Gastbeitrag veröffentlichen möchte, kann mich gerne kontaktieren. <br></div><div class="ztitel">Wie geht's weiter?</div><div class="text">In meinem nächsten Beitrag verwende ich Variadic Templates, um das C++-Idiom für eine vollständig generische Fabrik zu implementieren. Eine Implementierung dieses lebensrettenden C++ Idioms ist <span class="tx_code">std::make_unique</span>.<br></div><div class="simple-translate-result-contents"><br> <br></div>