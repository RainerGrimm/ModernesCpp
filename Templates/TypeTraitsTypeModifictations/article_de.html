<div class="text">Die beiden Hauptziele der Type-Traits-Bibliothek sind sehr überzeugend: Korrektheit und Optimierung. Heute schreibe ich über die Korrektheit. </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/3/1/3/8/6/TN_222014507_04974fe849.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Die Type-Traits-Bibliothek ermöglicht es, Typabfragen, Typvergleiche und Typmodifikationen zur Compiletime durchzuführen. In <a title="Link auf Beitrag 3224652" alt="%7B%22destination%22%3A3224652%2C%22text%22%3A%22meinem%20letzten%20Artikel%20%C3%BCber%20die%20Type-Traits-Bibliothek%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D1871b6df2d2be4d0eb8106e7c177d867%26rm%3Dopen_article_id%26bid%3D3224652%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22mediasync_id%22%3A%22%22%7D" href="/exec/mainmenu.pl?sid=1871b6df2d2be4d0eb8106e7c177d867&amp;rm=open_article_id&amp;bid=3224652">meinem letzten Artikel über die Type-Traits-Bibliothek</a> habe ich nur über Typabfragen und Typvergleiche geschrieben. Bevor ich über den Korrektheitsaspekt der Type-Traits-Bibliothek schreibe, möchte ich kurz auf Typmodifikationen eingehen.</div><div class="ztitel">Typmodifikationen<br></div><div class="text">Die Type-Traits-Bibliothek bietet viele Metafunktionen zur Manipulation von Typen. Hier sind die Interessantesten:<br></div><div class="pre">// const-volatile modifications:<br>remove_const;<br>remove_volatile;<br>remove_cv;<br>add_const;<br>add_volatile;<br>add_cv;<br><br>// reference modifications:<br>remove_reference;<br>add_lvalue_reference;<br>add_rvalue_reference;<br><br>// sign modifications:<br>make_signed;<br>make_unsigned;<br><br>// pointer modifications:<br>remove_pointer;<br>add_pointer;<br><br>// other transformations:<br>decay;<br>enable_if;<br>conditional;<br>common_type;<br>underlying_type;</div><div class="text">Um aus einem <span class="tx_code">int</span> oder einem <span class="tx_code">const int</span> einen <span class="tx_code">int</span> zu erhalten, musst du mit <span class="tx_code">::type</span> nach dem Typ fragen.</div><div class="pre">std::is_same&lt;int, std::remove_const&lt;int&gt;::type&gt;::value; // true<br>std::is_same&lt;int, std::remove_const&lt;const int&gt;::type&gt;::value; // true</div><div class="text">Seit C++14 kannst du einfach _t verwenden, um den Typ zu erhalten, wie bei std::remove_const_t:</div><div class="pre">std::is_same&lt;int, std::remove_const_t&lt;int&gt;&gt;::value; // true<br>std::is_same&lt;int, std::remove_const_t&lt;const int&gt;&gt;::value; // true</div><div class="text">Um eine Vorstellung davon zu bekommen, wie nützlich diese Metafunktionen aus der Type-Traits-Bibliothek sind, hier ein paar Beispiele:</div><div class="text"><ul><li><span class="tx_code"><b>std::decay</b></span>:<span class="tx_code"> std::thread</span> wendet<span class="tx_code"> std::decay</span> auf seine Argumente an. Zu den Argumenten von <span class="tx_code">std::thread</span> gehören die ausgeführte Funktion<span class="tx_code"> f </span>und ihre Argumente <span class="tx_code">args</span>. Decay bedeutet, dass implizite Konvertierungen von Array-zu-Zeiger, Funktion-zu-Zeiger durchgeführt werden und const/volatile-Qualifier und -Referenzen entfernt werden.</li><li><b><span class="tx_code">std::enable_if</span></b> ist eine bequeme Möglichkeit, SFINAE zu verwenden. SFINAE steht für "Substitution Failure Is Not An Error" (Eine fehlgeschlagene Substitution ist kein Fehler) und wird bei der Überladung eines Funktions-Templates angewendet. Das heißt, wenn die Substitution des Template-Parameters fehlschlägt, wird die Spezialisierung aus der Menge aller möglichen Überladungen verworfen, aber dieser Fehler verursacht keinen Compilerfehler.</li><li><b><span class="tx_code">std::conditional</span></b> ist der ternäre Operator zur Compiletime.</li><li><b><span class="tx_code">std::common_type</span></b> bestimmt den gemeinsamen Typ aller Typen, in den alle Typen umgewandelt werden können.</li><li><b><span class="tx_code">std::underlying_type</span></b> bestimmt den Typ einer <span class="tx_code">enum</span>.<br></li></ul></div><div class="text">Vielleicht bist du noch nicht von den Vorteilen der Type-Traits-Bibliothek überzeugt. Ich möchte meine Beitragsserie daher mit ihren beiden Hauptzielen beenden: Korrektheit und Optimierung.</div><div class="ztitel">Korrektheit</div><div class="text">Korrektheit bedeutet, dass du die Type-Traits-Bibliothek in C++11 nutzen kannst, um deinen Algorithmus sicherer zu machen. Die folgende Implementierung des gcd-Algorithmus setzt voraus, dass der binäre Modulo-Operator für seine Argumente gültig ist.</div><div class="pre">// gcd2.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>template&lt;typename T&gt;<br>T gcd(T a, T b) {<br>&nbsp;&nbsp;&nbsp; static_assert(std::is_integral&lt;T&gt;::value, "T should be an integral type!");&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; if( b == 0 ){ return a; }<br>&nbsp;&nbsp;&nbsp; else{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return gcd(b, a % b);<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; gcd(100, 33) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; gcd(3.5,4.0) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; gcd("100","10") &lt;&lt; '\n';<br><br>}</div><div class="text">Die Fehlermeldung ist eindeutig:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/3/1/3/8/6/TN_222014512_c4be23f16d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Der Compiler beschwert sich sofort, dass ein <span class="tx_code">double</span> oder ein <span class="tx_code">const char*</span> kein ganzzahliger Datentyp ist, da der<span class="tx_code"> static_assert</span>-Ausdruck in (1) zuschlägt.<br></div><div class="text">Aber Korrektheit bedeutet, dass du die Type-Traits-Bibliotheken nutzen kannst, um Concepts wie <span class="tx_code">Integral</span>, <span class="tx_code">SignedIntegral</span> und <span class="tx_code">UnsignedIntegral</span> in C++20 zu implementieren.</div><div class="pre">template &lt;typename T&gt;<br>concept Integral = std::is_integral&lt;T&gt;::value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>template &lt;typename T&gt;<br>concept SignedIntegral = Integral&lt;T&gt; &amp;&amp; std::is_signed&lt;T&gt;::value;&nbsp;&nbsp; // (2)<br><br>template &lt;typename T&gt;<br>concept UnsignedIntegral = Integral&lt;T&gt; &amp;&amp; !SignedIntegral&lt;T&gt;;</div><div class="text">Das Concept <span class="tx_code">Integral</span> verwendet direkt die type-traits-Funktionen <span class="tx_code">std::is_integra</span>l (1) und das Concept <span class="tx_code">SignedIntegral</span> die type-traits-Funktion <span class="tx_code">std::is_signed</span> (2). Probieren wir es aus und verwenden wir das Concept <span class="tx_code">Integral</span> direkt.</div><div class="pre">// gcdIntegral.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>template &lt;typename T&gt;<br>concept Integral = std::is_integral&lt;T&gt;::value;<br><br>template &lt;typename T&gt;<br>concept SignedIntegral = Integral&lt;T&gt; &amp;&amp; std::is_signed&lt;T&gt;::value;<br><br>template &lt;typename T&gt;<br>concept UnsignedIntegral = Integral&lt;T&gt; &amp;&amp; !SignedIntegral&lt;T&gt;;<br><br>Integral auto gcd(Integral auto a, decltype(a) b) {<br>&nbsp;&nbsp;&nbsp; if( b == 0 ){ return a; }<br>&nbsp;&nbsp;&nbsp; else{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return gcd(b, a % b);<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; gcd(100, 33) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; gcd(3.5,4.0) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; gcd("100","10") &lt;&lt; '\n';<br><br>}</div><div class="text">Der gcd-Algorithmus ist nun einfacher zu lesen. Er setzt voraus, dass das erste Argument <span class="tx_code">a</span> und sein Rückgabetyp ganzzahlige Datentypen sind. Um sicherzustellen, dass das zweite Argument <span class="tx_code">b</span> den gleichen Typ hat wie das erste Argument <span class="tx_code">a,</span> habe ich seinen Typ als <span class="tx_code">decltype(a) </span>angegeben. Folglich sind diese Implementierung des gcd-Algorithmus und die vorherige in gcd2.cpp gleichwertig.</div><div class="text">Jetzt ist die Fehlermeldung ausführlicher als die vorherige:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/3/1/3/8/6/TN_222014517_4ea5767cec.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Die Fehlermeldung des GCC ist nicht nur zu langatmig, sondern auch zu schwer zu lesen. Lass mich Clang im Compiler Explorer ausprobieren. Die Fehlermeldung über die fehlerhafte Verwendung von <span class="tx_code">double</span> liest sich wie Prosa:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/3/1/3/8/6/TN_222014522_290130f048.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Ehrlich gesagt glaube ich nicht, dass eine Fehlermeldung verständlicher formuliert sein könnte.<br></div><div class="text">Schließlich wollte ich noch den neuesten Microsoft Visual Studio Compiler ausprobieren. Dieser Compiler unterstützt Concepts mit einer Ausnahme: der sogenannten Abbreviated Function Template Syntax. Du hast es vielleicht schon erraten. Ich habe die Abbreviated Function Template Syntax in meinem gcd-Algorithmus verwendet. Du kannst mehr über diese schöne Syntax in meinem vorherigen Beitrag lesen: <a title="Link auf https://heise.de/-4615468" alt="%7B%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4615468%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4615468%22%2C%22text%22%3A%22C%2B%2B20%3A%20Concepts%20-%20Syntactic%20Sugar%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%7D" href="https://heise.de/-4615468">C++20: Concepts - Syntactic Sugar</a>.</div><div class="ztitel">Wie geht es weiter?</div><div class="text">Du weißt natürlich, worüber ich in meinem nächsten Beitrag schreiben werde: die Performanz-Geschichte&nbsp; der Type-Traits-Bibliothek.<br></div>