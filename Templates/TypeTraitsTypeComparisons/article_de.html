<div class="vorspann">Nach dem Artikel zu <a title="Link auf https://heise.de/-6273014" alt="%7B%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6273014%22%2C%22text%22%3A%22Typpr%C3%BCfungen%20zur%20Compiletime%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6273014%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" href="https://heise.de/-6273014">Typprüfungen zur Compiletime</a> mit der Type-Traits-Bibliothek folgen nun Typvergleichen beim Kompilieren. <br></div><div><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/2/1/5/2/7/TN_221254672_7472b9c29b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Die Type-Traits Bibliothek ermöglicht es, Typen zur Compiletime vergleichen, sodass sie nicht die Laufzeit belasten. <br> </div><div class="ztitel">Typvergleiche</div><div class="text">Die Type-Traits Bibliothek unterstützt in C++11 drei Arten von Vergleichen:</div><div class="pre"><ul><li>is_base_of&lt;Base, Derived&gt;</li><li>is_convertible&lt;From, To&gt;</li><li>is_same&lt;T, U&gt;</li></ul></div><div class="text">Mit C++20 haben wir zwei zusätzliche Funktionen:<br></div><div class="pre"><ul><li>is_pointer_interconvertible_with_class&lt;From, To&gt;</li><li>is_pointer_interconvertible_base_of&lt;Base, Derived&gt;</li></ul></div><div class="text">Der Einfachheit halber schreibe ich nur über die C++11-Metafunktionen.</div><div class="text">Dank ihres Attributes gibt jedes Template <span class="tx_code">true</span> oder <span class="tx_code">false</span> zurück und ist daher die optimale Ergänzung zu <span class="tx_code">static_assert.</span></div><div class="pre">// compare.cpp<br><br>#include &lt;cstdint&gt;<br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>class Base{};<br>class Derived: public Base{};<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "std::is_base_of&lt;Base,Derived&gt;::value: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_base_of&lt;Base,Derived&gt;::value &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "std::is_base_of&lt;Derived,Base&gt;::value: "<br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_base_of&lt;Derived,Base&gt;::value &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "std::is_base_of&lt;Derived,Derived&gt;::value: "<br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_base_of&lt;Derived,Derived&gt;::value &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; // static_assert(std::is_base_of&lt;Derived,Base&gt;::value,<br>&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Derived is not base of Base");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) <br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "std::is_convertible&lt;Base*,Derived*&gt;::value: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_convertible&lt;Base*,Derived*&gt;::value &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "std::is_convertible&lt;Derived*,Base*&gt;::value: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_convertible&lt;Derived*,Base*&gt;::value &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "std::is_convertible&lt;Derived*,Derived*&gt;::value: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_convertible&lt;Derived*,Derived*&gt;::value &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; // static_assert(std::is_convertible&lt;Base*,Derived*&gt;::value,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Base* can not be converted to Derived*");&nbsp; // (2)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "std::is_same&lt;int, int32_t&gt;::value: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_same&lt;int, int32_t&gt;::value &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "std::is_same&lt;int, int64_t&gt;::value: "<br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_same&lt;int, int64_t&gt;::value &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "std::is_same&lt;long int, int64_t&gt;::value: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_same&lt;long int, int64_t&gt;::value &lt;&lt; '\n';<br>&nbsp; // static_assert(std::is_same&lt;int, int64_t&gt;::value,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "int is not the same type as int64_t");&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>}<br></div><div class="text">Die Ausgabe des Programms sollte nicht überraschen.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/2/1/5/2/7/TN_221254675_239af09814.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="text">Wenn ich<span class="tx_code"> static_assert</span> in (1), (2) und (3) verwende, wird die Zusicherung zur Compiletime ausgelöst:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/2/1/5/2/7/TN_221254682_1749746527.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="text">Die Website cppreference.com enthält mögliche Implementierungen aller Meta-Funktionen&nbsp; <span class="tx_code"> <a title="Link auf https://en.cppreference.com/w/cpp/types/is_base_of" alt="%7B%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_base_of%22%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_base_of%22%2C%22text%22%3A%22std%3A%3Ais_base_of%22%7D" href="https://en.cppreference.com/w/cpp/types/is_base_of">std::is_base_of</a>,</span><a title="Link auf https://en.cppreference.com/w/cpp/types/is_same" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_same%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22std%3A%3Ais_convertible%22%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_same%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%7D" href="https://en.cppreference.com/w/cpp/types/is_same">std::is_convertible</a> und <a title="Link auf https://en.cppreference.com/w/cpp/types/is_same" alt="%7B%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_same%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_same%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22std%3A%3Ais_same%22%7D" href="https://en.cppreference.com/w/cpp/types/is_same">std::is_same</a><span class="tx_code">.</span> Es ist sehr interessant und herausfordernd, sie zu studieren. </div><div class="ztitel_kleiner">Implementierung<br></div><div class="text">Hier sind zunächst einmal drei Implementierungen der drei Metafunktionen. Ich beginne mit der einfachsten: </div><div class="text"><ul><li><b><span class="tx_code">std::is_same</span></b></li></ul></div><div class="text">Im folgenden Beispiel verwende ich den Namensraum <span class="tx_code">rgr</span>, um meine Implementierung von der C++ Standardimplementierung zu unterscheiden.</div><div class="pre">// isSame.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>namespace rgr {<br><br>&nbsp; template&lt;class T, T v&gt;<br>&nbsp; struct integral_constant {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static constexpr T value = v;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef T value_type;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef integral_constant type;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr operator value_type() const noexcept { return value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //since c++14:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr value_type operator()() const noexcept { return value; } <br>&nbsp; };<br><br>&nbsp; typedef integral_constant&lt;bool, true&gt; true_type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; typedef integral_constant&lt;bool, false&gt; false_type;<br>&nbsp; <br>&nbsp; template&lt;class T, class U&gt;<br>&nbsp; struct is_same : false_type {};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; template&lt;class T&gt;<br>&nbsp; struct is_same&lt;T, T&gt; : true_type {};<br><br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "rgr::is_same&lt;int, const int&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rgr::is_same&lt;int, const int&gt;::value &lt;&lt; '\n';&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "rgr::is_same&lt;int, volatile int&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rgr::is_same&lt;int, volatile int&gt;::value &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "rgr::is_same&lt;int, int&gt;::value: " &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rgr::is_same&lt;int, int&gt;::value &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::is_same&lt;int, const int&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_same&lt;int, const int&gt;::value &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::is_same&lt;int, volatile int&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_same&lt;int, volatile int&gt;::value &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::is_same&lt;int, int&gt;::value: " &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_same&lt;int, int&gt;::value &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text">Zunächst eine kurze Erinnerung: Der Aufruf des Funktions-Templates<span class="tx_code"> rgr::is_same&lt;int, const int&gt;</span> (1) bewirkt den Aufruf des Ausdrucks<span class="tx_code"> rgr::false_type::value</span> (2), da<span class="tx_code"> std::is_same&lt;&gt;</span> von <span class="tx_code">false_type</span> (3) abgeleitet ist. <span class="tx_code">rgr::false_type::value</span> ist ein Alias für <span class="tx_code">rgr::integral_constant&lt;bool, false&gt;::value</span> (2). Ich verwende im Beispiel den statischen <span class="tx_code">constexpr</span> Wert der Klasse <span class="tx_code">integral_constant. integral_constant</span> ist die Basisklasse der type-traits Funktionen.</div><div class="text">Zwei Fakten sind bei folgender Ausgabe interessant. Meine Implementierungen <span class="tx_code">rgr::is_same</span> verhalten sich wie <span class="tx_code">std::is_same</span> und <span class="tx_code">const</span> und <span class="tx_code">volatile</span> sind Teil des Typs.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/2/1/5/2/7/TN_221254690_9bf05fa7c0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Es ist recht einfach, die Metafunktion <span class="tx_code">isSameIgnoringConstVolatile</span> auf der Grundlage der Metafunktion<span class="tx_code"> is_same</span> zu implementieren.</div><div class="pre">// isSameIgnoringConstVolatile.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>namespace rgr {<br><br>&nbsp; template&lt;class T, T v&gt;<br>&nbsp; struct integral_constant {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static constexpr T value = v;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef T value_type;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef integral_constant type;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr operator value_type() const noexcept { return value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //since c++14:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr value_type operator()() const noexcept { return value; }<br>&nbsp; };<br><br>&nbsp; typedef integral_constant&lt;bool, true&gt; true_type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp; typedef integral_constant&lt;bool, false&gt; false_type;<br><br>&nbsp; template&lt;class T, class U&gt;<br>&nbsp; struct is_same : false_type {};<br>&nbsp;<br>&nbsp; template&lt;class T&gt;<br>&nbsp; struct is_same&lt;T, T&gt; : true_type {};<br>&nbsp; <br>&nbsp; template&lt;typename T, typename U&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; struct isSameIgnoringConstVolatile: rgr::integral_constant&lt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgr::is_same&lt;typename std::remove_cv&lt;T&gt;::type, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typename std::remove_cv&lt;U&gt;::type&gt;::value &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; &gt; {};<br><br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "rgr::isSameIgnoringConstVolatile&lt;int, const int&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rgr::isSameIgnoringConstVolatile&lt;int, const int&gt;::value <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "rgr::is_same&lt;int, volatile int&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rgr::isSameIgnoringConstVolatile&lt;int, volatile int&gt;::value <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "rgr::isSameIgnoringConstVolatile&lt;int, int&gt;::value: " &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rgr::isSameIgnoringConstVolatile&lt;int, int&gt;::value &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text">Die Metafunktion <span class="tx_code">isSameIgnoringConstVolatile</span> leitet sich von <span class="tx_code">rgr::integral_constant</span> ab und verwendet die Funktion <span class="tx_code">std::remove_cv</span>, um <span class="tx_code">const</span> oder <span class="tx_code">volatile</span> aus ihren Typen zu entfernen. <span class="tx_code">std::remove_cv</span> ist eine Funktion aus der Type-Traits Bibliothek und ermöglicht es, Typen zur Compiletime zu ändern. Ich werde in meinem nächsten Beitrag mehr über die Modifikation von Typen schreiben.</div><div class="text">Hier ist die Ausgabe des Programms:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/2/1/5/2/7/TN_221254698_818b14cd37.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Schauen wir uns die beiden Metafunktionen<span class="tx_code"> std::is_base_of </span>und <span class="tx_code">std::is_convertible</span> genauer an. Hier sind mögliche Implementierungen von ihnen direkt von cppreference.com.</div><div class="text"><ul><li><b><span class="tx_code">std::is_base_of</span></b></li></ul></div><div class="pre">namespace details {<br>&nbsp;&nbsp;&nbsp; template &lt;typename B&gt;<br>&nbsp;&nbsp;&nbsp; std::true_type test_pre_ptr_convertible(const volatile B*);<br>&nbsp;&nbsp;&nbsp; template &lt;typename&gt;<br>&nbsp;&nbsp;&nbsp; std::false_type test_pre_ptr_convertible(const volatile void*);<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; template &lt;typename, typename&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of(...) -&gt; std::true_type;<br>&nbsp;&nbsp;&nbsp; template &lt;typename B, typename D&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of(int) -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decltype(test_pre_ptr_convertible&lt;B&gt;(static_cast&lt;D*&gt;(nullptr)));<br>}<br>&nbsp;<br>template &lt;typename Base, typename Derived&gt;<br>struct is_base_of :<br>&nbsp;&nbsp;&nbsp; std::integral_constant&lt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_class&lt;Base&gt;::value &amp;&amp; std::is_class&lt;Derived&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decltype(details::test_pre_is_base_of&lt;Base, Derived&gt;(0))::value<br>&nbsp;&nbsp;&nbsp; &gt; { };</div><div class="text"><ul><li><b><span class="tx_code">std::is_convertible</span></b></li></ul></div><div class="pre">namespace detail {<br>&nbsp;<br>template&lt;class T&gt;<br>auto test_returnable(int) -&gt; decltype(<br>&nbsp;&nbsp;&nbsp; void(static_cast&lt;T(*)()&gt;(nullptr)), std::true_type{}<br>);<br>template&lt;class&gt;<br>auto test_returnable(...) -&gt; std::false_type;<br>&nbsp;<br>template&lt;class From, class To&gt;<br>auto test_implicitly_convertible(int) -&gt; decltype(<br>&nbsp;&nbsp;&nbsp; void(std::declval&lt;void(&amp;)(To)&gt;()(std::declval&lt;From&gt;())), std::true_type{}<br>);<br>template&lt;class, class&gt;<br>auto test_implicitly_convertible(...) -&gt; std::false_type;<br>&nbsp;<br>} // namespace detail<br>&nbsp;<br>template&lt;class From, class To&gt;<br>struct is_convertible : std::integral_constant&lt;bool,<br>&nbsp;&nbsp;&nbsp; (decltype(detail::test_returnable&lt;To&gt;(0))::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp; decltype(detail::test_implicitly_convertible&lt;From, To&gt;(0))::value) ||<br>&nbsp;&nbsp;&nbsp; (std::is_void&lt;From&gt;::value &amp;&amp; std::is_void&lt;To&gt;::value)<br>&gt; {};</div><div class="text">Das ist der Grund, warum ich<span class="tx_code"> std::is_same</span> erklärt habe. Zum Abschluss folgt eine kleine Challenge. <br> </div><div class="ztitel">Meine Herausforderung<br> </div><div class="text">Erklärt die beiden Implementierung der type-traits Funktionen <span class="tx_code">std::is_base_of</span> und<span class="tx_code"> std::is_convertible</span>. Schickt eure Erklärung bis Donnerstag (2. Dezember) an <a title="Link auf Rainer.Grimm@ModernesCpp.de" alt="%7B%22text%22%3A%22Rainer.Grimm%40ModernesCpp.de%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22mailto%3ARainer.Grimm%40ModernesCpp.de%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22type%22%3A%22E_Mail%22%2C%22target%22%3A%22%22%2C%22destination%22%3A%22Rainer.Grimm%40ModernesCpp.de%22%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%7D" href="mailto:Rainer.Grimm@ModernesCpp.de">Rainer.Grimm@ModernesCpp.de</a>. Die beste Antwort für jede Funktion erhält einen Gutschein für mein LeanPub-Bundle<a title="Link auf https://leanpub.com/b/modernccollection" alt="%7B%22href%22%3A%22https%3A%2F%2Fleanpub.com%2Fb%2Fmodernccollection%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22%20Modern%20C%2B%2B%20Collection.%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fleanpub.com%2Fb%2Fmodernccollection%22%2C%22ir_link%22%3A1%7D" href="https://leanpub.com/b/modernccollection"> Modern C++ Collection.</a> </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/2/1/5/2/7/TN_221254699_ec374fe998.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Ich veröffentliche die beste Antwort zu jeder Funktion in meinem nächsten Beitrag und nenne die Vornamen der Einsender. Wenn ich deinen vollständigen Namen nennen soll, schreibe mir dies bitte.</div><div class="ztitel">Wie geht's weiter? </div><div class="text">Dank der Type-Traits Bibliothek kannst du Typen zur Compiletime verändern. Ich stelle diese Typmodifikation in meinem nächsten Beitrag genauer vor.</div><div class="ztitel">Online-Schulung: Clean Code: Best Practices für modernes C++<br></div><div class="text">Ich freue mich darauf, meine nächste Online-Schulung vom <b>14.12 - 16.12.2021</b> durchzuführen. Jeder Teilnehmer erhält eines meiner Bücher zur freien Auswahl und einen Gutschein für meinen Onlinekurs <a title="Link auf https://www.educative.io/courses/cpp-fundamentals-for-professionals" alt="%7B%22text%22%3A%22C%2B%2B%20Fundamentals%20for%20Professionals%22%2C%22href%22%3A%22https%3A%2F%2Fwww.educative.io%2Fcourses%2Fcpp-fundamentals-for-professionals%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.educative.io%2Fcourses%2Fcpp-fundamentals-for-professionals%22%7D" href="https://www.educative.io/courses/cpp-fundamentals-for-professionals">C++ Fundamentals for Professionals</a>. Die Schulung findet definitiv statt.<br></div><div class="text">Mehr Informationen zu meinen Schulung gibt es hier: <a title="Link auf https://www.modernescpp.de/index.php/c" alt="%7B%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Modernes%20C%2B%2B%22%7D" href="https://www.modernescpp.de/index.php/c">Modernes C++</a>. </div>