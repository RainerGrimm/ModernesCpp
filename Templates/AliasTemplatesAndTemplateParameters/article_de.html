<div class="vorspann">Heute schreibe ich über zwei Themen: Alias Templates und Template-Parameter. Alias-Templates sind eine Möglichkeit, einer Familie von Typen einen eingängigen Namen zu geben. Template-Parameter können Typen, Nicht-Typen und Templates selbst sein.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/1/6/7/5/8/TN_211932537_3c7b803765.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Mit den Alias Templates möchte ich beginnen.</div><div class="ztitel">Alias-Templates</div><div class="text">Seit C++11 unterstützt die Programmiersprache Alias Templates. Sie bieten eine Möglichkeit, einer Familie von Typen einen lesbaren Namen zu geben. Der folgende Codeschnipsel zeigt die Idee für das Klassen-Template <span class="tx_code">Matrix</span>.</div><div class="pre">template &lt;typename T, int Line, int Col&gt;<br>class Matrix{<br>&nbsp;&nbsp;&nbsp; ....<br>};</div><div class="text">Matrix besitzt drei Template-Parameter. Den Typ-Parameter <span class="tx_code">T</span> und die Nicht-Typ-Parameter<span class="tx_code"> Line</span> und <span class="tx_code">Col</span> (Details zu den Template-Parametern folgen im nächsten Abschnitt).</div><div class="text">Aus Gründen der Lesbarkeit möchte ich zwei spezielle Matrizen haben: <span class="tx_code">Square</span> und <span class="tx_code">Vector</span>. Die Anzahl der Zeilen und Spalten der Matrix <span class="tx_code">Square</span> sollten gleich sein. Die Zeilenzahl von <span class="tx_code">Vector</span> sollte eins sein. Dank Typ-Aliasen kann ich meine Ideen direkt im Code ausdrücken.</div><div class="pre">template &lt;typename T, int Line&gt;<br>using Square = Matrix&lt;T, Line, Line&gt;; // (1)<br><br>template &lt;typename T, int Line&gt;<br>using Vector = Matrix&lt;T, Line, 1&gt;;&nbsp;&nbsp;&nbsp; // (2)</div><div class="text">Das Schlüsselwort <span class="tx_code">using</span> ((1) und (2)) deklariert einen Typ-Alias. Während das primäre Template <span class="tx_code">Matrix</span> in den drei Dimensionen<span class="tx_code"> T, Line</span> und <span class="tx_code">Col</span> parametrisiert werden kann, reduzieren die Typ-Aliase <span class="tx_code">Square</span> und <span class="tx_code">Vector</span> die Parametrisierung auf die zwei Dimensionen <span class="tx_code">T</span> und <span class="tx_code">Line</span>. Aus dieser Sicht ermöglichen es Alias Templates, intuitive Namen für teilweise gebundene Templates zu erstellen. Die Verwendung von <span class="tx_code">Square</span> und <span class="tx_code">Vector</span> ist intuitiv.</div><div class="pre">Matrix&lt;int, 5, 3&gt; ma;<br>Square&lt;double, 4&gt; sq;<br>Vector&lt;char, 5&gt; vec;</div><div class="text">Ein anschaulicher Anwendungsfall von Alias Templates ist die <a title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" alt="%7B%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22type-traits%20Bibliothek%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22target%22%3A%22_blank%22%7D" href="https://en.cppreference.com/w/cpp/header/type_traits">type-traits Bibliothek</a>.</div><div class="ztitel_kleiner">Type-Traits Bibliothek<br> </div><div class="text">Wenn du <span class="tx_code">std::move(arg)</span> auf einen Wert <span class="tx_code">arg</span> anwendest, greift der Compiler typischerweise auf <span class="tx_code"> <a title="Link auf https://en.cppreference.com/w/cpp/types/remove_reference" alt="%7B%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fremove_reference%22%2C%22text%22%3A%22std%3A%3Aremove_reference%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fremove_reference%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D" href="https://en.cppreference.com/w/cpp/types/remove_reference">std::remove_reference</a></span> zurück, um eine Referenz vom zugrunde liegenden Datentyp zu entfernen:</div><div class="pre">static_cast&lt;std::remove_reference&lt;decltype(arg)&gt;::type&amp;&amp;&gt;(arg);&nbsp;&nbsp; // (1)<br><br>static_cast&lt;std::remove_reference_t&lt;decltype(arg)&gt;&amp;&amp;&gt;(arg);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)</div><div class="text">Dank der Alias Templates ist die Version (Zeile 2) seit C++14 gültig. Der folgende Hilfs-Datentyp ist verfügbar:</div><div class="pre">template&lt; class T &gt;<br>using remove_reference_t = typename remove_reference&lt;T&gt;::type;</div><div class="text">Natürlich bietet die <a title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" alt="%7B%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22type-traits%20Bibliothek%22%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" href="https://en.cppreference.com/w/cpp/header/type_traits">type-traits Bibliothek</a> die entsprechenden Hilfs-Datentypen für weitere Funktionen, die ein Datentyp anbietet.<br></div><div class="text">Das zuvor definierte&nbsp; Klassen-Template <span class="tx_code">Matrix</span> verwendet die beiden Nicht-Typ-Template-Parameter <span class="tx_code">Line</span> und <span class="tx_code">Col</span>.</div><div class="ztitel">Template-Parameter</div><div class="text">Template-Parameter können Typen, Nicht-Typen und Templates selbst sein.</div><div class="ztitel_kleiner">Typen</div><div class="text">Typen sind die am häufigsten verwendeten Template-Parameter. Hier ein paar Beispiele:</div><div class="pre">std::vector&lt;int&gt; myVec;<br>std::map&lt;std::string, int&gt; myMap;<br>std::lock_guard&lt;std::mutex&gt; myLockGuard;</div><div class="ztitel_kleiner">Nicht-Typen</div><div class="text">Nicht-Typen können sein:<br></div><div class="text"><ul><li>lvalue-Referenz</li><li><span class="tx_code">nullptr</span></li><li>Zeiger</li><li>Aufzähler einer <span class="tx_code">enum</span><br></li><li>Ganzzahl-Werte<br></li><li>Fließkomma-Werte (C++20)<br></li></ul></div><div class="text">Ganzzahl-Werte sind die am häufigsten verwendeten Nicht-Typen. <span class="tx_code">std::array</span> ist das typische Beispiel, weil seine Größe zur Compilezeit spezifiziert werden muss:</div><div class="pre">std::array&lt;int, 3&gt; myArray{1, 2, 3};</div><div class="ztitel_kleiner">Templates</div><div class="text">Templates selbst können Template-Parameter sein. Ihre Definition wirkt auf den ersten Blick ein wenig eigentümlich:</div><div class="pre">// templateTemplateParameters.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;list&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br><br>template &lt;typename T, template &lt;typename, typename&gt; class Cont &gt;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>class Matrix{<br>public:<br>&nbsp; explicit Matrix(std::initializer_list&lt;T&gt; inList): data(inList) {&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; for (auto d: data) std::cout &lt;&lt; d &lt;&lt; " ";<br>&nbsp; }<br>&nbsp; int getSize() const{<br>&nbsp;&nbsp;&nbsp; return data.size();<br>&nbsp; }<br><br>private:<br>&nbsp; Cont&lt;T, std::allocator&lt;T&gt;&gt; data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>};<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp; Matrix&lt;int, std::vector&gt; myIntVec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "myIntVec.getSize(): " &lt;&lt; myIntVec.getSize() &lt;&lt; '\n';<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; Matrix&lt;double, std::vector&gt; myDoubleVec{1.1, 2.2, 3.3, 4.4, 5.5}; // (5)<br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "myDoubleVec.getSize(): "&nbsp; &lt;&lt; myDoubleVec.getSize() &lt;&lt; '\n';<br><br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp; Matrix&lt;std::string, std::list&gt; myStringList{"one", "two", "three", "four"}; &nbsp;<br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "myStringList.getSize(): " &lt;&lt; myStringList.getSize() &lt;&lt; '\n';<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text"><span class="tx_code">Matrix</span> ist ein Klassen-Template, das mit einer<span class="tx_code"> std::initializer_list</span> (Zeile 2) initialisiert werden muss. Eine <span class="tx_code">Matrix</span> kann mit einem <span class="tx_code">std::vector</span> (Zeile 4 und Zeile 5), oder einer <span class="tx_code">std::list</span> (Zeile 6) verwendet werden, um ihre Werte zu halten. So weit, nichts Besonderes.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/1/6/7/5/8/TN_211932542_83f4aacb32.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> <br> </div><div class="text">Aber halt, ich habe vergessen, Zeile 1 und Zeile 3 zu erläutern. Zeile 1 deklariert ein Klassen-Template, das zwei Template-Parameter besitzt. Okay, der erste Parameter ist der Typ der Elemente und der zweite Parameter steht für den Container. Schauen wir uns den zweiten Parameter genauer an: <span class="tx_code">template &lt;typename, typename&gt; class Cont &gt;</span>. Das bedeutet, dass der zweite Template-Parameter ein Template sein soll, das zwei Template-Parameter benötigt. Der erste Template-Parameter ist der Datentyp der Elemente, die der Container speichert, und der zweite Template-Parameter ist der Allokator, den jeder Container der Standard-Template-Bibliothek besitzt. Auch der Allokator hat einen Defaultwert, wie im Fall eines<span class="tx_code"> std::vector</span>. Der Allokator hängt vom Datentyp der Elemente ab.</div><div class="pre">template&lt;<br>&nbsp;&nbsp;&nbsp; class T,<br>&nbsp;&nbsp;&nbsp; class Allocator = std::allocator&lt;T&gt;<br>&gt; class vector;</div><div class="text">Zeile 3 zeigt die Verwendung des Allokators im intern verwendeten Container. Die Matrix kann alle Container verwenden, die von der Art<span class="tx_code"> container&lt;Typ der Elemente, Allocator der Elemente&gt;</span> sind. Dies gilt für die <a title="Link auf https://en.cppreference.com/w/cpp/container" alt="%7B%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcontainer%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcontainer%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Sequenzcontainer%22%2C%22alias%22%3A%22%22%7D" href="https://en.cppreference.com/w/cpp/container">Sequenzcontainer</a> wie <span class="tx_code">std::vector, std::deque</span> oder<span class="tx_code"> std::list. std::array</span> und <span class="tx_code">std::forward_list</span> würden scheitern, da <span class="tx_code">std::array</span> einen zusätzlichen Nicht-Typ zur Angabe seiner Größe zur Compilezeit benötigt und <span class="tx_code">std::forward_list</span> die <span class="tx_code">size</span>-Memberfunktion nicht unterstützt.</div><div class="text">Wen das Schlüsselwort <span class="tx_code">class</span> für den Namen des Template-Parameters irritiert [--] mit C++17 kann dafür <span class="tx_code">typename</span> verwendet werden:</div><div class="pre">template &lt;typename T, template &lt;typename, typename&gt; class Cont &gt;&nbsp;&nbsp;&nbsp; // (1)<br>class Matrix;<br><br>template &lt;typename T, template &lt;typename, typename&gt; typename Cont &gt; // (2) <br>class Matrix;</div><div class="text">Zeile (2) ist seit C++17 gültig und äquivalent zu Zeile (1).</div><div class="ztitel">Das nächste pdf-Bundle: Coroutines</div><div class="text">In dem Artikel "Which pdf bundle do you want? Make your choice!" fiel die Wahl auf das Coroutine-Bundle.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/1/6/7/5/8/TN_211932550_4a5594ad73.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="text">Ich bin noch dabei, das Bundle vorzubereiten. In den nächsten Tagen sollte es aber verfügbar sein. <br></div><div class="text">Wenn du den <a title="Link auf https://www.modernescpp.com/" alt="%7B%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2F%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22englischen%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2F%22%7D" href="https://www.modernescpp.com/">englischen</a> oder <a title="Link auf https://www.grimm-jaud.de/index.php/blog" alt="%7B%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22deutschen%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%22%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%7D" href="https://www.grimm-jaud.de/index.php/blog">deutschen</a> Newsletter abonnierst, bekommst du automatisch den Link zum aktuellen pdf-Bundle. Schau mal rechts oben auf dieser Seite nach. Dieser Automatismus macht es für mich ganz bequem. Leute, die bereits meinen Newsletter abonniert haben, bekommen den Link automatisch.</div><div class="ztitel">Wie geht's weiter?</div><div class="text">In meinem nächsten Artikel schreibe ich über Template-Argumente. Es ist sehr interessant, wie der Compiler automatisch die Datentypen bestimmt. Die Regeln gelten nicht nur für Funktions-Templates (C++98), sondern auch für <span class="tx_code">auto</span> (C++11), für Klassen-Templates (C++17) und Concepts (C++20).</div>