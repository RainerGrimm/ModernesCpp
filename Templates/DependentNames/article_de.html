<div class="vorspann">Ein abhängiger Name ist ein Name, der von einem Template abhängt. Er kann ein Typ, ein Nichttyp oder ein Template-Parameter sein. <br></div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/8/1/6/6/1/TN_217906156_6aa7080277.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Um abhängige Namen in Template zu verstehen, beginnt dieser Artikel mit Template-Parametern. Sie können Typen, Nichttypen oder Templates sein.<br></div>
<div class="ztitel_kleiner">Typen</div>
<div class="text">Typen sind die am häufigsten verwendeten Template-Parameter. Hier sind ein paar Beispiele:</div>
<div class="pre">std::vector&lt;int&gt; myVec;<br>std::map&lt;std::string, int&gt; myMap;<br>std::lock_guard&lt;std::mutex&gt; myLockGuard;</div>
<div class="ztitel_kleiner">Nichttypen</div>
<div class="text">Nichttypen können sein:</div>
<div class="text"><ul><li> Lvalue-Referenzen</li><li>nullptr</li><li>Zeiger</li><li>Aufzähler</li><li>Integrale Datentypen<br></li></ul></div>
<div class="text">Integrale Datentypen sind wohl die bekanntesten Nichttypen.<i> std::array </i>ist ein typisches Beispiel, denn sein Datentyp und seine Größe müssen zur Compilezeit angegeben werden:</div>
<div class="pre">std::array&lt;int, 3&gt; myArray{1, 2, 3};</div>
<div class="text">Mit C++20 lassen sich zwei neue Nichttypen verwenden: Fließkommatypen und literale Typen.</div>
<div class="text">Literale Typen müssen im Wesentlichen die folgenden zwei Eigenschaften besitzen:</div>
<div class="text"><ul><li>Alle Basisklassen und nicht-statischen Datenelemente sind <span class="tx_code">public</span> und nicht veränderbar.</li><li>Die Typen aller Basisklassen und nicht-statischen Datenelemente sind Strukturtypen oder Arrays von Strukturtypen.</li></ul></div>
<div class="text">Ein literaler Typ muss einen <span class="tx_code">constexpr</span>-Konstruktor besitzen.<br></div>
<div class="text">Das folgende Programm verwendet Fließkommatypen und Literal-Typen als Template-Parameter.</div>
<div class="pre">// nonTypeTemplateParameter.cpp<br><br>struct ClassType {<br>&nbsp;&nbsp;&nbsp; constexpr ClassType(int) {}&nbsp; // (1)<br>};<br><br>template &lt;ClassType cl&gt; // (2)<br>auto getClassType() {<br>&nbsp;&nbsp;&nbsp; return cl;<br>}<br><br>template &lt;double d&gt; // (3)<br>auto getDouble() {<br>&nbsp;&nbsp;&nbsp; return d;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; auto c1 = getClassType&lt;ClassType(2020)&gt;();<br><br>&nbsp;&nbsp;&nbsp; auto d1 = getDouble&lt;5.5&gt;(); // (4)<br>&nbsp;&nbsp;&nbsp; auto d2 = getDouble&lt;6.5&gt;(); // (4)<br><br>}</div>
<div class="text"><span class="tx_code">ClassType</span> hat einen <span class="tx_code">constexpr</span>-Konstruktor (1) und kann als Template-Argument verwendet werden (2). Das Funktions-Template <span class="tx_code">getDouble</span> (3) kann nur <span class="tx_code">double</span>-Werte annehmen. Ich möchte ausdrücklich betonen, dass jeder Aufruf der Funktionsvorlage <span class="tx_code">getDouble</span> (4) mit einem neuen Argument die Instanziierung einer neuen Spezialisierung von <span class="tx_code">getDouble</span> auslöst.&nbsp; Das bedeutet, dass es zwei Instanziierungen für die <span class="tx_code">double</span>-Werte 5.5 und 6.5 gibt.<br></div>
<div class="ztitel_kleiner">Templates</div>
<div class="text">Templates können selbst Template-Parameter sein. In diesem Fall werden sie Template-Template-Parameter genannt. <br></div>
<div class="pre">// templateTemplateParameters.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;list&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br><br>template &lt;typename T, template &lt;typename, typename&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class Cont &gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // (1)<br>class Matrix{<br>public:<br>&nbsp; explicit Matrix(std::initializer_list&lt;T&gt; inList): <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data(inList){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; for (auto d: data) std::cout &lt;&lt; d &lt;&lt; " ";<br>&nbsp; }<br>&nbsp; int getSize() const{<br>&nbsp;&nbsp;&nbsp; return data.size();<br>&nbsp; }<br><br>private:<br>&nbsp; Cont&lt;T, std::allocator&lt;T&gt;&gt; data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>};<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp; Matrix&lt;int, std::vector&gt; myIntVec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "myIntVec.getSize(): " &lt;&lt; myIntVec.getSize() &lt;&lt; '\n';<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp; Matrix&lt;double, std::vector&gt; myDoubleVec{1.1, 2.2, 3.3, 4.4, 5.5}; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "myDoubleVec.getSize(): "<br>&nbsp; &nbsp; &lt;&lt; myDoubleVec.getSize() &lt;&lt; '\n';<br><br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp; Matrix&lt;std::string, std::list&gt; myStringList{"one", "two", <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "three", "four"};&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "myStringList.getSize(): " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; myStringList.getSize() &lt;&lt; '\n';<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>}<br></div>
<div class="text"><span class="tx_code">Matrix</span> ist ein einfaches Klassen-Template, dass sich über eine <span class="tx_code">std::initializer_list</span> (2) initialisieren lässt. Eine <span class="tx_code">Matrix</span> kann einen <span class="tx_code">std::vector </span>(4 und 5) oder eine<span class="tx_code"> std::list</span> (6) verwenden, um ihre Werte zu speichern. Soweit, nichts besonderes.<br></div>
<div class="ztitel_kleiner"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/8/1/6/6/1/TN_217906162_14d788f079.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Stopp, ich habe (1) und (3) ignoriert. (1) deklariert ein Klasse-Template, das zwei Template-Parameter benötigt. Der erste Parameter steht für den Datentyp der Elemente und der zweite für den Container, der die Datenelemente speichert. Insbesondere der zweite Parameter verdient eine genauere Betrachtung: <span class="tx_code">template &lt;typename, typename&gt; class Cont&gt;</span>. Das heißt, das zweite Template-Argument ist ein Template, das selbst zwei Template-Parameter benötigt. Der erste Template-Parameter steht in diesem Fall für den Datentyp der Elemente, die der Container speichert und der zweite ist der Allokator, den ein Container der Standard Template Library besitzt. Der Allokator besitzt einen Default wie im Fall von <span class="tx_code"><a title="Link auf https://en.cppreference.com/w/cpp/container/vector" alt="%7B%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcontainer%2Fvector%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22std%3A%3Avector%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcontainer%2Fvector%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%7D" href="https://en.cppreference.com/w/cpp/container/vector" class="">std::vector</a></span>. Der Allokator ist vom Elemente abhängig: <br></div>
<div class="pre">template&lt;<br>&nbsp;&nbsp;&nbsp; typename T,<br>&nbsp;&nbsp;&nbsp; typename Allocator = std::allocator&lt;T&gt;<br>&gt; class vector;<br></div>
<div class="text">(3 )zeigt die Anwendung des Allokators in der Matrix. Matrix kann alle Container verwenden, die nach dem Muster <span class="tx_code">Container&lt; Datentyp der Elemente, Allokator für die Elemente&gt;</span> gestrickt sind. Dies trifft auf die sequenziellen Container wie<span class="tx_code"> std::vector, std::deque</span> oder <span class="tx_code">std::list </span><i>zu. </i><span class="tx_code">std::array </span>und<span class="tx_code"> std::forward_list</span> können nicht verwendet werden, da <i>std::array </i>einen zusätzlichen Parameter besitzt, um seine Größe zur Compilezeit anzugeben und<span class="tx_code"> std::forward_list</span> die <span class="tx_code">size</span>-Methode nicht unterstützt.</div>
<div class="text">Nun habe ich die Grundlagen gelegt und komme zum zentralen Punkt dieses Artikels.</div>
<div class="ztitel">Abhängige Namen<br></div>
<div class="text">Zuerst einmal: Was ist ein abhängiger Name? Er ist im Wesentlichen ein Name, der von einem Template-Parameter abhängt. Hier sind sein paar Beispiel, basierend auf <a title="Link auf https://en.cppreference.com/w/cpp/language/dependent_name" alt="%7B%22text%22%3A%22cppreference.com%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fdependent_name%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fdependent_name%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" href="https://en.cppreference.com/w/cpp/language/dependent_name" class="">cppreference.com</a>: <br></div>
<div class="pre">template&lt;typename T&gt;<br>struct X : B&lt;T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // "B&lt;T&gt;" is dependent on T<br>{<br>&nbsp;&nbsp;&nbsp; typename T::A* pa;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // "T::A" is dependent on T<br>&nbsp;&nbsp;&nbsp; void f(B&lt;T&gt;* pb) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int i = B&lt;T&gt;::i; // "B&lt;T&gt;::i" is dependent on T<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb-&gt;j++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // "pb-&gt;j" is dependent on T<br>&nbsp;&nbsp;&nbsp; }<br>};</div>
<div class="text">Jetzt geht es los mit dem Spaß. Ein abhängiger Name kann ein Typ, ein Nichttyp oder ein Template selbst sein. Die Namensauflösung ist der erste große Unterschied zwischen einem nicht abhängigen und einem abhängigen Namen.</div>
<div class="text"><ul><li> <b>Nicht abhängige</b> Name werden bei der Template-Definition aufgelöst.</li><li><b>Abhängige Namen</b> werden bei der Template-Instanziierung aufgelöst.<br></li></ul></div>
<div class="text">Beim Verwenden eines abhängigen Namens in einer Template, weiß der Compiler nicht, ob sich der Name auf einen Typen, einen Nichttypen oder ein Template bezieht. In diesem Fall nimmt der Compiler an, dass der abhängig Namen für einen Nichttyp steht. Das kann natürlich falsch sein. Hier muss man dem Compiler unter die Schulter greifen.</div>
<div class="text">Bevor ich zwei Beispiele zeige, muss ich der Vollständigkeit halber noch auf eine Ausnahme der Regel hinweisen. Wer nur an der zentralen Idee interessiert ist, kann diese Zeile gerne ignorieren und zum nächsten Abschnitt springen. Hier ist die Ausnahme der Regel: Wenn der Name sich auf die aktuelle Instanziierung (current instantiation) bezieht, kann der Compiler den Namen bereits zum Zeitpunkt der Template-Definition bestimmen. Hier sind ein paar Beispiele:</div>
<div class="pre">template &lt;typename T&gt;<br>class A {<br>&nbsp;&nbsp;&nbsp; A* p1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // A is the current instantiation<br>&nbsp;&nbsp;&nbsp; A&lt;T&gt;* p2;&nbsp;&nbsp; // A&lt;T&gt; is the current instantiation<br>&nbsp;&nbsp;&nbsp; ::A&lt;T&gt;* p4; // ::A&lt;T&gt; is the current instantiation<br>&nbsp;&nbsp;&nbsp; A&lt;T*&gt; p3;&nbsp;&nbsp; // A&lt;T*&gt; is not the current instantiation<br>};<br><br>template &lt;class T&gt; <br>class A&lt;T*&gt; {<br>&nbsp;&nbsp;&nbsp; A&lt;T*&gt;* p1;&nbsp; // A&lt;T*&gt; is the current instantiation<br>&nbsp;&nbsp;&nbsp; A&lt;T&gt;* p2;&nbsp;&nbsp; // A&lt;T&gt; is not the current instantiation<br>};<br><br>template &lt;int I&gt; <br>struct B {<br>&nbsp;&nbsp;&nbsp; static const int my_I = I;<br>&nbsp;&nbsp;&nbsp; static const int my_I2 = I+0;<br>&nbsp;&nbsp;&nbsp; static const int my_I3 = my_I;<br>&nbsp;&nbsp;&nbsp; B&lt;my_I&gt;* b3;&nbsp; // B&lt;my_I&gt; is the current instantiation<br>&nbsp;&nbsp;&nbsp; B&lt;my_I2&gt;* b4; // B&lt;my_I2&gt; is not the current instantiation<br>&nbsp;&nbsp;&nbsp; B&lt;my_I3&gt;* b5; // B&lt;my_I3&gt; is the current instantiation<br>};<br></div>
<div class="text">Hier ist nochmals der zentrale Punkt meines Artikels. Falls ein abhängiger Name ein Typ oder ein Template ist, benötigt der Compiler Hilfe. </div>
<div class="ztitel_kleiner">Verwende <i>typename,</i> falls der abhängige Name ein Typ ist</div>
<div class="text">Nach solch einer langen Einleitung sollte das nächste Programmbeispiel die Mehrdeutigkeit auf den Punkt bringen:</div>
<div class="pre">template &lt;typename T&gt;<br>void test(){<br>&nbsp;&nbsp;&nbsp; std::vector&lt;T&gt;::const_iterator* p1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; typename std::vector&lt;T&gt;::const_iterator* p2; // (2)<br>}</div>
<div class="text">Ohne das Schlüsselwort <span class="tx_code">typename</span> in (2) würde der Name<span class="tx_code"> std::vector&lt;T&gt;::const_iterator</span> in (2) als Nichttyp interpretiert werden und damit wäre konsequenterweise das <span class="tx_code">*</span> Symbol eine Multiplikation und keine Zeigerdeklaration. Genau das passiert in (1).&nbsp;</div>
<div class="text">Entsprechend gilt, dass der Compiler einen Hinweis benötigt, falls der abhängige Name ein Template sein soll.<br></div>
<div class="ztitel_kleiner">Verwende <i>.template,</i> falls der abhängige Name ein Template ist</div>
<div class="text">Ehrlich gesagt, schaut die Syntax sehr gewöhnungsbedürftig aus:<br></div>
<div class="pre">template&lt;typename T&gt;<br>struct S{<br>&nbsp;&nbsp;&nbsp; template &lt;typename U&gt; void func(){}<br>}<br>template&lt;typename T&gt;<br>void func2(){<br>&nbsp;&nbsp;&nbsp; S&lt;T&gt; s;<br>&nbsp;&nbsp;&nbsp; s.func&lt;T&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; s.template func&lt;T&gt;();&nbsp;&nbsp;&nbsp; // (2)<br>}<br></div>
<div class="text">Dieselbe Geschichte wie gerade eben. Vergleiche (1) und (2). Wenn der Compiler den Name <span class="tx_code">s.func</span> liest (1), entscheidet er, diesen als Nichttyp zu interpretieren. Dies bedeutet, dass das &lt;-Zeichen für einen Vergleichsoperator steht, aber nicht für die öffnende Klammer des Template-Arguments der generischen Methode<span class="tx_code"> func</span><i>. </i>In diesem Fall muss angegeben werden, dass<span class="tx_code"> s.func </span>für ein Template steht (2):&nbsp;<span class="tx_code"> s.template func. </span></div>
<div class="text">Hier ist die Zentralaussage dieses Artikels in einem Satz:<b> Wer einen abhängigen Namen hat, muss </b><span class="tx_code">typename</span><b> verwenden, um auszudrücken, dass es sich um einen Typ handelt oder </b><span class="tx_code">.template</span><b><i>, </i>um auszudrücken, dass es sich um ein Template handelt. </b></div>
<div class="ztitel">Wie geht es weiter?</div>
<div class="text">In meinem nächsten Artikel stelle ich automatische Rückgabetypen genauer vor. Sie sind oft ein Lebensretter, wenn es um Funktions-Templates geht.<br></div>