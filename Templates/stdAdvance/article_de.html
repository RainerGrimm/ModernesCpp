<div class="vorspann">Nach der std::advance-Implementierung auf Basis von Tag-Dispatching zeigt der Beitrag diesmal Umsetzungen von std::advance vor, die auf constexpr if und Concepts basieren.<br></div><div class="text">In meinem letzten Artikel habe ich eine mögliche<span class="tx_code"> std::advance</span>-Implementierung auf Basis von Tag-Dispatching (C++98) vorgestellt. Einer meiner Leser erwähnte, dass ich<span class="tx_code"> std::advance</span> auch auf Basis von<span class="tx_code"> constexpr if</span> (C++17) oder Concepts (C++20) implementieren kann. Stimmt! In diesem Artikel stelle ich zwei weitere Implementierungen von<span class="tx_code"> std::advance</span> vor.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/4/4/7/1/9/3/TN_236289945_787c8322e3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="text">Eine kurze Erinnerung:<span class="tx_code"> std::advance(it, n)</span> erhöht einen gegebenen Iterator<span class="tx_code"> it</span> um<span class="tx_code"> n</span> Elemente. Wenn<span class="tx_code"> n</span> negativ ist, wird der Iterator dekrementiert. Abhängig vom Container und dem Iterator, der vom Container bereitgestellt wird, kommt die passende Version von<span class="tx_code"> std::advance</span> zum Einsatz. Typsicherheit und Performanz sind die zwei Gründe für diese maßgeschneiderte Varianten. In meinem letzten Artikel "<a title="Link auf https://heise.de/-6599217" alt="%7B%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6599217%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Softwaredesign%20mit%20Traits%20und%20Tag%20Dispatching%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6599217%22%7D" href="https://heise.de/-6599217">Softwaredesign mit Traits und Tag Dispatching</a>" habe ich<span class="tx_code"> std::advance</span> basierend auf Tag Dispatching implementiert. Bevor ich auf eine mögliche<span class="tx_code"> std::advance</span>-Implementierung auf Basis von <span class="tx_code">constexpr if</span> (C++17) oder Concepts (C++20) eingehe, möchte ich noch einmal die auf Tag Dispatching basierend Implementierung (C++98) kurz vorstellen.</div><div class="ztitel">Tag Dispatching (C++98)</div><div class="text">Ich nenne die Funktion <span class="tx_code">advance_</span>, um sie von <span class="tx_code">std::advance</span> zu unterscheiden.</div><div class="pre">// advance_.cpp<br><br>#include &lt;iterator&gt;<br>#include &lt;forward_list&gt;<br>#include &lt;list&gt;<br>#include &lt;vector&gt;<br>#include &lt;iostream&gt;<br><br>template &lt;typename InputIterator, typename Distance&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>void advance_impl(InputIterator&amp; i, Distance n, std::input_iterator_tag) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "InputIterator used" &lt;&lt; '\n'; <br>&nbsp;&nbsp;&nbsp; while (n--) ++i;<br>}<br><br>template &lt;typename BidirectionalIterator, typename Distance&gt; <br>void advance_impl(BidirectionalIterator&amp; i, Distance n,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::bidirectional_iterator_tag) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "BidirectionalIterator used" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; if (n &gt;= 0) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (n--) ++i;<br>&nbsp;&nbsp;&nbsp; else <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (n++) --i;<br>}<br><br>template &lt;typename RandomAccessIterator, typename Distance&gt; <br>void advance_impl(RandomAccessIterator&amp; i, Distance n, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::random_access_iterator_tag) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "RandomAccessIterator used" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; i += n;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>}<br><br>template &lt;typename InputIterator, typename Distance&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>void advance_(InputIterator&amp; i, Distance n) {<br>&nbsp;&nbsp;&nbsp; typename <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::iterator_traits&lt;InputIterator&gt;::iterator_category category;<br>&nbsp;&nbsp;&nbsp; advance_impl(i, n, category);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br>&nbsp; <br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; myVec{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; auto myVecIt = myVec.begin();&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myVecIt: " &lt;&lt; *myVecIt &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; advance_(myVecIt, 5);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myVecIt: " &lt;&lt; *myVecIt &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::list&lt;int&gt; myList{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; auto myListIt = myList.begin();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myListIt: " &lt;&lt; *myListIt &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; advance_(myListIt, 5);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myListIt: " &lt;&lt; *myListIt &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::forward_list&lt;int&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myForwardList{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; auto myForwardListIt = myForwardList.begin();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myForwardListIt: " &lt;&lt; *myForwardListIt &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; advance_(myForwardListIt, 5);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myForwardListIt: " &lt;&lt; *myForwardListIt &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>}</div><div class="text">Ohne weitere Umschweife: Hier ist die Ausgabe des Programms. </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/4/4/7/1/9/3/TN_236289951_486883219d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="text">Die Details zu Tag Dispatching lassen sich in meinem vorherigen "<a title="Link auf https://heise.de/-6599217" alt="%7B%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6599217%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Softwaredesign%20mit%20Traits%20und%20Tag%20Dispatching%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6599217%22%2C%22anchor%22%3A%22%22%7D" href="https://heise.de/-6599217">Softwaredesign mit Traits und Tag Dispatching</a>" nachlesen.<br></div><div class="ztitel_kleiner"><span class="tx_code">constexpr if</span> (C++17)</div><div class="text"><span class="tx_code">constexpr if</span> ermöglicht es, Quellcode bedingt zu übersetzen<br></div><div class="pre">template &lt;typename T&gt;<br>auto getValue(T t) {<br>&nbsp;&nbsp;&nbsp; if constexpr (std::is_pointer_v&lt;T&gt;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *t; // deduces return type to int for T = int*<br>&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return t;&nbsp; // deduces return type to int for T = int<br>}</div><div class="text">Der Ausdruck in<span class="tx_code"> constexpr if</span> muss ein Compilezeitprädikat sein: eine Funktion, die einen booleschen Wert zurückgibt und zur Compilezeit ausgeführt wird. In diesem Fall kommt die Type-Traits Funktions<span class="tx_code"> std::is_pointer </span>zum Einsatz. Beide Zweige der <span class="tx_code">constexpr if </span>Kontrollstruktur (Zeilen 1 und 2) müssen gültig sein.</div><div class="text">Die folgende Implementierung von<span class="tx_code"> std::advance</span> ist eine Kopie von <a title="Link auf https://en.cppreference.com/w/cpp/iterator/advance" alt="%7B%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fiterator%2Fadvance%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22cppreference.com%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fiterator%2Fadvance%22%7D" href="https://en.cppreference.com/w/cpp/iterator/advance">cppreference.com</a>. Ich habe lediglich einige Zeilenmarkierungen hinzugefügt und die Funktion in <span class="tx_code">advance_</span> umbenannt, damit sie mit dem Funktionsnamen in meinem vorherigen Programm<span class="tx_code"> advance_.cpp</span> übereinstimmt. Folglich lässt sich die vorherige C++98-basierende durch diese neue Implementierung ersetzen:</div><div class="pre">// implementation via constexpr if, available in C++17<br>template&lt;class It, class Distance&gt;<br>constexpr void advance_(It&amp; it, Distance n)<br>{<br>&nbsp;&nbsp;&nbsp; using category = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typename std::iterator_traits&lt;It&gt;::iterator_category;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; static_assert(std::is_base_of_v&lt;std::input_iterator_tag,&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; category&gt;);&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; auto dist = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typename std::iterator_traits&lt;It&gt;::difference_type(n);&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; if constexpr (std::is_base_of_v&lt;std::random_access_iterator_tag, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; category&gt;) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it += dist;<br>&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (dist &gt; 0) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // (6)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --dist;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++it;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if constexpr (std::is_base_of_v&lt;std::bidirectional_iterator_tag,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; category&gt;) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (dist &lt; 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++dist;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --it;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</div><div class="text">Diese Implementierung bestimmt die Iterator-Kategorie anhand des verwendeten Iterators (1) und fordert, dass die Iterator-Kategorie von <span class="tx_code">std::input_iterator_tag </span>abgeleitet ist (2). In (3) wird der Wert für die Inkrementierung des Iterators festgelegt. Jetzt kommt<span class="tx_code"> constexpr if </span>ins Spiel.&nbsp; Je nach Typ des Iterators wird (4), (5) oder (6) verwendet. (4) erfordert einen <span class="tx_code">std::random_access_iterator</span>, (5) einen<span class="tx_code"> std::bidirectional_iterator</span> und (6) nimmt die verbleibenden Iteratoren an.<br></div><div class="text">Die folgende Grafik zeigt, welcher Container die Kompilierung welches<span class="tx_code"> constexpr if </span>Zweigs auslöst:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/4/4/7/1/9/3/TN_236289960_8443662d06.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Ehrlich gesagt ist die C++98-Version, die auf Tag Dispatching basiert, einfacher zu verstehen. Dazu springe ich drei Jahre vorwärts, um den Fortschritt mit Concepts umsetzen.</div><div class="ztitel">Concepts (C++20)</div><div class="text">C++20 unterstützt die folgenden Concepts für Iteratoren:</div><div class="pre">std::input_or_output_iterator<br>std::input_iterator<br>std::output_iterator<br>std::forward_iterator<br>std::bidirectionaler_iterator<br>std::random_access_iterator<br>std::contiguous_iterator</div><div class="text">Ein<span class="tx_code"> std::input_output_iterator</span> unterstützt die Operationen <span class="tx_code">++It, It++</span>&nbsp; und<span class="tx_code"> *It</span>.&nbsp; Sowohl<span class="tx_code"> std::input_iterator </span>als auch <span class="tx_code">std::output_iterator</span> sind bereits ein&nbsp;<span class="tx_code"> std::input_or_output_iterator</span>. Es gelten die folgende Beziehungen: Ein zusammenhängender Iterator <span class="tx_code">(std::contiguous_iterator</span>) ist ein Iterator mit wahlfreiem Zugriff (<span class="tx_code">std::random_access_iterator</span>), ein Iterator mit wahlfreiem Zugriff ist ein bidirektionaler Iterator (<span class="tx_code">std::bidirectionaler_iterator</span>) und ein bidirektionaler Iterator ist ein Vorwärts-Iterator (<span class="tx_code">std::forward_iterator</span>). Ein zusammenhängender Iterator setzt voraus, dass die Elemente des Containers zusammenhängend im Speicher abgelegt sind.</div><div class="text">Dank Concepts ist die Implementierung von<span class="tx_code"> advance_</span> ziemlich einfach umzusetzen. Ich überlade lediglich <span class="tx_code">advance_</span> auf den Concepts und verwende dabei Concepts als eingeschränkte Typparameter.</div><div class="pre">// conceptsAdvance.cpp<br><br>#include &lt;concepts&gt;<br>#include &lt;iostream&gt;<br>#include &lt;forward_list&gt;<br>#include &lt;list&gt;<br>#include &lt;vector&gt;<br><br>template&lt;std::input_iterator I&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>void advance_(I&amp; i, int n){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "InputIterator used" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; while (n--) ++i;<br>}<br><br>template&lt;std::bidirectional_iterator I&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>void advance_(I&amp; i, int n){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "BidirectionalIterator used" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; if (n &gt;= 0) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (n--) ++i;<br>&nbsp;&nbsp;&nbsp; else <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (n++) --i;<br>}<br><br>template&lt;std::random_access_iterator I&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>void advance_(I&amp; i, int n){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "RandomAccessIterator used" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; i += n; &nbsp;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::forward_list forwList{1, 2, 3};<br>&nbsp;&nbsp;&nbsp; std::forward_list&lt;int&gt;::iterator itFor = forwList.begin();<br>&nbsp;&nbsp;&nbsp; advance_(itFor, 2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br><br>&nbsp;&nbsp;&nbsp; std::list li{1, 2, 3};<br>&nbsp;&nbsp;&nbsp; std::list&lt;int&gt;::iterator itBi = li.begin();<br>&nbsp;&nbsp;&nbsp; advance_(itBi, 2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br><br>&nbsp;&nbsp;&nbsp; std::vector vec{1, 2, 3};<br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt;::iterator itRa = vec.begin();<br>&nbsp;&nbsp;&nbsp; advance_(itRa, 2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>}<br></div><div class="text">Die drei Varianten der Funktion <span class="tx_code">advance_</span> werden für die Concepts<span class="tx_code"> std::input_iterator</span> (1), <span class="tx_code">std::bidirectional_iterator</span> (2) und <span class="tx_code">std::random_access_iterator</span> (3) überladen. Der Compiler wählt die am besten passende Überladung aus. Das bedeutet, dass für eine <span class="tx_code">std::forward_list </span>(4)&nbsp; die auf dem Concept <span class="tx_code">std::forward_iterator</span> basierende Überladung, für eine<span class="tx_code"> std::list </span>(5) die auf dem Concept <span class="tx_code">std::bidirectional_iterator</span> basierende Überladung und für einen<span class="tx_code"> std::vector </span>(6) die auf dem Concept <span class="tx_code">std::random_access_iterator </span>basierende Überladung zum Einsatz kommt.<br></div><div class="text">Der Vollständigkeit halber ist hier die Programmausgabe mit dem <a title="Link auf https://godbolt.org/z/7f65Yfbhq" alt="%7B%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2F7f65Yfbhq%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2F7f65Yfbhq%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22%20Compiler%20Explore%22%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%7D" href="https://godbolt.org/z/7f65Yfbhq"> Compiler Explore</a>r<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/4/4/7/1/9/3/TN_236289965_ca31f9ea9f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Ich weiß nicht, welche Version von <span class="tx_code">advance_</span>&nbsp; die Leserinnen und Leser bevorzuge: die auf Tag Dispatching basierende C++98-Implementierung, die auf<span class="tx_code"> constexpr if </span>basierende C++17-Implementierung oder die auf Concepts basierende C++20-Implementierung. Vom Standpunkt der Lesbarkeit und Wartbarkeit ist die Concept basierende Version mein Favorit. Der Nachteil ist, dass diese Version einen C++20-Compiler verlangt. <a title="Link auf https://en.cppreference.com/w/cpp/compiler_support" alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcompiler_support%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22cppreference.com%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcompiler_support%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" href="https://en.cppreference.com/w/cpp/compiler_support">cppreference.com</a> gibt einen schöne Überblick dazu, welcher C++-Compiler welche C++ Feature unterstützt.</div><div class="ztitel">Wie geht's weiter?</div><div class="text">Nach diesem kurzen Zwischenspiel mit dem<span class="tx_code"> std::advance</span>-Algorithmus, verbinde ich in meinem nächsten Artikel den dynamischen Polymorphismus (Objektorientierung) mit dem statischen Polymorphismus (Templates), um eine ziemlich anspruchsvolle Technik vorzustellen: Type Erasure.</div><div class="ztitel">Meine C++ Schulungen in 2022:</div><div class="text">Dieses Jahr werde ich die folgenden offenen C++-Schulungen anbieten.<br></div><div class="text"><ul><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/37-embedded-programmierung-mit-modernem-c" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F37-embedded-programmierung-mit-modernem-c%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Embedded%20Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F37-embedded-programmierung-mit-modernem-c%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/37-embedded-programmierung-mit-modernem-c">Embedded Programmierung mit modernem C++</a>: 28.06.2022 - 30.06.2022 (Termingarantie)</li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/38-c-20" alt="%7B%22mediasync_id%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F38-c-20%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F38-c-20%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%7D" href="https://www.modernescpp.de/index.php/c/2-c/38-c-20">C++20</a>: 23.08.2022 - 25.08.2022 (Termingarantie)</li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/39-clean-code-best-practices-fuer-modernes-c" alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F39-clean-code-best-practices-fuer-modernes-c%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Clean%20Code%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F39-clean-code-best-practices-fuer-modernes-c%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%7D" href="https://www.modernescpp.de/index.php/c/2-c/39-clean-code-best-practices-fuer-modernes-c">Clean Code</a>: Best Practices für modernes C++: 11.10.2022 - 13.10.2022</li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/36-design-pattern-und-architekturpattern-mit-c" alt="%7B%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F36-design-pattern-und-architekturpattern-mit-c%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Design%20Pattern%20und%20Architekturpattern%20mit%20C%2B%2B%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F36-design-pattern-und-architekturpattern-mit-c%22%2C%22alias%22%3A%22%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/36-design-pattern-und-architekturpattern-mit-c">Design Pattern und Architekturpattern mit C++</a>: 08.11.2022 - 10.11.2022 (Termingarantie)</li></ul></div><div class="text">Zum jetzigen Zeitpunkt geht ich davon aus, dass ich sie als Präsenzschulungen in der Nähe von Stuttgart durchführen kann. Weitere Informationen zu meinen C++ und Python Schulungen und meinem neuen Mentoringprogramm gibt es hier:</div><div class="text"><ul><li><a title="Link auf https://www.modernescpp.de/index.php" alt="%7B%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20und%20Python%20Schulungen%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%22%2C%22alias%22%3A%22%22%7D" href="https://www.modernescpp.de/index.php">C++ und Python Schulungen</a></li><li> <a title="Link auf https://www.modernescpp.org/" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.org%2F%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Mentoring%3A%20Fundamentals%20for%20C%2B%2B%20Professionals%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.org%2F%22%7D" href="https://www.modernescpp.org/">Mentoring: Fundamentals for C++ Professionals</a> <br></li></ul></div>