<div class="text">Nachdem ich in meinem <a title="Link auf Beitrag 3127900" alt="%7B%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D1fe9b7dcdd105fdea13b05ee9b61e693%26rm%3Dopen_article_id%26bid%3D3127900%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22type%22%3A%22B%22%2C%22text%22%3A%22letzten%20Beitrag%22%2C%22version%22%3A1%2C%22destination%22%3A3127900%7D" href="/exec/mainmenu.pl?sid=1fe9b7dcdd105fdea13b05ee9b61e693&amp;rm=open_article_id&amp;bid=3127900" class="">letzten Beitrag</a> die Grundlagen zur Template-Spezialisierung vorgestellt habe, tauche ich heute tiefer ein. Ich möchte die partielle und vollständige Spezialisierung eines Klassen-Templates als Compilezeit if vorstellen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/3/3/4/3/8/TN_213353003_f91b10f196.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Spezialisierung von Klassen-Templates als Compilezeit if</div>
<div class="text">Zu meinen Einführungen in die Template-Spezialisierung habe ich ein paar ähnliche Fragen erhalten, darunter: Wie kann man entscheiden, ob ein Datentyp einen gegebenen Typ besitzt oder zwei Typen gleich sind? Die Beantwortung dieser Fragen ist einfacher als es scheinen mag und hilft mir, weitere Theorien über die Spezialisierung von Klassen-Templates zu präsentieren. Für meine Antwort implementiere ich vereinfachte Versionen von<span class="tx_code"> <a title="Link auf https://en.cppreference.com/w/cpp/types/is_same" alt="%7B%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_same%22%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fis_same%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22std%3A%3Ais_same%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%7D" href="https://en.cppreference.com/w/cpp/types/is_same" class="">std::is_same</a> </span> und<span class="tx_code"> <a title="Link auf https://en.cppreference.com/w/cpp/types/remove_reference" alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fremove_reference%22%2C%22version%22%3A1%2C%22text%22%3A%22std%3A%3Aremove_reference%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fremove_reference%22%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://en.cppreference.com/w/cpp/types/remove_reference" class="">std::remove_reference</a></span>. Die in diesem Post vorgestellten Techniken sind eine Anwendung der Spezialisierung von Klassen-Templates und stellen ein Compilezeit if dar.</div>
<div class="ztitel_kleiner"><span class="tx_code">std::is_same</span></div>
<div class="text"><span class="tx_code">std::is_same </span>ist eine Funktion aus der type-traits-Bibliothek. Sie gibt <a title="Link auf https://en.cppreference.com/w/cpp/types/integral_constant" alt="%7B%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fintegral_constant%22%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fintegral_constant%22%2C%22version%22%3A1%2C%22text%22%3A%22std%3A%3Atrue_type%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%7D" href="https://en.cppreference.com/w/cpp/types/integral_constant" class="">std::true_type</a> zurück, wenn beide Typen gleich sind, andernfalls gibt sie <span class="tx_code">std::false_type</span> zurück. Der Einfachheit halber gebe ich in meiner Implementierung <span class="tx_code">true</span> oder <span class="tx_code">false</span> zurück.</div>
<div class="pre">// isSame.cpp<br><br>#include &lt;iostream&gt;<br><br>template&lt;typename T, typename U&gt; // (1)<br>struct isSame {<br>&nbsp;&nbsp;&nbsp; static constexpr bool value = false;<br>};<br>&nbsp;<br>template&lt;typename T&gt; // (2)<br>struct isSame&lt;T, T&gt; {<br>&nbsp;&nbsp;&nbsp; static constexpr bool value = true;<br>}; <br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSame&lt;int, int&gt;::value: " &lt;&lt; isSame&lt;int, int&gt;::value &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSame&lt;int, int&amp;&gt;::value: " &lt;&lt; isSame&lt;int, int&amp;&gt;::value &lt;&lt; '\n';<br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; int a(2011);<br>&nbsp;&nbsp;&nbsp; int&amp; b(a); // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSame&lt;decltype(a), decltype(b)&gt;::value " &lt;&lt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSame&lt;decltype(a), decltype(b)&gt;::value &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div>
<div class="text">Das primäre Template (1) gibt als Default <span class="tx_code">false</span> zurück, wenn du nach dem Wert fragst. Im Gegensatz dazu gibt die partielle Spezialisierung (2), die verwendet wird, wenn beide Typen gleich sind, <span class="tx_code">true</span> zurück. Das Klassen-Template <span class="tx_code">isSame</span> lässt sich auf Datentypen (3) und, dank <span class="tx_code">decltype</span>, auf Werte (4) anwenden. Der folgende Screenshot zeigt die Ausgabe des Programms:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/3/3/4/3/8/TN_213353009_ff0b54e0e4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Du ahnst es wohl schon? Das Klassen-Template <span class="tx_code">isSame</span> ist ein Beispiel für Template-Metaprogrammierung. Nun muss ich einen kleinen Umweg machen und ein paar Worte über Meta verlieren.<br></div>
<div class="ztitel_kleiner">Metafunktionen und Metadaten</div>
<div class="text">Zur Laufzeit verwenden wir Daten und Funktionen. Zur Compilezeit verwenden wir Metadaten und Metafunktionen. Ganz einfach, es heißt Meta, da wir Metaprogrammierung umsetzen. Was sind Metadaten oder Metafunktionen? Hier ist die erste Definition:</div>
<div class="text"><ul><li><b>Metadaten</b>: Typen und Ganzzahlen, die in Metafunktionen verwendet werden.</li><li><b>Metafunktion</b>: Funktionen, die zur Compilezeit ausgeführt werden.</li></ul></div>
<div class="text">Lass mich die Begriffe Metadaten und Metafunktion näher erläutern.</div>
<div class="text"><b>Metadaten</b> beinhalten drei Entitäten:</div>
<div class="text"><ul><li>Datentypen wie <span class="tx_code">int</span>, <span class="tx_code">double</span> oder <span class="tx_code">std::string</span></li><li>Nicht-Typen wie Ganzzahlen, Enumeratoren, Zeiger, lvalue-Referenzen und Fließkommawerte mit C++20</li><li>Templates</li></ul></div>
<div class="text">In der <b>Metafunktion</b> <span class="tx_code">isSame</span> habe ich nur Datentypen verwendet.</div>
<div class="text">Datentypen wie das Klassen-Template <span class="tx_code">isSame</span> werden in der Template-Metaprogrammierung verwendet, um Funktionen zu simulieren. Basierend auf meiner Definition von Metafunktionen, können <span class="tx_code">constexpr</span>-Funktionen auch zur Compile Time ausgeführt werden und sind somit auch Metafunktionen.</div>
<div class="text">Eine Metafunktion kann nicht nur einen Wert, sie kann auch einen Datentyp zurückgeben. Per Konvention gibt eine Metafunktion einen Wert mittels<span class="tx_code"> ::value</span> und einen Datentyp mittels <span class="tx_code">::type</span> zurück. Die folgende Metafunktion <span class="tx_code">removeReference</span> gibt einen Datentyp als Ergebnis zurück.</div>
<div class="pre">// removeReference.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;utility&gt;<br><br>template&lt;typename T, typename U&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>struct isSame {<br>&nbsp;&nbsp;&nbsp; static constexpr bool value = false;<br>};<br>&nbsp;<br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>struct isSame&lt;T, T&gt; {<br>&nbsp;&nbsp;&nbsp; static constexpr bool value = true<br>}; <br><br>template&lt;typename T&gt; // (1)<br>struct removeReference { <br>&nbsp;&nbsp;&nbsp; using type = T;<br>};<br><br>template&lt;typename T&gt; // (2)<br>struct removeReference&lt;T&amp;&gt; {<br>&nbsp;&nbsp;&nbsp; using type = T; }<br>};<br><br>template&lt;typename T&gt; // (3)<br>struct removeReference&lt;T&amp;&amp;&gt; {<br>&nbsp;&nbsp;&nbsp; using type = T; }<br>};<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSame&lt;int, removeReference&lt;int&gt;::type&gt;::value: " &lt;&lt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSame&lt;int, removeReference&lt;int&gt;::type&gt;::value &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSame&lt;int, removeReference&lt;int&amp;&gt;::type&gt;::value: " &lt;&lt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSame&lt;int, removeReference&lt;int&amp;&gt;::type&gt;::value &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSame&lt;int, removeReference&lt;int&amp;&amp;&gt;::type&gt;::value: " &lt;&lt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSame&lt;int, removeReference&lt;int&amp;&amp;&gt;::type&gt;::value &lt;&lt; '\n';<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br><br>&nbsp;&nbsp;&nbsp; int a(2011);<br>&nbsp;&nbsp;&nbsp; int&amp; b(a);&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSame&lt;int, removeReference&lt;decltype(a)&gt;::type&gt;::value: " &lt;&lt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSame&lt;int, removeReference&lt;decltype(a)&gt;::type&gt;::value &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSame&lt;int, removeReference&lt;decltype(b)&gt;::type&gt;::value: " &lt;&lt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSame&lt;int, removeReference&lt;decltype(b)&gt;::type&gt;::value &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSame&lt;int, removeReference&lt;decltype(std::move(a))&gt;::type&gt;::value: " &lt;&lt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSame&lt;int, removeReference&lt;decltype(std::move(a))&gt;::type&gt;::value &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div>
<div class="text">In diesem Beispiel wende ich die zuvor definierte Metafunktion <span class="tx_code">isSame</span> und die Metafunktion <span class="tx_code">removeReference</span> an. Das primäre Template <span class="tx_code">removeReference</span> (1) gibt T mittels des Bezeichners <span class="tx_code">type</span> zurück. Die partiellen Spezialisierungen für die lvalue-Referenz (2) und die rvalue-Referenz geben ebenfalls<span class="tx_code"> T</span> zurück, indem sie die Referenzen von ihrem Template-Parameter entfernen. Wie zuvor lässt sich die Metafunktion <span class="tx_code">removeReference</span> mit Typen (4) und, dank <span class="tx_code">decltype</span>, mit Werten (5) verwenden. <span class="tx_code">decltype(a)</span> gibt einen Wert, <span class="tx_code">decltype(b</span>) gibt eine lvalue-Referenz und<span class="tx_code"> decltype(std::move(a))</span> gibt eine rvalue-Referenz zurück.</div>
<div class="text">Zum Abschluss folgt hier die Ausgabe des Programms:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/3/3/4/3/8/TN_213353016_eda06e11b3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="text">Es gibt eine Falle, in die ich bereits getappt bin. Wenn eine Memberfunktion eines voll spezialisierten Klassen-Templates außerhalb der Klasse definiert wird, darf nicht<span class="tx_code"> template&lt;&gt;</span> verwendet werden.</div>
<div class="ztitel_kleiner">Memberfunktionen einer Spezialisierung, die außerhalb des Klassenkörpers definiert werden</div>
<div class="text">Das folgende Programm zeigt das Klassen-Template <span class="tx_code">Matrix</span>, das eine partielle und eine vollständige Spezialisierung besitzt.</div>
<div class="pre">// specializationExtern.cpp<br><br>#include &lt;cstddef&gt;<br>#include &lt;iostream&gt;<br><br>template &lt;typename T, std::size_t Line, std::size_t Column&gt; // (1)<br>struct Matrix;<br><br>template &lt;typename T&gt; // (2)<br>struct Matrix&lt;T, 3, 3&gt;{<br>&nbsp;&nbsp;&nbsp; int numberOfElements() const;<br>};<br><br>template &lt;typename T&gt;<br>int Matrix&lt;T, 3, 3&gt;::numberOfElements() const {<br>&nbsp;&nbsp;&nbsp; return 3 * 3;<br>};<br><br>template &lt;&gt; // (3)<br>struct Matrix&lt;int, 4, 4&gt;{<br>&nbsp;&nbsp;&nbsp; int numberOfElements() const;<br>};<br><br>// template &lt;&gt; // (4)<br>int Matrix&lt;int, 4, 4&gt;::numberOfElements() const {<br>&nbsp;&nbsp;&nbsp; return 4 * 4;<br>};<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; Matrix&lt;double, 3, 3&gt; mat1; // (5)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "mat1.numberOfElements(): " &lt;&lt; mat1.numberOfElements() &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; Matrix&lt;int, 4, 4&gt; mat2; // (6)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "mat2.numberOfElements(): " &lt;&lt; mat2.numberOfElements() &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">(1) deklariert das primäre Template, (2) definiert die partielle Spezialisierung und (3) die vollständige Spezialisierung von <span class="tx_code">Matrix</span>. Die Memberfunktionen <span class="tx_code">numberOfElements</span> werden außerhalb des Klassenkörpers definiert. Zeile (4) ist wohl die nicht-intuitive Zeile. Wenn die Memberfunktion <span class="tx_code">numberOfElements</span> außerhalb des Klassenkörpers definiert wird, darf&nbsp; kein<span class="tx_code"> template &lt;&gt;</span> verwendet werden. Zeile (5) bewirkt die Instanziierung der partiellen und Zeile (6) die Instanziierung der vollständigen Spezialisierung.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/3/3/4/3/8/TN_213353031_6313c68870.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">In meinem nächsten Beitrag schreibe ich über die vollständige Spezialisierung von Funktions-Templates und deren überraschendes Zusammenspiel mit Funktionen. Um es kurz zu machen, gemäß den C++ Core Guidelines gilt: <a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-specialize-function" alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-specialize-function%22%2C%22version%22%3A1%2C%22text%22%3A%22T.144%3A%20Don%27t%20specialize%20function%20templates%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-specialize-function%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-specialize-function" class="">T.144: Don't specialize function templates</a>.<br></div>