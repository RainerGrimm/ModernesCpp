<div class="vorspann">Die Type-Traits-Bibliothek hat zwei Hauptziele: Korrektheit und Optimierung. Heute steht die Optimierung im Fokus.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/3/5/1/5/1/TN_222340710_8a0ecee04b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Dieser Beitrag ist der letzte in meiner Miniserie über die Type-Traits-Bibliothek. Ich habe bereits die folgenden Beiträge geschrieben:</div><div class="text"><ul><li> <a title="Link auf https://heise.de/-6273014" alt="%7B%22text%22%3A%22Die%20Type-Traits-Bibliothek%3A%20Typpr%C3%BCfungen%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6273014%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6273014%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%7D" href="https://heise.de/-6273014">Die Type-Traits-Bibliothek: Typprüfungen</a> </li><li> <a title="Link auf https://heise.de/-6277964" alt="%7B%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22Die%20Type-Traits-Bibliothek%3A%20Typvergleiche%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6277964%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6277964%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%7D" href="https://heise.de/-6277964">Die Type-Traits-Bibliothek: Typvergleiche</a> </li><li> <a title="Link auf https://heise.de/-6283615" alt="%7B%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6283615%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6283615%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Die%20Type-Traits-Bibliothek%3A%20std%3A%3Ais_base_of%22%7D" href="https://heise.de/-6283615">Die Type-Traits-Bibliothek: std::is_base_of</a> </li><li> <a title="Link auf https://heise.de/-6292251" alt="%7B%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6292251%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6292251%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Die%20Type-Traits-Bibliothek%3A%20Korrektheit%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" href="https://heise.de/-6292251">Die Type-Traits-Bibliothek: Korrektheit</a> </li></ul></div><div class="text">Bevor ich beginne, über Optimierung in C++ zu schreiben, möchte ich eine kurze Anekdote erzählen. In meinen Kursen führe ich oft das folgende Gespräch mit meinen Teilnehmern:</div><div class="text"><ul><li>Ich: Warum haben wir in C++ das Feature ABC?</li><li>Teilnehmer: Ich weiß es nicht.</li><li>Ich: Wenn Sie keine Antwort haben, sagen Sie einfach Performance. Das funktioniert in C++ immer.</li></ul></div><div class="text">Daher schreibe ich über die Bibliothek der Type Traits aus der Perspektive der Optimierung.<br></div><div class="ztitel">Optimierung<br></div><div class="text">Die Idee ist recht simpel und wird in der Standard Template Library (STL) verwendet. Wenn die Elemente eines Ranges einfach genug sind, werden die Algorithmen der STL wie<span class="tx_code"> std::copy</span>,<span class="tx_code"> std::fill </span>oder <span class="tx_code">std::equa</span>l direkt auf den Speicher angewendet. Anstatt mit <span class="tx_code">std::copy </span>jedes Element einzeln zu kopieren, wird alles in einem einzigen großen Schritt erledigt. Intern werden C-Funktionen wie <a title="Link auf http://en.cppreference.com/w/cpp/string/byte/memcmp" alt="%7B%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22memcmp%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fstring%2Fbyte%2Fmemcmp%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fstring%2Fbyte%2Fmemcmp%22%2C%22type%22%3A%22E%22%7D" href="http://en.cppreference.com/w/cpp/string/byte/memcmp">memcmp</a>, <a title="Link auf http://en.cppreference.com/w/cpp/string/byte/memset" alt="%7B%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fstring%2Fbyte%2Fmemset%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fstring%2Fbyte%2Fmemset%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22memset%22%7D" href="http://en.cppreference.com/w/cpp/string/byte/memset">memset</a>, <a title="Link auf http://en.cppreference.com/w/cpp/string/byte/memcpy" alt="%7B%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22memcpy%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fstring%2Fbyte%2Fmemcpy%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fstring%2Fbyte%2Fmemcpy%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22mediasync_id%22%3A%22%22%7D" href="http://en.cppreference.com/w/cpp/string/byte/memcpy">memcpy</a> oder <a title="Link auf http://en.cppreference.com/w/cpp/string/byte/memmove" alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22memmove%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fstring%2Fbyte%2Fmemmove%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fstring%2Fbyte%2Fmemmove%22%7D" href="http://en.cppreference.com/w/cpp/string/byte/memmove">memmove</a> verwendet. Der kleine Unterschied zwischen <span class="tx_code">memcpy</span> und <span class="tx_code">memmove</span> besteht darin, dass <span class="tx_code">memmove</span> mit überlappenden Speicherbereichen umgehen kann.</div><div class="text">Die Implementierungen des Algorithmus<span class="tx_code"> std::copy, std::fill </span>oder <span class="tx_code">std::equal</span> verwenden eine einfache Strategie. <span class="tx_code">std::copy</span> ist eine Art Wrapper. Dieser Wrapper prüft, ob die Elemente einfach genug sind. Wenn ja, delegiert der Wrapper die Arbeit an die optimierte Kopierfunktion. Wenn nicht, wird der konservative Kopieralgorithmus verwendet. Dieser konservative Algorithmus kopiert jedes Element einzeln. Um die richtige Entscheidung zu treffen, werden die Funktionen der Type-Traits Bibliothek intensiv genutzt.</div><div class="text">Die Grafik zeigt die allgemeine Strategie:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/3/5/1/5/1/TN_222340717_ff884ca1f3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Das war die Theorie, aber hier ist die Praxis. Welche Strategie wird von<span class="tx_code"> std::fill</span> verwendet?</div><div class="ztitel">std::fill</div><div class="text"><span class="tx_code">std::fill</span> weist jedem Element im Bereich einen Wert zu. Das Listing zeigt eine GCC-inspirierte Implementierung von <span class="tx_code">std::fill</span>.</div><div class="pre">// fillGCC.cpp<br>&nbsp;<br>#include &lt;cstring&gt;<br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>namespace my{<br><br>&nbsp; template &lt;typename I, typename T, bool b&gt;<br>&nbsp; void fill_impl(I first, I last, const T&amp; val,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::integral_constant&lt;bool, b&gt;&amp;){<br>&nbsp;&nbsp;&nbsp; while(first != last){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *first = val;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++first;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br><br>&nbsp; template &lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; void fill_impl(T* first, T* last, const T&amp; val, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::true_type&amp;){<br>&nbsp;&nbsp;&nbsp; std::memset(first, val, last-first);<br>&nbsp; }<br><br>&nbsp; template &lt;class I, class T&gt;<br>&nbsp; inline void fill(I first, I last, const T&amp; val){<br>&nbsp;&nbsp;&nbsp; typedef std::integral_constant&lt;bool,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; std::is_trivially_copy_assignable&lt;T&gt;::value <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (sizeof(T) == 1)&gt; boolType;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; fill_impl(first, last, val, boolType());<br>&nbsp; }<br>}<br><br>const int arraySize = 100'000'000;<br>char charArray1[arraySize]= {0,};<br>char charArray2[arraySize]= {0,};<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp; auto begin = std::chrono::steady_clock::now();<br>&nbsp; my::fill(charArray1, charArray1 + arraySize,1);<br>&nbsp; auto last =&nbsp; std::chrono::steady_clock::now() - begin;<br>&nbsp; std::cout &lt;&lt;&nbsp; "charArray1: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::chrono::duration&lt;double&gt;(last).count() &lt;&lt; " seconds\n";<br><br>&nbsp; begin = std::chrono::steady_clock::now();<br>&nbsp; my::fill(charArray2, charArray2 + arraySize, static_cast&lt;char&gt;(1));<br>&nbsp; last=&nbsp; std::chrono::steady_clock::now() - begin;<br>&nbsp; std::cout &lt;&lt;&nbsp; "charArray2: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::chrono::duration&lt;double&gt;(last).count() &lt;&lt; " seconds\n";<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text">Zurück zum Codebeispiel. Wenn der Ausdruck<span class="tx_code"> boolType()</span> in (1) wahr ergibt, wird die optimierte Version von <span class="tx_code">my::fill_impl</span> in (2)&nbsp; verwendet. Diese Variante füllt den gesamten Speicher von 100 Millionen Einträgen mit dem Wert 1.<span class="tx_code"> sizeof(char) </span>ist 1.</div><div class="text">Wie sieht es mit der Performance des Programms aus? Ich habe das Programm ohne Optimierung kompiliert, um die nicht optimierte Leistung zu messen.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/3/5/1/5/1/TN_222340731_af37cfc424.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Die optimierte Version in Zeile (2) ist etwa zehnmal schneller. Interessanterweise sind beide Varianten gleich schnell, wenn ich die vollständige Optimierung aktiviere, da der Compiler für beide Varianten denselben Code erzeugt. Auch die allgemeine Version (3) verwendet <span class="tx_code">memset</span>: mit maximaler Optimierung im <a title="Link auf https://godbolt.org/z/69b4aMrEM" alt="%7B%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Compiler%20Explorer%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2F69b4aMrEM%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2F69b4aMrEM%22%7D" href="https://godbolt.org/z/69b4aMrEM">Compiler Explorer</a>.</div><div class="text">Ich habe eine alte GCC-Implementierung von <span class="tx_code">std::fill </span>vorgestellt, weil die Neueren nicht so einfach zu lesen sind. Hier sind die wesentlichen Teile der GCC 6 Implementierung.</div><div class="pre">// fill &nbsp;<br>// Specialization: for char types we can use memset.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>template&lt;typename _Tp&gt;<br>&nbsp; inline typename<br>&nbsp; __gnu_cxx::__enable_if&lt;__is_byte&lt;_Tp&gt;::__value, void&gt;::__type&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; __fill_a(_Tp* __first, _Tp* __last, const _Tp&amp; __c)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; const _Tp __tmp = __c;<br>&nbsp;&nbsp;&nbsp; if (const size_t __len = __last - __first)<br>&nbsp;&nbsp;&nbsp; __builtin_memset(__first, static_cast&lt;unsigned char&gt;(__tmp), __len);<br>&nbsp; }<br></div><div class="text">Die GCC 6-Implementierung setzt SFINAE ein. Die vollständige Spezialisierung des Funktions-Templates <span class="tx_code">__fill_a</span> verwendet <span class="tx_code">__builtin_memset</span>. Der entscheidende Ausdruck in dieser Implementierung ist Zeile (1): <span class="tx_code">__gnu_cxx::__enable_if&lt;__is_byte&lt;_Tp&gt;::__value, void&gt;::__type</span>. Folgendermaßen sieht dieser Ausdruck lesbarer umgeschrieben und mit den Namen des Standards aus:</div><div class="pre">std::enable_if&lt;std::is_byte&lt;Tp&gt;::value, void&gt;::type</div><div class="text">Der Ausdruck prüft zunächst, ob der Template-Parameter<span class="tx_code"> TP</span> ein Byte ist: <span class="tx_code">std::is_byte&lt;T&gt;::value</span>. Wenn dieser Ausdruck dank<span class="tx_code"> std::enable_if </span>aus der type-traits-Bibliothek <span class="tx_code">false</span> ergibt, tritt SFINAE in Aktion. SFINAE steht für "Substitution Failure Is Not An Error" (Substitutionsfehler ist kein Fehler) und wird bei der Überladungsauflösung eines Funktions-Templates angewendet. Das heißt, wenn die Substituierung des Template-Parameters fehlschlägt, wird die Spezialisierung aus der Menge der Überladungen verworfen. Dieser Fehler verursacht aber keinen Compilerfehler. Das bedeutet in diesem konkreten Fall: Wenn die Bedingung <span class="tx_code">std::is_byte&lt;T&gt;::value false </span>zurückgibt, wird diese vollständige Spezialisierung verworfen und eine allgemeine Version von<span class="tx_code"> __fill_a</span> verwendet.</div><div class="ztitel">Wie geht es weiter?</div><div class="text">Zuerst mache ich eine Weihnachtspause von zwei Wochen. Mein nächster Beitrag wird am 10. Januar 2022 veröffentlicht. Ich werde über<span class="tx_code"> constexpr</span>-Funktionen schreiben, da sie viele Gemeinsamkeiten mit Templates haben und mit C++20 noch leistungsfähiger werden.</div><div class="text">Zweitens möchte ich meinen professionellen Unterricht in C++ verbessern. Deshalb plane ich, ein Mentorenprogramm für C++ zu starten. Bald werde ich mehr Details auf meinem englischen Blog <a title="Link auf https://www.modernescpp.com/" alt="%7B%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Modernes%20C%2B%2B%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2F%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2F%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%7D" href="https://www.modernescpp.com/">Modernes C++</a> Idee veröffentlichen.<br></div>