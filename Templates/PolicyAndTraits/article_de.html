<div class="vorspann">Dank Templates gibt es neue Wege für den Softwareentwurf. Policies und Traits sind zwei dieser neuen Wege, die gerne in C++ verwendet werden.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/8/6/1/4/0/TN_232881473_c5378953cc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Policies und Traits werden oft in einem Zug genannt. Beginnen möchte ich in diesem Artikel mit dem Vorstellen der Policies.</div><div class="ztitel">Policy<br></div><div class="text">Eine Policy ist eine generische Funktion oder Klasse, deren Verhalten konfiguriert werden kann. Normalerweise gibt es Defaultwerte für die Policy-Parameter.<span class="tx_code"> std::vector</span> und<span class="tx_code"> std::unordered_map</span> sind typische Beispiele für Policies.</div><div class="text"><span class="tx_code">template&lt;class T, class Allocator = std::allocator&lt;T&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>class vector; <br><br>template&lt;class Key,<br>&nbsp;&nbsp;&nbsp; class T,<br>&nbsp;&nbsp;&nbsp; class Hash = std::hash&lt;Key&gt;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; class KeyEqual = std::equal_to&lt;Key&gt;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; class allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&nbsp; // (2)<br>class unordered_map;</span></div><div class="text">Diese Deklaration bedeutet, dass beide Container einen Standard-Allokator für ihre Elemente besitzen, der abhängig von<span class="tx_code"> T</span> (Zeile 1) oder von <span class="tx_code">std::pair&lt;const Key, T&gt;</span> (Zeile 2) ist. Außerdem verfügt <span class="tx_code">std::unorderd_map</span> über eine Default-Hash-Funktion (Zeile 3) und eine Default-Gleichheitsfunktion (Zeile 4). Die Hash-Funktion berechnet den Hash-Wert auf der Grundlage des Schlüssels und die Gleichheits-Funktion kümmert sich um Kollisionen in den Buckets. In meinem Artikel "<a title="Link auf https://www.grimm-jaud.de/index.php/blog/hashfunktionen" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fhashfunktionen%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fhashfunktionen%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Hashfunktionen%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/hashfunktionen">Hashfunktionen</a>" findest du mehr Informationen über <span class="tx_code">std::unordered_map.</span></div><div class="text">Lass mich einen benutzerdefinierten Datentyp <span class="tx_code">MyInt</span> als Schlüssel in einer <span class="tx_code">std::unordered_map</span> verwenden:</div><div class="pre">// MyIntAsKey.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;unordered_map&gt;<br><br>struct MyInt{<br>&nbsp;&nbsp;&nbsp; explicit MyInt(int v):val(v){}<br>&nbsp;&nbsp;&nbsp; int val;<br>};<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::unordered_map&lt;MyInt, int&gt; myMap{ {MyInt(-2), -2}, {MyInt(-1), -1}, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {MyInt(0), 0}, {MyInt(1), 1} };<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>}</div><div class="text">Der Versuch, das Programm zu übersetzen, scheitert kläglich, da <span class="tx_code">MyInt</span> weder eine Hash-Funktion noch die Gleichheitsfunktion besitzt.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/8/6/1/4/0/TN_232881477_66e2b0fb6e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="text">Jetzt kommen Policies ins Spiel. Diese können explizit gesetzt werden. Die Klasse <span class="tx_code">MyInt</span> kann daher als Schlüssel in einer<span class="tx_code"> std::unordered_map</span> verwendet werden.</div><div class="pre">// templatesPolicy.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;unordered_map&gt;<br><br>struct MyInt{<br>&nbsp;&nbsp;&nbsp; explicit MyInt(int v):val(v){}<br>&nbsp;&nbsp;&nbsp; int val;<br>};<br><br>struct MyHash{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::size_t operator()(MyInt m) const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::hash&lt;int&gt; hashVal;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hashVal(m.val);<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>struct MyEqual{<br>&nbsp;&nbsp;&nbsp; bool operator () (const MyInt&amp; fir, const MyInt&amp; sec) const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir.val == sec.val;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>std::ostream&amp; operator &lt;&lt; (std::ostream&amp; strm, const MyInt&amp; myIn){&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; strm &lt;&lt; "MyInt(" &lt;&lt; myIn.val &lt;&lt; ")";<br>&nbsp;&nbsp;&nbsp; return strm;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; typedef std::unordered_map&lt;MyInt, int, MyHash, MyEqual&gt; MyIntMap;&nbsp; // (4)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "MyIntMap: ";<br>&nbsp;&nbsp;&nbsp; MyIntMap myMap{{MyInt(-2), -2}, {MyInt(-1), -1}, {MyInt(0), 0}, {MyInt(1), 1}};<br><br>&nbsp;&nbsp;&nbsp; for(auto m : myMap) std::cout &lt;&lt; '{' &lt;&lt; m.first &lt;&lt; ", " &lt;&lt; m.second &lt;&lt; "}";<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>}</div><div class="text">Ich habe die Hash-Funktion (Zeile 1) und die Gleichheitsfunktion (Zeile 2) als Funktionsobjekt implementiert und den Ausgabeoperator (Zeile 3) überladen. Zeile 4 erstellt aus allen Komponenten einen neuen Typ <span class="tx_code">MyIntMap</span>, der <span class="tx_code">MyInt</span> als Schlüssel verwendet. Der folgende Screenshot zeigt die Ausgabe der Instanz <span class="tx_code">myMap</span>.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/8/6/1/4/0/TN_232881484_2fc5fd5df6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Es gibt zwei typische Möglichkeiten, Policies zu implementieren: Komposition und Vererbung.</div><div class="ztitel_kleiner">Komposition</div><div class="text">Die folgende Klasse <span class="tx_code">Message</span> verwendet Komposition, um ihr Ausgabegerät während der Compilezeit zu konfigurieren.</div><div class="pre">// policyComposition.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;fstream&gt;<br>#include &lt;string&gt;<br><br>template &lt;typename OutputPolicy&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>class Message {<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; void write(const std::string&amp; mess) const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outPolicy.print(mess);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; OutputPolicy outPolicy;&nbsp; &nbsp;<br>};<br><br>class WriteToCout {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; void print(const std::string&amp; message) const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; message &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>class WriteToFile {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; void print(const std::string&amp; message) const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::ofstream myFile;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myFile.open("policyComposition.txt");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myFile &lt;&lt; message &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; Message&lt;WriteToCout&gt; messageCout;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; messageCout.write("Hello world");<br><br>&nbsp;&nbsp;&nbsp; Message&lt;WriteToFile&gt; messageFile;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; messageFile.write("Hello world");<br><br>}</div><div class="text">Die Klasse <span class="tx_code">Message</span> besitzt den Template-Parameter <span class="tx_code">OutputPolicy</span> (Zeile 1) als Policy. Ein Aufruf ihrer Mitgliedsfunktion <span class="tx_code">write</span> delegiert direkt an ihr Mitglied <span class="tx_code">outPolicy</span> (Zeile 2). Du kannst zwei verschiedene Message-Instanzen erstellen (Zeile 3 und 4). Eine schreibt in die Konsole (Zeile 5), die andere in eine Datei (Zeile 6).</div><div class="text">Der Screenshot zeigt den Schreibvorgang nach <span class="tx_code">cout</span> und in die Datei<span class="tx_code"> policyComposition.txt</span>.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/8/6/1/4/0/TN_232881492_403db3a3f8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="ztitel_kleiner">Vererbung<br> </div><div class="text">Die auf Vererbung basierende Implementierung ist der auf Komposition basierenden in dem Beispiel <span class="tx_code">policyComposition.cpp</span> sehr ähnlich. Der Hauptunterschied besteht darin, dass die Komposition-Implementierung die Policy besitzt, während die Vererbungs-Implementierung von der Policy abgeleitet ist.</div><div class="pre">// policyInheritance.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;fstream&gt;<br>#include &lt;string&gt;<br><br>template &lt;typename OutputPolicy&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>class Message : private OutputPolicy {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) <br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; void write(const std::string&amp; mess) const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(mess);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; using OutputPolicy::print;<br>};<br><br>class WriteToCout {<br>&nbsp;protected:<br>&nbsp;&nbsp;&nbsp; void print(const std::string&amp; message) const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; message &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>class WriteToFile {<br>&nbsp;protected:<br>&nbsp;&nbsp;&nbsp; void print(const std::string&amp; message) const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::ofstream myFile;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myFile.open("policyInheritance.txt");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myFile &lt;&lt; message &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; Message&lt;WriteToCout&gt; messageCout;<br>&nbsp;&nbsp;&nbsp; messageCout.write("Hello world");<br><br>&nbsp;&nbsp;&nbsp; Message&lt;WriteToFile&gt; messageFile;<br>&nbsp;&nbsp;&nbsp; messageFile.write("Hello world");<br><br>}</div><div class="text">Anstelle der vorherigen Implementierung der Klasse <span class="tx_code">Message</span> leitet diese von ihrem Template-Parameter privat ab und führt die privat geerbte <span class="tx_code">print</span>-Funktion in den Klassenscope ein. Die Ausgabe des Programms überspringe ich aus offensichtlichen Gründen. Okay, ich höre deine Frage: Soll ich Komposition oder Vererbung für die Umsetzung eines Policy-based Design verwenden?</div><div class="ztitel_kleiner">Komposition oder Vererbung</div><div class="text">Im Allgemeinen ziehe ich Komposition der Vererbung vor. Aber für einen Policy-basierten Entwurf solltest du Vererbung in Betracht ziehen.</div><div class="text">Wenn <span class="tx_code">OutputPolicy</span> leer ist, kannst du von der sogenannten <i><a title="Link auf https://en.cppreference.com/w/cpp/language/ebo" alt="%7B%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Febo%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Febo%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22empty%20base%20class%20optimization%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%7D" href="https://en.cppreference.com/w/cpp/language/ebo">empty base class optimization</a></i> profitieren. Leer bedeutet, dass <span class="tx_code">OutputPolicy</span> keine nicht statischen Datenmitglieder und keine nicht leeren Basisklassen hat. Folglich trägt <span class="tx_code">OutputPolicy</span> nicht zur Größe von <span class="tx_code">Message</span> bei. Im Gegenteil dazu gilt jedoch: wenn <span class="tx_code">Message</span> das Member <span class="tx_code">OutputPolicy</span> hat, erhöht <span class="tx_code">OutputPolicy</span> die Größe von <span class="tx_code">Message</span> um mindestens ein Byte. Mein Argument klingt vielleicht nicht überzeugend, aber oft verwendet eine Klasse mehr als eine Policy.</div><div class="ztitel">Wie geht's weiter?</div><div class="text">Traits sind Klassen-Templates, die Eigenschaften aus einem generischen Typ herausziehen. Ich werde in meinem nächsten Beitrag genauer auf sie eingehen.<br></div>