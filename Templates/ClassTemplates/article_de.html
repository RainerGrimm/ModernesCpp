<div class="vorspann">Ein Funktions-Template repräsentiert eine Familie von Funktionen. Entsprechend repräsentiert ein Klassen-Template eine Familie von Klassen. Heute möchte ich Klassen-Templates vorstellen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/1/0/0/7/5/TN_211374045_3c5a1ee023.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Ein Klassen-Template zu definieren ist einfach.</div>
<div class="ztitel">Definition eines Klassen-Templates</div>
<div class="text">Angenommen, du hast eine Klasse Array, die ein Klassen-Template werden soll.</div>
<div class="pre">class Array{<br>&nbsp;<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; int getSize() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 10;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; int elem[10];<br>};</div>
<div class="text">Die Klasse <span class="tx_code">Array</span> enthält ein C-Array vom Typ <span class="tx_code">int</span> mit der Länge 10. Der Typ des C-Arrays und seine Länge sind offensichtliche Erweiterungspunkte. Lass mich ein Klassen-Template erstellen, indem wir einen Typ-Parameter <span class="tx_code">T</span> und einen Nicht-Typ-Parameter <span class="tx_code">N</span> einführen und damit spielen.</div>
<div class="pre">// arrayClassTemplate.cpp<br><br>#include &lt;cstddef&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>template &lt;typename T, std::size_t N&gt; // (2)<br>class Array{<br><br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; int getSize() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return N;<br>&nbsp;&nbsp;&nbsp; }<br><br>private:<br>&nbsp;&nbsp;&nbsp; T elem[N]<br>};<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; Array&lt;int, 100&gt; intArr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "intArr.getSize(): " &lt;&lt; intArr.getSize() &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; Array&lt;std::string, 5&gt; strArr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "strArr.getSize(): " &lt;&lt; strArr.getSize() &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; Array&lt;Array&lt;int, 3&gt;, 25&gt; intArrArr; // (5)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "intArrArr.getSize(): " &lt;&lt; intArrArr.getSize() &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div>
<div class="text">Das Array wird durch seinen Typ und seine Größe parametrisiert. Für die Größe habe ich den vorzeichenlosen Integer-Typ <span class="tx_code">std::size_t</span> (2) verwendet, der die maximale Größe speichern kann. Um <span class="tx_code">std::size_t</span> zu verwenden, muss ich den Header <span class="tx_code">&lt;cstddef&gt;</span> (1) einbinden. Jetzt kann das Array mit einem<span class="tx_code"> int</span> (3), einem <span class="tx_code">std::string</span> (4) und einem <span class="tx_code">Array&lt;int, 3&gt;</span> (5) instanziiert werden. Der folgende Screenshot zeigt die Ausgabe des Programms.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/1/0/0/7/5/TN_211374050_171b872486.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Du kannst die Memberfunktionen eines Templates innerhalb und außerhalb des Klassen-Templates definieren.</div>
<div class="ztitel_kleiner">Definitionen der Memberfunktionen</div>
<div class="text">Die Definition der Member-Funktionen innerhalb des Klassen-Templates ist ganz intuitiv.<br></div>
<div class="pre">template &lt;typename T, std::size_t N&gt;&nbsp; &nbsp;<br>class Array{<br><br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; int getSize() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return N;<br>&nbsp;&nbsp;&nbsp; }<br><br>private:<br>&nbsp;&nbsp;&nbsp; T elem[N]<br>};</div>
<div class="text">Wenn du die Memberfunktionen außerhalb der Klasse definierst, musst Du angeben, dass es sich um ein Template handelt. Dazu ist es notwendig, die volle Typqualifikation des Klassen-Templates anzugeben. Das modifizierte Klassen-Template Array sieht dann so aus:</div>
<div class="pre">template &lt;typname T, std::size_t N&gt; <br>class Array{<br><br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; int getSize() const;<br><br>private:<br>&nbsp;&nbsp;&nbsp; T elem[N]<br>};<br><br>template &lt;typename T, std::size_t N&gt; // (1)<br>int Array&lt;T, N&gt;::getSize() const {<br>&nbsp;&nbsp;&nbsp; return N;<br>}</div>
<div class="text">(1) ist die Memberfunktion <span class="tx_code">getSize</span> des Arrays, die außerhalb der Klasse definiert ist. Die Memberfunktion außerhalb des Klassen-Templates zu definieren, wird aufwändig, wenn die Memberfunktion selbst ein Template ist.</div>
<div class="ztitel_kleiner">Memberfunktionen als Templates</div>
<div class="text">Ein typisches Beispiel für eine generische Memberfunktion ist ein generischer Zuweisungsoperator. Der Grund für einen generischen Zuweisungsoperator ist naheliegend. Ein <span class="tx_code">Array&lt;T, N&gt;</span> soll sich einem <span class="tx_code">Array&lt;T2, N2&gt;</span> zuweisen lassen, wenn der Datentyp T sich T2 zuweisen lässt und beide Arrays die gleiche Größe besitzen.</div>
<div class="text">Das Zuweisen eines <span class="tx_code">Array&lt;float, 5&gt;</span> an ein <span class="tx_code">Array&lt;double, 5&gt;</span> ist nicht gültig, da beide Arrays unterschiedliche Typen besitzen.</div>
<div class="pre">// arrayAssignmentError.cpp<br><br>#include &lt;cstddef&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>template &lt;typename T, std::size_t N&gt;&nbsp; &nbsp;<br>class Array{<br><br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; int getSize() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return N;<br>&nbsp;&nbsp;&nbsp; }<br><br>private:<br>&nbsp;&nbsp;&nbsp; T elem[N]<br>};<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; Array&lt;float, 5&gt; floatArr; &nbsp;<br>&nbsp;&nbsp;&nbsp; Array&lt;float, 5&gt; floatArr2;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; floatArr2 = floatArr; // (1)<br>&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; Array&lt;double, 5&gt; doubleArr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; doubleArr = floatArr; // (2)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Das Zuweisen von <span class="tx_code">floatArr </span>an <span class="tx_code">floatArr2</span> (1) ist gültig, da beide Arrays den gleichen Typ haben. Das Zuweisen von <span class="tx_code">floatArr</span> an <span class="tx_code">doubleArr</span> ist hingegen nicht gültig (2). Der Compiler beschwert sich, dass es keine Konvertierung von <span class="tx_code">Array&lt;float, 5&gt;</span> zu einem <span class="tx_code">Array&lt;double, 5&gt;</span> gibt.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/1/0/0/7/5/TN_211374053_7b6b426a4a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Hier ist eine naive Implementierung der Klasse <span class="tx_code">Array</span>, die die Zuweisung von zwei Arrays gleicher Länge unterstützt. Das C-Array <span class="tx_code">elem</span> ist absichtlich <span class="tx_code">public</span>.</div>
<div class="pre">template &lt;typename T, std::size_t N&gt;&nbsp; &nbsp;<br>class Array{<br><br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; template &lt;typename T2&gt;<br>&nbsp;&nbsp;&nbsp; Array&lt;T, N&gt;&amp; operator = (const Array&lt;T2, N&gt;&amp; arr) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::copy(std::begin(arr.elem), std::end(arr.elem), std::begin(elem));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; int getSize() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return N;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; T elem[N];<br>&nbsp;&nbsp; &nbsp;<br>};</div>
<div class="text">Der Zuweisungsoperator <span class="tx_code">Array&lt;T, N&gt;&amp; operator = (const Array&lt;T2, N&gt;&amp; arr)</span> akzeptiert Arrays, die im zugrundeliegenden Typ variieren können, aber nicht in der Länge.&nbsp; Bevor ich den vollständigen Code vorstelle, möchte ich ihn noch sukzessive verbessern.</div>
<div class="text"><b>Freundschaft</b></div>
<div class="text">Wenn <span class="tx_code">elem </span>als <span class="tx_code">private</span> definiert wird, muss Array zum Freund der Klasse werden.</div>
<div class="pre">template &lt;typename T, std::size_t N&gt;&nbsp; &nbsp;<br>class Array{<br><br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; template &lt;typename T2&gt;<br>&nbsp;&nbsp;&nbsp; Array&lt;T, N&gt;&amp; operator = (const Array&lt;T2, N&gt;&amp; arr) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::copy(std::begin(arr.elem), std::end(arr.elem), std::begin(elem));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; template&lt;typename, std::size_t&gt; friend class Array; // (1)<br>&nbsp;&nbsp;&nbsp; int getSize() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return N;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; T elem[N]<br>&nbsp;&nbsp; &nbsp;<br>};</div>
<div class="text">Die Zeile <span class="tx_code">template&lt;typename, std::size_t&gt; friend class Array</span> (1) erklärt alle Instanzen von Array zu Freunden.</div>
<div class="text"><b>Memberfunktionen außerhalb der Klasse definiert</b></div>
<div class="text">Die generische Memberfunktion außerhalb der Klasse zu definieren ist ein wenig mühsam.</div>
<div class="pre">template &lt;typename T, std::size_t N&gt;&nbsp; &nbsp;<br>class Array{<br><br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; template &lt;typename T2&gt;<br>&nbsp;&nbsp;&nbsp; Array&lt;T, N&gt;&amp; operator = (const Array&lt;T2, N&gt;&amp; arr);<br>&nbsp;&nbsp;&nbsp; template&lt;typename, std::size_t&gt; friend class Array;<br>&nbsp;&nbsp;&nbsp; int getSize() const;<br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; T elem[N]<br>&nbsp;&nbsp; &nbsp;<br>};<br><br>template &lt;typename T, std::size_t N&gt; <br>int Array&lt;T, N&gt;::getSize() const { return N; }<br><br>template&lt;typename T, std::size_t N&gt; // (1)<br>template&lt;typename T2&gt;<br>Array&lt;T, N&gt;&amp; Array&lt;T, N&gt;::operator = (const Array&lt;T2, N&gt;&amp; arr) {<br>&nbsp;&nbsp;&nbsp; std::copy(std::begin(arr.elem), std::end(arr.elem), std::begin(elem));<br>&nbsp;&nbsp;&nbsp; return *this;<br>}</div>
<div class="text">Es ist für eine außerhalb des Klassenkörpers definierte generische Memberfunktion (1) notwendig, dass die Klasse und die Memberfunktionen Templates sind. Zusätzlich muss die vollständige Typqualifikation der generischen Memberfunktion angeben werden. In der Klasse <span class="tx_code">Array</span> wird der Zuweisungsoperator auch für Datentypen <span class="tx_code">T</span> und<span class="tx_code"> T2</span> eingesetzt, die nicht konvertierbar sind. Das Aufrufen des Zuweisungsoperators mit nichtkonvertierbaren Typen führt natürlich zu einer "hässlichen" Fehlermeldung. Dieses Problem sollte ich beheben.</div>
<div class="text"><b>Anforderungen an die Typparameter</b></div>
<div class="text">Die Anforderungen lassen sich mit der<a title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" alt="%7B%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22%20type%20traits%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://en.cppreference.com/w/cpp/header/type_traits" class=""> type traits</a> library und static_assert (C++11) oder mit Concepts (C++20) formulieren. Hier sind die beiden Varianten des generischen Zuweisungsoperators:</div>
<div class="text"><ul><li>C++11</li></ul></div>
<div class="pre">template&lt;typename T, std::size_t N&gt;<br>template&lt;typename T2&gt;<br>Array&lt;T, N&gt;&amp; Array&lt;T, N&gt;::operator = (const Array&lt;T2, N&gt;&amp; arr) {<br>&nbsp;&nbsp;&nbsp; static_assert(std::is_convertible&lt;T2, T&gt;::value, // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Cannot convert the source type into the destination type!");<br>&nbsp;&nbsp;&nbsp; std::copy(std::begin(arr.elem), std::end(arr.elem), std::begin(elem));<br>&nbsp;&nbsp;&nbsp; return *this;<br>}</div>
<div class="text"><ul><li>C++20</li></ul></div>
<div class="text">Abschließend ist hier das komplette Programm unter Verwendung des Concepts<span class="tx_code"> std::convertible_to</span> in der Deklaration (1) und der Definition (2) der Memberfunktion.</div>
<div class="pre">// arrayAssignment.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;cstddef&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;concepts&gt;<br><br>template &lt;typename T, std::size_t N&gt;&nbsp; &nbsp;<br>class Array{<br><br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; Template &lt;typename T2&gt;<br>&nbsp;&nbsp;&nbsp; Array&lt;T, N&gt;&amp; operator = (const Array&lt;T2, N&gt;&amp; arr) erfordert std::convertible_to&lt;T2, T&gt;; // (1)<br>&nbsp;&nbsp;&nbsp; template&lt;typename, std::size_t&gt; friend class Array;<br>&nbsp;&nbsp;&nbsp; int getSize() const;<br>&nbsp;private:<br>&nbsp;&nbsp;&nbsp; T elem[N]<br>&nbsp;&nbsp; &nbsp;<br>};<br><br>template &lt;typename T, std::size_t N&gt; <br>int Array&lt;T, N&gt;::getSize() const { return N; }<br><br>template&lt;typename T, std::size_t N&gt;<br>template&lt;typename T2&gt;<br>Array&lt;T, N&gt;&amp; Array&lt;T, N&gt;::operator = (const Array&lt;T2, N&gt;&amp; arr) erfordert std::convertible_to&lt;T2, T&gt; { // (2)<br>&nbsp;&nbsp;&nbsp; std::copy(std::begin(arr.elem), std::end(arr.elem), std::begin(elem));<br>&nbsp;&nbsp;&nbsp; return *this;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; Array&lt;float, 5&gt; floatArr; &nbsp;<br>&nbsp;&nbsp;&nbsp; Array&lt;float, 5&gt; floatArr2;<br>&nbsp;&nbsp;&nbsp; floatArr.getSize();<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; floatArr2 = floatArr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; Array&lt;double, 5&gt; doubleArr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; doubleArr = floatArr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; Array&lt;std::string, 5&gt; strArr;<br>&nbsp;&nbsp;&nbsp; // doubleArr = strArr; // (3)<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Wenn ich den Ausdruck (3) verwende, beschwert sich der GCC im Wesentlichen darüber, dass die Einschränkungen nicht erfüllt werden.</div>
<div class="ztitel">Wie geht es weiter?</div>
<div class="text">Natürlich bin ich noch nicht fertig mit meinen Artikeln zu Klassen-Templates. In meinem nächsten Artikel schreibe ich über zwei knifflige Details: Vererbung von Klassen-Templates und die Instanziierung von Memberfunktionen von Klassen-Templates<br></div>
<div class="ztitel">The Next PDF-Bundle</div>
<div class="text">I want to resuscitate an old service and create bundles about old posts. I will create the bundles only for my English posts because this is quite a job. These bundles include the posts, all source files, and a cmake file. In order for me to make the right decision, you have to make your cross. I will build the pdf bundle with the most votes. The vote is open until 30th of May (including). <a title="Link auf https://www.modernescpp.com/index.php/which-pdf-bundle-do-you-want-make-your-choice" alt="%7B%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fwhich-pdf-bundle-do-you-want-make-your-choice%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fwhich-pdf-bundle-do-you-want-make-your-choice%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Vote%20here%22%7D" href="https://www.modernescpp.com/index.php/which-pdf-bundle-do-you-want-make-your-choice" class="">Vote here</a>.</div>