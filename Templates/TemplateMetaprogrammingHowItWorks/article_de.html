<div class="vorspann">Nach dem Beitrag über die Ursprünge der Template-Metaprogrammierung geht es darum, wie Template-Metaprogrammierung verwendet werden kann, um Typen zur Compilezeit zu verändern.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/1/0/5/6/6/TN_220371240_da886ca587.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="text">Das faktorielle Programm im letzten Artikel "<a title="Link auf https://heise.de/-6233576" alt="%7B%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6233576%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6233576%22%2C%22type%22%3A%22E%22%2C%22mediasync_id%22%3A%22%22%2C%22text%22%3A%22Template%20Metaprogrammierung%3A%20Wie%20alles%20begann%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%7D" href="https://heise.de/-6233576">Template Metaprogrammierung: Wie alles begann</a>" war ein schönes Beispiel, aber nicht idiomatisch für Template Metaprogrammierung. Die Manipulation von Typen zur Compilezeit ist typisch für die Template-Metaprogrammierung.</div><div class="ztitel">Typmanipulation zur Compilezeit</div><div class="text">Hier ist ein Beispiel, wie <span class="tx_code"><a title="Link auf https://en.cppreference.com/w/cpp/utility/move" alt="%7B%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fmove%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fmove%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22text%22%3A%22std%3A%3Amove%22%7D" href="https://en.cppreference.com/w/cpp/utility/move">std::move</a></span> konzeptionell umgesetzt ist:</div><div class="text"><span class="tx_code">static_cast&lt;std::remove_reference&lt;decltype(arg)&gt;::type&amp;&amp;&gt;(arg);</span></div><div class="text"><span class="tx_code">std::move</span> nimmt sein Argument <span class="tx_code">arg</span> an, leitet seinen Typ ab (<span class="tx_code">decltype(arg)</span>), entfernt seine Referenz (<span class="tx_code">std::remove_reverence</span>) und wandelt sie in eine Rvalue-Referenz um (<span class="tx_code">static_cast&lt;...&gt;::type&amp;&amp;&gt;</span>). Im Wesentlichen ist <span class="tx_code">std::move</span> eine Konvertierung zu einer Rvalue-Referenz. Jetzt kann die Move-Semantik zum Einsatz kommen.<br></div><div class="text">Wie kann eine Funktion die Konstante aus ihrem Argument entfernen?</div><div class="pre">// removeConst.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>template&lt;typename T &gt;<br>&nbsp;&nbsp;&nbsp; struct removeConst {<br>&nbsp;&nbsp;&nbsp; using type = T;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>};<br><br>template&lt;typename T &gt;<br>&nbsp;&nbsp;&nbsp; struct removeConst&lt;const T&gt; {<br>&nbsp;&nbsp;&nbsp; using type = T;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>};<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::is_same&lt;int, removeConst&lt;int&gt;::type&gt;::value <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::is_same&lt;int, removeConst&lt;const int&gt;::type&gt;::value <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; '\n'; // true<br><br>}</div><div class="text">Ich habe <span class="tx_code">removeConst</span> so implementiert, wie die Funktion wohl in der <a title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" alt="%7B%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22Typ-Traits%20Bibliothek%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%7D" href="https://en.cppreference.com/w/cpp/header/type_traits">Typ-Traits Bibliothek</a> implementiert ist. <span class="tx_code">std::is_same</span> aus der Typ-Traits Bibliothek hilft mir, zur Compilezeit zu entscheiden, ob die beiden Typen gleich sind. Im Falle von<span class="tx_code"> removeConst&lt;int&gt;</span> greift das primäre oder allgemeine Klassen-Template; im Fall von<span class="tx_code"> removeConst&lt;const int&gt;</span> kommt die partielle Spezialisierung für <span class="tx_code">const T</span> zum Einsatz. Entscheidend ist, dass beide Klassen-Templates den zugrunde liegenden Typ in (1) und (2) über den Alias-Typ zurückgeben. Wie versprochen, wird die Konstante des Arguments entfernt.</div><div class="text">Es gibt noch weitere interessante Beobachtungen.</div><div class="text"><ul><li>Template-Spezialisierung (teilweise oder vollständig) ist eine bedingte Ausführung zur Compilezeit. Genauer: Wenn ich <span class="tx_code">removeConst</span> mit einem nicht konstanten <span class="tx_code">int</span> verwende, wählt der Compiler das primäre oder allgemeine Template aus. Wenn ich einen konstanten <span class="tx_code">int</span> verwende, wählt der Compiler die partielle Spezialisierung für<span class="tx_code"> const T</span> aus.</li><li>Der Ausdruck <span class="tx_code">type = T</span> dient als Rückgabewert, der in diesem Fall ein Typ ist.</li><li>Wer das Programm <a title="Link auf https://cppinsights.io/s/c9b121d0" alt="%7B%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2Fc9b121d0%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22removeConst.cpp%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2Fc9b121d0%22%2C%22type%22%3A%22E%22%2C%22mediasync_id%22%3A%22%22%7D" href="https://cppinsights.io/s/c9b121d0">removeConst.cpp</a> auf C++ Insights studiert, sieht, dass der Ausdruck <span class="tx_code">std::is_same&lt;int, removeConst&lt;int&gt;::type&gt;::value</span> auf den booleschen Wert <span class="tx_code">std::integral_constant&lt;bool, true&gt;::value</span> hinausläuft, der als <span class="tx_code">true</span> angezeigt wird.</li></ul></div><div class="text">Ich trete einen Schritt zurück, um über Template-Metaprogrammierung aus konzeptioneller Sicht schreiben.<br></div><div class="ztitel">Mehr Meta</div><div class="text">Zur Ausführungszeit verwenden wir Daten und Funktionen. Zur Compilezeit verwenden wir Metadaten und -funktionen. Es ist naheliegend, dass dies Meta heißt, weil wir Metaprogrammierung betreiben.</div><div class="ztitel_kleiner">Metadaten</div><div class="text">Metadaten sind Werte, die Metafunktionen zur Compilezeit verwenden.<br></div><div class="text">Es gibt drei Arten von Werten:<br></div><div class="text"><ul><li>Typen wie <span class="tx_code">int</span> oder <span class="tx_code">double</span></li><li>Nichttypen wie Integrale, Aufzählungszeichen, Zeiger, Referenzen, Fließkommazahlen mit C++20</li><li>Template wie <span class="tx_code">std::vector</span> oder<span class="tx_code"> std::deque</span></li></ul></div><div class="text">Mehr über die drei Arten von Werten steht in meinem vorherigen Artikel "<a title="Link auf https://heise.de/-6062972" alt="%7B%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6062972%22%2C%22type%22%3A%22E%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22Alias%20Templates%20und%20Template%20Parameter%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6062972%22%2C%22target%22%3A%22_blank%22%7D" href="https://heise.de/-6062972">Alias Templates und Template Parameter</a>".<br></div><div class="ztitel_kleiner">Metafunktionen</div><div class="text">Metafunktionen sind Funktionen, die zur Compilezeit ausgeführt werden.</div><div class="text">Zugegeben, das klingt seltsam: Typen werden in der Template-Metaprogrammierung verwendet, um Funktionen zu simulieren. Ausgehend von der Definition von Metafunktionen sind auch <span class="tx_code">constexpr</span>-Funktionen, die zur Compilezeit ausgeführt werden können, Metafunktionen. Die gleiche Argumentation gilt für<span class="tx_code"> consteval</span>-Funktionen in C++20.</div><div class="text">Hier sind zwei Metafunktionen.</div><div class="pre">template &lt;int a , int b&gt;<br>struct Product {<br>&nbsp;&nbsp;&nbsp; static int const value = a * b;<br>};<br><br>template&lt;typename T &gt;<br>struct removeConst&lt;const T&gt; {<br>&nbsp;&nbsp;&nbsp; using type = T;<br>};</div><div class="text">Die erste Metafunktion <span class="tx_code">Product</span> gibt einen Wert zurück und die zweite Funktion <span class="tx_code">removeConst</span> einen Typ. Die Namen <span class="tx_code">value</span> und <span class="tx_code">type</span> sind Namenskonventionen für die Rückgabewerte. Wenn eine Metafunktion einen Wert zurückgibt, wird dieser <span class="tx_code">value</span> genannt; wenn sie einen Typ zurückgibt, wird dieser <span class="tx_code">type</span> genannt. Die <a title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" alt="%7B%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22text%22%3A%22Typ-Traits%20Bibliothek%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22type%22%3A%22E%22%7D" href="https://en.cppreference.com/w/cpp/header/type_traits">Typ-Traits Bibliothek</a> folgt genau dieser Namenskonvention.</div><div class="text">Es ist recht aufschlussreich, Funktionen mit Metafunktionen zu vergleichen.</div><div class="ztitel_kleiner">Funktionen versus Meta-Funktionen</div><div class="text">Die folgende Funktion <span class="tx_code">power</span> und die Metafunktion <span class="tx_code">Power</span> berechnen pow(2, 10) zur Laufzeit und zur Compilezeit.</div><div class="pre">// power.cpp<br><br>#include &lt;iostream&gt;<br><br>int power(int m, int n) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; int r = 1;<br>&nbsp;&nbsp;&nbsp; for(int k = 1; k &lt;= n; ++k) r *= m;<br>&nbsp;&nbsp;&nbsp; return r;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>}<br><br>template&lt;int m, int n&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>struct Power {<br>&nbsp;&nbsp;&nbsp; static int const value = m * Power&lt;m, n-1&gt;::value;<br>};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>template&lt;int m&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>struct Power&lt;m, 0&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; static int const value = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>};<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "power(2, 10)= " &lt;&lt; power(2, 10) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Power&lt;2,10&gt;::value= " &lt;&lt; Power&lt;2, 10&gt;::value &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>}</div><div class="text">Dies ist der Hauptunterschied:<br></div><div class="text"><ul><li><b>Argumente</b>: Die Funktionsargumente kommen in den runden Klammern (<span class="tx_code">( ... )</span>) und die Meta-Funktionsargumente in den spitzen Klammern (<span class="tx_code">&lt; ...&gt;</span>) zum Einsatz. Diese Beobachtung gilt auch für die Definition der Funktion und der Metafunktion. Die Funktion verwendet runde Klammern und die Metafunktion spitze Klammern. Jedes Argument der Metafunktion erzeugt einen neuen Typ.</li><li><b>Rückgabewert</b>: Die Funktion verwendet eine Rückgabeanweisung und die Metafunktion einen statischen ganzzahligen konstanten Wert.<br></li></ul></div><div class="text">Auf diesen Vergleich gehe ich in einem weiteren Artikel über <span class="tx_code">constexpr</span>- und <span class="tx_code">consteval</span>-Funktionen näher ein. Hier ist die Ausgabe des Programms.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/1/0/5/6/6/TN_220371242_621a7dd120.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><span class="tx_code">power</span> wird zur Laufzeit und <span class="tx_code">Power</span> zur Compilezeit ausgeführt, aber was passiert im folgenden Beispiel?</div><div class="pre">// powerHybrid.cpp<br><br>#include &lt;iostream&gt;<br><br>#include &lt;iostream&gt;<br><br>template&lt;int n&gt;<br>int Power(int m){<br>&nbsp;&nbsp;&nbsp; return m * Power&lt;n-1&gt;(m);<br>}<br><br>template&lt;&gt;<br>int Power&lt;0&gt;(int m){<br>&nbsp;&nbsp;&nbsp; return 1;<br>}<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Power&lt;0&gt;(10): " &lt;&lt; Power&lt;0&gt;(20) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Power&lt;1&gt;(10): " &lt;&lt; Power&lt;1&gt;(10) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Power&lt;2&gt;(10): " &lt;&lt; Power&lt;2&gt;(10) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text">Die Frage ist natürlich: Ist <span class="tx_code">Power</span> eine Funktion oder eine Metafunktion? Ich verspreche, die Antwort auf diese Frage gibt mehr Aufschluss.</div><div class="ztitel">Wie geht's weiter?</div><div class="text">In meinem nächsten Artikel analysiere ich die Funktion/Metafunktion <span class="tx_code">Power</span> und stelle die <a title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" alt="%7B%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Typ-Traits%20Bibliothek%22%2C%22ir_link%22%3A1%7D" href="https://en.cppreference.com/w/cpp/header/type_traits">Typ-Traits Bibliothek</a> genauer vor. Die Typ-Traits-Bibliothek ist idiomatisch für die Compilezeitprogrammierung in C++.<br></div><div class="simple-translate-result-contents"><br> <br></div>