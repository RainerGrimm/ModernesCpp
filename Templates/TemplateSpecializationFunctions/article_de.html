<div class="text"><b>Um nachzuvollziehen, warum überladene Funktionen grundsätzlich Funktions-Templates vorzuziehen sind, ist ein Verständnis Letzterer hilfreich. </b><br></div>
<div class="text">Wie ich in meinem vorherigen Artikel "<a title="Link auf https://heise.de/-6118187" alt="%7B%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6118187%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22Einf%C3%BChrung%20in%20die%20Template-Spezialisierung%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6118187%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%7D" href="https://heise.de/-6118187" class="">Einführung in die Template-Spezialisierung</a>" gezeigt habe, können Funktions-Templates nur vollständig, aber nicht teilweise spezialisiert werden. Um meine lange Geschichte kurz zu machen: Spezialisiere keine Funktions-Templates. Verwende das Überladen von Funktionen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/3/6/6/3/7/TN_213629499_6c42579d76.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das wirft die Frage auf, warum ich über ein Feature von C++ schreibe, das man nicht benutzen sollte. Der Grund ist ganz einfach: We das überraschende Verhalten von voll spezialisierten Funktions-Templates sieht, wird wohl eine nicht-generische Funktion vorziehen.<br></div>
<div class="ztitel">Funktions-Templates sollen nicht spezialisiert werden<br></div>
<div class="text">Dieser Titel ist aus den C++ Core Guidelines: <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-specialize-function" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-specialize-function%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.144%3A%20Don%27t%20specialize%20function%20templates%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-specialize-function%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22type%22%3A%22E%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-specialize-function" class="">T.144: Don't specialize function templates</a> </div>
<div class="text">Der Grund für diese Regel ist einfach: Die Spezialisierung von Funktions-Templates nimmt nicht am Überladen teil. Schauen wir mal, was das bedeutet. Mein Programm basiert auf dem Programmschnipsel von Demiov/Abrahams.<br></div>
<div class="pre">// dimovAbrahams.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>// getTypeName<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) primary template<br>std::string getTypeName(T){<br>&nbsp;&nbsp;&nbsp; return "unknown";<br>}<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) primary template that overloads (1)<br>std::string getTypeName(T*){<br>&nbsp;&nbsp;&nbsp; return "pointer";<br>}<br><br>template&lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3) explicit specialization of (2)<br>std::string getTypeName(int*){<br>&nbsp;&nbsp;&nbsp; return "int pointer";<br>}<br><br>// getTypeName2<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4) primary template<br>std::string getTypeName2(T){<br>&nbsp;&nbsp;&nbsp; return "unknown";<br>}<br><br>template&lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5) explicit specialization of (4)<br>std::string getTypeName2(int*){<br>&nbsp;&nbsp;&nbsp; return "int pointer";<br>}<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6) primary template that overloads (4)<br>std::string getTypeName2(T*){<br>&nbsp;&nbsp;&nbsp; return "pointer";<br>}<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; int *p;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getTypeName(p): " &lt;&lt; getTypeName(p) &lt;&lt; std::endl;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getTypeName2(p): " &lt;&lt; getTypeName2(p) &lt;&lt; std::endl; <br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Der Code sieht nur auf den ersten Blick ziemlich langweilig aus. In (1) wird das primäre Template <span class="tx_code">getTypeName</span> definiert. (2) ist eine Überladung für Zeiger und (3) eine vollständige Spezialisierung für einen <span class="tx_code">int</span>-Zeiger. Im Fall von <span class="tx_code">getTypeName2</span> habe ich eine kleine Variation vollzogen. Die explizite Spezialisierung (5) wird vor der Überladung für Zeiger (6) definiert.<br></div>
<div class="text">Diese Umstellung der Funktionsaufrufe hat überraschende Konsequenzen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/3/6/6/3/7/TN_213629504_e9bad87ff2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Im ersten Fall wird die vollständige Spezialisierung für den<span class="tx_code"> int</span>-Zeiger aufgerufen, im zweiten Fall die Überladung für Zeiger. Der Grund für dieses wenig intuitive Verhalten ist, dass Überladung die Spezialisierung von Funktions-Templates ignoriert. Überladung betrachtet nur primäre Templates und Funktionen. In beiden Fällen hat die Überladung beide primären Templates gefunden. Im ersten Fall (<span class="tx_code">getTypeName</span>) ist die Zeigervariante die passendere Version und daher wurde die explizite Spezialisierung für den<span class="tx_code"> int</span>-Zeiger gewählt. In der zweiten Variante (<span class="tx_code">getTypeName2</span>) wurde die Zeigervariante gewählt. Die vollständige Spezialisierung bezieht sich auch auf das primäre Template (Zeile 4). Folglich wurde sie ignoriert.</div>
<div class="text">Das war ziemlich kompliziert, aber es genügt, folgende Regel im Hinterkopf zu behalten:<b> Spezialisiere keine Funktions-Templates. Verwende stattdessen nicht-generische Funktionen.</b></div>
<div class="text">Hier ist der Beweis für die Aussage: Wenn man aus der expliziten Spezialisierung in (3) und (5) nicht-generische Funktionen macht, ist das Problem gelöst. Ich muss nur noch die Template-Deklaration<span class="tx_code"> template&lt;&gt;</span> auskommentieren. Der Einfachheit halber habe ich die weiteren Kommentare entfernt.</div>
<div class="pre">// dimovAbrahams.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>// getTypeName<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>std::string getTypeName(T){<br>&nbsp;&nbsp;&nbsp; return "unknown";<br>}<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>std::string getTypeName(T*){<br>&nbsp;&nbsp;&nbsp; return "pointer";<br>}<br><br>// template&lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>std::string getTypeName(int*){<br>&nbsp;&nbsp;&nbsp; return "int pointer";<br>}<br><br>// getTypeName2<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>std::string getTypeName2(T){<br>&nbsp;&nbsp;&nbsp; return "unknown";<br>}<br><br>// template&lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>std::string getTypeName2(int*){<br>&nbsp;&nbsp;&nbsp; return "int pointer";<br>}<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>std::string getTypeName2(T*){<br>&nbsp;&nbsp;&nbsp; return "pointer";<br>}<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; int *p;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getTypeName(p): " &lt;&lt; getTypeName(p) &lt;&lt; std::endl;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getTypeName2(p): " &lt;&lt; getTypeName2(p) &lt;&lt; std::endl; <br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Jetzt funktioniert die Überladung wie erwartet und die nicht-generische Funktion, die einen<span class="tx_code"> int</span>-Zeiger nimmt, wird verwendet.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/3/6/6/3/7/TN_213629507_2033c5e864.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=1>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Ich habe bereits über Template Arguments geschrieben. Aber ich habe eine wichtige Tatsache vergessen: Template-Argumente von Funktions- oder Klassen-Templates können Defaultwerte besitzen.<br></div>
<div class="ztitel">Default Template-Argumente<br></div>
<div class="text">Was ist den Klassen-Templates der Standard Template Library (STL) gemein? Viele der Template-Argumente besitzen Defaultwerte.</div>
<div class="text">Hier sind ein paar Beispiele.</div>
<div class="pre">template&lt;<br>&nbsp;&nbsp;&nbsp; typename T,<br>&nbsp;&nbsp;&nbsp; typename Allocator = std::allocator&lt;T&gt;<br>&gt; class vector;<br><br>template&lt;<br>&nbsp;&nbsp;&nbsp; typename Key,<br>&nbsp;&nbsp;&nbsp; typename T,<br>&nbsp;&nbsp;&nbsp; typename Hash = std::hash&lt;Key&gt;,<br>&nbsp;&nbsp;&nbsp; typename KeyEqual = std::equal_to&lt;Key&gt;,<br>&nbsp;&nbsp;&nbsp; typename Allocator = std::allocator&lt; std::pair&lt;const Key, T&gt;&gt;<br>&gt; class unordered_map;<br><br>template&lt;<br>&nbsp;&nbsp;&nbsp; typename T,<br>&nbsp;&nbsp;&nbsp; typename Allocator = std::allocator&lt;T&gt;<br>&gt; class deque;<br><br>template&lt;<br>&nbsp;&nbsp;&nbsp; typename T,<br>&nbsp;&nbsp;&nbsp; typename Container = std::deque&lt;T&gt;<br>&gt; clas Stack;<br><br>template&lt;<br>&nbsp;&nbsp;&nbsp; typename CharT,<br>&nbsp;&nbsp;&nbsp; typename Traits = std::char_traits&lt;CharT&gt;,<br>&nbsp;&nbsp;&nbsp; typename Allocator = std::allocator&lt;CharT&gt;<br>&gt; class basic_string;</div>
<div class="text">Dies ist eine große Stärke der STL:</div>
<div class="text"><ul><li>Jeder Container hat einen Standard-Allokator, der von seinen Elementen abhängt.</li><li>Für eine<span class="tx_code"> std::unordered_map</span> muss man lediglich die notwendigen Argumente wie den Schlüsseltyp und den Wertetyp angeben:<span class="tx_code"> std::unordered_map&lt;std::string, int&gt;</span>.</li><li>Eine <span class="tx_code">std::unordered_map</span> lässt sich auch instanziieren, indem man eine spezielle Hash-Funktion und ein spezielles binäres Prädikat verwendet. Die Hash-Funktion muss den Hash-Wert für den Schlüssel zurückgeben und das spezielle binäres Prädikat muss bestimmen, ob zwei Schlüssel gleich sind:<span class="tx_code"> std::unordered_map&lt;std::string, int, MyHash&gt;</span>, oder auch <span class="tx_code">std::unordered_map&lt;std::string, int, MyHash, MyBinaryPredicate&gt;.</span></li><li><span class="tx_code">std::string</span> ist nur ein Alias für einen allgemeinen Zeichentyp. Dies sind die Aliase basierend auf <span class="tx_code">std::basic_string.</span><br></li></ul></div>
<div class="text"><span class="tx_code">std::string std::basic_string&lt;char&gt;<br>std::wstring std::basic_string&lt;wchar_t&gt;<br>std::u8string std::basic_string&lt;char8_t&gt; (C++20)<br>std::u16string std::basic_string&lt;char16_t&gt; (C++11)<br>std::u32string std::basic_string&lt;char32_t&gt; (C++11)</span></div>
<div class="text">Wenn ein Template-Argument einen Defaultwert besitzt, müssen die folgenden Template-Argumente auch Defaultwerte besitzen.</div>
<div class="text">Bis jetzt habe ich nur über Defaultwerte von Klassen-Templates geschrieben. Ich möchte diesen Beitrag mit einem Beispiel zu Funktions-Templates beenden.</div>
<div class="text">Angenommen, ich möchte für ein paar Objekte des gleichen Typs entscheiden, welches kleiner ist. Ein Algorithmus wie<span class="tx_code"> isSmaller</span> modelliert eine universelle Idee und sollte daher ein Template sein.</div>
<div class="pre">// templateDefaultArguments.cpp<br><br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>class Account{<br>public:<br>&nbsp; explicit Account(double b): balance(b){}<br>&nbsp; double getBalance() const {<br>&nbsp;&nbsp;&nbsp; return balance;<br>&nbsp; }<br>private:<br>&nbsp; double balance;<br>};<br><br>template &lt;typename T, typename Pred = std::less&lt;T&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>bool isSmaller(T fir, T sec, Pred pred = Pred() ){<br>&nbsp; return pred(fir,sec);<br>}<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; '\n';<br><br>&nbsp; std::cout &lt;&lt; "isSmaller(3,4): " &lt;&lt; isSmaller(3,4) &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) <br>&nbsp; std::cout &lt;&lt; "isSmaller(2.14,3.14): "&nbsp; &lt;&lt; isSmaller(2.14,3.14) &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "isSmaller(std::string(abc),std::string(def)): " &lt;&lt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSmaller(std::string("abc"),std::string("def")) &lt;&lt; '\n';<br><br>&nbsp; bool resAcc= isSmaller(Account(100.0),Account(200.0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](const Account&amp; fir, const Account&amp; sec){ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir.getBalance() &lt; sec.getBalance(); });<br>&nbsp; std::cout &lt;&lt; "isSmaller(Account(100.0),Account(200.0)): "<br>&nbsp;&nbsp;&nbsp; &lt;&lt; resAcc &lt;&lt; '\n';<br><br>&nbsp; bool acc= isSmaller(std::string("3.14"),std::string("2.14"),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](const std::string&amp; fir, const std::string&amp; sec){ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::stod(fir) &lt; std::stod(sec); });<br>&nbsp; std::cout &lt;&lt; "isSmaller(std::string(3.14),std::string(2.14)): "<br>&nbsp;&nbsp;&nbsp; &lt;&lt; acc &lt;&lt; '\n';<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div>
<div class="text">Im Standardfall (2) funktioniert <span class="tx_code">isSmaller</span> wie erwartet. <span class="tx_code">isSmaller</span> (1) verwendet das Template-Argument <span class="tx_code">std::less</span>, das eines von vielen vordefinierten Funktionsobjekten in der STL ist. Es wendet den kleiner-als Operator <span class="tx_code">&lt;</span> auf seine Argumente an. Um ihn einzusetzen, muss ich<span class="tx_code"> std::less&lt;T&gt;</span> in der folgenden Zeile instanziieren:<span class="tx_code"> Pred pred = Pred().</span></div>
<div class="text">Dank des Standardarguments für <span class="tx_code">pred</span> kann ich Strings (4) vergleichen. <span class="tx_code">Account</span> unterstützt den less-than-Operator nicht. Trotzdem ist es mir möglich, <span class="tx_code">Account</span>s zu vergleichen (3). Außerdem möchte ich Strings nicht lexikografisch, sondern basierend auf ihrer internen Zahl vergleichen (4). Durch die Bereitstellung der beiden Lambda-Ausdrücke in (3) und (4) als binäres Prädikat kann ich die Aufgabe erfolgreich erledigen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/3/6/6/3/7/TN_213629517_3f873ad007.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Wie geht's weiter? <br></div>
<div class="text">Wenn du dir die Grafik am Anfang dieses Beitrags ansiehst, siehst du, dass ich mit den Grundlagen von Templates fertig bin. In meinem nächsten Artikel über Templates tauche ich in ihre Details weiter ein und schreibe über die Template-Instanziierung.</div>