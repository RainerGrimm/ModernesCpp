<div class="vorspann">Ein Variadic Template kann eine beliebige Anzahl von Template-Parametern besitzen. Dieses Feature mag auf den ersten Blick magisch erscheinen. Daher ist es Zeit, Variadic Templates zu entmystifizieren.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/5/0/0/6/1/TN_215204895_4bc2f1e6f5.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;">&nbsp;</div><div class="text">Manch einer mag sich wundern, dass meine Grafik mit den vorgestellten Themen die Template-Instanziierung enthält. Der Grund ist einfach: Nach meinem letzten Artikel über "<a title="Link auf https://heise.de/-6151298" alt="%7B%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6151298%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6151298%22%2C%22text%22%3A%22Template-Instanziierung%22%7D" href="https://heise.de/-6151298">Template-Instanziierung</a>" hat einer meiner deutschsprachigen Leser (Pseudonym Urfahraner Auge) in einem Kommentar geschrieben, dass es einen wichtigen Unterschied zwischen impliziter und expliziter Instanziierung eines Templates gebe, den ich vergessen habe vorzustellen. Er hat recht. Die implizite Instanziierung von Templates ist lazy (faul), aber die explizite Instanziierung von Templates ist eager (gierig).<br> </div><div class="ztitel">Lazy- versus Eager- Template-Instanziierung<br></div><div class="text">Die Template-Instanziierung ist lazy. Das heißt, dass eine nicht benötigte Memberfunktion eines Klassen-Templates nicht instanziiert wird. Nur die Deklaration der Member-Funktion ist verfügbar, aber nicht ihre Definition. Damit ist es möglich, ungültigen Code in einer Menber-Funktion zu verwenden, solange sie nicht aufgerufen wird.</div><div class="pre">// numberImplicitExplicit.cpp<br><br>#include &lt;cmath&gt;<br>#include &lt;string&gt;<br><br>template &lt;typename T&gt;<br>struct Number {<br>&nbsp;&nbsp; &nbsp;int absValue() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::abs(val);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; T val{};<br>};<br><br>// template class Number&lt;std::string&gt;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>// template int Number&lt;std::string&gt;::absValue(); // (3)<br><br>int main() {<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; Number&lt;std::string&gt; numb;<br>&nbsp;&nbsp;&nbsp; // numb.absValue();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; <br>}<br></div><div class="text">Wer die Member-Funktion<span class="tx_code"> numb.absValue()</span> (1) aufruft, bekommst erwartungsgemäß eine Fehlermeldung zur Kompilierzeit, die besagt, dass es keine Überladung<span class="tx_code"> std::abs</span> für <span class="tx_code">std::string</span> gibt. Hier sind die ersten beiden Zeilen der ausführlichen Fehlermeldung:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/5/0/0/6/1/TN_215204903_40ef35432a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br> </div><div class="text">Nun möchte ich die Template-Instanziierung genauer erklären: Die implizite Instanziierung von Templates ist lazy, aber die explizite Instanziierung von Templates ist eager.<br> </div><div class="text">Wer (2) aktiviert (<span class="tx_code">template class number&lt;std::string&gt;</span>) und damit explizit das Klassen-Template <span class="tx_code">Number</span> instanziiert oder (3) aktiviert (<span class="tx_code">template int Number&lt;std::string&gt;::absValue()</span>) und damit explizit die Member-Funktion <span class="tx_code">absValue</span> für <span class="tx_code">std::string </span>instanziiert, bekommt einen Kompilierzeitfehler. Dieser ist äquivalent zum Compiler-Fehler beim Aufruf der Member-Funktion<span class="tx_code"> absValue </span>in (1) (<span class="tx_code">numb.absValue()</span>). Hier sind noch einmal die ersten beiden Zeilen der Fehlermeldungen nach dem Aktivieren von (2) oder (3).<br></div><div class="text"><ul><li>&nbsp;(2) aktiviert</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/5/0/0/6/1/TN_215204912_a99f43a0cc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>(3) aktiviert</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/5/0/0/6/1/TN_215204916_487a7855a3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel_kleiner">Eine persönliche Anmerkung:</div><div class="text">Ich freue mich sehr über Kommentare zu meinen Beiträgen. Sie helfen mir, über die Inhalte zu schreiben, die die Leser meines Blogs interessieren. Vor allem die deutsche Community ist sehr engagiert.</div><div class="text">Nun aber endlich zu etwas ganz anderem: Variadic Templates.</div><div class="ztitel">Variadic Templates</div><div class="text">Ein Variadic Template ist ein Template, das eine beliebige Anzahl von Template-Parametern besitzen kann. Dieses Feature mag beim ersten Mal magisch erscheinen.</div><div class="pre">template &lt;typename ... Args&gt;<br>void variadicTemplate(Args ... args) { <br>&nbsp;&nbsp;&nbsp; . . . . // four dots<br>}</div><div class="text">Durch die Ellipse (...) werden <span class="tx_code">Args</span> beziehungsweise args zu einem sogenannten Parameterpack. Genauer gesagt ist <span class="tx_code">Args</span> ein Template-Parameterpack und <span class="tx_code">args</span> ein Funktionsparameterpack. Mit Ersterem sind zwei Operationen möglich: Es kann gepackt und entpackt werden. Wenn die Ellipse links von <span class="tx_code">Args</span> steht, wird das Parameterpack gepackt, wenn sie rechts steht, wird es entpackt. Durch Function Template Argument Deduction kann der Compiler die Template Argumente automatisch ableiten.</div><div class="text">Variadic Templates werden oft in der Standard Template Library und auch in der Kernsprache verwendet.</div><div class="pre">template &lt;typename... Types&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>class tuple; <br><br>template &lt;typename Callabe, typename... Args &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>explicit thread(Callable&amp;&amp; f, Args&amp;&amp;... args);&nbsp;&nbsp;&nbsp; <br><br>template &lt;typename Lockable1, typename Lockable2, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typename... LockableN&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>void lock( Lockable1&amp; lock1, Lockable2&amp; lock2, LockableN&amp;... lockn );<br><br>sizeof...(ParameterPack);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)</div><div class="text">Alle vier Beispiele aus dem C++11 Standard verwenden Variadic Templates. Die ersten drei sind Teil der Standard Template Library. Was lässt sich aus den Deklarationen bestimmen?<br></div><div class="text"><ul><li><span class="tx_code">std::tuple</span> akzeptiert eine beliebige Anzahl von verschiedenen Typen.</li><li><span class="tx_code">std::thread </span>erlaubt es, ein Callable mit einer beliebigen Anzahl von Argumenten aufzurufen. Die Argumente können verschiedene Typen besitzen. Ein Callable ist eine Entität, das man aufrufen kann, beispielsweise eine Funktion, ein Funktionsobjekt oder ein Lambda-Ausdruck. Die Funktion <span class="tx_code">std::thread</span> nimmt ihr Callable und ihre Argumente per Universeller Referenz an. Wenn du mehr Details brauchst: Über die Ableitung von Template-Argumenten und Universeller Referenzen habe ich bereits in meinem Beitrag "<a title="Link auf https://www.heise.de/developer/artikel/Template-Arguments-6069388.html" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FTemplate-Arguments-6069388.html%22%2C%22text%22%3A%22Template%20Arguments%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FTemplate-Arguments-6069388.html%22%7D" href="https://www.heise.de/developer/artikel/Template-Arguments-6069388.html">Template Arguments</a>" geschrieben.&nbsp;</li><li><span class="tx_code">std::lock </span>erlaubt es, eine beliebige Anzahl von <span class="tx_code">Lockable</span>-Typen in einem atomaren Schritt zu sperren. Einen lockable Typ in einem atomaren Schritt zu locken ist trivial. Folglich benötigt <span class="tx_code">std::lock </span>mindestens zwei Argumente. <span class="tx_code">Lockable</span> wird die Anforderung genannt. Datentypen, die <span class="tx_code">Lockable</span> unterstützen, müssen die Memberfunktionen <span class="tx_code">lock</span>, <span class="tx_code">unlock</span> und<span class="tx_code"> try_lock</span> anbieten.</li><li>Der<span class="tx_code"> sizeof ...</span> - Operator gibt die Anzahl der Elemente im Parameterpack zurück.</li></ul></div><div class="text">Der<span class="tx_code"> sizeof...</span>-Operator ist besonders, da hier Parameterpacks auf der C++ Kernsprache zum Einsatz kommen. <br></div><div class="ztitel_kleiner"><span class="tx_code">sizeof...</span>-Operator</div><div class="text">Mithilfe des<span class="tx_code"> sizeof...</span>-Operators kann direkt ermittelt werden, wie viele Elemente ein Parameterpack enthält. Die Elemente werden dabei nicht ausgewertet.</div><div class="pre">// printSize.cpp<br><br>#include &lt;iostream&gt;<br><br>using namespace std::literals;<br><br>template &lt;typename ... Args&gt;<br>void printSize(Args&amp;&amp; ... args){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; sizeof...(Args) &lt;&lt; ' ';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; sizeof...(args) &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; printSize();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; printSize("C string", "C++ string"s, 2011, true);&nbsp; // (4)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text">Der<span class="tx_code"> sizeof...</span>-Operator erlaubt es, die Größe des Template-Parameterpacks (1) und des Funktionsparameterpacks (2) zur Kompilierzeit zu bestimmen. Ich wende ihn auf ein leeres Parameterpaket (3) und ein Parameterpaket mit vier Elementen an. Das erste Element ist ein C-String und das zweite ein C++-String. Um das C++-String-Literal zu verwenden, muss ich den Namensraum<span class="tx_code"> std::literals </span>(5) einbinden. C++14 unterstützt C++-String-Literale.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/5/0/0/6/1/TN_215204925_620898fa3a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel">Wie geht's weiter?</div><div class="text">In meinem nächsten Beitrag tauche ich tiefer in Variadic Templates ein und stelle das funktionale Muster zur Auswertung eines Variadic Template vor. Außerdem präsentiere ich die perfekte Fabrikfunktion und springe von C++11 sechs Jahre weiter: Fold Expression in C++17.<br></div>