<div class="text"><b>Es ist recht interessant, welche Regeln der Compiler anwendet, um die Template-Argumente abzuleiten. Um es kurz zu machen: Fast immer resultiert der erwartete Datentyp. </b></div><div class="text">Die Regeln gelten nicht nur für Funktions-Templates (C++98), sondern auch für <span class="tx_code">auto</span> (C++11), für Klassen-Templates (C++17) und Concepts (C++20).</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/2/0/5/2/8/TN_212236574_9a6797cd4c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="text">C++ unterstützt die Ableitung von Funktions-Template-Argumenten seit seinen Anfängen. Hier ist eine kurze Rekapitulation.</div><div class="ztitel">Funktions-Template Argument Deduktion</div><div class="text">Zunächst rufe ich ein Funktions-Template <span class="tx_code">max</span> für <span class="tx_code">int</span> und <span class="tx_code">double</span> auf <br></div><div class="pre">template &lt;typename T&gt;<br>T max(T lhs, T rhs) {<br>&nbsp;&nbsp;&nbsp; return (lhs &gt; rhs)? lhs : rhs;<br>}<br><br>int main() {<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; max(10, 5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; max(10.5, 5.5);&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; <br>}</div><div class="text">In diesem Fall leitet der Compiler die Template-Argumente aus den Funktionsargumenten ab. C++ Insights zeigt, dass der Compiler ein vollständig spezialisiertes Funktions-Template für <span class="tx_code">max</span> für <span class="tx_code">int</span> (1) und für <span class="tx_code">double</span> (2) erstellt.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/2/0/5/2/8/TN_212236583_d9fe4c3ae9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Der Prozess der Template-Typ-Deduktion, wie in diesem Fall, produziert meist den erwarteten Typ. Es ist recht aufschlussreich, diesen Prozess tiefer zu analysieren.</div><div class="ztitel">Template Type Deduction</div><div class="text">Bei der Ableitung des Template-Typs kommen drei Entitäten ins Spiel: <span class="tx_code">T</span>, <span class="tx_code">ParameterType</span> und der Ausdruck <span class="tx_code">expression.</span><br></div><div class="pre">template &lt;typename T&gt;<br>void func(ParameterType param);<br><br>func(expression);</div><div class="text">Es werden zwei Typen abgeleitet:</div><div class="text"><ul><li><span class="tx_code">T</span></li><li><span class="tx_code">ParameterType</span><br></li></ul></div><div class="text">Für <span class="tx_code">ParameterType</span> gibt es die drei Möglichkeiten:<br></div><div class="text"><ul><li>Wert&nbsp;</li><li>Referenz (<span class="tx_code">&amp;</span>) oder Zeiger (<span class="tx_code">*</span>)</li><li>Univerale Referenz (<span class="tx_code">&amp;&amp;</span>)</li></ul></div><div class="text">Der Ausdruck wiederum kann ein <span class="tx_code">lvalue</span> oder ein <span class="tx_code">rvalue</span> sein. Zusätzlich kann der <span class="tx_code">lvalue</span> oder <span class="tx_code">rvalue</span> eine Referenz, oder <span class="tx_code">const</span> oder <span class="tx_code">volatile</span> qualifiziert <span class="tx_code">sein</span>.<br></div><div class="text">Der einfachste Weg, die Template-Typ-Deduktion zu verstehen, ist, den <span class="tx_code">ParameterType</span> zu variieren.</div><div class="ztitel_kleiner">ParameterType ist ein Wert</div><div class="text">Den Parameter als Wert zu nehmen, ist wohl die am häufigsten verwendete Variante.<br></div><div class="pre">template &lt;typename T&gt;<br>void func(T param);<br><br>func(expr);<br></div><div class="text"><ul><li>Wenn <span class="tx_code">expr</span> eine Referenz ist, wird die Referenz ignoriert =&gt; <span class="tx_code">newExpr</span> wird erzeugt</li><li>Wenn <span class="tx_code">newExpr</span> <span class="tx_code">const</span> oder <span class="tx_code">volatile</span> ist, wird <span class="tx_code">const</span> oder <span class="tx_code">volatile</span> ignoriert.</li></ul></div><div class="text">Wenn der <span class="tx_code">ParameterType</span> eine Referenz oder eine universelle Referenz ist, wird die constness (oder volatileness) von <span class="tx_code">expr</span> beachtet.</div><div class="ztitel_kleiner">ParameterType ist eine Referenz (&amp;) oder ein Zeiger (*)</div><div class="text">Der Einfachheit halber verwende ich eine Referenz. Die analoge Argumentation gilt für einen Zeiger. Im Wesentlichen ergibt sich das erwartete Ergebnis.</div><div class="pre">template &lt;typename T&gt;<br>void func(T&amp; param);<br>// void func(T* param);<br><br>func(expr);</div><div class="text"><ul><li>Wenn <span class="tx_code">expr</span> eine Referenz ist, wird die Referenz ignoriert (aber letztendlich wieder hinzugefügt).</li><li>Wenn <span class="tx_code">expr</span> mit dem <span class="tx_code">ParameterType</span> übereinstimmt, wird der resultierende Typ zu einer Referenz. Das bedeutet:</li><ul><li>eine <span class="tx_code">expr</span> vom Typ <span class="tx_code">int</span> wird zu einem<span class="tx_code"> int&amp;</span></li><li>eine <span class="tx_code">expr</span> vom Typ<span class="tx_code"> const int </span>wird zu einem <span class="tx_code">const int&amp;</span></li><li>eine<span class="tx_code"> expr</span> vom Typ <span class="tx_code">const int&amp;</span> wird zu einem <span class="tx_code">const int&amp;</span></li></ul></ul></div><div class="ztitel_kleiner">ParameterType ist eine Universelle Referenz (&amp;&amp;)</div><div class="pre">template &lt;typename T&gt;<br>void func(T&amp;&amp; param);<br><br>func(expr);</div><div class="text"><ul><li>Wenn <span class="tx_code">expr</span> ein <span class="tx_code">lvalue</span> ist, wird der resultierende Typ zu einer lvalue-Referenz.</li><li>Wenn <span class="tx_code">expr</span> ein <span class="tx_code">rvalue</span> ist, wird der resultierende Typ zu einer rvalue-Referenz.</li></ul></div><div class="text">Zugegeben, diese Erklärung war ziemlich technisch. Hier ist ein Beispiel.</div><div class="pre">// templateTypeDeduction.cpp<br><br>template &lt;typename T&gt;<br>void funcValue(T param) { }<br><br>template &lt;typename T&gt;<br>void funcReference(T&amp; param) { }<br><br>template &lt;typename T&gt;<br>void funcUniversalReference(T&amp;&amp; param) { }<br><br>class RVal{};<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; const int lVal{};<br>&nbsp;&nbsp;&nbsp; const int&amp; ref = lVal;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; funcValue(lVal);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; funcValue(ref);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; funcReference(lVal);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; funcUniversalReference(lVal);&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; funcUniversalReference(RVal());<br><br>}</div><div class="text">Ich definiere und verwende ein Funktions-Template, das sein Argument per Wert (1), per Referenz (2) und per universeller Referenz (3) nimmt.</div><div class="text">Dank <a title="Link auf https://cppinsights.io/s/6bb71783" alt="%7B%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F6bb71783%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C%2B%2B%20Insights%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F6bb71783%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" href="https://cppinsights.io/s/6bb71783">C++ Insights</a> kann ich die Typableitung des Compilers visualisieren.<br> </div><div class="text"><ul><li>(1): Beide Aufrufe von <span class="tx_code">funcValue</span> bewirken die gleiche Instanziierung der Funktions-Templates. Der abgeleitete Typ ist ein <span class="tx_code">int</span>.</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/2/0/5/2/8/TN_212236589_2c53df233d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>&nbsp;(2): Der Aufruf der Funktion <span class="tx_code">funcReference</span> mit <span class="tx_code">const int&amp;</span> ergibt den Typ <span class="tx_code">const int&amp;</span>.</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/2/0/5/2/8/TN_212236594_821f7ff231.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>&nbsp;(3): Der Aufruf der Funktion <span class="tx_code">funcUniversalReference</span> ergibt eine lvalue-Referenz oder eine rvalue-Referenz.</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/2/0/5/2/8/TN_212236598_2f9ef8c913.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Es gibt ein interessantes Verhalten, wenn man die Funktion <span class="tx_code">funcValue</span> mit einem C-Array aufruft. Das C-Array decays (verfällt).<br></div><div class="ztitel_kleiner">Decay eines C-Arrays</div><div class="text">Ein C-Array als Wert anzunehmen ist besonders.</div><div class="pre">// typeDeductionArray.cpp<br><br>template &lt;typename T&gt;<br>void funcValue(T param) { }<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; int intArray[10]{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};<br><br>&nbsp;&nbsp;&nbsp; funcValue(intArray);<br>&nbsp;&nbsp; &nbsp;<br>}</div><div class="text">Wird das Funktions-Template <span class="tx_code">funcValue</span> mit einem C-Array aufgerufen, <i>decayed</i> das C-Array in einen Zeiger auf sein erstes Element. Decay hat viele Facetten. Es wird angewendet, wenn ein Funktionsargument als Wert übergeben wird. Decay bedeutet, dass eine implizite Konvertierung Funktion-zu-Zeiger, Array-zu-Zeiger oder lvalue-zu-rvalue gegebenenfalls angewendet wird. Zusätzlich werden die Referenz eines Typs <span class="tx_code">T</span> und seine<span class="tx_code"> const/volatile</span> Qualifizierer entfernt.</div><div class="text">Hier ist der Screenshot des Programms aus<a title="Link auf https://cppinsights.io/s/910a53e4" alt="%7B%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F910a53e4%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22%20C%2B%2B%20Insights%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F910a53e4%22%7D" href="https://cppinsights.io/s/910a53e4"> C++ Insights</a>.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/2/0/5/2/8/TN_212236605_1baa0c2ab9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:8 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Das bedeutet im Wesentlichen, dass die Größe des C-Arrays nicht bekannt ist. </div><div class="text">Aber es gibt einen Trick. Wenn man das C-Array per Referenz nimmt und den Typ und die Größe des C-Arrays annimmt, ermittelt der Compiler seine Größe.<br></div><div class="pre">// typeDeductionArraySize.cpp<br><br>#include &lt;cstddef&gt;<br>#include &lt;iostream&gt;<br><br>template &lt;typename T, std::size_t N&gt;<br>std::size_t funcArraySize(T (&amp;arr)[N]) { <br>&nbsp;&nbsp;&nbsp; return N;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; int intArray[10]{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};<br><br>&nbsp;&nbsp;&nbsp; funcArraySize(intArray);<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "funcArraySize(intArray): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; funcArraySize(intArray) &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>}</div><div class="text">Das Funktions-Template <span class="tx_code">funcArraySize</span> leitet die Größe des C-Arrays ab. Ich habe aus Gründen der Lesbarkeit dem C-Array Parameter den Namen <span class="tx_code">arr</span> gegeben:<span class="tx_code"> std::size_t funcArraySize(T (&amp;arr)[N])</span>. Dies ist nicht notwendig und du kannst einfach<span class="tx_code"> std::size_t funcArraySize(T (&amp;)[N])</span> schreiben.&nbsp; Hier sind die Interna aus<a title="Link auf https://cppinsights.io/s/6e908572" alt="%7B%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F6e908572%22%2C%22text%22%3A%22%20C%2B%2B%20Insights%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F6e908572%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D" href="https://cppinsights.io/s/6e908572"> C++ Insights</a>.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/2/0/5/2/8/TN_212236612_5928adeddf.png" title="<ir_inline itemname=bilder_mvp_bild_var2:9 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Zum Abschluss noch die Ausgabe des Programms:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/2/0/5/2/8/TN_212236628_e5f494ef22.png" title="<ir_inline itemname=bilder_mvp_bild_var2:12 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="text">Dieses Wissen über die automatische Bestimmung der Typen der Template-Argumente, lässt sich direkt auf <span class="tx_code">auto</span> (C++11) anwenden.</div><div class="ztitel">auto Typ Deduktion</div><div class="text">Die <span class="tx_code">auto</span> Typ-Deduktion verwendet die Regeln der Template-Typ-Deduktion<br></div><div class="text">Zur Erinnerung, dies sind die wesentlichen Entitäten der Template-Typ-Deduktion:</div><div class="pre">template &lt;typname T&gt; <br>void func(ParameterType param);<br><br>auto val = 2011;</div><div class="text">Das Verständnis von <span class="tx_code">auto</span> bedeutet, dass <span class="tx_code">auto</span> als Ersatz für<span class="tx_code"> T</span> und die Typspezifizierer von <span class="tx_code">auto</span> als Ersatz für den <span class="tx_code">ParameterType</span> in dem Funktions-Template zu betrachten ist.</div><div class="text">Der Typspezifizierer kann ein Wert (1), eine Referenz (2) oder eine universelle Referenz (3) sein.</div><div class="pre">auto val = arg; // (1)<br><br>auto&amp; val = arg; // (2)<br><br>auto&amp;&amp; val = arg; // (3)</div><div class="text">Probieren wir es aus und ändern das vorherige Programm<span class="tx_code"> templateTypeDeduction.cpp</span> und verwenden <span class="tx_code">auto</span> anstelle von Funktions-Templates.</div><div class="pre">// autoTypeDeduction.cpp<br><br>class RVal{};<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; const int lVal{};<br>&nbsp;&nbsp;&nbsp; const int&amp; ref = lVal;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; auto val1 = lVal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; auto val2 = ref;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; auto&amp; val3 = lVal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; auto&amp;&amp; val4 = lVal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; auto&amp;&amp; val5 = RVal();<br><br>}</div><div class="text">Beim Betrachten der resultierenden Typen in<a title="Link auf https://cppinsights.io/s/2c652b47" alt="%7B%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F2c652b47%22%2C%22text%22%3A%22%20C%2B%2B%20Insights%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F2c652b47%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%7D" href="https://cppinsights.io/s/2c652b47"> C++ Insights</a> fällt auf, dass sie identisch mit den Typen sind, die im Programm<span class="tx_code"> templateTypeDeduction.cpp</span> abgeleitet wurden.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/2/0/5/2/8/TN_212236615_17e6324a2a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:10 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Natürlich <i>decayed</i> auto auch, wenn es ein C-Array als Wert annimmt.</div><div class="ztitel">Das neue pdf-Bundle ist fertig: C++20 Coroutines</div><div class="text">Ich habe das pdf-Bundle vorbereitet. Es zu erhalten ist ganz einfach. Ich verschicke automatisch bei der Anmeldung an meinen deutschen oder englischen Newsletter einen Link zu dem pdf-Bundle.<br></div><div class="text">Hier gibt es mehr Informationen zu dem pdf-Bundle:&nbsp; <a title="Link auf https://www.modernescpp.com/index.php/the-new-pdf-bundle-is-ready-coroutines" alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C%2B%2B%20Coroutines%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fthe-new-pdf-bundle-is-ready-coroutines%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fthe-new-pdf-bundle-is-ready-coroutines%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%7D" href="https://www.modernescpp.com/index.php/the-new-pdf-bundle-is-ready-coroutines">C++ Coroutines</a>.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/2/0/5/2/8/TN_212236621_cea6928a62.png" title="<ir_inline itemname=bilder_mvp_bild_var2:11 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel">Wie geht's weiter?<br></div><div class="text">C++17 macht Typ-Deduktion mächtiger. Erstens ist eine automatische Typableitung für Nicht-Typ-Template-Parameter möglich und zweitens können Klassen-Templates auch ihre Argumente ableiten. Insbesondere die Klassen-Template-Argument-Deduktion macht das Programmiererleben viel einfacher.<br></div>