<div class="vorspann">Nach dem Einblick in dynamische Polymorphie fahre ich mit der statischen Polymorphie fort und stelle ein interessantes Idiom in C++ vor: das Curiously Recurring Template Pattern (CRTP).</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/5/1/0/0/8/TN_229590018_27b0c6ef92.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Starten möchte ich diesen Artikel mit einer kurzen Erinnerung an den letzten <a title="Link auf Beitrag 3325024" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D59f651ab790860d4e62eb3871cb545c7%26rm%3Dopen_article_id%26bid%3D3325024%22%2C%22mediasync_id%22%3A%22%22%2C%22target%22%3A%22%22%2C%22text%22%3A%22Beitrag%20zur%20dynamischen%20Polymorphie%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22destination%22%3A3325024%7D" href="/exec/mainmenu.pl?sid=59f651ab790860d4e62eb3871cb545c7&amp;rm=open_article_id&amp;bid=3325024">Beitrag zur dynamischen Polymorphie</a>.<br></div><div class="text">Dynamische Polymorphie basiert auf der Objektorientierung und ermöglicht es uns, zwischen dem Interface und der Implementierung einer Klassenhierarchie zu unterscheiden. Um Dynamic Dispatch zu erhalten, genügen zwei Zutaten: Virtualität und eine Indirektion wie einen Zeiger oder eine Referenz. Das folgende Programm liefert ein Beispiel für dynamische Polymorphie:<br></div><div class="pre">// dispatchDynamicPolymorphism.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br><br>auto start = std::chrono::steady_clock::now();<br><br>void writeElapsedTime(){<br>&nbsp;&nbsp;&nbsp; auto now = std::chrono::steady_clock::now();<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; diff = now - start;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; diff.count() &lt;&lt; " sec. elapsed: ";<br>}<br><br>struct MessageSeverity{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;virtual void writeMessage() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::cerr &lt;&lt; "unexpected" &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;}<br>};<br><br>struct MessageInformation: MessageSeverity{&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;void writeMessage() const override {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::cerr &lt;&lt; "information" &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;}<br>};<br><br>struct MessageWarning: MessageSeverity{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;void writeMessage() const override {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::cerr &lt;&lt; "warning" &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;}<br>};<br><br>struct MessageFatal: MessageSeverity{};<br><br>void writeMessageReference(const MessageSeverity&amp; messServer){&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;writeElapsedTime();<br>&nbsp;&nbsp; &nbsp;messServer.writeMessage();<br>&nbsp;&nbsp; &nbsp;<br>}<br><br>void writeMessagePointer(const MessageSeverity* messServer){&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;writeElapsedTime();<br>&nbsp;&nbsp; &nbsp;messServer-&gt;writeMessage();<br>&nbsp;&nbsp; &nbsp;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageInformation messInfo;<br>&nbsp;&nbsp;&nbsp; MessageWarning messWarn;<br>&nbsp;&nbsp;&nbsp; MessageFatal messFatal;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageSeverity&amp; messRef1 = messInfo;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; MessageSeverity&amp; messRef2 = messWarn;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; MessageSeverity&amp; messRef3 = messFatal;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; writeMessageReference(messRef1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; writeMessageReference(messRef2);<br>&nbsp;&nbsp;&nbsp; writeMessageReference(messRef3);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; '\n';<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageSeverity* messPoin1 = new MessageInformation;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; MessageSeverity* messPoin2 = new MessageWarning;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; MessageSeverity* messPoin3 = new MessageFatal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; writeMessagePointer(messPoin1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; writeMessagePointer(messPoin2);<br>&nbsp;&nbsp;&nbsp; writeMessagePointer(messPoin3);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}<br></div><div class="text">Die statische Polymorphie basiert auf Templates. Lass mich das Programm mithilfe des Curiously Recurring Template Pattern (CRTP) refaktorieren.</div><div class="ztitel">Statische Polymorphie<br></div><div class="text">Bevor ich das vorherige Programm <span class="tx_code">dispatchDynamicPolymorphism.cpp</span> überarbeite, möchte ich den Kerngedanken von CRTP vorstellen: Eine Klasse <span class="tx_code">Derived</span> leitet sich von einem Klassen-Template <span class="tx_code">Base</span> ab, das seinerseits <span class="tx_code">Derived</span> als Template-Argument besitzt.<br></div><div class="pre">template &lt;typename T&gt;<br>class Base<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>};<br><br>class Derived : public Base&lt;Derived&gt;<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>};<br></div><div class="text">Die eigentliche Natur von CRTP sieht folgendermaßen aus:<br></div><div class="pre">// crtp.cpp<br><br>#include &lt;iostream&gt;<br><br>template &lt;typename Derived&gt;<br>struct Base{<br>&nbsp; void interface(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; static_cast&lt;Derived*&gt;(this)-&gt;implementation();<br>&nbsp; }<br>&nbsp; void implementation(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Implementation Base" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>struct Derived1: Base&lt;Derived1&gt;{<br>&nbsp; void implementation(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Implementation Derived1" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>struct Derived2: Base&lt;Derived2&gt;{<br>&nbsp; void implementation(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Implementation Derived2" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>struct Derived3: Base&lt;Derived3&gt;{};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br><br>template &lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>void execute(T&amp; base){<br>&nbsp;&nbsp;&nbsp; base.interface();<br>}<br><br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; Derived1 d1;<br>&nbsp; execute(d1);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; Derived2 d2;<br>&nbsp; execute(d2);<br>&nbsp; <br>&nbsp; Derived3 d3;<br>&nbsp; execute(d3);<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>}</div><div class="text">Ich verwende in dem Funktions-Template <span class="tx_code">execute</span> (// 1) statische Polymorphie. Jede <span class="tx_code">base</span> ruft die Methode<span class="tx_code"> base.interface</span> auf. Die Memberfunktion<span class="tx_code"> Base::interface</span> (// 2) ist der Schlüssel des CRTP-Idioms. Die Memberfunktion leitet an die Implementierung der abgeleiteten Klasse weiter: <span class="tx_code">static_cast&lt;Derived*&gt;(this)-&gt;implementation()</span>.&nbsp; Das ist möglich, weil die Funktion erst beim Aufruf instanziiert wird. Zu diesem Zeitpunkt sind die abgeleiteten Klassen <span class="tx_code">Derived1</span>, <span class="tx_code">Derived2</span> und <span class="tx_code">Derived3</span> vollständig definiert. Daher kann die Funktion <span class="tx_code">Base::interface</span> die Implementierung der abgeleiteten Klassen verwenden. Interessant ist dabei die Memberfunktion <span class="tx_code">Base::implementation</span> (// 3). Sie spielt die Rolle einer Defaultimplementierung für die statische Polymorphie der Klasse <span class="tx_code">Derived3</span> (// 4).<br></div><div class="text">Hier ist die Ausgabe des Programms:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/5/1/0/0/8/TN_229590025_71939d7bfc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br> </div><div class="text">Nun möchte ich den nächsten Schritt machen und das Programm <span class="tx_code">dispatchDynamicPolymorphism.cpp</span> refaktorieren.<br> </div><div class="pre">// dispatchStaticPolymorphism.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br><br>auto start = std::chrono::steady_clock::now();<br><br>void writeElapsedTime(){<br>&nbsp;&nbsp;&nbsp; auto now = std::chrono::steady_clock::now();<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; diff = now - start;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; diff.count() &lt;&lt; " sec. elapsed: ";<br>}<br><br>template &lt;typename ConcreteMessage&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>struct MessageSeverity{<br>&nbsp; void writeMessage(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; static_cast&lt;ConcreteMessage*&gt;(this)-&gt;writeMessageImplementation();<br>&nbsp; }<br>&nbsp; void writeMessageImplementation() const {<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "unexpected" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>struct MessageInformation: MessageSeverity&lt;MessageInformation&gt;{<br>&nbsp; void writeMessageImplementation() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "information" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>struct MessageWarning: MessageSeverity&lt;MessageWarning&gt;{<br>&nbsp; void writeMessageImplementation() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "warning" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>struct MessageFatal: MessageSeverity&lt;MessageFatal&gt;{};&nbsp; // (5)<br><br>template &lt;typename T&gt;<br>void writeMessage(T&amp; messServer){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; writeElapsedTime();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; messServer.writeMessage();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp; &nbsp;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageInformation messInfo;<br>&nbsp;&nbsp;&nbsp; writeMessage(messInfo);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; MessageWarning messWarn;<br>&nbsp;&nbsp;&nbsp; writeMessage(messWarn);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; MessageFatal messFatal;<br>&nbsp;&nbsp;&nbsp; writeMessage(messFatal);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div><div class="text">In diesem Fall leiten sich alle konkreten Klassen (// 3, // 4 und // 5) von der Basisklasse <span class="tx_code">MessageSeverity</span> ab. Die Memberfunktion <span class="tx_code">writeMessage</span> ist die Schnittstelle, die an die konkreten Implementierungen <span class="tx_code">writeMessageImplementation</span> weiterleitet. Um dies zu erreichen, wird das Objekt in die ConcreteMessage upgecastet:<span class="tx_code"> static_cast&lt;ConcreteMessage*&gt;(this)-&gt;writeMessageImplementation()</span>. Dies ist der statische Dispatch zur Compilezeit, der auch den Namen für diese Technik geprägt hat: statische Polymorphie.<br> </div><div class="text">Um ehrlich zu sein, habe ich einige Zeit gebraucht, um mich an die eigentümliche Syntax von CRTP zu gewöhnen, aber die Anwendung der statischen Polymorphie in // (6) ist recht einfach.<br> </div><div class="text">Zum Schluss möchte ich dynamische und statische Polymorphie kurz vergleichen:<br> </div><div class="ztitel">Dynamische versus statische Polymorphie <br> </div><div class="text">Dynamische Polymorphie findet zur Laufzeit statt, statische Polymorphie zur Compilezeit. Dynamische Polymorphie erfordert in der Regel eine Zeigerindirektion zur Laufzeit (vergleiche den Beitrag "<a title="Link auf https://medium.com/@abhichavhan/demystifying-virtual-functions-vtable-and-vptr-in-c-bf56f11f7cc7" alt="%7B%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fmedium.com%2F%40abhichavhan%2Fdemystifying-virtual-functions-vtable-and-vptr-in-c-bf56f11f7cc7%22%2C%22text%22%3A%22Demystifying%20virtual%20functions%2C%20Vtable%2C%20and%20VPTR%20in%20C%2B%2B%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fmedium.com%2F%40abhichavhan%2Fdemystifying-virtual-functions-vtable-and-vptr-in-c-bf56f11f7cc7%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%7D" href="https://medium.com/@abhichavhan/demystifying-virtual-functions-vtable-and-vptr-in-c-bf56f11f7cc7">Demystifying virtual functions, Vtable, and VPTR in C++</a>"), statische Polymorphie hat hingegen keinen Laufzeiteinfluss. Zugegeben, es gibt einen Grund, warum das Idiom Curiously Recurring Template Pattern (CRTP) den Begriff curious (seltsam) im Namen trägt: Für Anfänger ist das Idiom ziemlich schwer zu verstehen. Wann sollte es daher eingesetzt werden?<br></div><div class="text">Zunächst einmal solltest du die Kosten für einen virtuellen Aufruf nicht überschätzen. In den meisten Fällen lassen sie sich ignorieren. Details zu den Performanzzahlen finden sich in dem hervorragenden Paper "<a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf" alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22Technical%20Report%20on%20C%2B%2B%20Performance%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2FTR18015.pdf%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2FTR18015.pdf%22%2C%22ir_link%22%3A1%7D" href="http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf">Technical Report on C++ Performance</a>". Es ist zwar recht alt, enthält aber in Abschnitt 5.3.3 interessante Messungen zu den zusätzlichen Kosten virtueller Funktionsaufrufe. Wenn du dir immer noch Sorgen um die Performanz machst, gibt es nur ein Mittel: Messen. Versioniere deine Performanztests und wiederhole sie immer dann, wenn sich etwas an deiner Hardware, deinem Compiler oder der Compiler-Version geändert hat, denn derartige Änderungen lassen deine bisherigen Leistungszahlen ungültig werden.<br> </div><div class="text">Letztendlich wird der Code viel öfter gelesen als geschrieben. Daher solltest du die Techniken anwenden, mit denen dein Team am besten zurechtkommt.<br></div><div class="ztitel">Wie geht's weiter?<br> </div><div class="text">Mixins sind eine beliebte Technik in Python. Sie ermöglichen es dir, das Verhalten einer Klasse durch Mehrfachvererbung zu ändern. Dank CRTP gibt es Mixins auch in C++. Lies mehr darüber in meinem nächsten Artikel.<br></div>