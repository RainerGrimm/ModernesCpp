<div class="vorspann">Expression Templates werden typischerweise in der linearen Algebra verwendet und vermeiden temporäre Objekte.</div><div class="text">Sie sind <a title="Link auf https://en.wikipedia.org/wiki/Expression_templates" alt="%7B%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FExpression_templates%22%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FExpression_templates%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22laut%20Wikipedia%22%7D" href="https://en.wikipedia.org/wiki/Expression_templates">laut Wikipedia</a> "structures representing a computation at compile-time, which structures are evaluated only as needed to produce efficient code for the entire computation". Mit anderen Worten: Expression Templates werden nur bei Bedarf ausgewertet. </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/6/3/1/6/2/TN_230532048_d97c71c6ad.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">In diesem Artikel stelle ich nur die zentralen Ideen von Expression Templates vor. Um sie einzusetzen, sollte man weitere Inhalte kennen wie<br></div><div class="text"><ul><li> C++ Templates: The Complete Guide von David Vandervoorde, Nicolai M. Josuttis, und Douglas Gregor (<a title="Link auf http://www.tmplbook.com/" alt="%7B%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.tmplbook.com%2F%22%2C%22href%22%3A%22http%3A%2F%2Fwww.tmplbook.com%2F%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22http%3A%2F%2Fwww.tmplbook.com%2F%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%7D" href="http://www.tmplbook.com/">http://www.tmplbook.com/</a>)</li><li>Boost Basic Linear Algebra Library (<a title="Link auf https://www.boost.org/doc/libs/1_59_0/libs/numeric/ublas/doc/index.html" alt="%7B%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.boost.org%2Fdoc%2Flibs%2F1_59_0%2Flibs%2Fnumeric%2Fublas%2Fdoc%2Findex.html%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.boost.org%2Fdoc%2Flibs%2F1_59_0%2Flibs%2Fnumeric%2Fublas%2Fdoc%2Findex.html%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22https%3A%2F%2Fwww.boost.org%2Fdoc%2Flibs%2F1_59_0%2Flibs%2Fnumeric%2Fublas%2Fdoc%2Findex.html%22%7D" href="https://www.boost.org/doc/libs/1_59_0/libs/numeric/ublas/doc/index.html">https://www.boost.org/doc/libs/1_59_0/libs/numeric/ublas/doc/index.html</a>)</li><li>Expression Templates Revisited von Klaus Iglberger (<a title="Link auf https://www.youtube.com/watch?v=hfn0BVOegac" alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Dhfn0BVOegac%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Dhfn0BVOegac%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Dhfn0BVOegac%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%7D" href="https://www.youtube.com/watch?v=hfn0BVOegac">https://www.youtube.com/watch?v=hfn0BVOegac</a>). Klaus demystifiziert in seinem Vortrag viele Performanzmythen rund um Expression Templates.</li></ul></div><div class="text">Welches Problem wird mit Expression Templates gelöst? Mit Expression Templates kann man überflüssige temporäre Objekte in Ausdrücken loswerden. Was ich damit meine, zeige ich an meiner Implementierung der Klasse <span class="tx_code">MyVector</span>.</div><div class="ztitel">Ein erster naiver Ansatz</div><div class="text"><span class="tx_code">MyVector</span> ist ein einfacher Wrapper für einen <span class="tx_code">std::vector&lt;T&gt;</span>. Der Wrapper hat zwei Konstruktoren (1 und 2), kennt seine Länge (3) und unterstützt den Indexzugriff zum Lesen (4) und Schreiben (4) seiner Werte.</div><div class="pre">// vectorArithmeticOperatorOverloading.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>template&lt;typename T&gt;<br>class MyVector{<br>&nbsp; std::vector&lt;T&gt; cont;&nbsp; &nbsp;<br><br>public:<br>&nbsp; // MyVector with initial size<br>&nbsp; MyVector(const std::size_t n) : cont(n){}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp; // MyVector with initial size and value<br>&nbsp; MyVector(const std::size_t n, const double initialValue) : <br>&nbsp;&nbsp;&nbsp; cont(n, initialValue){}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; <br>&nbsp; // size of underlying container<br>&nbsp; std::size_t size() const{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; return cont.size(); <br>&nbsp; }<br><br>&nbsp; // index operators<br>&nbsp; T operator[](const std::size_t i) const<br>&nbsp; {&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; return cont[i]; <br>&nbsp; }<br><br>&nbsp; T&amp; operator[](const std::size_t i)<br>&nbsp; { &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; return cont[i]; <br>&nbsp; }<br><br>};<br><br>// function template for the + operator<br>template&lt;typename T&gt; <br>MyVector&lt;T&gt; operator+ (const MyVector&lt;T&gt;&amp; a, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const MyVector&lt;T&gt;&amp; b){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp; MyVector&lt;T&gt; result(a.size());<br>&nbsp; for (std::size_t s = 0; s &lt;= a.size(); ++s){<br>&nbsp;&nbsp;&nbsp; result[s] = a[s] + b[s];<br>&nbsp; }<br>&nbsp; return result;<br>}<br><br>// function template for the * operator<br>template&lt;typename T&gt;<br>MyVector&lt;T&gt; operator* (const MyVector&lt;T&gt;&amp; a, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const MyVector&lt;T&gt;&amp; b)<br>&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp;&nbsp; MyVector&lt;T&gt; result(a.size());<br>&nbsp; for (std::size_t s = 0; s &lt;= a.size(); ++s){<br>&nbsp;&nbsp;&nbsp; result[s] = a[s] * b[s]; <br>&nbsp; }<br>&nbsp; return result;<br>}<br><br>// function template for &lt;&lt; operator<br>template&lt;typename T&gt;<br>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const MyVector&lt;T&gt;&amp; cont)<br>&nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (8)<br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; for (int i = 0; i &lt; cont.size(); ++i) {<br>&nbsp;&nbsp;&nbsp; os &lt;&lt; cont[i] &lt;&lt; ' ';<br>&nbsp; }<br>&nbsp; os &lt;&lt; '\n';<br>&nbsp; return os;<br>} <br><br>int main(){<br><br>&nbsp; MyVector&lt;double&gt; x(10, 5.4);<br>&nbsp; MyVector&lt;double&gt; y(10, 10.3);<br><br>&nbsp; MyVector&lt;double&gt; result(10);<br>&nbsp; <br>&nbsp; result = x + x + y * y;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; result &lt;&lt; '\n';<br>&nbsp; <br>}<br></div><div class="text">Dank der überladenen Operatoren + (6) und&nbsp; * (7) und des überladenen Ausgabeoperators (8) verhalten sich die Objekte<span class="tx_code"> x, y</span> und <span class="tx_code">result</span> wie Zahlen.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/6/3/1/6/2/TN_230532058_50af52bbda.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Warum ist diese Implementierung naiv? Die Antwort liegt in dem Ausdruck<span class="tx_code"> result = x + x + y * y</span>. Um den Ausdruck auszuwerten, werden drei temporäre Objekte benötigt, die das Ergebnis jedes arithmetischen Teilausdrucks enthalten.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/6/3/1/6/2/TN_230532060_bbfcb79c2c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Wie kann ich diese temporären Objekte loswerden? Die Idee ist einfach: Statt die Vektoroperationen sofort auszuführen, erstelle ich den Ausdruck für <span class="tx_code">result[i]</span> zur Compiletime lazy. Lazy bedeutet, dass ein Ausdruck nur bei Bedarf ausgewertet wird. </div><div class="ztitel">Expression Templates </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/6/3/1/6/2/TN_230532069_1b4f295929.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Für den Ausdruck <span class="tx_code">result[i] = x[i] + x[i] + y[i] * y[i] </span>werden keine temporären Werte benötigt.&nbsp; Die Zuweisung löst die Auswertung aus. Leider ist der Code selbst in dieser einfachen Anwendung nicht so leicht zu verdauen.</div><div class="pre">// vectorArithmeticExpressionTemplates.cpp<br><br>#include &lt;cassert&gt;<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>template&lt;typename T, typename Cont= std::vector&lt;T&gt; &gt;<br>class MyVector{<br>&nbsp; Cont cont;&nbsp; &nbsp;<br><br>public:<br>&nbsp; // MyVector with initial size<br>&nbsp; MyVector(const std::size_t n) : cont(n){}<br><br>&nbsp; // MyVector with initial size and value<br>&nbsp; MyVector(const std::size_t n, const double initialValue) : <br>&nbsp;&nbsp;&nbsp; cont(n, initialValue){}<br><br>&nbsp; // Constructor for underlying container<br>&nbsp; MyVector(const Cont&amp; other) : cont(other){}<br><br>&nbsp; // assignment operator for MyVector of different type<br>&nbsp; template&lt;typename T2, typename R2&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; MyVector&amp; operator=(const MyVector&lt;T2, R2&gt;&amp; other){<br>&nbsp;&nbsp;&nbsp; assert(size() == other.size());<br>&nbsp;&nbsp;&nbsp; for (std::size_t i = 0; i &lt; cont.size(); ++i) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cont[i] = other[i];<br>&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp; }<br><br>&nbsp; // size of underlying container<br>&nbsp; std::size_t size() const{ <br>&nbsp;&nbsp;&nbsp; return cont.size(); <br>&nbsp; }<br><br>&nbsp; // index operators<br>&nbsp; T operator[](const std::size_t i) const{ <br>&nbsp;&nbsp;&nbsp; return cont[i]; <br>&nbsp; }<br><br>&nbsp; T&amp; operator[](const std::size_t i){ <br>&nbsp;&nbsp;&nbsp; return cont[i]; <br>&nbsp; }<br><br>&nbsp; // returns the underlying data<br>&nbsp; const Cont&amp; data() const{ <br>&nbsp;&nbsp;&nbsp; return cont; <br>&nbsp; }<br><br>&nbsp; Cont&amp; data(){ <br>&nbsp;&nbsp;&nbsp; return cont; <br>&nbsp; }<br>};<br><br>// MyVector + MyVector<br>template&lt;typename T, typename Op1 , typename Op2&gt;<br>class MyVectorAdd{<br>&nbsp; const Op1&amp; op1;<br>&nbsp; const Op2&amp; op2;<br><br>public:<br>&nbsp; MyVectorAdd(const Op1&amp; a, const Op2&amp; b): op1(a), op2(b){}<br><br>&nbsp; T operator[](const std::size_t i) const{ <br>&nbsp;&nbsp;&nbsp; return op1[i] + op2[i]; <br>&nbsp; }<br><br>&nbsp; std::size_t size() const{ <br>&nbsp;&nbsp;&nbsp; return op1.size(); <br>&nbsp; }<br>};<br><br>// elementwise MyVector * MyVector<br>template&lt; typename T, typename Op1 , typename Op2 &gt;<br>class MyVectorMul {<br>&nbsp; const Op1&amp; op1;<br>&nbsp; const Op2&amp; op2;<br><br>public:<br>&nbsp; MyVectorMul(const Op1&amp; a, const Op2&amp; b ): op1(a), op2(b){}<br><br>&nbsp; T operator[](const std::size_t i) const{ <br>&nbsp;&nbsp;&nbsp; return op1[i] * op2[i]; <br>&nbsp; }<br><br>&nbsp; std::size_t size() const{ <br>&nbsp;&nbsp;&nbsp; return op1.size(); <br>&nbsp; }<br>};<br><br>// function template for the + operator<br>template&lt;typename T, typename R1, typename R2&gt;<br>MyVector&lt;T, MyVectorAdd&lt;T, R1, R2&gt; &gt;<br>operator+ (const MyVector&lt;T, R1&gt;&amp; a, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const MyVector&lt;T, R2&gt;&amp; b){<br>&nbsp; return MyVector&lt;T, MyVectorAdd&lt;T, R1, R2&gt; &gt;<br>&nbsp;&nbsp;&nbsp; (MyVectorAdd&lt;T, R1, R2 &gt;(a.data(), b.data()));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>}<br><br>// function template for the * operator<br>template&lt;typename T, typename R1, typename R2&gt;<br>MyVector&lt;T, MyVectorMul&lt; T, R1, R2&gt; &gt;<br>operator* (const MyVector&lt;T, R1&gt;&amp; a, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const MyVector&lt;T, R2&gt;&amp; b)<br>&nbsp; {<br>&nbsp;&nbsp; return MyVector&lt;T, MyVectorMul&lt;T, R1, R2&gt; &gt;<br>&nbsp;&nbsp;&nbsp;&nbsp; (MyVectorMul&lt;T, R1, R2 &gt;(a.data(), b.data()));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>}<br><br>// function template for &lt; operator<br>template&lt;typename T&gt;<br>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const MyVector&lt;T&gt;&amp; cont){&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; for (int i = 0; i &lt; cont.size(); ++i) {<br>&nbsp;&nbsp;&nbsp; os &lt;&lt; cont[i] &lt;&lt; ' ';<br>&nbsp; }<br>&nbsp; os &lt;&lt; '\n';<br>&nbsp; return os;<br>} <br><br>int main(){<br><br>&nbsp; MyVector&lt;double&gt; x(10,5.4);<br>&nbsp; MyVector&lt;double&gt; y(10,10.3);<br><br>&nbsp; MyVector&lt;double&gt; result(10);<br>&nbsp; <br>&nbsp; result= x + x + y * y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; result &lt;&lt; '\n';<br>&nbsp; <br>}</div><div class="text">Der Hauptunterschied zwischen der ersten naiven Implementierung und dieser Implementierung mit Expression Templates besteht darin, dass die überladenen Operatoren + und * Operatoren im Falle der Ausdrücke Proxyobjekte zurückkehren. Diese Proxys repräsentieren die Ausdrücke (1 und 2). Die Ausdrücke werden nur erstellt, aber nicht ausgewertet: lazy, natürlich. Der Zuweisungsoperator (3) löst die Auswertung des Gesamtausdrucks aus, der keine temporären Objekte benötigt</div><div class="text">Die Ergebnisse sind natürlich identisch.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/6/3/1/6/2/TN_230532075_c95559c49c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="text">Dank des Compiler-Explorers kann ich die Magie des Programms <span class="tx_code">vectorArithmeticExpressionTemplates.cpp</span> offenlegen.</div><div class="ztitel_kleiner">Unter der Haube</div><div class="text">Hier sind die wesentlichen Assembler-Anweisungen für die letzte Zuweisung in der Hauptfunktion:<span class="tx_code"> result = x + x + y * y</span>.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/6/3/1/6/2/TN_230532083_6a18a17a23.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Der Ausdruck in dem Assemblerschnipsel schaut ziemlich kompliziert aus, aber mit einem scharfen Auge erkennt man die Struktur . Der Einfachheit halber habe ich<span class="tx_code"> std::allocator</span> in meiner Grafik ignoriert.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/6/3/1/6/2/TN_230532093_7ec18af144.png" title="<ir_inline itemname=bilder_mvp_bild_var2:9 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel">Wie geht's weiter?</div><div class="text">Eine Policy ist eine generische Funktion oder Klasse, deren Verhalten konfiguriert werden kann. Ich werde sie in meinem nächsten Artikel genauer vorstellen.</div><div class="ztitel">My English Mentoring Program "Fundamentals for C++ Professionals" is Open for Registration</div><div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/6/3/1/6/2/TN_230532084_9ec2f7c2e1.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=3>" style="max-height: 25px; max-width: 25px;"></div><div class="text">My new mentoring program "Fundamentals for C++ Professionals" starts on April 22nd. Registration is open until April 17nd. Here is more information:</div><div class="text">Launch page: <a title="Link auf https://www.modernescpp.org/" alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22https%3A%2F%2Fwww.modernescpp.org%2F%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.org%2F%22%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.org%2F%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%7D" href="https://www.modernescpp.org/">https://www.modernescpp.org/</a> </div><div class="text">Introduction: <a title="Link auf https://www.modernescpp.org/my-mentoring-program-fundamentals-for-c-professionals/" alt="%7B%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22https%3A%2F%2Fwww.modernescpp.org%2Fmy-mentoring-program-fundamentals-for-c-professionals%2F%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.org%2Fmy-mentoring-program-fundamentals-for-c-professionals%2F%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.org%2Fmy-mentoring-program-fundamentals-for-c-professionals%2F%22%2C%22mediasync_id%22%3A%22%22%7D" href="https://www.modernescpp.org/my-mentoring-program-fundamentals-for-c-professionals/">https://www.modernescpp.org/my-mentoring-program-fundamentals-for-c-professionals/</a> </div><div class="text">Still open questions? Please, call me: <a title="Link auf info@modernescpp.de" alt="%7B%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22info%40modernescpp.de%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E_Mail%22%2C%22target%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22info%40modernescpp.de%22%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22mailto%3Ainfo%40modernescpp.de%22%2C%22version%22%3A1%7D" href="mailto:info@modernescpp.de">info@modernescpp.de</a> </div>