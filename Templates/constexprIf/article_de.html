<div class="vorspann">Im heutigen Artikel möchte ich ein sehr interessantes C++17-Feature vorstellen:<span class="tx_code"> constexpr if. </span>Es ermöglicht , Sourcecode bedingt zu kompilieren und kann auch für nette Tricks zur Compilezeit verwendet werden. <br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/0/4/8/3/7/TN_226935063_f1f4446282.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="text">Die Einführung von <span class="tx_code">constexpr if </span>ist recht einfach.<br></div><div class="pre">template &lt;typename T&gt;<br>auto getValue(T t) {<br>&nbsp;&nbsp;&nbsp; if constexpr (std::is_pointer_v&lt;T&gt;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *t; // deduces return type to int for T = int*<br>&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return t;&nbsp; // deduces return type to int for T = int<br>}<br></div><div class="text">Der Codeschnipsel zeigt eine interessante Eigenschaft von <span class="tx_code">constexpr if</span>: Obwohl es <span class="tx_code">constexpr if </span>genannt wird, wird es als<span class="tx_code"> if constexpr </span>verwendet: <span class="tx_code">if constexpr (std::is_pointer_v&lt;T&gt;)</span>.<br></div><div class="text">Wenn <span class="tx_code">T</span> ein Zeiger ist, wird der<span class="tx_code"> if</span>-Zweig in (1) kompiliert. Wenn nicht, wird der <span class="tx_code">else</span>-Zweig in (2) kompiliert. Zwei Punkte sind wichtig zu erwähnen: Die Funktion<span class="tx_code"> getValue</span> hat zwei verschiedene Rückgabetypen und beide Zweige der<span class="tx_code"> if-</span>Anweisung müssen gültig sein.<br></div><div class="text">Der Ausdruck in <span class="tx_code">constexpr if</span> muss ein Compilezeitprädikat sein: eine Funktion, die einen booleschen Wert zurückgibt und zur Compilezeit ausgeführt wird. Ich habe im Codeschnipsel eine Funktion aus der type-traits-Bibliothek verwendet. Alternativ lässt sich in C++20 auch ein Concept verwenden. Hier ist das entsprechende Beispiel, das das Concept<span class="tx_code"> std::integral</span> einsetzt:<br></div><div class="text"><span class="tx_code">template &lt;typename T&gt;<br>auto get_value(T t) {<br>&nbsp;&nbsp;&nbsp; if constexpr (std::integral&lt;T&gt;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *t; // deduces return type to int for T = int*<br>&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return t;&nbsp; // deduces return type to int for T = int<br>}</span><br></div><div class="text">Okay, die beiden Codeschnipsel sind nicht sehr beeindruckend. Daher gehe ich über zur Template-Metaprogrammierung.<br></div><div class="text">Dank <span class="tx_code">constexpr if </span>ist Template-Metaprogrammierung oft einfacher zu schreiben und zu lesen.<br></div><div class="ztitel">Template-Metaprogrammierung mit <span class="tx_code">constexpr if</span><br></div><div class="text">Metaprogrammierung ist Programmieren auf Programmen. C++ wendet Metaprogrammierung zur Compilezeit an. Sie begann in C++98 mit der Template-Metaprogrammierung, wurde in C++11 mit der type-traits-Bibliothek formalisiert und hat sich seitdemstetig verbessert.<br></div><div class="text">Hier ist das "Hello World" der Template-Metaprogrammierung: Berechnen der Fakultät einer Zahl:<br></div><div class="pre">// factorial.cpp<br><br>#include &lt;iostream&gt;<br><br>template &lt;int N&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // (2)<br>struct Factorial{<br>&nbsp;&nbsp;&nbsp; static int const value = N * Factorial&lt;N-1&gt;::value;<br>};<br><br>template &lt;&gt;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>struct Factorial&lt;1&gt;{<br>&nbsp;&nbsp;&nbsp; static int const value = 1;<br>};<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Factorial&lt;5&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; Factorial&lt;5&gt;::value &lt;&lt; '\n' ; &nbsp; &nbsp; &nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Factorial&lt;10&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; Factorial&lt;10&gt;::value &lt;&lt; '\n' ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n' ;<br><br>}<br></div><div class="text">Der Aufruf <span class="tx_code">factorial&lt;5&gt;::value</span> (1) bewirkt die Instanziierung des primären oder allgemeinen Template (2). Während dieser Instanziierung wird <span class="tx_code">Factorial&lt;4&gt;::value</span> instanziiert. Diese rekusrive Instanziierung endet mit dem vollständig spezialisierte Klassen-Template <span class="tx_code">Factorial&lt;1&gt;</span> (Zeile 3).<br></div><div class="text">Mehr über Template-Metaprogrammierung findet sich in meinen früheren Artikeln:<br> </div><div class="text"><ul><li> <a title="Link auf https://heise.de/-6233576" alt="%7B%22type%22%3A%22E%22%2C%22text%22%3A%22Template-Metaprogrammierung%3A%20Wie%20alles%20anfing%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6233576%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6233576%22%7D" href="https://heise.de/-6233576">Template-Metaprogrammierung: Wie alles anfing</a> </li><li> <a title="Link auf https://heise.de/-6237233" alt="%7B%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6237233%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6237233%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Template-Metaprogrammierung%3A%20Wie%20es%20funktioniert%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%7D" href="https://heise.de/-6237233">Template-Metaprogrammierung: Wie es funktioniert</a> </li><li> <a title="Link auf https://heise.de/-6266012" alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22Template-Metaprogrammierung%3A%20Hybride%20Programmierung%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6266012%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6266012%22%2C%22alias%22%3A%22%22%7D" href="https://heise.de/-6266012">Template-Metaprogrammierung: Hybride Programmierung</a> <br></li></ul></div><div class="text">Nun schreibe ich das Programm mithilfe von<span class="tx_code"> constexpr if </span>um:<br> </div><div class="pre">// factorialConstexprIf.cpp<br><br>template &lt;int N&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>struct Factorial{<br>&nbsp;&nbsp;&nbsp; static int const value = N * Factorial&lt;N-1&gt;::value;<br>};<br><br>template &lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>struct Factorial&lt;1&gt;{<br>&nbsp;&nbsp;&nbsp; static int const value = 1;<br>};<br><br>template &lt;int N&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>constexpr int factorial() {<br>&nbsp;&nbsp;&nbsp; if constexpr (N &gt;= 2) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return N * factorial&lt;N-1&gt;();<br>&nbsp;&nbsp;&nbsp; else <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return N;<br>}<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; static_assert(Factorial&lt;5&gt;::value == factorial&lt;5&gt;());&nbsp;&nbsp;&nbsp;&nbsp; // (4) <br>&nbsp;&nbsp;&nbsp; static_assert(Factorial&lt;10&gt;::value == factorial&lt;10&gt;());&nbsp;&nbsp; // (4)<br><br>}<br></div><div class="text">Das primäre Template von <span class="tx_code">Factorial</span> (Zeile 1) wird zur <span class="tx_code">if</span>-Bedingung in der <span class="tx_code">constexpr</span>-Funktion <span class="tx_code">factorial</span> (3), und die vollständige Spezialisierung von <span class="tx_code">Factorial</span> für 1 (2) wird zum <span class="tx_code">else</span>-Fall in der <span class="tx_code">constexpr</span>-Funktion <span class="tx_code">factorial</span> (3). Natürlich geben die Klassen-Templates <span class="tx_code">Factorial</span> und die constexpr-Funktion <span class="tx_code">factorial</span> das gleiche Ergebnis zurück und werden zur Compilezeit ausgeführt (4). Um es kurz zu machen: Ich bevorzuge die <span class="tx_code">constexpr</span> Funktion mit<span class="tx_code"> constexpr if,</span> weil sie sich so angenehm liest wie eine normale Funktion.<br> </div><div class="text">Zum Abschluss möchte ich noch ein weiteres Beispiel zeigen: die berüchtigte Fibonacci-Funktion. Die folgenden Implementierungen basieren auf Template-Metaprogrammierung (<span class="tx_code">Fibonacci</span>) und <span class="tx_code">constexpr if (fibonacci).</span><br> </div><div class="pre">// fibonacciConstexprIf.cpp<br><br>template&lt;int N&gt;<br>constexpr int fibonacci()<br>{<br>&nbsp;&nbsp;&nbsp; if constexpr (N&gt;=2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fibonacci&lt;N-1&gt;() + fibonacci&lt;N-2&gt;();<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return N;<br>}<br><br>template &lt;int N&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>struct Fibonacci{<br>&nbsp;&nbsp;&nbsp; static int const value = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fibonacci&lt;N-1&gt;::value + Fibonacci&lt;N-2&gt;::value;<br>};<br><br>template &lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) <br>struct Fibonacci&lt;1&gt;{<br>&nbsp;&nbsp;&nbsp; static int const value = 1;<br>};<br><br>template &lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3) <br>struct Fibonacci&lt;0&gt;{<br>&nbsp;&nbsp;&nbsp; static int const value = 0;<br>};<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; static_assert(fibonacci&lt;7&gt;() == 13);<br>&nbsp;&nbsp;&nbsp; static_assert(fibonacci&lt;7&gt;() == Fibonacci&lt;7&gt;::value);<br>&nbsp;&nbsp; &nbsp;<br>} <br></div><div class="text">Die <span class="tx_code">constexpr</span>-Funktion <span class="tx_code">fibonacci</span> ist sehr angenehm zu lesen. Die gesamte Funktionalität befindet sich in einem einzigen Funktionskörper. Im Gegensatz dazu benötigt das Template-Metaprogramm Fibonacci drei Klassen. Das primäre Template (1) und die beiden vollständigen Spezialisierungen für die Werte 1 und 0 (2 und 3).</div><div class="ztitel">More Information about my Mentoring Program "Fundamentals for C++ Professionals"<br> </div><div class="text">I created the platform for my new mentoring on <a title="Link auf https://www.modernescpp.org/" alt="%7B%22ir_link%22%3A1%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.org%2F%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.org%2F%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22https%3A%2F%2Fwww.modernescpp.org%2F%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%7D" href="https://www.modernescpp.org/">https://www.modernescpp.org/</a>. You can skip through each of the 28 lessons. I also presented the 6th lesson about move semantics and perfect forwarding in the post <a title="Link auf https://www.modernescpp.org/moredetails/" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.org%2Fmoredetails%2F%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.org%2Fmoredetails%2F%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22%27More%20Information%20about%20my%20Mentoring%20Program%20%5C%22Fundamentals%20for%20C%2B%2B%20Professionals%5C%22%27%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%7D" href="https://www.modernescpp.org/moredetails/">'More Information about my Mentoring Program "Fundamentals for C++ Professionals"'</a>. Here are the next step before I start the mentoring program.&nbsp;&nbsp;&nbsp; </div><div class="text"><ul><li><b>Beginning of March</b>: online information session about my mentoring program, where you can also ask your questions</li><li><b>Middle of March</b>: my mentoring program opens for registration</li><li><b>April</b>: the registration for the mentoring program closes, and the mentoring program starts<br></li></ul></div><div class="text">If you want to stay informed, write an e-mail to info@ModernesCpp.de with the subject "Mentoring". Write me also an e-mail if you need more information</div><div class="ztitel">Wie geht's weiter?<br> </div><div class="text">Templates sind ein mächtiges Werkzeug und bieten daher neue Möglichkeiten für den Softwareentwurf. In meinem nächsten Artikel schreibe ich über statische und dynamische Polymorphie.<br></div>