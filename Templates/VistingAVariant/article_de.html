<div class="vorspann">Eine std::variant besitzt einen Wert aus einem ihrer Datentypen. std::visit ermöglicht es, einen Besucher auf sie anzuwenden. Hier kommt das praktische Overload Pattern ins Spiel.</div><div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/7/4/5/5/6/TN_217297872_e53773b8e9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="text">In meinem letzten Artikel "<a title="Link auf Beitrag 3170416" alt="%7B%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Clevere%20Tricks%20mit%20Parameterpacks%20und%20Fold%20Expressions%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D0397aa403a1eb2018c9f9b41cff98c17%26rm%3Dopen_article_id%26bid%3D3170416%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A3170416%2C%22type%22%3A%22B%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%7D" href="/exec/mainmenu.pl?sid=0397aa403a1eb2018c9f9b41cff98c17&amp;rm=open_article_id&amp;bid=3170416">Clevere Tricks mit Parameterpacks und Fold Expressions</a>" habe ich das Overload Pattern als einen cleveren Trick zum Erstellen eines Overload Set mit Lambdas vorgestellt. Typischerweise wird das Overload Pattern verwendet, um den Wert einer <span class="tx_code">std::variant</span> zu besuchen.<br></div><div class="text">Aus meinen C++-Seminaren weiß ich, dass viele Entwicklerinnen und Entwickler <span class="tx_code">std::variant</span> und<span class="tx_code"> std::visit</span> nicht kennen und stattdessen eine Union verwenden. Deshalb möchte ich <span class="tx_code">std::variant</span> und <span class="tx_code">std::visit</span> kurz und kompakt vorstellen.<br></div><div class="ztitel"><span class="tx_code">std::variant</span> (C++17)<br></div><div class="text">Eine<span class="tx_code"> std::variant</span> ist eine typsichere Union. Eine Instanz von <span class="tx_code">std::variant</span> besitzt einen Wert einer ihrer Datentypen. Der Wert darf keine Referenz, kein C-array und nicht <span class="tx_code">void</span> sein. Eine <span class="tx_code">std::variant</span> kann einen Datentyp mehr als einmal besitzen. Eine default-initialisierte <span class="tx_code">std::variant</span> wird mit ihrem ersten Datentyp initialisiert. In diesem Fall muss der erste Typ einen Default-Konstruktor anbieten. Hierzu ein auf <a title="Link auf http://en.cppreference.com/w/cpp/utility/variant" alt="%7B%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fvariant%22%2C%22type%22%3A%22E%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fvariant%22%2C%22text%22%3A%22cppreference.com%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22version%22%3A1%7D" href="http://en.cppreference.com/w/cpp/utility/variant">cppreference.com</a> basierendes Beispiel:<br></div><div class="pre">// variant.cpp<br><br>#include &lt;variant&gt;<br>#include &lt;string&gt;<br>&nbsp;<br>int main(){<br><br>&nbsp; std::variant&lt;int, float&gt; v, w;<br>&nbsp; v = 12;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; int i = std::get&lt;int&gt;(v);<br>&nbsp; w = std::get&lt;int&gt;(v);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; w = std::get&lt;0&gt;(v);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; w = v;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;<br>&nbsp; //&nbsp; std::get&lt;double&gt;(v);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5) ERROR<br>&nbsp; //&nbsp; std::get&lt;3&gt;(v);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6) ERROR<br>&nbsp;<br>&nbsp; try{<br>&nbsp;&nbsp;&nbsp; std::get&lt;float&gt;(w);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp; }<br>&nbsp; catch (std::bad_variant_access&amp;) {}<br>&nbsp;<br>&nbsp; std::variant&lt;std::string&gt; v("abc");&nbsp; // (8)<br>&nbsp; v = "def";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (9)<br><br>}<br></div><div class="text">Ich definiere die beiden Varianten <span class="tx_code">v</span> und <span class="tx_code">w</span>. Sie können einen<span class="tx_code"> int</span>- und einen <span class="tx_code">float</span>-Wert besitzen. Ihr Startwert ist 0.<span class="tx_code"> v</span> erhält den Wert 12 (Zeile 1). <span class="tx_code">std::get&lt;int&gt;(v)</span> gibt den Wert zurück. In Zeile (2) - (4) siehst du drei Möglichkeiten, der Variante <span class="tx_code">v</span> die Variante <span class="tx_code">w</span> zuzuweisen. Dabei musst du einige Regeln beachten. Du kannst den Wert einer Variante aufgrund ihres Datentyps (Zeile 5) oder mit einem Index (Zeile 6) abfragen. Der Typ muss eindeutig und der Index gültig sein. In Zeile (7) enthält die Variante<span class="tx_code"> w</span> einen <span class="tx_code">int</span>-Wert. Dadurch verursache ich eine<span class="tx_code"> std::bad_variant_access</span>-Exception. Wenn entweder der Konstruktoraufruf oder der Zuweisungsoperator eindeutig ist, findet eine einfache Umwandlung statt. Das ist der Grund dafür, dass eine<span class="tx_code"> std::variant&lt;std::string&gt;</span> in Zeile (8) mit einem C-String konstruiert oder der Variante ein neuer C-String zugewiesen werden kann (Zeile 9).<br></div><div class="text">Natürlich gibt es noch viel mehr über<span class="tx_code"> std::variant</span> zu schreiben. Lies dazu beispielsweise den Artikel "<a title="Link auf https://www.cppstories.com/2018/06/variant/" alt="%7B%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22mediasync_id%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.cppstories.com%2F2018%2F06%2Fvariant%2F%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Everything%20You%20Need%20to%20Know%20About%20std%3A%3Avariant%20from%20C%2B%2B17%22%2C%22href%22%3A%22https%3A%2F%2Fwww.cppstories.com%2F2018%2F06%2Fvariant%2F%22%7D" href="https://www.cppstories.com/2018/06/variant/">Everything You Need to Know About std::variant from C++17</a>" von Bartlomiej Filipek.<br></div><div class="text">Dank der Funktion<span class="tx_code"> std::visit </span>bietet C++17 eine praktische Möglichkeit, die Elemente einer <span class="tx_code">std::variant</span> zu besuchen.<br></div><div class="ztitel"><span class="tx_code">std::visit</span><br></div><div class="text">Was wie das Besuchsmuster des klassischen Entwurfsmusters klingt, ist in Wirklichkeit eine Art Besucher für die Werte einer Variante.<br></div><div class="text"><span class="tx_code">std::visit</span> ermöglicht es, einen Besucher auf einen Container mit Varianten anzuwenden. Der Besucher muss ein Callable sein. Ein Callable ist eine Einheit, die du aufrufen kannst. Typische Callables sind Funktionen, Funktionsobjekte oder Lambdas. In meinem Beispiel verwende ich Lambdas:<br></div><div class="pre">// visitVariants.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;typeinfo&gt;<br>#include &lt;variant&gt;<br><br>&nbsp; <br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::vector&lt;std::variant&lt;char, long, float, int, double, long long&gt;&gt;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vecVariant = {5, '2', 5.4, 100ll, 2011l, 3.5f, 2017};<br>&nbsp; <br>&nbsp; for (auto&amp; v: vecVariant){<br>&nbsp;&nbsp;&nbsp; std::visit([](auto arg){std::cout &lt;&lt; arg &lt;&lt; " ";}, v);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; }<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; for (auto&amp; v: vecVariant){<br>&nbsp;&nbsp;&nbsp; std::visit([](auto arg){std::cout &lt;&lt; typeid(arg).name() &lt;&lt; " ";}, v); // (3)<br>&nbsp; }<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp; <br>}<br></div><div class="text">In Zeile (1) erstelle ich einen <span class="tx_code">std::vector </span>von <span class="tx_code">std::variant</span>s und initialisiere jede Variante. Jede Variante kann einen <span class="tx_code">char-, long-, float-, int-, double-</span> oder<span class="tx_code"> long long</span>-Wert enthalten. Es ist ganz einfach, den Vektor der Varianten zu durchlaufen und das Lambda auf ihn anzuwenden (siehe Zeile (2) und (3)). Erstens zeige ich den aktuellen Wert an (2), und zweitens erhalte ich dank des Aufrufs <span class="tx_code">typeid(arg).name()</span> (3) eine String-Darstellung des Datentyps des aktuellen Wertes.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/7/4/5/5/6/TN_217297877_7db7ee20a3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Gut? Nein! Ich habe in dem Programm <span class="tx_code">visitVariant.cpp</span> ein generisches Lambda verwendet. Daher sind die String-Darstellungen der Typen mit dem GCC ziemlich unleserlich: "<span class="tx_code">i c d x l f i</span>". Ehrlich gesagt, möchte ich auf jeden Typ der Varianten eine spezielle Lambda anwenden. Jetzt kommt das Overload Pattern zum Einsatz.<br></div><div class="ztitel">Overload Pattern<br></div><div class="text">Dank des Overload Patterns kann ich jeden Datentyp mit einem lesbaren String anzeigen und jeden Wert auf eine geeignete Weise darstellen.<br></div><div class="pre">// visitVariantsOverloadPattern.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;typeinfo&gt;<br>#include &lt;variant&gt;<br>#include &lt;string&gt;<br><br>template&lt;typename ... Ts&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7) <br>struct Overload : Ts ... { <br>&nbsp;&nbsp;&nbsp; using Ts::operator() ...;<br>};<br>template&lt;class... Ts&gt; Overload(Ts...) -&gt; Overload&lt;Ts...&gt;;<br><br>int main(){<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::variant&lt;char, long, float, int, double, long long&gt;&gt; // (1) &nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vecVariant = {5, '2', 5.4, 100ll, 2011l, 3.5f, 2017};<br><br>&nbsp;&nbsp;&nbsp; auto TypeOfIntegral = Overload {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](char) { return "char"; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int) { return "int"; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](unsigned int) { return "unsigned int"; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](long int) { return "long int"; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](long long int) { return "long long int"; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](auto) { return "unknown type"; },<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; for (auto v : vecVariant) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::visit(TypeOfIntegral, v) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::variant&lt;std::vector&lt;int&gt;, double, std::string&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vecVariant2 = { 1.5, std::vector&lt;int&gt;{1, 2, 3, 4, 5}, "Hello "};<br><br>&nbsp;&nbsp;&nbsp; auto DisplayMe = Overload {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](std::vector&lt;int&gt;&amp; myVec) { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto v: myVec) std::cout &lt;&lt; v &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n'; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](auto&amp; arg) { std::cout &lt;&lt; arg &lt;&lt; '\n';},<br>&nbsp;&nbsp;&nbsp; };<br><br>&nbsp;&nbsp;&nbsp; for (auto v : vecVariant2) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; // (6)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::visit(DisplayMe, v);<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>}<br></div><div class="text">Zeile (1) erzeugt einen Vektor von Varianten mit ganzzahligen Typen und Zeile (4) einen Vektor von Varianten mit einem <span class="tx_code">std::vector&lt;int&gt;, double</span> und einem <span class="tx_code">std::string</span>.<br></div><div class="text">Fahren wir mit der ersten Variante <span class="tx_code">vecVariant</span> fort. <span class="tx_code">TypeOfIntegral</span> (2) ist ein Overload Set, das für einige ganzzahlige Typen seine String-Darstellung zurückgibt. Wenn der Typ nicht von dem Overload Set angeboten wird, gebe ich als Fallback den String "<span class="tx_code">unknown type</span>" zurück. In Zeile (3) wende ich das Overload Set auf jede Variante<span class="tx_code"> v </span>mit<span class="tx_code"> std::visit</span> an.<br></div><div class="text">Die zweite Variante <span class="tx_code">vecVariant2</span> (4) hat zusammengesetzte Typen. Um ihre Werte darzustellen, erstelle ich ein Overload Set (5). Im Allgemeinen kann ich den Wert einfach in <span class="tx_code">std::cout</span> ausgeben. Für den <span class="tx_code">std::vector&lt;int&gt;</span> verwende ich eine range-basierte <span class="tx_code">for</span>-Schleife (6), um seine Werte darzustellen.<br></div><div class="text">Hier ist die Ausgabe des Programms:<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/7/4/5/5/6/TN_217297882_13622e7623.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Ich möchte noch ein paar Worte zu dem in diesem Beispiel verwendeten Overload Pattern (7) schreiben. Ich habe es bereits in meinem letzten Beitrag&nbsp; "<a title="Link auf Beitrag 3170416" alt="%7B%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22B%22%2C%22destination%22%3A3170416%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D0397aa403a1eb2018c9f9b41cff98c17%26rm%3Dopen_article_id%26bid%3D3170416%22%2C%22text%22%3A%22Clevere%20Tricks%20mit%20Parameterpacks%20und%20Fold%20Expressions%22%7D" href="/exec/mainmenu.pl?sid=0397aa403a1eb2018c9f9b41cff98c17&amp;rm=open_article_id&amp;bid=3170416">Clevere Tricks mit Parameterpacks und Fold Expressions</a>" vorgestellt.<br></div><div class="pre">template&lt;typename ... Ts&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>struct Overload : Ts ... { <br>&nbsp;&nbsp;&nbsp; using Ts::operator() ...;<br>};<br>template&lt;class... Ts&gt; Overload(Ts...) -&gt; Overload&lt;Ts...&gt;; // (2)<br></div><div class="text">Zeile (1) ist das Overload Pattern und Zeile (2) ist der Deduction Guide dafür. Die Struktur Overload kann beliebig viele Basisklassen<span class="tx_code"> (Ts ...) </span>haben. Sie leitet von jeder Klasse <span class="tx_code">public</span> ab und bringt den Aufrufoperator (<span class="tx_code">Ts::operator...</span>) jeder Basisklasse in ihren Geltungsbereich. Die Basisklassen benötigen einen überladenen Aufrufoperator (<span class="tx_code">Ts::operator()</span>). Lambdas stellen diesen Aufrufoperator zur Verfügung. Das folgende Beispiel ist so einfach wie möglich gehalten:<br></div><div class="pre">#include &lt;variant&gt;<br><br>template&lt;typename ... Ts&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>struct Overload : Ts ... { <br>&nbsp;&nbsp;&nbsp; using Ts::operator() ...;<br>};<br>template&lt;class... Ts&gt; Overload(Ts...) -&gt; Overload&lt;Ts...&gt;;<br><br>int main(){<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::variant&lt;char, int, float&gt; var = 2017;<br><br>&nbsp;&nbsp;&nbsp; auto TypeOfIntegral = Overload {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](char) { return "char"; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int) { return "int"; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](auto) { return "unknown type"; },<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp; <br>}<br></div><div class="text">Wenn du dieses Beispiel in C++ Insights verwendest, wird die Magie erkennbar. Zunächst bewirkt der Aufruf (1) die Erstellung eines vollständig spezialisierten Klassen-Templates.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/7/4/5/5/6/TN_217297888_69b05a4f8a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Zweitens bewirken die verwendeten Lambdas im Overload Pattern wie<span class="tx_code"> [](char) { return "char"; }</span> die Erstellung eines Funktionsobjekts. In diesem Fall gibt der Compiler dem Funktionsobjekt den Namen <span class="tx_code">__lambda_15_9</span>.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/7/4/5/5/6/TN_217297899_00b883b476.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Die Untersuchung der automatisch generierten Datentypen zeigt einen weiteren interessanten Punkt. Der Aufrufoperator von <span class="tx_code">__lambda_15_9</span> ist für <span class="tx_code">char</span> überladen: <span class="tx_code">const char * operator() (char) const { return "char"; }.</span></div><div class="text">Der Deduction Guide (<span class="tx_code">template&lt;class... Ts&gt; Overload(Ts...) -&gt; Overload&lt;Ts...&gt;;</span>) (Zeile 2) wird nur für C++17 benötigt. Dieser teilt dem Compiler mit, wie er aus Konstruktor-Argumenten Template-Parameter erzeugen kann. C++20 kann dieses Klassen-Template automatisch ableiten. <br></div><div class="ztitel">Wie geht es weiter?<br></div><div class="text">Die "Freundschaft" von Templates ist etwas Besonderes. In meinem nächsten Beitrag erkläre ich, warum.<br></div>