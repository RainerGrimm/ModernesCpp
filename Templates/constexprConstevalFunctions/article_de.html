<div class="vorspann">Mit C++20 wurde <span class="tx_code">constexpr</span> viel mächtiger. Zusätzlich besitzt C++20 <span class="tx_code">consteval</span> Funktionen, die <span class="tx_code">constexpr</span> Funktionen sehr ähnlich sind.</div><div class="text">&nbsp;<img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/7/1/2/9/0/TN_225053959_46dcc2878b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Ich möchte zunächst eine Funktionalität in C++20 beschreiben, die mich wohl am meisten überrascht hat.</div><div class="ztitel"><span class="tx_code">constexpr</span> Container und Algorithmen der Standard Template Library</div><div class="text">C++20 bietet die <span class="tx_code">constexpr</span> Container<span class="tx_code"> std::vector</span> und <span class="tx_code">std::string</span>, wobei <span class="tx_code">constexpr</span> bedeutet, dass die Memberfunktionen beider Container zur Compilezeit angewendet werden können. Zusätzlich können die mehr als 100 klassischen Algorithmen der Standard Template Library als <span class="tx_code">constexpr</span> deklariert werden. Damit lässt sich ein<span class="tx_code"> std::vector</span> von ints zur Compilezeit sortieren.</div><div class="text">Schauen wir uns an, was das bedeutet:</div><div class="pre">// constexprVector.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>constexpr int maxElement() {<br>&nbsp;&nbsp;&nbsp; std::vector myVec = {1, 2, 4, 3};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::sort(myVec.begin(), myVec.end());<br>&nbsp;&nbsp;&nbsp; return myVec.back();<br>}<br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt;&nbsp; '\n';<br><br>&nbsp;&nbsp;&nbsp; constexpr int maxValue = maxElement();<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "maxValue: " &lt;&lt; maxValue &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; constexpr int maxValue2 = [] {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector myVec = {1, 2, 4, 3};&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::sort(myVec.begin(), myVec.end()) ;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return myVec.back();<br>&nbsp;&nbsp;&nbsp; }(); <br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "maxValue2: " &lt;&lt; maxValue2 &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}<br></div><div class="text">Die beiden Container<span class="tx_code"> std::vector</span> ((1) und (2)) werden zur Compilezeit mithilfe von <span class="tx_code">constexpr</span>-deklarierten Funktionen sortiert. Im ersten Fall gibt die Funktion <span class="tx_code">maxElemen</span>t das letzte Element des Vektors <span class="tx_code">myVec</span> zurück, was dessen Maximalwert ist. Im zweiten Fall verwende ich eine direkt aufgerufene Lambda-Funktion, die als <span class="tx_code">constexpr</span> deklariert ist. Hier ist das Ergebnis des Programms:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/7/1/2/9/0/TN_225053964_ce8d41dcb0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Der entscheidende Grund für <span class="tx_code">constexpr</span> Container ist die transiente Zuweisung.</div><div class="ztitel_kleiner">Transiente Zuweisung</div><div class="text">Transiente Zuweisung bedeutet, dass der zur Compilezeit zugewiesene Speicher auch zur Compilezeit wieder freigegeben werden muss. So kann der Compiler ein Missverhältnis zwischen Zuweisung und Freigabe in einer <span class="tx_code">constexpr</span> Funktion erkennen. Das folgende Beispiel wendet die transiente Zuweisung an.</div><div class="pre">// transientAllocation.cpp<br><br>#include &lt;memory&gt;<br><br>constexpr auto correctRelease() { &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; auto* p = new int[2020];<br>&nbsp;&nbsp;&nbsp;&nbsp; delete [] p;<br>&nbsp;&nbsp;&nbsp;&nbsp; return 2020;<br>}<br><br>constexpr auto forgottenRelease() { // (1)<br>&nbsp;&nbsp;&nbsp; auto* p = new int[2020]; &nbsp;<br>&nbsp;&nbsp;&nbsp; return 2020;<br>}<br><br>constexpr auto falseRelease() {&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; auto* p = new int[2020];<br>&nbsp;&nbsp;&nbsp; delete p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; return 2020;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; constexpr int res1 = correctRelease();<br>&nbsp;&nbsp;&nbsp; constexpr int res2 = forgottenRelease();<br>&nbsp;&nbsp;&nbsp; constexpr int res3 = falseRelease();<br><br>}<br></div><div class="text">Das kleine Programm hat zwei ernsthafte Probleme. Erstens wird der Speicher in der <span class="tx_code">constexpr</span> Funktion <span class="tx_code">forgottenRelease</span> (1) nicht freigegeben. Zweitens stimmt die Nicht-Array-Freigabe (3) in der <span class="tx_code">constexpr</span> Funktion <span class="tx_code">falseRelease </span>(2) nicht mit der Array-Freigabe überein. Infolgedessen schlägt die Kompilierung fehl.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/7/1/2/9/0/TN_225053972_494223d4a2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="text">Mit C++20 gibt es <span class="tx_code">consteval</span> Funktionen, die den <span class="tx_code">contexpr</span> Funktionen sehr ähnlich sind.<br></div><div class="ztitel"><span class="tx_code">consteval</span> Funktionen<br></div><div class="text">Oft sind Entwickler irritiert, weil sie nicht wissen, ob eine <span class="tx_code">constexpr</span> Funktion zur Laufzeit oder zur Compilezeit ausgeführt wird. Betrachten wir den folgenden Codeschnipsel.<br></div><div class="pre">constexpr int constexprFunction(int arg) {<br>&nbsp;&nbsp;&nbsp; return arg * arg;<br>}<br><br>static_assert(constexprFunction(10) == 100);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>int arrayNewWithConstExpressiomFunction[constexprFunction(100)]; // (2)<br>constexpr int prod = constexprFunction(100);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>int a = 100;<br>int runTime = constexprFunction(a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br><br>int runTimeOrCompiletime = constexprFunction(100);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br></div><div class="text"><span class="tx_code">constexprFunction</span> ist, wie der Name schon sagt, eine <span class="tx_code">constexpr</span> Funktion. <br></div><div class="text"><ol><li>Eine <span class="tx_code">constexpr</span> Funktion muss zur Compilezeit ausgeführt werden, wenn sie in einem <span class="tx_code">constexpr</span> Kontext verwendet wird oder das Ergebnis zur Compilezeit explizit angefordert wird. (1) und (2) sind <span class="tx_code">constexpr</span> Kontexte. (3) hingegen erfordert explizit die Funktionsausführung von <span class="tx_code">constexprFuncion</span> zur Compilezeit.</li><li>Der Aufruf <span class="tx_code">constexprFunction(a)</span> (4) muss zur Compilezeit ausgeführt werden, da <span class="tx_code">a </span>kein konstanter Ausdruck ist.</li><li>(5) ist der interessante Fall. Es gibt keine Anforderungen an die Ausführung der Funktion. Daher kann der Aufruf<span class="tx_code"> constexprFunction(100) </span>zur Laufzeit oder zur Compilezeit ausgeführt werden. Aus Sicht des C++-Standards ist beides in Ordnung.</li></ol></div><div class="text">Im Gegensatz zu einer <span class="tx_code">constexpr</span> Funktion kann eine <span class="tx_code">consteval</span> Funktion nur zur Compilezeit ausgeführt werden.<br></div><div class="text">consteval erzeugt eine sogenannte <i>immediate</i> Funktion.<br></div><div class="pre">consteval int sqr(int n) {<br>&nbsp;&nbsp;&nbsp; <span class="tx_code">return</span> n * n;<br>}<br></div><div class="text">Jeder Aufruf einer <i>immediate</i> Funktion erzeugt eine Konstante zur Compilezeit. <span class="tx_code">consteval</span> kann nicht auf Destruktoren oder Funktionen angewendet werden, die allokieren oder deallokieren. Eine <span class="tx_code">consteval</span> Funktion ist wie eine <span class="tx_code">constexpr</span> Funktion implizit <span class="tx_code">inline</span> und muss die Anforderungen an eine <span class="tx_code">constexpr</span> Funktion erfüllen.<br> </div><div class="text">Die Anforderungen an eine <span class="tx_code">constexpr</span> Funktion in C++14 und damit auch an eine <span class="tx_code">consteval</span> Funktion sind: <br></div><div class="text">Eine <span class="tx_code">consteval (constexpr) </span>Funktion kann<br></div><div class="text"><ul><li>bedingte Sprung- oder Schleifenanweisungen enthalten.</li><li>mehr als eine Anweisung haben.</li><li><span class="tx_code">constexpr</span> Funktionen aufrufen. Eine <span class="tx_code">consteval</span> Funktion kann nur eine <span class="tx_code">constexpr</span> Funktion aufrufen, aber nicht umgekehrt.</li><li>built-in Datentypen als Variablen verwenden, die mit einem konstanten Ausdruck initialisiert werden müssen.&nbsp;&nbsp; <br></li></ul></div><div class="text">Eine <span class="tx_code">consteval (constexpr)</span> Funktion kann nicht </div><div class="text"><ul><li> statische oder thread_local Daten besitzen<br></li><li>weder einen <span class="tx_code">try</span>-Block noch eine <span class="tx_code">goto</span>-Anweisung besitzen.</li><li>nicht <span class="tx_code">conteval</span> Funktionen oder nicht <span class="tx_code">constexpr</span> Daten aufrufen oder verwenden.<br></li></ul></div><div class="text">Es gibt einen interessanten Anwendungsfall, den <span class="tx_code">consteval</span> ermöglicht. Mit <span class="tx_code">consteval</span> lässt sich eine lokale nicht konstante Variable zur Compilezeit initialisieren.<br> </div><div class="text"><span class="tx_code">// compileTimeInitializationLocal.cpp<br><br>consteval auto doubleMe(auto val) {<br>&nbsp; return 2 * val;<br>}<br><br>int main() {<br><br>auto res = doubleMe(1010);&nbsp; // (1)<br>++res;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2021 (2)<br><br>} </span><br></div><div class="text">Die lokale Variable&nbsp; <span class="tx_code">res</span> wird zur Compilezeit initialisiert (1) und zur Laufzeit geändert (2). Wenn die Funktion <span class="tx_code">doubleMe</span> hingegen als <span class="tx_code">constexpr</span> deklariert wird, könnte sie zur Laufzeit ausgeführt werden.</div><div class="ztitel">Wie geht's weiter?<br> </div><div class="text">Bevor ich in den neuen Themenblock Design mit Templates eintauche, möchte ich im nächsten Beitrag das C++17-Feature <span class="tx_code">constexpr if </span>vorstellen. <span class="tx_code">constexpr if </span>ermöglicht es, Quellcode bedingt zu kompilieren und kann auch für nette Tricks zur Compilezeit verwendet werden. <br></div>