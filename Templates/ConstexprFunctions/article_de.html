<div class="vorspann">&nbsp;Nach der Template-Metaprogrammierung und der Type-Traits-Bibliothek geht es heute vor allem um constexpr-Funktionen.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/6/6/4/7/5/TN_224652467_0af095b08b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Ich habe in den letzten Jahren bereits ein paar Beiträge über <span class="tx_code">constexpr</span> geschrieben. Hier ist meine Motivation: Erstens werde ich interessante Ähnlichkeiten zwischen <span class="tx_code">constexpr</span> Funktionen und Templaten aufzeigen. Zweitens möchte ich über die Verbesserungen von <span class="tx_code">constexpr</span> in C++20 schreiben. Und schließlich gehe ich auch auf <span class="tx_code">consteval</span> in C++20 ein. Wenn eine Theorie in meinen Beiträgen nicht ausführlich genug ist, werde ich auf frühere Beiträge verweisen. Beginnen wir mit einer kurzen Zusammenfassung, bevor ich auf die neuen Themen eingehe.</div><div class="ztitel">Ein kurzer Rückblick</div><div class="text"><span class="tx_code">constexpr</span> ermöglicht es, zur Compilezeit mit der typischen C++-Syntax zu programmieren. Konstante Ausdrücke mit <span class="tx_code">constexpr</span> können drei Formen haben.</div><div class="ztitel_kleiner">Variablen</div><div class="text"><ul><li>sind implizit const.</li><li>müssen durch einen konstanten Ausdruck initialisiert werden.<br></li></ul></div><div class="pre">constexpr double pi = 3,14;<br></div><div class="ztitel_kleiner">Funktionen</div><div class="text"><span class="tx_code">constexpr</span> Funktionen in C++14 sind recht komfortabel. Sie können</div><div class="text"><ul><li>andere <span class="tx_code">constexpr</span> Funktionen aufrufen.</li><li>können Variablen haben, die durch einen konstanten Ausdruck initialisiert werden müssen.</li><li>können bedingte Ausdrücke oder Schleifen enthalten.</li><li>sind implizit inline.</li><li>können keine static oder<span class="tx_code"> thread_local </span>Daten besitzen.</li></ul></div><div class="ztitel_kleiner">Benutzerdefinierte Typen</div><div class="text"><ul><li>müssen einen Konstruktor besitzen, der ein konstanter Ausdruck ist.</li><li>können keine virtuellen Funktionen besitzen.</li><li>können keine virtuelle Basisklasse besitzen.</li></ul></div><div class="text">Die Regeln für <span class="tx_code">constexpr</span> Funktionen oder Memberfunktionen sind simpel. Der Einfachheit wegen, nenne ich beide Funktionen.</div><div class="text"><span class="tx_code">constexpr</span> Funktionen müssen alle ihr Abhängigkeit zur Compliezeit auflösen können. Eine <span class="tx_code">constexpr</span>-Funktion zu sein, bedeutet nicht, dass die Funktion zur Compilezeit ausgeführt wird. Es bedeutet, dass die Funktion das Potenzial hat, zur Compilezeit ausgeführt zu werden. Eine <span class="tx_code">constexpr</span>-Funktion kann auch zur Runtime ausgeführt werden. Es ist oft eine Frage des Compilers und der Optimierungsstufe, ob eine <span class="tx_code">constexpr</span> Funktion zur Compilezeit oder zur Runtime ausgeführt wird. Es gibt zwei Kontexte, in denen eine<span class="tx_code"> constexpr</span>-Funktion <span class="tx_code">func</span> zur Compilezeit ausgeführt werden muss.</div><div class="text"><ul><li>Die <span class="tx_code">constexpr</span> Funktion wird in einem Kontext ausgeführt, der zur Compilezeit ausgewertet wird. Das kann ein<span class="tx_code"> static_assert</span>-Ausdruck wie bei der type-traits-Bibliothek oder die Initialisierung eines C-Arrays sein.&nbsp;&nbsp; <br></li><li>Der Wert einer <span class="tx_code">constexpr</span>-Funktion wird mit constexpr angefordert: <span class="tx_code">constexpr auto res = func(5);</span></li></ul></div><div class="text">Hier ist ein kleines Beispiel zur Theorie. Das Programm <span class="tx_code">constexpr14.cpp</span> berechnet den größten gemeinsamen Teiler zweier Zahlen.</div><div class="pre">// constexpr14.cpp<br><br>#include &lt;iostream&gt;<br><br>constexpr auto gcd(int a, int b){<br>&nbsp; while (b != 0){<br>&nbsp;&nbsp;&nbsp; auto t= b;<br>&nbsp;&nbsp;&nbsp; b= a % b;<br>&nbsp;&nbsp;&nbsp; a= t;<br>&nbsp; }<br>&nbsp; return a;<br>}<br><br>int main(){<br>&nbsp; <br>&nbsp;std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; constexpr int i= gcd(11, 121);&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; <br>&nbsp; int a= 11;<br>&nbsp; int b= 121;<br>&nbsp; int j= gcd(a, b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp; std::cout &lt;&lt; "gcd(11,121): " &lt;&lt; i &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "gcd(a,b): " &lt;&lt; j &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;<br>}</div><div class="text">(1) berechnet das Ergebnis<span class="tx_code"> i </span>zur Compilezeit und (2) <span class="tx_code">j</span> zur Runtime. Der Compiler würde sich beschweren, wenn ich<span class="tx_code"> j</span> als <span class="tx_code">constexpr</span> deklariere: <span class="tx_code">constexpr int j = gcd(a, b)</span>. Das Problem ist in diesem Fall, dass die Integer <span class="tx_code">a </span>und <span class="tx_code">b</span> keine konstanten Ausdrücke sind.</div><div class="text">Die Ausgabe des Programms sollte nicht überraschen.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/6/6/4/7/5/TN_224652470_2622d41c6a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Die Überraschung kann jetzt beginnen. Die Magie zeige ich mit dem Compiler Explorer.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/6/6/4/7/5/TN_224652479_72ffa63c13.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">(1) im Programm <span class="tx_code">constexpr14.cpp </span>läuft auf die Konstante 11 im folgenden Ausdruck hinaus: <span class="tx_code">mov DWORD PTR[rbp-4], 11 </span>(Zeile 33 im Screenshot). Im Gegensatz dazu ist Zeile (2) ein Funktionsaufruf: <span class="tx_code">call gcd(int, int)</span> (Zeile 41 im Screenshot).</div><div class="text">Nach dieser Zusammenfassung möchte ich auf die Gemeinsamkeiten von <span class="tx_code">constexpr</span>-Funktionen und Template-Metaprogrammierung eingehen.<br></div><div class="ztitel">Template-Metaprogrammierung<br></div><div class="text"><span class="tx_code">constexpr</span>-Funktionen haben viel mit der Template-Metaprogrammierung gemeinsam. Wer mit der Template-Metaprogrammierung nicht vertraut ist, sollte meine drei vorangegangenen Beiträge einen Eindruck vermitteln.</div><div class="text"><ul><li><a title="Link auf https://www.heise.de/developer/artikel/Template-Metaprogrammierung-Wie-alles-begann-6233576.html" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FTemplate-Metaprogrammierung-Wie-alles-begann-6233576.html%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FTemplate-Metaprogrammierung-Wie-alles-begann-6233576.html%22%2C%22text%22%3A%22%26nbsp%3BTemplate-Metaprogrammierung%20-%20Wie%20alles%20begann%22%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" href="https://www.heise.de/developer/artikel/Template-Metaprogrammierung-Wie-alles-begann-6233576.html">&nbsp;Template-Metaprogrammierung - Wie alles begann</a><br></li><li>&nbsp;<a title="Link auf https://www.heise.de/developer/artikel/Template-Metaprogrammierung-Wie-es-funktioniert-6237233.html" alt="%7B%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FTemplate-Metaprogrammierung-Wie-es-funktioniert-6237233.html%22%2C%22target%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FTemplate-Metaprogrammierung-Wie-es-funktioniert-6237233.html%22%2C%22text%22%3A%22Template-Metaprogrammierung%20-%20Wie%20es%20funktioniert%22%7D" href="https://www.heise.de/developer/artikel/Template-Metaprogrammierung-Wie-es-funktioniert-6237233.html">Template-Metaprogrammierung - Wie es funktioniert</a></li><li>&nbsp;<a title="Link auf https://www.heise.de/developer/artikel/Template-Metaprogrammierung-Hybride-Programmierung-6266012.html" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FTemplate-Metaprogrammierung-Hybride-Programmierung-6266012.html%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Template%20Metaprogrammierung%20-%20Hybride%20Programmierung%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FTemplate-Metaprogrammierung-Hybride-Programmierung-6266012.html%22%7D" href="https://www.heise.de/developer/artikel/Template-Metaprogrammierung-Hybride-Programmierung-6266012.html">Template Metaprogrammierung - Hybride Programmierung</a></li></ul></div><div class="text">Hier ist das große Bild, das <span class="tx_code">constexpr</span>-Funktionen mit Template-Metaprogrammierung vergleicht:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/6/6/4/7/5/TN_224652487_5cf5d7d097.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Ich möchte meiner Tabelle noch ein paar Anmerkungen hinzufügen.<br></div><div class="text"><ul><li>Ein Template-Metaprogramm wird zur Compilezeit ausgeführt, aber eine <span class="tx_code">constexpr</span>-Funktion kann zur Compilezeit oder zur Runtime ausgeführt werden.</li><li>Argumente eines Template-Metaprogramms können Typen, Nicht-Typen wie <span class="tx_code">int</span> oder auch Templates sein.&nbsp;&nbsp; <br></li><li>Zur Compilezeit gibt es keinen Zustand und daher auch keine Veränderung. Das bedeutet, dass die Template-Metaprogrammierung ein rein funktionaler Programmierstil ist. Hier sind die Merkmale aus der Perspektive des funktionalen Stils:</li><ul><li>Bei der Template-Metaprogrammierung wird ein Wert nicht verändert, sondern jedes Mal ein neuer Wert zurückgegeben.</li><li>Die Steuerung einer<span class="tx_code"> for</span>-Schleife durch das Erhöhen einer Variablen wie <span class="tx_code">i</span> ist zur Compilezeit nicht möglich: <span class="tx_code">for (int i; i &lt;= 10; ++i)</span>. Die Template-Metaprogrammierung ersetzt daher Schleifen durch Rekursion.</li><li>Bei der Template-Metaprogrammierung wird die bedingte Ausführung durch eine Template-Spezialisierung ersetzt.<br></li></ul></ul></div><div class="text">Zugegeben, dieser Vergleich war recht knapp. Ein bildlicher Vergleich einer Metafunktion (siehe <a title="Link auf https://www.heise.de/developer/artikel/Template-Metaprogrammierung-Wie-es-funktioniert-6237233.html" alt="%7B%22text%22%3A%22Template-Metaprogrammierung%20-%20Wie%20es%20funktioniert%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FTemplate-Metaprogrammierung-Wie-es-funktioniert-6237233.html%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FTemplate-Metaprogrammierung-Wie-es-funktioniert-6237233.html%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%7D" href="https://www.heise.de/developer/artikel/Template-Metaprogrammierung-Wie-es-funktioniert-6237233.html">Template-Metaprogrammierung - Wie es funktioniert</a>) und einer <span class="tx_code">constexpr</span>-Funktion sollte die offenen Fragen beantworten. Beide Funktionen berechnen die Fakultät einer Zahl.</div><div class="text"><ul><li>Die Funktionsargumente einer <span class="tx_code">constexpr</span>-Funktion entsprechen den Template-Argumenten einer Metafunktion.</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/6/6/4/7/5/TN_224652494_0149ad97bb.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>Eine <span class="tx_code">constexpr</span>-Funktion kann Variablen besitzen und diese verändern. Eine Metafunktion erzeugt einen neuen Wert.</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/6/6/4/7/5/TN_224652503_5e1479d2bd.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>Eine Metafunktion verwendet Rekursion, um eine Schleife zu simulieren.</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/6/6/4/7/5/TN_224652511_23100e414c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:8 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>Anstelle einer Endbedingung verwendet eine Metafunktion eine vollständige Spezialisierung eines Templates, um eine Schleife zu beenden. Außerdem verwendet eine Metafunktion eine teilweise oder vollständige Spezialisierung, um eine bedingte Ausführung wie <span class="tx_code">if</span>-Anweisungen durchzuführen.</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/6/6/4/7/5/TN_224652517_c23ac0dfcc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:9 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>Anstelle eines aktualisierten Wertes<span class="tx_code"> res</span> erzeugt die Metafunktion in jeder Iteration einen neuen Wert. </li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/6/6/4/7/5/TN_224652518_5c3c648cf4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:10 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>Eine Metafunktion hat keine Rückgabeanweisung. Sie verwendet den Wert als Rückgabewert.</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/6/6/4/7/5/TN_224652526_bbf9a43a3b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:11 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><span class="tx_code">constexpr</span>-Funktionen und Templates haben aber noch mehr gemeinsam.</div><div class="ztitel">Instanziierung von Templates</div><div class="text">Details zur Template-Instantiierung finden sich in meinen vorherigen Beitrag "<a title="Link auf https://www.heise.de/developer/artikel/Template-Instanziierung-6151298.html" alt="%7B%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Template-Instanziierung%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FTemplate-Instanziierung-6151298.html%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22target%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FTemplate-Instanziierung-6151298.html%22%2C%22type%22%3A%22E%22%7D" href="https://www.heise.de/developer/artikel/Template-Instanziierung-6151298.html">Template-Instanziierung</a>".&nbsp; Ich möchte hier nur die wichtigsten Fakten hervorheben.</div><div class="text">Eine Template wie <span class="tx_code">isSmaller</span> wird zweimal syntaktisch geprüft:</div><div class="pre">template&lt;typename T&gt;<br>bool isSmaller(T fir, T sec){<br>&nbsp;&nbsp;&nbsp; return fir &lt; sec;<br>}<br><br>isSmaller(5, 10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>std::unordered_set&lt;int&gt; set1;<br>std::unordered_set&lt;int&gt; set2;</div><div class="text"><ul><li>Zuerst wird die Syntax der Template-Definition geprüft. Diese Prüfung ist nicht durch den C++-Standard gefordert, aber erlaubt und wird in der Regel von Compilern durchgeführt.</li><li>Zweitens leitet der Compiler die Template-Argumente aus den Funktionsargumenten ab. Er erstellt dabei für jedes Template-Aargument eine konkrete Funktion und überprüft deren Syntax. Dieser Instanziierungsprozess schlägt im Fall von<span class="tx_code"> std::unordered_set&lt;int&gt;</span> (2) fehl, weil der Datentyp den <span class="tx_code">&lt;</span>-Operator nicht unterstützt.</li></ul></div><div class="text"><span class="tx_code">constexpr</span>-Funktionen werden ebenfalls zweimal auf ihre Syntax geprüft.</div><div class="pre">constexpr auto gcd(int a, int b){<br>&nbsp; while (b != 0){<br>&nbsp;&nbsp;&nbsp; auto t= b;<br>&nbsp;&nbsp;&nbsp; b= a % b;<br>&nbsp;&nbsp;&nbsp; a= t;<br>&nbsp; }<br>&nbsp; return a;<br>}<br><br><br>constexpr int i= gcd(11, 121);&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; <br>int a= 11;<br>int b= 121;<br>constexpr int j= gcd(a, b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)</div><div class="text"><ul><li>Zunächst prüft der Compiler, ob die Funktion <span class="tx_code">gcd</span> zur Compilezeit ausgeführt werden kann. Das bedeutet im Wesentlichen, dass alle Abhängigkeiten einer<span class="tx_code"> constexpr</span>-Funktion, wie zum Beispiel Funktion, die sie aufruft,<span class="tx_code"> constexpr</span> sein müssen.</li><li>Der Compiler muss bei jedem Aufruf von <span class="tx_code">gcd</span> darüber hinaus prüfen, ob die Argumente konstante Ausdrücke sind. Das hat zur Folge, dass der erste Aufruf (1) gültig ist, der zweite (2) jedoch nicht.</li></ul></div><div class="text">Letztlich sind sich Templates und <span class="tx_code">constexpr</span>-Funktionen auch in Bezug auf die Sichtbarkeit ihrer Definition sehr ähnlich.</div><div class="ztitel">Sichtbarkeit</div><div class="text">Zum Instanziieren eines Template muss dessen Definition sichtbar sein. Das Gleiche gilt für <span class="tx_code">constexpr</span>-Funktionen. <br></div><div class="ztitel">Wie geht's weiter?</div><div class="text">Im nächsten Beitrag schreibe ich über<span class="tx_code"> constexpr</span>-Funktionen in C++20 und das neue C++20 Schlüsselwort <span class="tx_code">consteval</span>. <br></div>