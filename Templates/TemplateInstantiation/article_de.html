<div class="vorspann">Template-Instanziierung ist das Erstellen einer konkreten Funktion oder einer konkreten Klasse von einem Funktions- oder Klassen-Template. </div><div class="text">Der Prozess kann implizit erfolgen (vom Compiler generiert) oder explizit (vom Benutzer bereitgestellt) sein.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/4/7/0/5/7/TN_214500874_b7c27f823a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Für das Template benötigte Template-Argument generiert der Compiler automatisch. Manchmal ist es notwendig, die Template-Definitionen aus Header-Dateien zu entfernen oder die rechenintensive Template-Instanziierung zu minimieren. In diesem Fall hilft die explizite Instanziierung.</div><div class="ztitel">Implizite Instanziierung</div><div class="text">Implizite Instanziierung sollte der Default sein. Das bedeutet, dass der Compiler automatisch die konkrete Funktion oder Klasse für die angegebenen Template-Argumente erzeugt. Im Allgemeinen leitet der Compiler die Template-Argumente aus den Funktionsargumenten ab. In C++17 kann der Compiler auch die Template-Argumente für Klassen-Templates ableiten.</div><div class="pre">// implicitTemplateInstantiation.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>template &lt;typename T&gt;<br>class MyClass{<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; MyClass(T t) { }<br>&nbsp;&nbsp;&nbsp; std::string getType() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return typeid(T).name();<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>template&lt;typename T&gt;<br>bool isSmaller(T fir, T sec){<br>&nbsp;&nbsp;&nbsp; return fir &lt; sec;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector vec{1, 2, 3, 4, 5};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "vec.size(): " &lt;&lt; vec.size() &lt;&lt; '\n';<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; MyClass myClass(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "myClass.getType(): " &lt;&lt; myClass.getType() &lt;&lt; '\n';<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSmaller(5, 10): " &lt;&lt; isSmaller(5, 10) &lt;&lt; '\n';&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSmaller&lt;double&gt;(5.5f, 6.5): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; isSmaller&lt;double&gt;(5.5f, 6.5) &lt;&lt; '\n';&nbsp; // (4)<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>}</div><div class="text">(1) und (2) verwenden class template argument deductoin (CTAG). <span class="tx_code">std::vector</span> oder <span class="tx_code">MyClass</span> können ihren Typ aus ihren Konstruktorargumenten ableiten. (3) leitet auch ihr Template-Argument ab. In (4) hingegen wird das Template-Argument <span class="tx_code">double</span> explizit angegeben:<span class="tx_code"> isSmaller&lt;double&gt;(5.5f, 6.5).</span></div><div class="text"><span class="tx_code"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/4/7/0/5/7/TN_214500879_3f1a007379.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;">&nbsp;</span></div><div class="text">Der Compiler erzeugt für jede implizite Template-Instanziierung eine konkrete Funktion oder Klasse. <a title="Link auf https://cppinsights.io/s/e8145723" alt="%7B%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2Fe8145723%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2Fe8145723%22%2C%22mediasync_id%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22C%2B%2BInsights%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%7D" href="https://cppinsights.io/s/e8145723">C++Insights</a> visualisiert diesen Prozess.</div><div class="text">Dieser automatische Prozess ist sehr komfortabel, hat aber auch ein paar Nachteile.</div><div class="text"><ul><li>Beim impliziten Instanziieren ist die Definition des Templates typischerweise in einer Header-Datei sichtbar. Nicht jeder möchte aber die Definition offenlegen.</li><li>Ist ein Template für bestimmte Template-Argumente erforderlich, instanziiert sie der Compiler, wenn es noch nicht in Übersetzungseinheit verfügbar ist. Eine Übersetzungseinheit ist die Quelldatei nach der Verarbeitung durch den C-Präprozessor. Typischerweise entfernt der Linker alle überflüssigen Template-Instanziierungen und behält eine. Dies ist eine Verschwendung von Zeit und Speicher.<br></li></ul></div><div class="text">Beide Probleme können mit expliziter Template-Instanziierung gelöst werden.</div><div class="ztitel">Explizite Instanziierung</div><div class="text">Explizite Instanziierung kennt zwei Varianten in C++: Definition und Deklaration der expliziten Instanziierung.</div><div class="text"><ul><li>Syntax der Definition der expliziten Instanziierung:<span class="tx_code"> template &lt;template declaration&gt;</span></li><li>Syntax der Deklaration der expliziten Instanziierung:<span class="tx_code"> extern template &lt;template declaration</span></li></ul></div><div class="text">Beim Vergleich der Syntax , macht das Schlüsselwort <span class="tx_code">extern</span> den feinen Unterschied.</div><div class="text">Explizite Template-Instanziierung bedeutet, dass Entwickler die Instanziierung eines Template direkt anfordern wie in folgendem einfachen Beispiel:</div><div class="pre">// explicitTemplateInstantiation.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>template &lt;typename T&gt;<br>class MyClass{<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; MyClass(T t) { }<br>&nbsp;&nbsp;&nbsp; std::string getType() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return typeid(T).name();<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>template&lt;typename T&gt;<br>bool isSmaller(T fir, T sec){<br>&nbsp; return fir &lt; sec;<br>}<br>&nbsp;<br>template class std::vector&lt;int&gt;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>template bool std::vector&lt;double&gt;::empty() const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>template class MyClass&lt;int&gt;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>template std::string MyClass&lt;double&gt;::getType() const; // (4)<br><br>template bool isSmaller(int, int);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>template bool isSmaller&lt;double&gt;(double, double);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp; <br>&nbsp; std::vector vec{1, 2, 3, 4, 5};<br>&nbsp; std::cout &lt;&lt; "vec.size(): " &lt;&lt; vec.size() &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; MyClass myClass(5);<br>&nbsp; std::cout &lt;&lt; "myClass.getType(): " &lt;&lt; myClass.getType() &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "isSmaller(5, 10): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; isSmaller(5,10) &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "isSmaller&lt;double&gt;(5.5f, 6.5): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; isSmaller&lt;double&gt;(5.5f, 6.5) &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>}</div><div class="text">Der Bereich (1) bis (6) ist die am interessantesten. Dank des Schlüsselworts <span class="tx_code">template</span> erfolgt eine explizite Template-Instanziierung.</div><div class="text"><ul><li>(1) instanziiert explizit<span class="tx_code"> std::vector</span> für <span class="tx_code">int</span> und Zeile (2) die zugehörige Memberfunktion <span class="tx_code">empty</span> für <span class="tx_code">double</span>.</li><li>(3) instanziiert explizit <span class="tx_code">MyClass</span> für <span class="tx_code">int</span> und Zeile (4) deren Memberfunktion <span class="tx_code">getType</span> für <span class="tx_code">double</span>.</li><li>(5) instanziiert explizit <span class="tx_code">isSmaller </span>für<span class="tx_code"> (int, int)</span>&nbsp; und Zeile (6) tut dasselbe für <span class="tx_code">(double, double</span>) mit dem expliziten Template-Argument <span class="tx_code">double</span>.</li></ul></div><div class="ztitel_kleiner">Verstecken der Template-Implementierung<br></div><div class="text">Wie kann die explizite Template-Instanziierung helfen, die Definition der Templates zu verstecken?</div><div class="text"><ol><li>Sollte Template-Deklaration in der Header-Datei formuliert sein.<br></li><li>Die Template-Definition sollte in der Quelldatei sein die Instanziierung des Templates am Ende der Quelldatei stattfinden.</li><li>Schließlich lässt sich das Template lässt sich durch Einbinden der Header-Datei einbinden. <br></li></ol></div><div class="text">Hier sind drei Dateien, die diesen Prozess veranschaulichen.</div><div class="text"><ul><li><b>Template-Deklaration</b></li></ul></div><div class="pre">// MyClass.h<br><br>#include &lt;typeinfo&gt;<br>#include &lt;string&gt;<br><br>template &lt;typename T&gt;<br>class MyClass{<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; MyClass(T t) { }<br>&nbsp;&nbsp;&nbsp; std::string getType() const;<br>};</div><div class="text"><ul><li><b>Template-Definition und explizite Instanziierung für<span class="tx_code"> int</span></b></li></ul></div><div class="pre">// MyClass.cpp<br><br>#include "MyClass.h"<br><br>template &lt;typename T&gt;<br>std::string MyClass&lt;T&gt;::getType() const {<br>&nbsp;&nbsp;&nbsp; return typeid(T).name();<br>}<br><br>template class MyClass&lt;int&gt;; </div><div class="text"><ul><li><b>Verwenden des Templates</b></li></ul></div><div class="pre">// mainMyClass.cpp<br><br>#include "MyClass.h"<br>#include &lt;iostream&gt;<br><br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n'; <br><br>&nbsp;&nbsp;&nbsp; MyClass myClass(5);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "myClass.getType(): " &lt;&lt; myClass.getType() &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; /*<br>&nbsp;&nbsp;&nbsp; MyClass myClass2(5.5);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "myClass2.getType(): " &lt;&lt; myClass2.getType() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; */<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text">Das Kompilieren und Ausführen des Programms liefert das erwartete Ergebnis.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/4/7/0/5/7/TN_214500889_78b2bc0e68.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="text">Wenn ich versuche, <span class="tx_code">MyClass</span> für einen anderen Datentyp als <span class="tx_code">int</span> zu verwenden, bekomme ich einen Linker-Fehler. Folgende Fehlermeldung erhalte ich, wenn ich die auskommentierten Zeilen verwende.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/4/7/0/5/7/TN_214500894_3b11ab1131.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="text">Es ist keine Template-Instanziierung für <span class="tx_code">double</span> verfügbar.</div><div class="ztitel_kleiner">Unterdrücken der Template-Instanziierung</div><div class="text">Beim Verwenden von <span class="tx_code">MyClass&lt;int&gt;</span> in verschiedenen Übersetzungseinheiten wirft der Linker im Wesentlichen alle Template-Instanziierung außer einer weg. Das ist eine Verschwendung von Rechenzeit. Wer das <span class="tx_code">extern</span>-Schlüsselworts in C++11 verwendet, kann eine Definition der expliziten Instanziierung in eine Deklaration der expliziten Instanziierung transformieren: <br></div><div class="pre">template class MyClass&lt;int&gt;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; Definition der expliziten <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; Instanziierung<br>extern template class MyClass&lt;int&gt;; //&nbsp; Deklaration der expliziten <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; Instanziierung</div><div class="text">Die wichtigste Beobachtung ist, dass die zweite Zeile keine Template-Instanziierung auslöst. Das bedeutet, dass der Compiler nichts erzeugt, was der Linker gegebenenfalls wegwirft. Es gilt lediglich, sicherzustellen, dass eine Instanziierung von <span class="tx_code">MyClass&lt;int&gt; </span>für den Linker verfügbar ist, da sonst ein Linker-Fehle erscheint. </div><div class="ztitel">Was geht's weiter?<br> </div><div class="text">Nach diesem eher technischem Artikel, schreibe ich in meinem nächsten Artikel über variadische Templates ... .<br></div>