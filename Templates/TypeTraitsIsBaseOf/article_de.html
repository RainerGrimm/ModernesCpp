<div class="vorspann">Der letzte Artikel zu der Type-Traits-Bibliothek endete mit einer Herausforderung, und dieser Beitrag präsentiert die Antwort. <br></div><div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/2/7/5/0/5/TN_221680023_e179766c2f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Bevor ich die Antwort von Herr Zeisel vorstelle, möchte ich kurz die Herausforderung wiederholen. <br></div><div class="ztitel">Meine Herausforderung<br> </div><div class="text">Erklärt die beiden Implementierung der type-traits Funktionen <span class="tx_code">std::is_base_of</span> und<span class="tx_code"> std::is_convertible</span>. </div><div class="text"><ul><li><b><span class="tx_code">std::is_base_of</span></b></li></ul></div><div class="pre">namespace details {<br>&nbsp;&nbsp;&nbsp; template &lt;typename B&gt;<br>&nbsp;&nbsp;&nbsp; std::true_type test_pre_ptr_convertible(const volatile B*);<br>&nbsp;&nbsp;&nbsp; template &lt;typename&gt;<br>&nbsp;&nbsp;&nbsp; std::false_type test_pre_ptr_convertible(const volatile void*);<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; template &lt;typename, typename&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of(...) -&gt; std::true_type;<br>&nbsp;&nbsp;&nbsp; template &lt;typename B, typename D&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of(int) -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decltype(test_pre_ptr_convertible&lt;B&gt;(static_cast&lt;D*&gt;(nullptr)));<br>}<br>&nbsp;<br>template &lt;typename Base, typename Derived&gt;<br>struct is_base_of :<br>&nbsp;&nbsp;&nbsp; std::integral_constant&lt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_class&lt;Base&gt;::value &amp;&amp; std::is_class&lt;Derived&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decltype(details::test_pre_is_base_of&lt;Base, Derived&gt;(0))::value<br>&nbsp;&nbsp;&nbsp; &gt; { };</div><div class="text"><ul><li><b><span class="tx_code">std::is_convertible</span></b></li></ul></div><div class="pre">namespace detail {<br>&nbsp;<br>template&lt;class T&gt;<br>auto test_returnable(int) -&gt; decltype(<br>&nbsp;&nbsp;&nbsp; void(static_cast&lt;T(*)()&gt;(nullptr)), std::true_type{}<br>);<br>template&lt;class&gt;<br>auto test_returnable(...) -&gt; std::false_type;<br>&nbsp;<br>template&lt;class From, class To&gt;<br>auto test_implicitly_convertible(int) -&gt; decltype(<br>&nbsp;&nbsp;&nbsp; void(std::declval&lt;void(&amp;)(To)&gt;()(std::declval&lt;From&gt;())), std::true_type{}<br>);<br>template&lt;class, class&gt;<br>auto test_implicitly_convertible(...) -&gt; std::false_type;<br>&nbsp;<br>} // namespace detail<br>&nbsp;<br>template&lt;class From, class To&gt;<br>struct is_convertible : std::integral_constant&lt;bool,<br>&nbsp;&nbsp;&nbsp; (decltype(detail::test_returnable&lt;To&gt;(0))::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp; decltype(detail::test_implicitly_convertible&lt;From, To&gt;(0))::value) ||<br>&nbsp;&nbsp;&nbsp; (std::is_void&lt;From&gt;::value &amp;&amp; std::is_void&lt;To&gt;::value)<br>&gt; {};</div><div class="text">Zugegeben, es gibt deutlich einfachere Herausforderungen. Daher habe ich nur eine sehr gute Antwort zu <span class="tx_code">std::is_base_of </span>erhalten. Es lohnt sich aber, die folgende Erklärung von Herr Zeisel zu studieren, denn sie ist sehr lehrreich. <br></div><div class="ztitel"><span class="tx_code">std::is_base_of</span></div><div class="ztitel_kleiner">Program1.cpp<br></div><div class="text"><span class="tx_code">std::is_base_of</span> beruht im Wesentlichen auf einigen Details der Regeln zu C++ Function Overload Resolution, die sich beispielsweise auf <a title="Link auf https://en.cppreference.com/w/cpp/language/overload_resolution" alt="%7B%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Foverload_resolution%22%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Foverload_resolution%22%2C%22text%22%3A%22der%20C%2B%2B-Referenzseite%20cppreference.com%22%2C%22type%22%3A%22E%22%7D" href="https://en.cppreference.com/w/cpp/language/overload_resolution">der C++-Referenzseite cppreference.com</a> <br>finden. Die erste dabei verwendete Regel ist: "Conversion that converts pointer-to-derived to pointer-to-base is better than the conversion of pointer-to-derived to pointer-to-void,"</div><div class="text">Ein Beispiel dazu ist<span class="tx_code"> Program1.cpp</span><br></div><div class="pre"><i>// Program1.cpp</i><br><br>#include &lt;iostream&gt;<br>struct Base {};<br>struct Derived : public Base {};<br>struct A { };<br>// Conversion that converts pointer-to-derived to pointer-to-base<br>// is better than the conversion of pointer-to-derived to pointer-to-void,<br>// https://en.cppreference.com/w/cpp/language/overload_resolution<br>void f(void*)<br>{<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "f(void*)" &lt;&lt; std::endl;<br>}<br>void f(const Base*)<br>{<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "f(Base*)" &lt;&lt; std::endl;<br>}<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; Derived d;<br>&nbsp;&nbsp;&nbsp; A a;<br>&nbsp;&nbsp;&nbsp; f(&amp;d);<br>&nbsp;&nbsp;&nbsp; f(&amp;a);<br>&nbsp;&nbsp;&nbsp; return 0;<br>}</div><div class="text">Der Output ist</div><div class="pre">f(Base*)<br>f(void*)<br></div><div class="ztitel_kleiner">Program2.cpp</div><div class="text">Mit dieser Regel lässt sich also ein Zeiger auf eine abgeleitete Klasse von einem anderen Zeiger<br>unterscheiden. Daraus lässt sich ein Type Trait wie im Program2.cpp konstruieren:<br></div><div class="pre">// Program2.cpp<br><br>#include &lt;iostream&gt;<br>namespace details<br>{<br>&nbsp;&nbsp;&nbsp; template &lt;typename B&gt;<br>&nbsp;&nbsp;&nbsp; std::true_type test_pre_ptr_convertible(const volatile B *);<br>&nbsp;&nbsp;&nbsp; template &lt;typename&gt;<br>&nbsp;&nbsp;&nbsp; std::false_type test_pre_ptr_convertible(const volatile void *);<br>}<br>template &lt;typename Base, typename Derived&gt;<br>struct is_base_of : std::integral_constant&lt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_class&lt;Base&gt;::value &amp;&amp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_class&lt;Derived&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decltype(details::test_pre_ptr_convertible&lt;Base&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (static_cast&lt;Derived *&gt;(nullptr)))::value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt; { };<br>struct Base {};<br>struct Derived : public Base {};<br>struct A {};<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Base is base of Derived: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;Base, Derived&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Derived is base of Base: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;Derived, Base&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Base is base of A: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;Base, A&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Base is base of Base: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;Base, Base&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Base is base of const Derived: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;Base, const Derived&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "int is base of int: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;int, int&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "void is base of void: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;void, void&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "void is base of Base: " &lt; &lt; is_base_of&lt;void, Base&gt;::value <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; return 0;<br>}<br></div><div class="text"><span class="tx_code">test_pre_ptr_convertible</span> sind zwei Funktionen mit unterschiedlichen Argument-Typen und<br>unterschiedlichen Typen der Rückgabewerte. Die Funktionen werden lediglich deklariert. Eine<br>Implementierung des Funktionsrumpfes ist nicht notwendig, da sie nie wirklich aufgerufen werden,<br>sondern lediglich zur Compilezeit der Typ des Rückgabewerts abgefragt wird:</div><div class="text"><span class="tx_code">test_pre_ptr_convertible&lt;Base&gt;(static_cast&lt;Derived*&gt;(nullptr)</span></div><div class="text">Ist <span class="tx_code">Derived</span> tatsächlich von <span class="tx_code">Base</span> abgeleitet, so wird die Funktion</div><div class="pre">test_pre_ptr_convertible(const volatile B*)</div><div class="text">mit Rückgabetyp<span class="tx_code"> std::true_type</span> ausgewählt; der Rückgabetyp wird mit <span class="tx_code">decltype</span> bestimmt und die zum Typ gehörende statische Variable <span class="tx_code">value</span> hat den Wert <span class="tx_code">true</span>.</div><div class="text">Ist <span class="tx_code">Derived</span> nicht von <span class="tx_code">Base</span> abgeleitet, so wird die Funktion</div><div class="pre">test_pre_ptr_convertible(const volatile volatile*)</div><div class="text">mit Rückgabetyp <span class="tx_code">std::false_type</span> ausgewählt und die entsprechende statische Variable <span class="tx_code">value</span><br>hat den Wert <span class="tx_code">false</span>.</div><div class="text"><span class="tx_code">const volatile</span> ist notwendig, damit ggf. auch <span class="tx_code">const Derived</span> oder <span class="tx_code">volatile Derived</span> als<br>von <span class="tx_code">Base</span> abgeleitet erkannt werden. In der Implementierung wird auch eine Klasse als Basis seiner<br>selbst angesehen, also<span class="tx_code"> is_base_of&lt;Base,Base&gt;</span> liefert <span class="tx_code">true</span>.</div><div class="text">Da Ableitung nur für Klassen Sinn hat, dient</div><div class="pre">std::is_class&lt;Base&gt;::value &amp;&amp; std::is_class&lt;Derived&gt;::value</div><div class="text">dazu, damit z.B</div><div class="pre">is_base_of&lt;int,int&gt;::value</div><div class="text"><span class="tx_code">false</span> liefert.<br></div><div class="ztitel_kleiner">Program3.cpp</div><div class="text">Auf den ersten Blick schaut es so aus, als ob Program2.cpp bereits das Gewünschte leistet. Allerdings unterstützt C++ Mehrfachvererbung. Daher ist es möglich, dass eine Basisklasse mehrfach in der Ableitungshierarchie vorkommt. Das lässt sich mit Program3.cpp ausprobieren:<br></div><div class="pre">// Program3.cpp<br><br>#include &lt;iostream&gt;<br>namespace details<br>{<br>&nbsp;&nbsp;&nbsp; template &lt;typename B&gt;<br>&nbsp;&nbsp;&nbsp; std::true_type test_pre_ptr_convertible(const volatile B *);<br>&nbsp;&nbsp;&nbsp; template &lt;typename&gt;<br>&nbsp;&nbsp;&nbsp; std::false_type test_pre_ptr_convertible(const volatile void *);<br>}<br>template &lt;typename Base, typename Derived&gt;<br>struct is_base_of : std::integral_constant&lt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_class&lt;Base&gt;::value &amp;&amp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_class&lt;Derived&gt;::value &amp;&amp;<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; decltype(details::test_pre_ptr_convertible&lt;Base&gt;<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (static_cast&lt;Derived *&gt;(nullptr)))::value<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&gt; {};<br>struct Base {};<br>struct Derived1 : public Base {};<br>struct Derived2 : public Base { };<br>struct Multi : public Derived1, public Derived2 { };<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp;&nbsp; // error: ‘Base’ is an ambiguous base of ‘Multi’<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Base is base of Multi: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;Base, Multi&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; return 0;<br>}<br></div><div class="text">Der Compiler liefert jetzt die Fehlermeldung</div><div class="pre">error: ‘Base’ is an ambiguous base of ‘Multi’</div><div class="ztitel_kleiner">Program4.cpp</div><div class="text">Um hier wieder Eindeutigkeit zu bekommen, bietet sich SFINAE und ein extra Level Indirektion (in der Gestalt der Funktion<span class="tx_code"> test_pre_is_base_of</span>) an:</div><div class="pre">// Program4.cpp<br><br>#include &lt;iostream&gt;<br>namespace details<br>{<br>&nbsp;&nbsp;&nbsp; template &lt;typename B&gt;<br>&nbsp;&nbsp;&nbsp; std::true_type test_pre_ptr_convertible(const volatile B *);<br>&nbsp;&nbsp;&nbsp; template &lt;typename&gt;<br>&nbsp;&nbsp;&nbsp; std::false_type test_pre_ptr_convertible(const volatile void *);<br>&nbsp;&nbsp;&nbsp; template &lt;typename, typename&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of() -&gt; std::true_type;<br>&nbsp;&nbsp;&nbsp; template &lt;typename B, typename D&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of() -&gt; d<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecltype(test_pre_ptr_convertible&lt;B&gt;(static_cast&lt;D *&gt;(nullptr)));<br>}<br>template &lt;typename Base, typename Derived&gt;<br>struct is_base_of : std::integral_constant&lt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_class&lt;Base&gt;::value &amp;&amp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_class&lt;Derived&gt;::value &amp;&amp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decltype(details::test_pre_is_base_of&lt;Base, Derived&gt;())::value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt; { };<br>struct Base {};<br>struct Derived1 : public Base {};<br>struct Derived2 : public Base {};<br>struct Multi : public Derived1, public Derived2 {};<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Base is base of Multi: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;Base, Multi&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; // error: call of overloaded ‘test_pre_is_base_of&lt;Derived2, Multi&gt;()’<br>&nbsp;&nbsp;&nbsp; // is ambiguous<br>&nbsp;&nbsp;&nbsp; // std::cout &lt;&lt; "Base is base of Derived1: "<br>&nbsp;&nbsp;&nbsp; //&lt;&lt; is_base_of&lt;Base, Derived1&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; return 0;<br>}<br></div><div class="text">Für den Funktionsaufruf<br></div><div class="pre">test_pre_is_base_of&lt;Base,Multi&gt;()</div><div class="text">stehen die beiden Funktionen</div><div class="pre">template &lt;typename B, typename D&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of() -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decltype(test_pre_ptr_convertible&lt;B&gt;(static_cast&lt;D*&gt;(nullptr)));</div><div class="text">und</div><div class="pre">&nbsp;&nbsp;&nbsp; template &lt;typename, typename&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of() -&gt; std::true_type;</div><div class="text">zur Wahl. Der Funktionsaufruf</div><div class="pre">test_pre_ptr_convertible&lt;Base&gt;(static_cast&lt;Multi*&gt;(nullptr))</div><div class="text">ruft</div><div class="pre">test_pre_ptr_convertible(const volatile Base*);</div><div class="text">auf. Das ist aber zweideutig, da nicht klar ist, auf welche der beiden Base von <span class="tx_code">Multi</span> der Zeiger<span class="tx_code"> Base* </span>zeigen soll. Das gibt also einen „Substitution Failure“. Da aber ein „Substitution Failure“ kein „Error“ ist, wird noch die andere Funktion</div><div class="pre">template &lt;typename, typename&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of() -&gt; std::true_type;</div><div class="text">überprüft. Da diese gültig ist, liefert</div><div class="pre">decltype(details::test_pre_is_base_of&lt;Base,Multi&gt;())::value</div><div class="text">über diesen Weg den Wert <span class="tx_code">true</span>.</div><div class="text">Leider funktioniert aber dieser Type Trait nicht mehr für einfache Basisklassen</div><div class="pre">is_base_of&lt;Base, Derived1&gt;::value</div><div class="text">da in diesem Fall beide Funktionen</div><div class="pre">template &lt;typename B, typename D&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of() -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decltype(test_pre_ptr_convertible&lt;B&gt;(static_cast&lt;D*&gt;(nullptr)));</div><div class="text">und</div><div class="pre">&nbsp;&nbsp;&nbsp; template &lt;typename, typename&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of() -&gt; std::true_type;</div><div class="text">gültig und nach den Function Overload Resolution Regeln gleichwertig sind. Um dieses Problem zu lösen, muss daher irgendwie erzwungen werden, dass zuerst</div><div class="pre">template &lt;typename B, typename D&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of() -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decltype(test_pre_ptr_convertible&lt;B&gt;(static_cast&lt;D*&gt;(nullptr)));</div><div class="text">gewählt wird, und</div><div class="pre">template &lt;typename, typename&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of() -&gt; std::true_type;</div><div class="text">nur dann gewählt wird, wenn die erste Funktion einen „Substitution Failure“ liefert.</div><div class="ztitel_kleiner">Program5.cpp</div><div class="text">Auch dafür gibt es eine Lösung:<br>„A standard conversion sequence is always better than a user-defined conversion sequence or an<br>ellipsis conversion sequence.“</div><div class="pre">// Program5.cpp<br><br>#include &lt;iostream&gt;<br>namespace details<br>{<br>&nbsp;&nbsp;&nbsp; template &lt;typename B&gt;<br>&nbsp;&nbsp;&nbsp; std::true_type test_pre_ptr_convertible(const volatile B *);<br>&nbsp;&nbsp;&nbsp; template &lt;typename&gt;<br>&nbsp;&nbsp;&nbsp; std::false_type test_pre_ptr_convertible(const volatile void *);<br>&nbsp;&nbsp;&nbsp; template &lt;typename, typename&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of(...) -&gt; std::true_type;<br>&nbsp;&nbsp;&nbsp; template &lt;typename B, typename D&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of(int) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; decltype(test_pre_ptr_convertible&lt;B&gt;(static_cast&lt;D *&gt;(nullptr)));<br>}<br>// A standard conversion sequence is always better<br>// than a user-defined conversion sequence<br>// or an ellipsis conversion sequence.<br>// https://en.cppreference.com/w/cpp/language/overload_resolution<br>template &lt;typename Base, typename Derived&gt;<br>struct is_base_of : std::integral_constant&lt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_class&lt;Base&gt;::value &amp;&amp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_class&lt;Derived&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; decltype(details::test_pre_is_base_of&lt;Base, Derived&gt;(0))::value<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &gt; {};<br>struct Base {};<br>struct Derived1 : public Base {};<br>struct Derived2 : public Base {};<br>struct Multi : public Derived1, public Derived2 {};<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Base is base of Derived1: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;Base, Derived1&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Derived1 is base of Base: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;Derived1, Base&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Base is base of Derived2: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;Base, Derived2&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Derived2 is base of Base: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;Derived2, Base&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Derived1 is base of Multi: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;Derived1, Multi&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Derived2 is base of Multi: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;Derived2, Multi&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Base is base of Multi: "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; is_base_of&lt;Base, Multi&gt;::value &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; return 0;<br>}<br></div><div class="text">Verwendet man</div><div class="pre">template &lt;typename B, typename D&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of(int) -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decltype(test_pre_ptr_convertible&lt;B&gt;(static_cast&lt;D*&gt;(nullptr)));</div><div class="text">(also eine „standard conversion“ zu <span class="tx_code">int</span>), und<br> </div><div class="pre">template &lt;typename, typename&gt;<br>&nbsp;&nbsp;&nbsp; auto test_pre_is_base_of(...) -&gt; std::true_type;</div><div class="text">(also eine „ellipsis“), dann wird bevorzugt die erste Funktion (standard conversion) ausgewählt und<br>die zweite (ellispsis) tatsächlich nur im SFINAE Fall. Der Type Trait funktioniert damit also sowohl<br>für mehrfache als auch für einfache Basisklassen.</div><div class="ztitel">Wie geht's weiter? </div><div class="text">Mit der Type-Traits Bibliothek lassen sich nicht nur Datentypen prüfen oder vergleichen sondern auch modifizieren. Genau damit beschäftigt sich mein nächster Artikel.</div>