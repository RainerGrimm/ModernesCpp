<div class="vorspann">Als Vervollständigung zu den Beiträgen zu Variadic Templates und Fold Expressions gibt es clevere Tricks mit Parameterpacks und Fold Expressions.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/7/1/1/6/1/TN_217016003_5fdf31f173.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Fold Expressions ermöglichen es, ein Parameterpack mit einem binären Operator zu reduzieren. Dank ihnen kann man prägnante Ausdrücke für wiederholte Operationen schreiben, beispielsweise eine <span class="tx_code">print</span>-Funktion oder eine <span class="tx_code">push_back</span>-Funktion , um Elemente in einen Vektor zu schieben. Beginnen möchte ich mit der <span class="tx_code">print</span> Funktion.</div><div class="pre">// printFoldExpressions.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>template&lt;typename ... Args&gt;<br>void printMe(Args&amp;&amp; ... args) {<br>&nbsp;&nbsp;&nbsp; (std::cout &lt;&lt; ... &lt;&lt; std::forward&lt;Args&gt;(args)) &lt;&lt; '\n';<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br><br>&nbsp;&nbsp;&nbsp; printMe();<br>&nbsp;&nbsp;&nbsp; printMe("Rainer ", "Grimm");<br>&nbsp;&nbsp;&nbsp; printMe(true, " ", "+", " ",false, " = ", true + false);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text">Die Funktion <span class="tx_code">printMe</span> kann eine beliebige Anzahl von Argumenten annehmen. In der konkreten Funktion bedeutet das: kein Argumente, zwei C-Strings sowie ein paar Strings und Zahlen. Die <span class="tx_code">printMe</span> Funktion bestimmt automatisch deren Typen und zeigt sie an. Drei leistungsstarke C++-Techniken sind beteiligt.</div><div class="text"><ul><li>Variadic Templates (<span class="tx_code"> ... </span>): akzeptiert eine beliebige Anzahl von Argumenten. Mehr Details bieten die folgenden Artikel zu "<a title="Link auf https://heise.de/-6157802" alt="%7B%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6157802%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Variadic%20Templates%20oder%20die%20Power%20der%20drei%20Punkte%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6157802%22%2C%22mediasync_id%22%3A%22%22%7D" href="https://heise.de/-6157802">Variadic Templates oder die Power der drei Punkte</a>" und "<a title="Link auf https://heise.de/-6165404" alt="%7B%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6165404%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6165404%22%2C%22mediasync_id%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Mehr%20%C3%BCber%20Variadic%20Templates%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://heise.de/-6165404">Mehr über Variadic Templates</a>" an.<br></li><li>Perfect Forwarding (<span class="tx_code">std::forward</span>): Leitet die Argumente weiter, ohne ihre Wertkategorie zu ändern. Mehr Details bietet der Artikel "<a title="Link auf https://www.grimm-jaud.de/index.php/blog/perfect-forwarding" alt="%7B%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fperfect-forwarding%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fperfect-forwarding%22%2C%22text%22%3A%22Perfect%20Forwarding%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/perfect-forwarding">Perfect Forwarding</a>" an.<br></li><li>Fold Expressios (<span class="tx_code">std::cout &lt;&lt; ... &lt;&lt; std::forward&lt;Args&gt;(args)</span>): reduziert das Parameterpack von links mithilfe des binären Operators<span class="tx_code"> &lt;&lt;</span> und dem Anfangswert <span class="tx_code">std::cout</span>. Mehr Details bietet der Artikel "<a title="Link auf https://heise.de/-6189541" alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6189541%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Von%20Variadic%20Templates%20zu%20Fold%20Expressions%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6189541%22%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://heise.de/-6189541">Von Variadic Templates zu Fold Expressions</a>" an. </li></ul></div><div class="text">Zum Schluss ist hier die Ausgabe des Programms. </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/7/1/1/6/1/TN_217016005_ff0252f14d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Dank der Fold Expression lässt sich eine beliebige Anzahl von Argumenten in einen Vektor schieben.</div><div class="pre">// pushBackFoldExpressions.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>using namespace std;<br>&nbsp;<br>template&lt;typename T, typename... Args&gt;<br>void myPushBack(vector&lt;T&gt;&amp; v, Args&amp;&amp;... args) {<br>&nbsp;&nbsp;&nbsp; (v.push_back(args), ...); // (1)<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; myIntVec;<br>&nbsp;&nbsp; &nbsp;myPushBack(myIntVec, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);<br>&nbsp;&nbsp; &nbsp;for (auto v : myIntVec) std::cout &lt;&lt; v &lt;&lt; ' ';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp;&nbsp;&nbsp; std::vector myDoubleVec{1.1, 2.2, 3.3}; // (2)<br>&nbsp;&nbsp;&nbsp; myPushBack(myDoubleVec, 4.4, 5.5, 6.6);<br>&nbsp;&nbsp;&nbsp; for (auto v: myDoubleVec) std::cout &lt;&lt; v &lt;&lt; ' ';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>}</div><div class="text">(1) und (2) sind besonders interessant. (2) schiebt die drei <span class="tx_code">double</span>-Werte in den Vektor. Mit C++17 kann der Compiler automatisch die Typen der Argumente ableiten. Der Ausdruck (<span class="tx_code">v.push_back(args),...</span>) schiebt die Elemente von rechts mit dem binären Kommaoperator (,) auf den Vektor. Da er assoziativ ist, lassen sich die Elemente auch von links drauf schieben:&nbsp; (<span class="tx_code">...,</span><span class="tx_code"> v.push_back(args)</span>). Ehrlich gesagt, sieht das ungewohnt aus. Deshalb bevorzuge ich die erste Variante.</div><div class="text">Der folgende Screenshot zeigt die Ausgabe des Programms.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/7/1/1/6/1/TN_217016015_c16b57f521.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br> </div><div class="text">Jetzt möchte ich einen Schritt zurück von den Fold Expressions zu den Variadic Templates gehen und das Overload Pattern vorstellen. Das Overload Pattern ist eine clevere Methode, um mehrere Lambdas in ein Overload Set zu packen.<br> </div><div class="ztitel">Overload Pattern<br></div><div class="text">Ich will es kurz machen. Hier ist das Overload Pattern mit C++20 implementiert:<br></div><div class="pre">template&lt;typename ... Ts&gt; struct Overload : Ts ... { using Ts::operator() ... ; };</div><div class="text">Was? Entschuldigung, mein Fehler. Ich sollte es richtig layouten.</div><div class="pre">template&lt;typename ... Ts&gt; <br>struct Overload : Ts ... { <br>&nbsp;&nbsp;&nbsp; using Ts::operator() ... ; <br>};</div><div class="text">Die <span class="tx_code">struct</span> <span class="tx_code">Overload</span> kann beliebig viele Basisklassen (<span class="tx_code">Ts ...</span>) besitzen. Sie leitet sich von jeder Klasse <span class="tx_code">public</span> ab und nimmt den Aufrufoperator (<span class="tx_code">Ts::operator...</span>) jeder Basisklasse in ihren Geltungsbereich auf.</div><div class="text">Es gibt noch mehr über diese vier magischen Codezeilen zu erklären. Bevor ich das in meinem nächsten Beitrag tue, möchte ich das Overload Pattern verwenden, um die Typen der Ganzzahlliterale darzustellen. Das folgende Programm erfordert einen C++20-Compiler.</div><div class="pre">// overloadPattern.cpp<br><br>#include &lt;iostream&gt;<br><br>template&lt;typename ... Ts&gt; <br>struct Overload : Ts ... { <br>&nbsp;&nbsp;&nbsp; using Ts::operator() ...;<br>};<br><br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; auto TypeOfIntegral = Overload {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int) { return " int"; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](unsigned int) { return " unsigned int"; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](long int) { return " long int"; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](long long int) { return "long long int"; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](auto) { return "unbekannter Typ"; },<br>&nbsp;&nbsp;&nbsp; };<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "TypeOfIntegral(5): " &lt;&lt; TypeOfIntegral(5) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "TypeOfIntegral(5u): " &lt;&lt; TypeOfIntegral(5u) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "TypeOfIntegral(5U): " &lt;&lt; TypeOfIntegral(5U) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "TypeOfIntegral(5l): " &lt;&lt; TypeOfIntegral(5l) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "TypeOfIntegral(5L): " &lt;&lt; TypeOfIntegral(5L) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "TypeOfIntegral(5ll): " &lt;&lt; TypeOfIntegral(5ll) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "TypeOfIntegral(5LL): " &lt;&lt; TypeOfIntegral(5LL) &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "TypeOfIntegral(5ul): " &lt;&lt; TypeOfIntegral(5ul) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "TypeOfIntegral(5.5): " &lt;&lt; TypeOfIntegral(5.5) &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n'; <br><br>}</div><div class="text">Im Programm <span class="tx_code">overloadPattern.cpp</span> besteht das Overload Set aus Lambda-Ausdrücken, die einen <span class="tx_code">int</span>, einen <span class="tx_code">unsigned int</span>, einen<span class="tx_code"> long int</span>, einen <span class="tx_code">long long int</span> und <span class="tx_code">auto</span> akzeptieren. <span class="tx_code">auto</span> ist der Fallback, der verwendet wird, wenn das Overload Set mit einem unbekannten Typ aufgerufen wird. Das passiert zum Beispiel, wenn ich <span class="tx_code">TypeOfIntegral</span> mit einem <span class="tx_code">unsigned long</span> oder einem <span class="tx_code">double</span> Wert aufrufe.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/7/1/1/6/1/TN_217016017_6b228faaf6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel">Wie geht es weiter?</div><div class="text">Normalerweise kommt das Overload Pattern für eine <span class="tx_code">std::variant</span> zum Einsatz, die eine typsichere Union ist. Eine Instanz <span class="tx_code">var</span> von <span class="tx_code">std::variant</span> (C++17) hat einen Wert aus einem ihrer Typen. <span class="tx_code">std::visit</span> ermöglicht es, einen Besucher auf <span class="tx_code">var</span> anzuwenden. Genau hier kommt das Overload Pattern sehr praktisch ins Spiel. Lies mehr über<span class="tx_code"> std::variant, std::visit</span> und das Overload Pattern in meinem nächsten Beitrag.</div><div class="ztitel">Pdf-Päckchen: C++20 Module</div><div class="text">Auf der Grundlage der letzten Umfrage habe ich das nächste Pdf-Päckchen erstellt.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/7/1/1/6/1/TN_217016027_4f3169d1f3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Das pdf-Päckchen enthält alle</div><div class="text"><ul><li>Beiträge.</li><li>Quellcode-Dateien zu diesen Beiträgen.</li></ul></div><div class="text">In dem Artikel "<a title="Link auf https://www.modernescpp.com/index.php/the-new-pdf-bundle-is-ready-c-20-modules" alt="%7B%22text%22%3A%22The%20New%20pdf%20Bundle%20is%20Ready%3A%20C%2B%2B20%20Modules%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fthe-new-pdf-bundle-is-ready-c-20-modules%22%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fthe-new-pdf-bundle-is-ready-c-20-modules%22%7D" href="https://www.modernescpp.com/index.php/the-new-pdf-bundle-is-ready-c-20-modules">The New pdf Bundle is Ready: C++20 Modules</a><span class="css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0">" erkläre ich, wie man das pdf-Päckchen einfach erhalten kann.<br></span></div><div class="text"><br></div>