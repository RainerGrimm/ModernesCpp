<div class="text"><b>In meinem letzten Beitrag <a title="Link auf https://heise.de/-6069388" alt="%7B%22target%22%3A%22_blank%22%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Template%20Arguments%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6069388%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6069388%22%2C%22version%22%3A1%7D" href="https://heise.de/-6069388" class="">Template Arguments</a> habe ich über die Typbestimmung von Funktions-Templates (C++98) und <span class="tx_code">auto</span> (C++11) geschrieben. Heute setze ich mir einen moderneren Hut auf. Ich beginne mit der automatischen Typbestimmung von Nicht-Template-Parametern, Klassen-Templates (C++17) und schließe mit der automatischen Typbestimmung von Concepts (C++20) ab.</b></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/2/4/1/2/5/TN_212583278_d0014cbd4d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Der chronologischen Reihenfolge folgend, möchte ich mit zwei C++17-Features beginnen: Typbestimmung von Nicht-Typ-Template-Parametern und Typbestimmung von Klassen-Templates in C++17.</div>
<div class="ztitel">Automatische Typbestimmung von Nicht-Typ-Template-Parametern</div>
<div class="text">Zuallererst, was sind Nicht-Typ-Template-Parameter? Das sind <span class="tx_code">nullptr</span>, ganzzahlige Werte wie zum Beispiel <span class="tx_code">bool</span> oder <span class="tx_code">int</span>, lvalue Referenzen, Zeiger, Aufzähler und mit C++20 Fließkommazahlen. Am häufigsten werden ganzzahlige Typen verwendet.</div>
<div class="text">Nach dieser Theorie fahre ich mit einem Beispiel fort:</div>
<div class="pre">template &lt;auto N&gt; // (1)<br>class MyClass{<br>&nbsp;&nbsp;&nbsp; ....<br>};<br><br>template &lt;int N&gt; // (2)<br>class MyClass&lt;N&gt; {<br>&nbsp;&nbsp;&nbsp; ....<br>};<br><br><br>MyClass&lt;'x'&gt; myClass1;&nbsp; // (3)<br>MyClass&lt;2017&gt; myClass2; // (4)</div>
<div class="text">Durch die Verwendung von <span class="tx_code">auto</span> (1) in der Template-Signatur ist<span class="tx_code"> N</span> ein Nicht-Typ-Template-Parameter. Der Compiler wird ihn automatisch ableiten.<span class="tx_code">MyClass</span> lässt sich auch für <span class="tx_code">int</span> partiell spezialisieren (2). Die Template-Instanziierung (3) wird das primäre Template (1) verwenden und die folgende Template-Instanziierung die partielle Spezialisierung für <span class="tx_code">int</span> (4).</div>
<div class="text">Die üblichen Typqualifizierer können verwendet werden, um den Typ der Nicht-Typ-Template-Parameter einzuschränken.</div>
<div class="pre">template &lt;const auto* p&gt;<br>class S;</div>
<div class="text">In dieser Deklaration eines Klassen-Template<span class="tx_code"> S</span>, muss <span class="tx_code">p</span> ein Zeiger auf <span class="tx_code">const</span> sein.</div>
<div class="text">Die automatische Typbestimmung für Nicht-Typ-Templates lässt sich auch auf variadische Templates anwenden.</div>
<div class="pre">template &lt;auto... ns&gt;<br>class VariadicTemplate{ .... };<br><br>template &lt;auto n1, decltype(n1)... ns&gt;<br>class TypedVariadicTemplate{ .... };</div>
<div class="text"><span class="tx_code">VariadicTemplate</span> kann eine beliebige Anzahl von Nicht-Typ-Template-Parametern ableiten. <span class="tx_code">TypedVariadicTemplate</span> wird nur den ersten Template-Parameter bestimmen. Die restlichen Template-Parameter müssen vom gleichen Typ wie der erste Typ sein:<span class="tx_code"> decltype(n1)</span>. </div>
<div class="text">Die automatische Typbestimmung von Klassen-Templates macht ihre Verwendung recht komfortabel.</div>
<div class="ztitel">Automatische Typbestimmung von Klassen-Templates</div>
<div class="text">Ein Funktions-Template kann seine Typparameter aus seinen Funktionsargumenten automatisch bestimmen. Aber das war für spezielle Funktionen nicht möglich: Konstruktoren von Klassen-Templates. Mit C++17 ist diese Aussage falsch. Ein Konstruktor kann seine Typparameter von seinen Konstruktorargumenten ableiten. Hier ist ein erstes Beispiel:</div>
<div class="pre">// templateArgumentDeduction.cpp<br><br>#include &lt;iostream&gt;<br><br>template &lt;typename T&gt;<br>void showMe(const T&amp; t) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; t &lt;&lt; '\n';<br>}<br><br>template &lt;typename T&gt;<br>struct ShowMe{<br>&nbsp;&nbsp;&nbsp; ShowMe(const T&amp; t) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; t &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main() {<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; showMe(5.5); // not showMe&lt;double&gt;(5.5);<br>&nbsp;&nbsp;&nbsp; showMe(5); // not showMe&lt;int&gt;(5);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; ShowMe(5.5); // not ShowMe&lt;double&gt;(5.5);<br>&nbsp;&nbsp;&nbsp; ShowMe(5); // not ShowMe&lt;int&gt;(5);<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Nun noch ein paar Worte zur <span class="tx_code">main</span>-Funktion. Die Instanziierung des Funktions-Templates <span class="tx_code">showMe</span> ist seit dem ersten C++ Standard C++98 gültig, die Instanziierung der Klassen-Templates <span class="tx_code">ShowMe</span> jedoch erst seit C++17. Aus Benutzersicht fühlt sich die Verwendung von Funktions- oder Klassen-Templates genauso an wie eine gewöhnliche Funktion oder Klasse.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/2/4/1/2/5/TN_212583298_8eaf3a4cf0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Wer noch nicht überzeugt ist, findet hier weitere Beispiele für die Ableitung der Argumente von Klassen-Templates:</div>
<div class="pre">// classTemplateArgumentDeduction.cpp<br><br>#include &lt;array&gt;<br>#include &lt;Vektor&gt;<br>#include &lt;mutex&gt;<br>#include &lt;memory&gt;<br><br>int main() {<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; std::array myArr{1, 2, 3}; // deduces std::array&lt;int, 3&gt;<br>&nbsp;&nbsp;&nbsp; std::vector myVec{1.5, 2.5}; // deduces std::vector&lt;double&gt;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; std::mutex mut;<br>&nbsp;&nbsp;&nbsp; std::lock_guard myLock(mut); // deduces std::lock_guard&lt;mutex&gt;(mut) <br>&nbsp;<br>&nbsp;&nbsp;&nbsp; std::pair myPair(5, 5.5); // deduces std::pair&lt;int, double&gt; <br>&nbsp;&nbsp;&nbsp; std::tuple myTup(5, myArr, myVec); // deduces std::tuple&lt;int,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // std::array&lt;int, 3&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // std::vector&lt;double&gt;&gt;<br>}</div>
<div class="text">Die Kommentare zeigen, wie der C++17 Compiler den Typ bestimmt. Dank<a title="Link auf https://cppinsights.io/s/b83f6def" alt="%7B%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2Fb83f6def%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2Fb83f6def%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22%20C%2B%2B%20Insights%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%7D" href="https://cppinsights.io/s/b83f6def" class=""> C++ Insights</a> lässt sich der Prozess der Bestimmung von Template-Argumenten visualisieren.</div>
<div class="text">Die letzten beiden Beispiele zu <span class="tx_code">std::pair</span> und<span class="tx_code"> std::tuple</span> sind ziemlich interessant. Vor C++17 haben wir Fabrikfunktionen wie<span class="tx_code"> std::make_pair</span> oder<span class="tx_code"> std::make_tuple</span> verwendet, um ein<span class="tx_code"> std::pair</span> oder ein<span class="tx_code"> std::tuple</span> zu erzeugen, ohne die Typparameter anzugeben. Im Gegensatz zu Klassen-Templates konnte der Compiler die Typparameter&nbsp; automatisch aus den Funktionsargumenten ableiten. Hier ist eine vereinfachte Version von <span class="tx_code">std::make_pair</span>.</div>
<div class="pre">// makePair.cpp<br><br>#include &lt;utility&gt;<br><br>template&lt;typename T1, typename T2&gt;<br>std::pair&lt;T1, T2&gt; make_pair2(T1 t1, T2 t2) {<br>&nbsp;&nbsp;&nbsp; return std::pair&lt;T1, T2&gt;(t1, t2);<br>}<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; auto arg{5.5};<br>&nbsp;&nbsp; auto pair1 = std::make_pair(5, arg);<br>&nbsp;&nbsp; auto pair2 = make_pair2(5, arg);<br>&nbsp;&nbsp; auto pair3 = std::pair(5, arg);<br>&nbsp; &nbsp;<br>}</div>
<div class="text">Der Compiler bestimmt die gleichen Datentypen für <span class="tx_code">pair1</span> und <span class="tx_code">pair2</span>. Mit C++17 brauchen wir diese Fabrikfunktion nicht mehr und können direkt den Konstruktor von<span class="tx_code"> std::pair</span> aufrufen, um <span class="tx_code">pair3</span> zu erhalten.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/2/4/1/2/5/TN_212583285_a5a20406a9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das Programm lässt sich direkt auf <a title="Link auf https://cppinsights.io/s/513635bd" alt="%7B%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F513635bd%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F513635bd%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C%2B%2B%20Insights%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%7D" href="https://cppinsights.io/s/513635bd" class="">C++ Insights</a> studieren.<br> </div>
<div class="text">Es mag verwundern, dass mein Funktions-Template<span class="tx_code"> make_pair2</span> seine Argumente per Wert angenommen hat.<span class="tx_code"> std::make_pair</span> <i>decayed</i> seine Argumente und so auch mein Funktions-Template <span class="tx_code">make_pair2</span>. Ich habe über den Decay von Funktionsargumenten in meinem letzten Beitrag&nbsp; <a title="Link auf https://heise.de/-6069388" alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Template%20Arguments%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6069388%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6069388%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%7D" href="https://heise.de/-6069388" class="">Template Arguments</a> geschrieben.</div>
<div class="text">Bevor ich ein paar Worte über die automatische Typbestimmung mit Concepts schreibe, möchte ich es explizit betonen: Die automatische Typbestimmung ist mehr als praktisch und sie ist ein Sicherheitsfeature. <b>Wer den Datentyp nicht angibt, kann dabei keinen Fehler machen.</b></div>
<div class="pre">// automaticTypeDeduction.cpp<br><br>#include &lt;string&gt;<br><br>template&lt;typename T&gt;<br>void func(T) {};<br><br>template &lt;typename T&gt;<br>struct Class{<br>&nbsp; Class(T){}<br>};<br><br>int main() {<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; int a1 = 5.5; // static_cast&lt;int&gt;(5.5)<br>&nbsp;&nbsp;&nbsp; auto a2 = 5.5;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; func&lt;float&gt;(5.5); // static_cast&lt;float&gt;(5.5)<br>&nbsp;&nbsp;&nbsp; func(5.5);<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; Class&lt;std::string&gt; class1("class"); // calls essentially<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // std::string("class")<br>&nbsp;&nbsp;&nbsp; Class class2("class");<br>&nbsp;<br>}</div>
<div class="text">Alle Fehler sind darauf zurückzuführen, dass ich den Datentyp explizit angegeben habe:</div>
<div class="text"><ul><li> <span class="tx_code">int a1</span> löst die<i> narrowing conversion</i> von <span class="tx_code">double</span> nach <span class="tx_code">int</span> aus</li><li><span class="tx_code">func&lt;float&gt;(5.5)</span> bewirkt die Umwandlung von dem <span class="tx_code">double</span>-Wert 5.5 in <span class="tx_code">float</span></li><li><span class="tx_code">Class&lt;std::string&gt; class1("class")</span> erzeugt einen C++-String, der mit einem C-String initialisiert wird.<br></li></ul></div>
<div class="text">Auf <a title="Link auf https://cppinsights.io/s/c8c70e7c" alt="%7B%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2Fc8c70e7c%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2Fc8c70e7c%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Insights%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://cppinsights.io/s/c8c70e7c" class="">C++ Insights</a> lässt sich das Programm wieder schön studieren.</div>
<div class="text">Der Geschichte der automatischen Typendeduktion ist nicht viel hinzuzufügen, wenn Concepts ins Spiel kommen.</div>
<div class="ztitel">Automatische Typbestimmung mit Concepts</div>
<div class="text">Die automatische Typbestimmung mit Concepts birgt keine Überraschungen.</div>
<div class="pre">// typeDeductionConcepts.cpp<br><br>#include &lt;concepts&gt;<br><br>void foo(auto t) {}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>void bar(std::integral auto t){}&nbsp;&nbsp;&nbsp; // (2)<br><br>template &lt;std::regular T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>struct Class{<br>&nbsp; Class(T){}<br>};<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; foo(5.5);<br>&nbsp;&nbsp;&nbsp; bar(5);<br>&nbsp;&nbsp;&nbsp; Class cl(true);<br><br>}</div>
<div class="text">Unabhängig davon, ob ein uneingeschränkter Platzhalter (<span class="tx_code">auto</span> in Zeile 1), ein eingeschränkter Platzhalter (Concept in Zeile 2) oder ein eingeschränkter Template-Parameter (Concept in Zeile 3) zum Einsatz kommt, bestimmt der Compiler automatisch den erwarteten Datentyp. <a title="Link auf https://cppinsights.io/s/218e9e55" alt="%7B%22ir_link%22%3A1%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F218e9e55%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F218e9e55%22%2C%22text%22%3A%22C%2B%2B%20Insights%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://cppinsights.io/s/218e9e55" class="">C++ Insights</a> hilft dabei, die Typbestimmung zu visualisieren.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/2/4/1/2/5/TN_212583293_123ab5bcc7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br> </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">In meinem nächsten Artikel schreibe ich über ein weiteres spannendes Templatefeature: Spezialisierung. Man kann ein Funktions-Template oder Klassen-Template vollständig spezialisieren, und zusätzlich lässt es sich partiell spezialisieren.</div>