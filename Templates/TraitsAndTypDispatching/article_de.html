<div class="vorspann">Tag Dispatching ermöglicht es, eine Funktion auf der Grundlage der Typeingenschaften auszuwählen. Diese Entscheidung findet zur Compiletime statt und basiert auf Traits.</div><div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/4/4/2/7/8/8/TN_235923809_cd4f08bcfd.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Tag Dispatching basiert auf Traits. Folgerichtig möchte ich ein paar Worte über Traits schreiben.</div><div class="ztitel">Traits</div><div class="text">Traits sind Klassen-Templates, die Merkmale eines generischen Typs bereitstellen. Sie können ein oder mehrere Merkmale eines Klassen-Templates extrahieren.</div><div class="text">Du hast es vielleicht schon vermutet: Die Metafunktionen aus der type-traits-Bibliothek sind typische Beispiele für Traits in C++. Ich habe bereits ein paar Beiträge über sie geschrieben: </div><div class="text"><ul><li> <a title="Link auf https://heise.de/-6273014" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22text%22%3A%22Typpr%C3%BCfungen%22%2C%22target%22%3A%22_blank%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6273014%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6273014%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="https://heise.de/-6273014">Typprüfungen</a> </li><li> <a title="Link auf https://heise.de/-6277964" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Typvergleiche%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6277964%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6277964%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="https://heise.de/-6277964">Typvergleiche</a> </li><li> <span class="tx_code"><a title="Link auf https://heise.de/-6283615" alt="%7B%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6283615%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6283615%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22std%3A%3Ais_base_of%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22mediasync_id%22%3A%22%22%7D" href="https://heise.de/-6283615">std::is_base_of</a></span> </li><li> <a title="Link auf https://heise.de/-6292251" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Korrektheit%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6292251%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6292251%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="https://heise.de/-6292251">Korrektheit</a> </li><li> <a title="Link auf https://heise.de/-6298337" alt="%7B%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6298337%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6298337%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Optimierung%22%2C%22target%22%3A%22_blank%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D" href="https://heise.de/-6298337">Optimierung</a> <br></li></ul></div><div class="text">Bevor ich in diesem Beitrag in das Tag-Dispatching einsteige, möchte ich die Iterator-Traits vorstellen. Der folgende Codeschnipsel zeigt ihre partielle Spezialisierung für Zeiger:</div><div class="pre">template&lt;T&gt; <br>struct iterator_traits&lt;T*&gt; { <br>&nbsp;&nbsp;&nbsp; using difference_type = std::ptrdiff_t; <br>&nbsp;&nbsp;&nbsp; using value_type = T; <br>&nbsp;&nbsp;&nbsp; using pointer = T*; <br>&nbsp;&nbsp;&nbsp; using reference = T&amp;; <br>&nbsp;&nbsp;&nbsp; using iterator_category = std::random_access_iterator_tag; <br>};</div><div class="text">Die Iterator Kategorien bilden die folgende Hierarchie:</div><div class="pre">struct input_iterator_tag{}; <br>struct output_iterator_tag{}; <br>struct forward_iterator_tag: public input_iterator_tag{}; <br>struct bidirectional_iterator_tag: public forward_iterator_tag{}; <br>struct random_access_iterator_tag: public bidirectional_iterator_tag{}; </div><div class="text">Die verschiedenen Iterator-Kategorien lassen sich den Containern der Standard Template Library zuordnen.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/4/4/2/7/8/8/TN_235923818_41e6d6ddca.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Für die Iterator-Kategorien und ihre unterstützenden Operationen gelten die folgenden Beziehungen: Ein Iterator mit wahlfreiem Zugriff ist ein bidirektionaler Iterator, und ein bidirektionaler Iterator ist ein Forward-Iterator. Das bedeutet, dass <span class="tx_code">std::array, std::vector</span> und <span class="tx_code">std::string</span> einen Iterator mit wahlfreiem Zugriff unterstützen. Das gilt aber nicht für<span class="tx_code"> std::deque</span>.</div><div class="ztitel">Tag Dispatching</div><div class="text">Jetzt kann ich Tag Dispatching anwenden und einen maßgeschneiderten <span class="tx_code">advance_</span>-Algorithmus implementieren, der für den verwendeten Container optimiert ist. Zunächst einmal ist <span class="tx_code">std::advance</span> bereits Bestandteil der Standard Template Library:</div><div class="pre">template&lt; class InputIt, class Distance &gt;<br>void advance( InputIt&amp; it, Distance n );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (until C++17)<br><br>template&lt; class InputIt, class Distance &gt;<br>constexpr void advance( InputIt&amp; it, Distance n );&nbsp; (since C++17)</div><div class="text"><span class="tx_code">std::advance</span> setzt einen gegebenen Iterator <span class="tx_code">it</span> um <span class="tx_code">n</span> Positionen weiter. Wenn <span class="tx_code">n</span> negativ ist, wird der Iterator dekrementiert. Folglich muss der Container, der den Iterator bereitstellt, in diesem Fall bidirektional sein.</div><div class="text">Hier ist meine Implementierung von <span class="tx_code">advance_</span>:</div><div class="pre">// advance_.cpp<br><br>#include &lt;iterator&gt;<br>#include &lt;forward_list&gt;<br>#include &lt;list&gt;<br>#include &lt;vector&gt;<br>#include &lt;iostream&gt;<br><br>template &lt;typename InputIterator, typename Distance&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>void advance_impl(InputIterator&amp; i, Distance n, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::input_iterator_tag) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "InputIterator used" &lt;&lt; '\n'; <br>&nbsp;&nbsp;&nbsp; while (n--) ++i;<br>}<br><br>template &lt;typename BidirectionalIterator, typename Distance&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>void advance_impl(BidirectionalIterator&amp; i, Distance n,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::bidirectional_iterator_tag) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "BidirectionalIterator used" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; if (n &gt;= 0) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (n--) ++i;<br>&nbsp;&nbsp;&nbsp; else <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (n++) --i;<br>}<br><br>template &lt;typename RandomAccessIterator, typename Distance&gt;&nbsp;&nbsp;&nbsp;&nbsp; <br>void advance_impl(RandomAccessIterator&amp; i, Distance n,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::random_access_iterator_tag) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "RandomAccessIterator used" &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; i += n;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>}<br><br>template &lt;typename InputIterator, typename Distance&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>void advance_(InputIterator&amp; i, Distance n) {<br>&nbsp;&nbsp;&nbsp; typename <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::iterator_traits&lt;InputIterator&gt;::iterator_category category;<br>&nbsp;&nbsp;&nbsp; advance_impl(i, n, category);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br>&nbsp; <br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; myVec{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; auto myVecIt = myVec.begin();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myVecIt: " &lt;&lt; *myVecIt &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; advance_(myVecIt, 5);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myVecIt: " &lt;&lt; *myVecIt &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::list&lt;int&gt; myList{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; auto myListIt = myList.begin();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myListIt: " &lt;&lt; *myListIt &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; advance_(myListIt, 5);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myListIt: " &lt;&lt; *myListIt &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::forward_list&lt;int&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myForwardList{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; auto myForwardListIt = myForwardList.begin();&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myForwardListIt: " &lt;&lt; *myForwardListIt &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; advance_(myForwardListIt, 5);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myForwardListIt: " &lt;&lt; *myForwardListIt &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>}</div><div class="text">In dem Beispiel verwende ich einen<span class="tx_code"> std::vector </span>(1), eine<span class="tx_code"> std::list</span> (2) und eine <span class="tx_code">std::forward_lis</span>t (3). Ein <span class="tx_code">std::vector</span> unterstützt einen Iterator mit wahlfreiem Zugriff, eine <span class="tx_code">std::list</span> einen bidirektionalen Iterator und eine<span class="tx_code"> std::forward_list </span>einen Forward-Iterator. Der Aufruf <span class="tx_code">std::iterator_traits&lt;InputIterator&gt;::iterator_category</span> in der Funktion <span class="tx_code">advance_</span> (4) bestimmt die unterstützte Iterator-Kategorie anhand des eingesetzten Iterators. Der abschließende Aufruf<span class="tx_code"> advance_impl(i, n, category)</span> verwendet schließlich die am stärksten spezialisierte Überladung der Implementierungsfunktion<span class="tx_code"> advance_impl.</span></div><div class="text">Um diese Abbildung zu visualisieren, habe ich den Implementierungsfunktionen <span class="tx_code">advance_impl </span>eine kurze Nachricht hinzugefügt.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/4/4/2/7/8/8/TN_235923821_6d3896a158.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Was sind die Vorteile einer so fein abgestimmten advance-Implementierung?</div><div class="text"><ul><li><b>Typsicherheit</b>: Der Compiler entscheidet, welche Version von <span class="tx_code">advance</span> <span class="tx_code">_impl </span>verwendet wird. Folglich lässt sich eine Implementierung, die einen bidirektionalen Iterator erfordert, nicht mit einem Forward-Iterator aufrufen. Rückwärts iterieren mit einem Forward-Iterator ist undefiniertes Verhalten.</li><li><b>Performanz</b>: Einen Forward-Iterator oder einen bidirektionalen Iterator<span class="tx_code"> n</span> Positionen weiter zu setzen, erfordert<span class="tx_code"> n</span> Inkrementoperationen. Seine Komplexität ist daher linear. Diese Beobachtung gilt nicht für einen Iterator mit wahlfreiem Zugriff: Eine Zeigerarithmetik wie<span class="tx_code"> i += n</span> (5) ist eine konstante Operation.</li></ul></div><div class="ztitel">Wie geht's weiter?</div><div class="text">In meinem nächsten Artikel verbinde ich den dynamischen Polymorphismus (Objektorientierung) mit dem statischen Polymorphismus (Templates) und führe eine ziemlich anspruchsvolle Technik ein: type erasure.</div><div class="ztitel">Die Zukunft von Modernes C++</div><div class="text">Der folgende Artikel über type erasure wird vorerst mein letzter Artikel über Templates sein. Wer alle vorherigen Artikel lesen möchte, kann mein <a title="Link auf https://www.grimm-jaud.de/index.php/der-einstieg-in-modernes-c" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Inhaltsverzeichnis%22%2C%22target%22%3A%22_blank%22%2C%22mediasync_id%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fder-einstieg-in-modernes-c%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fder-einstieg-in-modernes-c%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/der-einstieg-in-modernes-c">Inhaltsverzeichnis</a> oder meine Kategorie <a title="Link auf https://www.grimm-jaud.de/index.php/blog/category/templates" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Templates%22%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Ftemplates%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Ftemplates%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/category/templates">Templates</a> nutzen. Danach schreibe ich weitere Artikel zu C++20 und werde einen Blick in die Zukunft von C++23 werfen. Wer eine interessante Beitragsidee hast, sendet mir bitte eine E-Mail: <a title="Link auf Rainer.Grimm@modernescpp.de" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Rainer.Grimm%40modernescpp.de%22%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22target%22%3A%22%22%2C%22href%22%3A%22mailto%3ARainer.Grimm%40modernescpp.de%22%2C%22type%22%3A%22E_Mail%22%2C%22destination%22%3A%22Rainer.Grimm%40modernescpp.de%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="mailto:Rainer.Grimm@modernescpp.de">Rainer.Grimm@modernescpp.de</a>.</div>