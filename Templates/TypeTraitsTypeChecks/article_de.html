<div class="vorspann">Die Type-Traits Bibliothek ist Bestandteil von C++11 und unterstützt Typprüfungen, Typvergleiche und Typänderungen zur Compiletime. Die Bibliothek umfasst mehr als 100 Funktionen und wächst mit jeder neuen C++-Standardversion. </div><div class="text">In diesem Artikel stelle ich Typprüfungen mir der Type-Traits Bibliothek genauer vor.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/1/8/3/0/8/TN_220967718_95c7174e7f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel">Typprüfung</div><div class="text">Jeder Typ gehört genau zu einer der vierzehn primären Typkategorien.<br></div><div class="ztitel_kleiner">Primäre Typkategorien<br></div><div class="text">Hier sind alle Kategorien:<br></div><div class="pre">template &lt;class T&gt; struct is_void;<br>template &lt;class T&gt; struct is_integral;<br>template &lt;class T&gt; struct is_floating_point;<br>template &lt;class T&gt; struct is_array;<br>template &lt;class T&gt; struct is_pointer;<br>template &lt;class T&gt; struct is_null_pointer;<br>template &lt;class T&gt; struct is_member_object_pointer;<br>template &lt;class T&gt; struct is_member_function_pointer;<br>template &lt;class T&gt; struct is_enum;<br>template &lt;class T&gt; struct is_union;<br>template &lt;class T&gt; struct is_class;<br>template &lt;class T&gt; struct is_function;<br>template &lt;class T&gt; struct is_lvalue_reference;<br>template &lt;class T&gt; struct is_rvalue_reference;<br></div><div class="text">Das folgende Programm stellt für jede primäre Typkategorie einen Datentyp vor:<br></div><div class="pre">// primaryTypeCategories.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>struct A {<br>&nbsp; int a;<br>&nbsp; int f(int) { return 2011; }<br>};<br><br>enum E {<br>&nbsp; e= 1,<br>};<br><br>union U {<br>&nbsp; int u;<br>};<br><br><br>int main() {<br><br>&nbsp; using namespace std;<br>&nbsp; <br>&nbsp; cout &lt;&lt;&nbsp; boolalpha &lt;&lt;&nbsp; '\n';<br><br>&nbsp; cout &lt;&lt; is_void&lt;void&gt;::value &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp; cout &lt;&lt; is_integral&lt;short&gt;::value &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp; cout &lt;&lt; is_floating_point&lt;double&gt;::value &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp; cout &lt;&lt; is_array&lt;int []&gt;::value &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp; cout &lt;&lt; is_pointer&lt;int*&gt;::value &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp; cout &lt;&lt; is_null_pointer&lt;nullptr_t&gt;::value &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp; cout &lt;&lt; is_member_object_pointer&lt;int A::*&gt;::value &lt;&lt;&nbsp; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp; cout &lt;&lt; is_member_function_pointer&lt;int (A::*)(int)&gt;::value &lt;&lt;'\n';// true<br>&nbsp; cout &lt;&lt; is_enum&lt;E&gt;::value &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp; cout &lt;&lt; is_union&lt;U&gt;::value &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp; cout &lt;&lt; is_class&lt;string&gt;::value &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp; cout &lt;&lt; is_function&lt;int * (double)&gt;::value &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp; cout &lt;&lt; is_lvalue_reference&lt;int&amp;&gt;::value &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp; cout &lt;&lt; is_rvalue_reference&lt;int&amp;&amp;&gt;::value &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp; <br>} <br></div><div class="ztitel_kleiner">Wie funktioniert dieser Zauber? <br></div><div class="text">Diese Technik basiert auf Templates und Template-Spezialisierung, ein paar Konventionen und einer Menge Tipparbeit. Ich habe eine vereinfachte Version des Funktions-Templates <span class="tx_code">std::integra</span>l implementiert. <span class="tx_code">std::integra</span>l prüft, ob ein gegebener Typ ein integral Typ ist. Ich ignoriere dabei <span class="tx_code">const</span> oder <span class="tx_code">volatile</span> Qualifier.<br></div><div class="pre">// integral.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>namespace rgr{<br><br>&nbsp; template&lt;class T, T v&gt;<br>&nbsp; struct integral_constant {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static constexpr T value = v;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef T value_type;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef integral_constant type;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr operator value_type() const noexcept { return value; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //since c++14:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr value_type operator()() const noexcept { return value; }<br>&nbsp; };<br><br>&nbsp; typedef integral_constant&lt;bool, true&gt; true_type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; typedef integral_constant&lt;bool, false&gt; false_type;<br><br>&nbsp; template &lt;class T&gt;<br>&nbsp; struct is_integral : public false_type{};<br><br>&nbsp; template &lt;&gt;<br>&nbsp; struct is_integral&lt;bool&gt; : public true_type{};<br><br>&nbsp; template &lt;&gt;<br>&nbsp; struct is_integral&lt;char&gt; : public true_type{};<br><br>&nbsp; template &lt;&gt;<br>&nbsp; struct is_integral&lt;signed char&gt; : public true_type{};<br><br>&nbsp; template &lt;&gt;<br>&nbsp; struct is_integral&lt;unsigned char&gt; : public true_type{};<br><br>&nbsp; template &lt;&gt;<br>&nbsp; struct is_integral&lt;wchar_t&gt; : public true_type{};<br><br>&nbsp; template &lt;&gt;<br>&nbsp; struct is_integral&lt;short&gt; : public true_type{};<br><br>&nbsp; template &lt;&gt;<br>&nbsp; struct is_integral&lt;int&gt; : public true_type{};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>&nbsp; template &lt;&gt;<br>&nbsp; struct is_integral&lt;long&gt; : public true_type{};<br><br>&nbsp; template &lt;&gt;<br>&nbsp; struct is_integral&lt;long long&gt; : public true_type{};<br><br>&nbsp; template &lt;&gt;<br>&nbsp; struct is_integral&lt;unsigned short&gt; : public true_type{};<br><br>&nbsp; template &lt;&gt;<br>&nbsp; struct is_integral&lt;unsigned int&gt; : public true_type{};<br><br>&nbsp; template &lt;&gt;<br>&nbsp; struct is_integral&lt;unsigned long&gt; : public true_type{};<br><br>&nbsp; template &lt;&gt;<br>&nbsp; struct is_integral&lt;unsigned long long&gt; : public true_type{};<br>&nbsp; <br>}<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "std::is_integral&lt;int&gt;::value: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_integral&lt;int&gt;::value &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "rgr::is_integral&lt;int&gt;::value: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; rgr::is_integral&lt;int&gt;::value &lt;&lt; '\n'; // (1)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "std::is_integral&lt;double&gt;::value: "<br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_integral&lt;double&gt;::value &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "rgr::is_integral&lt;double&gt;::value: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; rgr::is_integral&lt;double&gt;::value &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "std::true_type::value: " &lt;&lt; std::true_type::value &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "rgr::true_type::value: " &lt;&lt; rgr::true_type::value &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "std::false_type::value: " &lt;&lt; std::false_type::value &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "rgr::false_type::value: " &lt;&lt; rgr::false_type::value &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "std::integral_constant&lt;bool, true&gt;::value: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::integral_constant&lt;bool, true&gt;::value &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "rgr::integral_constant&lt;bool, true&gt;::value: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; rgr::integral_constant&lt;bool, true&gt;::value &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "std::integral_constant&lt;bool, false&gt;::value: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; std::integral_constant&lt;bool, false&gt;::value &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "rgr::integral_constant&lt;bool, false&gt;::value: " <br>&nbsp;&nbsp;&nbsp; &lt;&lt; rgr::integral_constant&lt;bool, false&gt;::value &lt;&lt; '\n'; &nbsp;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>}<br></div><div class="text">Ich verwende in meiner Implementierung den Namespace <span class="tx_code">rgr </span>und vergleiche die Funktionen mit den entsprechenden Type-Traits-Funktionen im Namespace <span class="tx_code">std</span>. Der Aufruf der Funktionsvorlage <span class="tx_code">rgr::is_integral&lt;int&gt;::value</span> (1) bewirkt den Aufruf des Ausdrucks<span class="tx_code"> rgr::true_type::value</span> (2), weil<span class="tx_code"> integral&lt;int&gt; </span>von <span class="tx_code">true_type</span> (3) abgeleitet ist.<span class="tx_code"> rgr::true_type::value</span> ist ein Alias für <span class="tx_code">rgr::integral_constant&lt;bool, true&gt;::value</span> (2). Im Beispiel verwende ich den statischen constexpr <span class="tx_code">value </span>der Klasse<span class="tx_code"> integral_constant</span>. <span class="tx_code">integral_constant</span> ist die Basisklasse der Type-Traits-Funktionen.<br></div><div class="text">Der Vollständigkeit halber ist hier die Ausgabe des Programms. Meine Implementierung liefert die gleichen Ergebnisse, wie die Funktionen aus der Type-Traits Bibliothek.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/1/8/3/0/8/TN_220967723_e056bc68fc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br> </div><div class="text">Ich habe in meinem Funktions-Template<span class="tx_code"> rgr::is_integral ::value</span> als Rückgabe verwendet. Hier möchte ich an diese Konvention aus meinem vorherigen Beitrag "<a title="Link auf https://heise.de/-6237233" alt="%7B%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6237233%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Template%20Metaprogrammierung%3A%20Wie%20es%20funktioniert%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6237233%22%7D" href="https://heise.de/-6237233">Template Metaprogrammierung: Wie es funktioniert</a>" erinnern: Meine Funktions-Templates<span class="tx_code"> rgr::is_integra</span>l sind Metafunktionen und sie verwenden die Namenskonventionen der Template-Metaprogrammierung. Seit C++17 gibt es für Konventionen eine Hilfsklasse für <span class="tx_code">::value</span>. Diese Hilfsklasse basiert auf Variablen-Templates.<br></div><div class="pre">template&lt; Klasse T &gt;<br>inline constexpr bool is_integral_v = is_integral&lt;T&gt;::value<br> </div><div class="text">Variablen-Templates stellen im Wesentlichen eine Familie von Variablen dar. Dank dieser Hilfsklasse kann man <span class="tx_code">std::integral_v&lt;T&gt;</span> anstelle von<span class="tx_code"> std::integral&lt;T&gt;::value</span> verwenden.&nbsp; Diese verkürzte Schreibweise funktioniert für alle Funktions-Templates der Type-Traits Library.<br></div><div class="text">Zusammengesetzte Typkategorien werden aus den primären Typkategorien zusammengesetzt.<br> </div><div class="ztitel_kleiner">Zusammengesetzte Typkategorien<br> </div><div class="text">Es gibt sieben zusammengesetzte Typkategorien. Die folgende Tabelle zeigt sie.<br> </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/1/8/3/0/8/TN_220967736_d4cab29547.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Zusätzlich zu den primären Typkategorien und den zusammengesetzten Typkategorien bietet die Type-Traits Bibliothek Typeneigenschaften und die Abfrage von Typeneigenschaften an. Der Vollständigkeit halber sind sie hier aufgeführt.<br> </div><div class="ztitel_kleiner">Typ-Eigenschaften<br> </div><div class="pre">template &lt;class T&gt; struct is_const;<br>template &lt;class T&gt; struct is_volatile;<br>template &lt;class T&gt; struct is_trivial;<br>template &lt;class T&gt; struct is_trivially_copyable;<br>template &lt;class T&gt; struct is_standard_layout;<br>template &lt;class T&gt; struct is_empty;<br>template &lt;class T&gt; struct is_polymorphic;<br>template &lt;class T&gt; struct is_abstract;<br>template &lt;class T&gt; struct is_final;<br>template &lt;class T&gt; struct is_aggregate;<br>&nbsp;<br>template &lt;class T&gt; struct is_signed;<br>template &lt;class T&gt; struct is_unsigned;<br>template &lt;class T&gt; struct is_bounded_array;<br>template &lt;class T&gt; struct is_unbounded_array;<br>template &lt;class T&gt; struct is_scoped_enum;<br>&nbsp;<br>template &lt;class T, class... Args&gt; struct is_constructible;<br>template &lt;class T&gt; struct is_default_constructible;<br>template &lt;class T&gt; struct is_copy_constructible;<br>template &lt;class T&gt; struct is_move_constructible;<br>&nbsp;<br>template &lt;class T, class U&gt; struct is_assignable;<br>template &lt;class T&gt; struct is_copy_assignable;<br>template &lt;class T&gt; struct is_move_assignable;<br>&nbsp;<br>template &lt;class T, class U&gt; struct is_swappable_with;<br>template &lt;class T&gt; struct is_swappable;<br>&nbsp;<br>template &lt;class T&gt; struct is_destructible;<br>&nbsp;<br>template &lt;class T, class... Args&gt; struct is_trivially_constructible;<br>template &lt;class T&gt; struct is_trivially_default_constructible;<br>template &lt;class T&gt; struct is_trivially_copy_constructible;<br>template &lt;class T&gt; struct is_trivially_move_constructible;<br>&nbsp;<br>template &lt;class T, class U&gt; struct is_trivially_assignable;<br>template &lt;class T&gt; struct is_trivially_copy_assignable;<br>template &lt;class T&gt; struct is_trivially_move_assignable;<br>template &lt;class T&gt; struct is_trivially_destructible;<br>&nbsp;<br>template &lt;class T, class... Args&gt; struct is_nothrow_constructible;<br>template &lt;class T&gt; struct is_nothrow_default_constructible;<br>template &lt;class T&gt; struct is_nothrow_copy_constructible;<br>template &lt;class T&gt; struct is_nothrow_move_constructible;<br>&nbsp;<br>template &lt;class T, class U&gt; struct is_nothrow_assignable;<br>template &lt;class T&gt; struct is_nothrow_copy_assignable;<br>template &lt;class T&gt; struct is_nothrow_move_assignable;<br>&nbsp;<br>template &lt;class T, class U&gt; struct is_nothrow_swappable_with;<br>template &lt;class T&gt; struct is_nothrow_swappable;<br>&nbsp;<br>template &lt;class T&gt; struct is_nothrow_destructible;<br>&nbsp;<br>template &lt;class T&gt; struct has_virtual_destructor;<br>&nbsp;<br>template &lt;class T&gt; struct has_unique_object_representations; <br></div><div class="text">Viele der Metafunktionen wie<span class="tx_code"> std::is_trivially_copyable</span> haben "trivial" in ihrem Namen. Das bedeutet, dass der Compiler diese Methode bereitstellt. Eine Methode vom Compiler mit dem Schlüsselwort default anzufordern, ist ebenfalls trivial.<br> </div><div class="ztitel_kleiner">Typ-Eigenschaftsabfragen<br> </div><div class="text"><span class="tx_code">template &lt;class T&gt; struct alignment_of;<br>template &lt;class T&gt; struct rank;<br>template &lt;class T, unsigned I = 0&gt; struct extent;</span> <br> </div><div class="ztitel">Wie geht's weiter?<br> </div><div class="text">Auffällig Ist die Funktion<span class="tx_code"> std::is_same</span> in der zusammengesetzten Typkategorie<span class="tx_code"> std::is_fundamental: </span><span class="tx_code">std::is_same</span> ist etwas Besonderes, weil sie Typvergleiche zur Compiletime ermöglicht. Darüber werde ich in meinem nächsten Artikel schreiben.</div>