<div class="vorspann">In meinem letzten Beitrag "<a title="Link auf https://heise.de/-6052426" alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6052426%22%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6052426%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Klassen-Templates%22%7D" href="https://heise.de/-6052426" class="">Klassen-Templates</a>" habe ich deren Grundlagen vorgestellt. Heute halte ich&nbsp; Überraschungen zur Vererbung von Klassen-Templates und der Instanziierung von Memberfunktionen von Klassen-Templates parat.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/1/3/1/8/3/TN_211640310_dff56fd3bc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Hier ist die erste Überraschung. Zumindest war es eine Überraschung für mich.<br> </div>
<div class="ztitel">Vererbte Memberfunktionen von Klassen-Templates sind nicht verfügbar<br></div>
<div class="text">Fangen wir einfach an.<br> </div>
<div class="pre">// inheritance.cpp<br><br>#include &lt;iostream&gt;<br><br>class Base{<br>public:<br>&nbsp;&nbsp;&nbsp; void func(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "func\n";<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>class Derived: public Base{<br>public:<br>&nbsp;&nbsp;&nbsp; void callBase(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; func();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; Derived derived;<br>&nbsp;&nbsp;&nbsp; derived.callBase();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}<br></div>
<div class="text">Ich habe eine Klasse <span class="tx_code">Base</span> und <span class="tx_code">Derived</span> implementiert. <span class="tx_code">Derived</span> ist public abgeleitet von <span class="tx_code">Base</span> und kann daher in seiner Memberfunktion <span class="tx_code">callBase</span> (Zeile 2) die Memberfunktion <span class="tx_code">func</span> aus der Klasse <span class="tx_code">Base</span> verwenden. Ok, der Ausgabe des Programms habe ich nichts hinzuzufügen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/1/3/1/8/3/TN_211640317_a9acd9d7ea.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br> </div>
<div class="text">Wird <span class="tx_code">Base</span> als ein Klassen-Template implementiert, ändert sich das Verhalten komplett.<br> </div>
<div class="pre">// templateInheritance.cpp<br><br>#include &lt;iostream&gt;<br><br>template &lt;typename T&gt;<br>class Base{<br>public:<br>&nbsp;&nbsp;&nbsp; void func(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "func\n";<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>template &lt;typename T&gt;<br>class Derived: public Base&lt;T&gt;{<br>public:<br>&nbsp;&nbsp;&nbsp; void callBase(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; func();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; Derived&lt;int&gt; derived;<br>&nbsp;&nbsp;&nbsp; derived.callBase();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}<br></div>
<div class="text">Der Compilerfehler kommt überraschend.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/1/3/1/8/3/TN_211640320_5c5425374b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Zeile "there are no arguments to 'func' that depend on a template parameter, so a declaration of 'func' must be available" aus der Fehlermeldung gibt den ersten Hinweis. <span class="tx_code">func</span> ist ein sogenannter nichtabhängiger Name, da er nicht vom Template-Parameter<span class="tx_code"> T</span> abhängt. Nichtabhängige Namen werden an der Stelle der Template-Definition aufgelöst und gebunden. Folglich sucht der Compiler nicht in der von <span class="tx_code">T</span> abhängigen Basisklasse <span class="tx_code">Base&lt;T&gt;</span> und es gibt keinen Namen <span class="tx_code">func</span> außerhalb der Klassen-Templates. Nur abhängige Namen werden zum Zeitpunkt der Template-Instanzierung aufgelöst und gebunden.<br> </div>
<div class="text">Dieser Prozess wird <a title="Link auf https://stackoverflow.com/questions/7767626/two-phase-lookup-explanation-needed" alt="%7B%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fstackoverflow.com%2Fquestions%2F7767626%2Ftwo-phase-lookup-explanation-needed%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fstackoverflow.com%2Fquestions%2F7767626%2Ftwo-phase-lookup-explanation-needed%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Two%20Phase%20Lookup%22%7D" href="https://stackoverflow.com/questions/7767626/two-phase-lookup-explanation-needed" class="">Two Phase Lookup</a> genannt. Die erste Phase ist insbesondere für das Auflösen von nichtabhängigen Namen zuständig, die zweite Phase ist für das Auflösen von abhängigen Namen.<br> </div>
<div class="text">Es gibt drei Workarounds, um das Namens-Lookup auf die abhängige Basisklasse zu lösen. Das folgende Beispiel verwendet alle drei.<br></div>
<div class="pre">// templateInheritance2.cpp<br><br>#include &lt;iostream&gt;<br><br>template &lt;typename T&gt;<br>class Base{<br>public:<br>&nbsp; void func1() const {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "func1()\n";<br>&nbsp; }<br>&nbsp; void func2() const {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "func2()\n";<br>&nbsp; }<br>&nbsp; void func3() const {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "func3()\n";<br>&nbsp; }<br>};<br><br>template &lt;typename T&gt;<br>class Derived: public Base&lt;T&gt;{<br>public:<br>&nbsp; using Base&lt;T&gt;::func2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; void callAllBaseFunctions(){<br><br>&nbsp;&nbsp;&nbsp; this-&gt;func1();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; func2();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; Base&lt;T&gt;::func3();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>&nbsp; }<br>};<br><br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp; Derived&lt;int&gt; derived;<br>&nbsp; derived.callAllBaseFunctions();<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>}<br></div>
<div class="text"><ol><li>Mache den Namen abhängig: Der Aufruf<span class="tx_code"> this-&gt;func</span>1 in Zeile 1 ist abhängig, weil dieser implizit abhängig ist. Die Namenssuche wird in diesem Fall alle Basisklassen berücksichtigen.</li><li>Führe den Namen in den aktuellen Scope ein: Der Ausdruck <span class="tx_code">using Base&lt;T&gt;::func2</span> (Zeile 2) führt <span class="tx_code">func2</span> in den aktuellen Scope ein.</li><li>Rufe den Namen voll qualifiziert auf: Der Aufruf von<span class="tx_code"> func3</span> ist voll qualifiziert (Zeile 3). Dieser bricht allerdings einen virtuellen Dispatch und kann zu neuen Überraschungen führen.<br></li></ol></div>
<div class="text">Welche dieser Option empfiehlt sich? Im Allgemeinen bevorzuge ich die erste Option, durch die <span class="tx_code">func1</span> abhängig wird:<span class="tx_code"> this-&gt;func1</span>. Diese Lösung funktioniert auch, wenn man die Basisklasse umbenennt. <br></div>
<div class="text">Zum Abschluss hier noch die Ausgabe des Programms:<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/1/3/1/8/3/TN_211640330_415a8b6e6a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br> </div>
<div class="ztitel">Die Instanziierung von Memberfunktionen ist lazy<br> </div>
<div class="text">Lazy bedeutet, dass die Instanziierung einer Memberfunktion eines Klassen-Templates nur bei Bedarf erfolgt. Beleg? Hier ist er:</div>
<div class="pre">// lazy.cpp<br><br>#include &lt;iostream&gt;<br><br>template&lt;class T&gt; <br>struct Lazy{<br>&nbsp;&nbsp;&nbsp; void func() { std::cout &lt;&lt; "func\n"; }<br>&nbsp;&nbsp;&nbsp; void func2(); // not defined (1)<br>};<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; Lazy&lt;int&gt; lazy;<br>&nbsp; lazy.func();<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>}<br></div>
<div class="text">Obwohl die Methode <span class="tx_code">func2()</span> (1) der Klasse <span class="tx_code">Lazy</span> nur deklariert, aber nicht definiert ist, akzeptiert der Compiler das Programm. Eine Definition der Memberfunktion ist in diesem Fall nicht notwendig.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/1/3/1/8/3/TN_211640335_03db81e824.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Bedarfsauswertung des Instanziierungsprozesses von Memberfunktionen hat zwei interessante Eigenschaften.</div>
<div class="ztitel_kleiner">Ressourcen sparen<br></div>
<div class="text">Wenn man beispielsweise eine Klassenvorlage wie <span class="tx_code">Array2</span> für verschiedene Typen instanziiert, werden nur die verwendeten Memberfunktionen instanziiert. Diese Bedarfsauswertung gilt nicht für eine Nicht-Template-Klasse <span class="tx_code">Array1</span>. <br> </div>
<div class="pre">// lazyInstantiation.cpp<br><br>#include &lt;cstddef&gt; <br><br>class Array1 { <br>&nbsp;public: <br>&nbsp;&nbsp;&nbsp; int getSize() const { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 10; <br>&nbsp;} <br>&nbsp;private: <br>&nbsp;&nbsp;&nbsp; int elem[10]; <br>};<br><br>template &lt;typename T, std::size_t N&gt; <br>class Array2 { <br>&nbsp;public: <br>&nbsp;&nbsp;&nbsp; std::size_t getSize() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return N;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; private: <br>&nbsp;&nbsp;&nbsp;&nbsp; T elem[N]; <br>}; <br><br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; Array1 arr;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; Array2&lt;int, 5&gt; myArr1;<br>&nbsp;&nbsp;&nbsp; Array2&lt;double, 5&gt; myArr2;&nbsp;&nbsp; // (1) <br>&nbsp;&nbsp;&nbsp; myArr2.getSize();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) <br><br>}<br></div>
<div class="text">Die Memberfunktion<span class="tx_code"> getSize()</span> der Klassen-Templates <span class="tx_code">Array2</span> wird nur für <span class="tx_code">myArr2</span> (1) instanziiert. Diese Instanziierung wird durch den Aufruf <span class="tx_code">myArr2.getSize()</span> (2) ausgelöst<br> </div>
<div class="text"><a title="Link auf https://cppinsights.io/s/451db374" alt="%7B%22text%22%3A%22C%2B%2B%20Insights%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F451db374%22%2C%22version%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F451db374%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://cppinsights.io/s/451db374" class="">C++ Insights</a> zeigt die Hintergründe. Die entscheidenden Zeilen im folgenden Screenshot sind die Zeilen 40 und 59.<br> </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/1/3/1/8/3/TN_211640340_dea07f6327.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br> </div>
<div class="ztitel_kleiner">Teilweise Verwendung von Klassen-Templates<br> </div>
<div class="text">Klassen-Templates lassen sich mit Template-Argumenten instanziieren, die nicht alle Memberfunktionen unterstützen. Werden die Memberfunktionen nicht verwendet, ist alles in Ordnung.<br> </div>
<div class="pre">// classTemplatePartial.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>template &lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) <br>class Matrix {<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; explicit Matrix(std::initializer_list&lt;T&gt; inList): data(inList) {}<br>&nbsp;&nbsp;&nbsp; void printAll() const {&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; d: data) std::cout &lt;&lt; d &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp;&nbsp;&nbsp; std::vector&lt;T&gt; data;<br>};<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; const Matrix&lt;int&gt; myMatrix1({1, 2, 3, 4, 5});<br>&nbsp;&nbsp;&nbsp; myMatrix1.printAll();&nbsp;&nbsp; // (3) <br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp;&nbsp;&nbsp; const Matrix&lt;int&gt; myMatrix2({10, 11, 12, 13});<br>&nbsp;&nbsp;&nbsp; myMatrix2.printAll();&nbsp; // (4) <br><br>&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; const Matrix&lt;Matrix&lt;int&gt;&gt; myMatrix3({myMatrix1, myMatrix2});<br>&nbsp;&nbsp;&nbsp; // myMatrix3.printAll(); ERROR (5)<br><br>}<br></div>
<div class="text">Das Klassen-Template <span class="tx_code">Matrix</span> (1) ist absichtlich einfach gehalten. <span class="tx_code">Matrix</span> besitzt einen Typ-Parameter <span class="tx_code">T</span>, hält seine Daten in einem<span class="tx_code"> std::vector</span> und kann durch eine <span class="tx_code">std::initalizer_lis</span>t initialisiert werden. Dank der Memberfunktion<span class="tx_code"> printAll()</span> kann die Klasse seine Element ausgeben. (3) und (4) zeigen <span class="tx_code">Matrix</span> im Einsatz. Der Ausgabeoperator ist für <span class="tx_code">Matrix</span> nicht überladen. Folglich kann ich <span class="tx_code">myMatrix3</span> erstellen, das andere Matrix-Objekte als Mitglieder hat, aber ich kann sie nicht ausgeben.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/1/3/1/8/3/TN_211640348_bf2a178d1d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das Aktivieren von Zeile 5 verursacht eine ziemlich ausführliche Fehlermeldung von 274 Zeilen mit dem GCC.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/1/3/1/8/3/TN_211640354_7907666241.png" title="<ir_inline itemname=bilder_mvp_bild_var2:8 type=2>" style="max-height: 25px; max-width: 25px;"><br> </div>
<div class="ztitel">Wie geht's weiter? <br></div>
<div class="text">In meinem nächsten Artikel stelle ich Alias-Templates vor und gehe auf Template-Parameter genauer ein.<br> </div>
<div class="ztitel">Schlechtes Marketing<br> </div>
<div class="text">Ich habe ein schlechtes Marketing betrieben. Einige Leser haben mich in den letzten Tagen gefragt, ob mein auf LeanPub erschienenes <a title="Link auf https://leanpub.com/c20" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fleanpub.com%2Fc20%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fleanpub.com%2Fc20%22%2C%22text%22%3A%22C%2B%2B20%20Buch%22%2C%22type%22%3A%22E%22%7D" href="https://leanpub.com/c20" class="">C++20 Buch</a> auch in physischer Form erhältlich sei. Klar, <a title="Link auf https://www.amazon.de/dp/B09328NKXK" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.amazon.de%2Fdp%2FB09328NKXK%22%2C%22text%22%3A%22seit%20einem%20Monat%22%2C%22type%22%3A%22E%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.amazon.de%2Fdp%2FB09328NKXK%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%7D" href="https://www.amazon.de/dp/B09328NKXK" class="">seit einem Monat</a>.</div>