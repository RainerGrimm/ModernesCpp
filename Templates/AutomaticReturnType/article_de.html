<div class="vorspann">Je nach verwendetem C++-Standard gibt es verschiedene Möglichkeiten, den richtigen Rückgabetyp eines Funktions-Templates zu ermitteln.</div>
<div class="text"> In diesem Artikel beginne ich mit Traits (C++98), fahre in meinem nächsten Artikel mit C++11/14 fort und schließe mit Concepts (C++20) ab.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/8/5/5/0/6/TN_218225114_b32fe36990.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Dies ist meine Herausforderung für den heutigen Artikel.</div>
<div class="pre">template &lt;typename T, typename T2&gt;<br>??? sum(T t, T2 t2) {<br>&nbsp;&nbsp;&nbsp; return t + t2;<br>}</div>
<div class="text">Wer ein Funktions-Template wie <span class="tx_code">sum</span> mit mindestens zwei Parametertypen definiert, kannt im Allgemeinen den Rückgabetyp nicht bestimmen. Natürlich sollte <span class="tx_code">sum</span> den Typ zurückgeben, den die arithmetische Operation<span class="tx_code"> t + t2</span> liefert. Hier sind ein paar Beispiele für die Verwendung von <a title="Link auf https://en.wikipedia.org/wiki/Run-time_type_information" alt="%7B%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FRun-time_type_information%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FRun-time_type_information%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Laufzeittypinformationen%20%28RTTI%29%22%2C%22version%22%3A1%7D" href="https://en.wikipedia.org/wiki/Run-time_type_information" class="">Laufzeittypinformationen (RTTI)</a> mit <span class="tx_code">std::type_info</span>.</div>
<div class="pre">// typeinfo.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;typeinfo&gt;<br>&nbsp;<br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(5.5 + 5.5).name(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(5.5 + 5.5).name() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(5.5 + true).name(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(5.5 + true).name() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(true + 5.5).name(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(true + 5.5).name() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(true + false).name(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(true + false).name() &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>}<br></div>
<div class="text">Ich habe das Programm auf Windows mit MSVC ausgeführt, weil MSVC im Gegensatz zu GCC oder Clang menschenlesbare Namen für die Datentypen erzeugt.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/8/5/5/0/6/TN_218225123_959f4dd2a8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Addition von zwei <span class="tx_code">double</span>s ergibt einen<span class="tx_code"> double</span>, die Addition von <span class="tx_code">double</span> und <span class="tx_code">bool</span> ergibt einen <span class="tx_code">bool</span> und die Addition von zwei<span class="tx_code"> bool</span>s ergibt einen <span class="tx_code">int</span>.</div>
<div class="text">Ich verwende in meinen Beispielen nur <a title="Link auf https://en.cppreference.com/w/c/language/arithmetic_types" alt="%7B%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fc%2Flanguage%2Farithmetic_types%22%2C%22text%22%3A%22arithmetische%20Typen%22%2C%22version%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fc%2Flanguage%2Farithmetic_types%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%7D" href="https://en.cppreference.com/w/c/language/arithmetic_types" class="">arithmetische Typen</a>. Wer benutzerdefinierte Typen anwenden willt, die arithmetische Operationen unterstützen, muss diese Umsetzung erweitern.</div>
<div class="text">Jetzt beginnt meine Reise mit C++98.</div>
<div class="ztitel">C++98</div>
<div class="text">Ehrlich gesagt bietet C++98 keinen allgemeine Ansatz für die Rückgabe des richtigen Typs an. Im Wesentlichen muss man die Regeln zur Typableitung mit einer Technik namens <a title="Link auf https://accu.org/journals/overload/9/43/frogley_442/" alt="%7B%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Faccu.org%2Fjournals%2Foverload%2F9%2F43%2Ffrogley_442%2F%22%2C%22text%22%3A%22Traits%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Faccu.org%2Fjournals%2Foverload%2F9%2F43%2Ffrogley_442%2F%22%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" href="https://accu.org/journals/overload/9/43/frogley_442/" class="">Traits</a>, auch bekannt als Template Traits, implementieren. Eine Traits-Klasse liefert nützliche Informationen über Template-Parameter und kann anstelle der Template-Parameter verwendet werden.</div>
<div class="text">Die folgende Klasse <span class="tx_code">ResultType</span> bietet eine Typ-zu-Typ-Zuordnung unter Verwendung der vollständigen Template-Spezialisierung an.</div>
<div class="pre">// traits.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;typeinfo&gt;<br><br>template &lt;typename T, typename T2&gt; // primary template (1)<br>struct ReturnType;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>template &lt;&gt;&nbsp; // full specialization for double, double<br>struct ReturnType &lt;double, double&gt; {<br>&nbsp;&nbsp;&nbsp; typedef double Type;<br>};<br><br>template &lt;&gt; //&nbsp; full specialization for double, bool<br>struct ReturnType &lt;double, bool&gt; {<br>&nbsp;&nbsp;&nbsp; typedef double Type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>};<br><br>template &lt;&gt; // full specialization for bool, double<br>struct ReturnType &lt;bool, double&gt; {<br>&nbsp;&nbsp;&nbsp; typedef double Type;<br>};<br><br>template &lt;&gt; // full specialization for bool, bool<br>struct ReturnType &lt;bool, bool&gt; {<br>&nbsp;&nbsp;&nbsp; typedef int Type;<br>};<br><br>template &lt;typename T, typename T2&gt; &nbsp;<br>typename ReturnType&lt;T, T2&gt;::Type sum(T t, T2 t2) {&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; return t + t2;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(sum(5.5, 5.5)).name(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(sum(5.5, 5.5)).name() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(sum(5.5, true)).name(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(sum(5.5, true)).name() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(sum(true, 5.5)).name(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(sum(true, 5.5)).name() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(sum(true, false)).name(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(sum(true, false)).name() &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div>
<div class="text">(1) ist das primäre Template oder allgemeine Template. Das primäre Template muss vor den folgenden vollständigen Spezialisierungen deklariert werden. Wenn das primäre Template nicht benötigt wird, ist eine Deklaration wie in Zeile 1 ausreichend. Die folgenden Zeilen enthalten die vollständigen Spezialisierungen für <span class="tx_code">&lt;double, double&gt;</span>, für <span class="tx_code">&lt;double, bool&gt;</span>, für <span class="tx_code">&lt;bool, double&gt;</span> und für <span class="tx_code">&lt;bool, bool&gt;</span>. Mehr Details über die Template-Spezialisierung finden sich in meinen vorherigen Artikel:</div>
<div class="text"><ul><li> <a title="Link auf https://heise.de/-6118187" alt="%7B%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6118187%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6118187%22%2C%22alias%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22Einf%C3%BChrung%20in%20die%20Template-Spezialisierung%22%7D" href="https://heise.de/-6118187" class="">Einführung in die Template-Spezialisierung</a> </li><li> <a title="Link auf https://heise.de/-6121736" alt="%7B%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6121736%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6121736%22%2C%22version%22%3A1%2C%22text%22%3A%22Template-Spezialisierung%3A%20Mehr%20Details%20%C3%BCber%20Klassen-Templates%22%7D" href="https://heise.de/-6121736" class="">Template-Spezialisierung: Mehr Details über Klassen-Templates</a> </li><li> <a title="Link auf https://heise.de/-6124700" alt="%7B%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6124700%22%2C%22version%22%3A1%2C%22text%22%3A%22Vollst%C3%A4ndige%20Spezialisierung%20von%20Funktions-Templates%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6124700%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%7D" href="https://heise.de/-6124700" class="">Vollständige Spezialisierung von Funktions-Templates</a> </li></ul></div>
<div class="text">Die entscheidende Beobachtung bei den verschiedenen vollständigen Spezialisierungen von <span class="tx_code">ReturnType</span> ist, dass sie alle einen Alias <span class="tx_code">Type</span> besitzen, wie z. B. <span class="tx_code">typedef double Type</span> (2). Dieser Alias ist der Rückgabetyp des Funktions-Templates <span class="tx_code">sum</span> (3): <span class="tx_code">typename ReturnType&lt;T, T2&gt;::Type</span>.</div>
<div class="text">Die Traits verhalten sich wie erwartet.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/8/5/5/0/6/TN_218225129_33a71222ad.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das wirft die Frage auf, warum ich <span class="tx_code">typename</span> im Rückgabetyp-Ausdruck der Funktions-Templates <span class="tx_code">sum</span> anwende. Ein Leser meines letzten Artikels über abhängige Namen hat mich gefragt, wann er <span class="tx_code">typename</span> oder<span class="tx_code"> .template </span>in Templates verwenden soll. Die kurze Antwort ist, dass der Compiler nicht entscheiden kann, ob der Ausdruck<span class="tx_code"> ReturnType&lt;T, T2&gt;::Type</span> ein Typ (wie in diesem Fall), ein Nichttyp oder ein Template ist. Der Ausdruck <span class="tx_code">typename</span> vor <span class="tx_code">ReturnType&lt;T, T2&gt;::Type</span> gibt dem Compiler den entscheidenden Hinweis. Die lange Antwort kannst gibt mein vorheriger Artikel<a title="Link auf https://heise.de/-6212495" alt="%7B%22text%22%3A%22%20Abh%C3%A4ngige%20Namen%22%2C%22version%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6212495%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6212495%22%2C%22ir_link%22%3A1%7D" href="https://heise.de/-6212495" class=""> Abhängige Namen</a>.</div>
<div class="ztitel_kleiner">Fehlende Überladung</div>
<div class="text">Ursprünglich wollte ich meinen Artikel mit C++11 fortsetzen. Ich nehme aber an, es gibt noch eine weitere Frage: Was passiert, wenn ich die Funktions-Templates sum mit Argumenten aufrufe, für die keine partielle Template-Spezialisierung definiert ist? Lass es mich mit <span class="tx_code">sum(5.5f, 5)</span> ausprobieren.</div>
<div class="pre">// traitsError.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;typeinfo&gt;<br><br>template &lt;typename T, typename T2&gt; // primary template<br>struct ReturnType;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>template &lt;&gt;&nbsp; // full specialization for double, double<br>struct ReturnType &lt;double, double&gt; {<br>&nbsp;&nbsp;&nbsp; typedef double Type;<br>};<br><br>template &lt;&gt; //&nbsp; full specialization for double, bool<br>struct ReturnType &lt;double, bool&gt; {<br>&nbsp;&nbsp;&nbsp; typedef double Type;<br>};<br><br>template &lt;&gt; // full specialization for bool, double<br>struct ReturnType &lt;bool, double&gt; {<br>&nbsp;&nbsp;&nbsp; typedef double Type;<br>};<br><br>template &lt;&gt; // full specialization for bool, bool<br>struct ReturnType &lt;bool, bool&gt; {<br>&nbsp;&nbsp;&nbsp; typedef int Type;<br>};<br><br>template &lt;typename T, typename T2&gt; &nbsp;<br>typename ReturnType&lt;T, T2&gt;::Type sum(T t, T2 t2) {<br>&nbsp;&nbsp;&nbsp; return t + t2;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(sum(5.5f, 5.5)).name(): "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(sum(5.5f, 5.5)).name() &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div>
<div class="text">Viele C++ Programmierer erwarten, dass der <span class="tx_code">float</span>-Wert<span class="tx_code"> 5.5f i</span>n einen<span class="tx_code"> double</span>-Wert konvertiert und die volle Spezialisierung für<span class="tx_code"> &lt;double, double&gt;</span> verwendet wird? </div>
<div class="text">&nbsp;<img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/8/5/5/0/6/TN_218225135_615ef22b5b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">NEIN! Die Typen müssen genau übereinstimmen. Der MSVC-Compiler gibt eine genaue Fehlermeldung aus. Es ist keine Überladung <span class="tx_code">sum</span> für <span class="tx_code">T = float</span> und <span class="tx_code">T2 = double</span> verfügbar. Das primäre Template ist nicht definiert und kann daher nicht instanziiert werden.</div>
<div class="text"><b>Typen werden nicht konvertiert, nur Ausdrücke wie Werte können konvertiert werden: <span class="tx_code">double res = 5.5f + 5.5;</span></b></div>
<div class="ztitel_kleiner">Default-Rückgabetyp<br> </div>
<div class="text">Wenn man die Deklaration des primären Templates als Grundlage für eine Definition verwendet, wird das primäre Template zum Default-Fall. Folglich verwendet die folgende Implementierung von<span class="tx_code"> ReturnType long double</span> als Default-Rückgabetyp.</div>
<div class="pre">// traitsDefault.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;typeinfo&gt;<br><br>template &lt;typename T, typename T2&gt; // primary template<br>struct ReturnType {<br>&nbsp;&nbsp;&nbsp; typedef long double Type;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>};<br><br>template &lt;&gt;&nbsp; // full specialization for double, double<br>struct ReturnType &lt;double, double&gt; {<br>&nbsp;&nbsp;&nbsp; typedef double Type;<br>};<br><br>template &lt;&gt; //&nbsp; full specialization for double, bool<br>struct ReturnType &lt;double, bool&gt; {<br>&nbsp;&nbsp;&nbsp; typedef double Type;<br>};<br><br>template &lt;&gt; // full specialization for bool, double<br>struct ReturnType &lt;bool, double&gt; {<br>&nbsp;&nbsp;&nbsp; typedef double Type;<br>};<br><br>template &lt;&gt; // full specialization for bool, bool<br>struct ReturnType &lt;bool, bool&gt; {<br>&nbsp;&nbsp;&nbsp; typedef int Type;<br>};<br><br>template &lt;typename T, typename T2&gt; &nbsp;<br>typename ReturnType&lt;T, T2&gt;::Type sum(T t, T2 t2) {<br>&nbsp;&nbsp;&nbsp; return t + t2;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(sum(5.5, 5.5)).name(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(sum(5.5, 5.5)).name() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(sum(5.5, true)).name(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(sum(5.5, true)).name() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(sum(true, 5.5)).name(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(sum(true, 5.5)).name() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(sum(true, false)).name(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(sum(true, false)).name() &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "typeid(sum(5.5f, 5.5)).name(): " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; typeid(sum(5.5f, 5.5)).name() &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div>
<div class="text">Der Aufruf von<span class="tx_code"> sum(5.5f, 5.f</span>) bewirkt die Instanziierung der primären Template.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/8/5/5/0/6/TN_218225139_6dfd602841.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">In C++11 gibt es verschiedene Möglichkeiten, den Rückgabetyp automatisch abzuleiten. C++14 fügt diesen Techniken syntaktischen Zucker hinzu und C++20 ermöglicht es, sie sehr explizit zu schreiben. Diese Verbesserungen behandelt mein nächster Artikel.</div>