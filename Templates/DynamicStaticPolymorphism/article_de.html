<div class="vorspann">Polymorphie ist die Eigenschaft, dass verschiedene Datentypen das gleiche Interface unterstützen. In C++ unterscheiden wir zwischen dynamischer Polymorphie und statischer Polymorphie.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/3/7/8/0/1/TN_228790194_6f2983397c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Nachdem wir nun die Grundlagen, Details und Techniken rund um Templates kennengelernt haben, möchte ich nun über das Design mit Templates schreiben. Es gibt viele Arten von <a title="Link auf https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" alt="%7B%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPolymorphism_%28computer_science%29%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Polymorphie%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPolymorphism_%28computer_science%29%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%7D" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">Polymorphie</a>. Auf einen Aspekt möchte ich mich besonders konzentrieren: Findet der polymorphe Dispatch zur Laufzeit oder zur Compilezeit statt? Die Laufzeit-Polymorphie basiert auf der Objektorientierung und den virtuellen Funktionen in C++, die Compilezeit-Polymorphie basiert auf Templates.</div><div class="text">Beide Polymorphismen haben Vor- und Nachteile, die ich im folgenden Artikel darstelle.<br></div><div class="ztitel">Dynamische Polymorphie<br></div><div class="text">Hier sind die wichtigsten Fakten: Dynamische Polymorphie findet zur Laufzeit statt, sie basiert auf der Objektorientierung und ermöglicht es uns, zwischen der Schnittstelle und der Implementierung einer Klassenhierarchie zu trennen. Um Late Binding, Dynamic Dispatch oder Dispatch zur Laufzeit zu erhalten, benötigt man zwei Zutaten: Virtualität und eine Indirektion wie einen Zeiger oder eine Referenz.<br></div><div class="pre">// dispatchDynamicPolymorphism.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br><br>auto start = std::chrono::steady_clock::now();<br><br>void writeElapsedTime(){<br>&nbsp;&nbsp;&nbsp; auto now = std::chrono::steady_clock::now();<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; diff = now - start;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; diff.count() &lt;&lt; " sec. elapsed: ";<br>}<br><br>struct MessageSeverity{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;virtual void writeMessage() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::cerr &lt;&lt; "unexpected" &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;}<br>};<br><br>struct MessageInformation: MessageSeverity{&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;void writeMessage() const override {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::cerr &lt;&lt; "information" &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;}<br>};<br><br>struct MessageWarning: MessageSeverity{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;void writeMessage() const override {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::cerr &lt;&lt; "warning" &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;}<br>};<br><br>struct MessageFatal: MessageSeverity{};<br><br>void writeMessageReference(const MessageSeverity&amp; messServer){&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;writeElapsedTime();<br>&nbsp;&nbsp; &nbsp;messServer.writeMessage();<br>&nbsp;&nbsp; &nbsp;<br>}<br><br>void writeMessagePointer(const MessageSeverity* messServer){&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;writeElapsedTime();<br>&nbsp;&nbsp; &nbsp;messServer-&gt;writeMessage();<br>&nbsp;&nbsp; &nbsp;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageInformation messInfo;<br>&nbsp;&nbsp;&nbsp; MessageWarning messWarn;<br>&nbsp;&nbsp;&nbsp; MessageFatal messFatal;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageSeverity&amp; messRef1 = messInfo;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; MessageSeverity&amp; messRef2 = messWarn;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; MessageSeverity&amp; messRef3 = messFatal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; writeMessageReference(messRef1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; writeMessageReference(messRef2);<br>&nbsp;&nbsp;&nbsp; writeMessageReference(messRef3);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; '\n';<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageSeverity* messPoin1 = new MessageInformation;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp; MessageSeverity* messPoin2 = new MessageWarning;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp;&nbsp;&nbsp; MessageSeverity* messPoin3 = new MessageFatal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (8)<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; writeMessagePointer(messPoin1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; writeMessagePointer(messPoin2);<br>&nbsp;&nbsp;&nbsp; writeMessagePointer(messPoin3);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}<br></div><div class="text">Die Funktionen <span class="tx_code">writeMessageReference</span> (1) oder <span class="tx_code">writeMessagePointer</span> (2) benötigen eine Referenz oder einen Zeiger auf ein Objekt vom Typ <span class="tx_code">MessageSeverity</span>. Von <span class="tx_code">MessageSeverity</span> öffentlich abgeleitete Klassen wie <span class="tx_code">MessageInformation</span>, <span class="tx_code">MessageWarning</span> oder <span class="tx_code">MessageFatal</span> unterstützen das sogenannte <a title="Link auf https://de.wikipedia.org/wiki/Liskovsches_Substitutionsprinzip" alt="%7B%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FLiskovsches_Substitutionsprinzip%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Liskovsches%20Substitutionsprinzip%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FLiskovsches_Substitutionsprinzip%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%7D" href="https://de.wikipedia.org/wiki/Liskovsches_Substitutionsprinzip">Liskovsches Substitutionsprinzip</a>. Das bedeutet, dass eine <span class="tx_code">MessageInformation</span>, <span class="tx_code">MessageWarning</span> oder eine <span class="tx_code">MessageFatal</span> auch eine <span class="tx_code">MessageSeverity</span> ist.<br></div><div class="text">Hier ist die Ausgabe des Programms:<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/3/7/8/0/1/TN_228790198_989344b4d3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Das wirft die Frage auf, warum die Memberfunktion <span class="tx_code">writeMessage</span> der abgeleiteten Klasse und nicht der Basisklasse aufgerufen wird. Hier kommt die späte Bindung ins Spiel. Die folgende Erklärung gilt für die (3) bis (8). Der Einfachheit halber schreibe ich nur über (6): <span class="tx_code">MessageSeverity* messPoin1 = new MessageInformation. messPoint1</span> hat im Wesentlichen zwei Typen. Einen statischen Typ <span class="tx_code">MessageSeverity</span> und einen dynamischen Typ <span class="tx_code">MessageInformation</span>. Der statische Typ <span class="tx_code">MessageSeverity</span> steht für sein Interface und der dynamische Typ <span class="tx_code">MessageInformation</span> für seine Implementierung. Der statische Typ wird zur Compilezeit verwendet und der dynamische zur Laufzeit. Zur Laufzeit ist <span class="tx_code">messPoint1</span> vom Typ <span class="tx_code">MessageInformation</span>; daher wird die virtuelle Funktion <span class="tx_code">writeMessage</span> von <span class="tx_code">MessageInformation</span> aufgerufen. Hier gilt natürlich, dass der dynamische Dispatch eine Indirektion wie einen Zeiger oder eine Referenz und Virtualität erfordert.<br></div><div class="text">Ich betrachte diese Art von Polymorphismus als <b>vertragsorientiertes Design</b>. Eine Funktion wie <span class="tx_code">writeMessagePointer</span> erfordert, dass für ein Objekt gelten muss, dass es öffentlich von <span class="tx_code">MessageSeverity</span> abgeleitet ist. Wenn dieser Vertrag nicht erfüllt ist, beschwert sich der Compiler.<br></div><div class="text">Im Gegensatz zum vertragsgesteuerten Design gibt es auch ein <b>verhaltensgesteuertes Design</b> mit statischem Polymorphismus.<br></div><div class="ztitel">Statische Polymorphismie<br></div><div class="text">Für das Thema schlage ich einen kurzen Umweg ein.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/3/7/8/0/1/TN_228790207_ca35020dda.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=1>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Python interessiert sich für das Verhalten und nicht für formale Interfaces. Diese Idee ist als Duck-Typing bekannt. Um es kurz zu machen, der Ausdruck geht auf das Gedicht von James Whitcomb Rileys zurück: Hier ist es:<br></div><div class="einrueckung"><i>“When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.”</i><br></div><div class="text">Was soll das bedeuten? Gegeben sei eine Funktion <span class="tx_code">acceptOnlyDucks</span>, die nur Enten als Argument akzeptiert. In statisch typisierten Sprachen wie C++ können alle Typen, die von Duck abgeleitet sind, verwendet werden, um die Funktion aufzurufen. In Python können alle Typen, die sich wie eine Ente verhalten, zum Aufrufen der Funktion verwendet werden. Um es noch konkreter zu machen. Wenn sich ein Vogel wie Ente verhält, ist er eine Ente. In Python wird oft ein Sprichwort verwendet, das dieses Verhalten ganz gut beschreibt.<br></div><div class="einrueckung"><i>"Don't ask for permission, ask for forgiveness."</i><br></div><div class="text">Im Fall unserer Ente bedeutet das, dass man die Funktion <span class="tx_code">acceptsOnlyDucks</span> mit einem Vogel aufruft und auf das Beste hofft. Wenn etwas Schlimmes passiert, fängt man die Ausnahme mit einer Ausnahmebehandlung. Oft funktioniert diese Strategie in Python sehr gut und sehr schnell.<br></div><div class="text">Soweit mein kleiner Ausflug, und dank der Templates haben wir in C++ auch Duck-Typing.<br></div><div class="text">Das bedeutet, dass sich das vorherige Programm <span class="tx_code">disptachStaticPolymorphism.cpp</span> mit Duck Typing refaktorisieren lässt.<br></div><div class="pre">// duckTyping.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br><br>auto start = std::chrono::steady_clock::now();<br><br>void writeElapsedTime(){<br>&nbsp;&nbsp;&nbsp; auto now = std::chrono::steady_clock::now();<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; diff = now - start;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; diff.count() &lt;&lt; " sec. elapsed: ";<br>}<br><br>struct MessageSeverity{<br>&nbsp; void writeMessage() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "unexpected" &lt;&lt; '\n';<br>&nbsp; }<br>};<br><br>struct MessageInformation {<br>&nbsp; void writeMessage() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "information" &lt;&lt; '\n';<br>&nbsp; }<br>};<br><br>struct MessageWarning {<br>&nbsp; void writeMessage() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "warning" &lt;&lt; '\n';<br>&nbsp; }<br>};<br><br>struct MessageFatal: MessageSeverity{};&nbsp;&nbsp;&nbsp; &nbsp;<br><br>template &lt;typename T&gt;<br>void writeMessage(T&amp; messServer){&nbsp;&nbsp;&nbsp; // (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;writeElapsedTime();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;messServer.writeMessage();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageInformation messInfo;<br>&nbsp;&nbsp;&nbsp; writeMessage(messInfo);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; MessageWarning messWarn;<br>&nbsp;&nbsp;&nbsp; writeMessage(messWarn);<br><br>&nbsp;&nbsp;&nbsp; MessageFatal messFatal;<br>&nbsp;&nbsp;&nbsp; writeMessage(messFatal);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}<br></div><div class="text">Das Funktions-Template <span class="tx_code">writeMessage</span> (1) wendet Duck-Typing an. <span class="tx_code">writeMessage</span> geht davon aus, dass alle Objekte <span class="tx_code">messServer</span> die Mitgliedsfunktion <span class="tx_code">writeMessage</span> unterstützen. Wenn nicht, würde die Kompilierung fehlschlagen. Der Hauptunterschied zu Python besteht darin, dass der Fehler in C++ zur Compilezeit auftritt, in Python aber zur Laufzeit. Hier ist die Ausgabe des Programms.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/3/7/8/0/1/TN_228790211_3c779fb663.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Die Funktion <span class="tx_code">writeMessage</span> verhält sich polymorph, ist aber weder typsicher noch schreibt sie im Falle eines Fehlers eine lesbare Fehlermeldung. Zumindest das letzte Problem kann ich mit Concepts in C++20 elegant beheben. In meinen früheren Beiträgen zu Concepts lassen sich die Details schön nachlesen: <a title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/concepts" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fconcepts%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22mediasync_id%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fconcepts%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Concepts%20Artikel%22%7D" href="https://www.grimm-jaud.de/index.php/blog/tag/concepts">Concepts Artikel</a>. Im folgenden Beispiel definiere und verwende ich das Concept <span class="tx_code">MessageServer</span> (1).</div><div class="pre">// duckTypingWithConcept.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br><br>template &lt;typename T&gt;&nbsp;&nbsp; // (1)<br>concept MessageServer = requires(T t) {<br>&nbsp;&nbsp;&nbsp; t.writeMessage();<br>};<br><br>auto start = std::chrono::steady_clock::now();<br><br>void writeElapsedTime(){<br>&nbsp;&nbsp;&nbsp; auto now = std::chrono::steady_clock::now();<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; diff = now - start;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; diff.count() &lt;&lt; " sec. elapsed: ";<br>}<br><br>struct MessageSeverity{<br>&nbsp; void writeMessage() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "unexpected" &lt;&lt; '\n';<br>&nbsp; }<br>};<br><br>struct MessageInformation {<br>&nbsp; void writeMessage() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "information" &lt;&lt; '\n';<br>&nbsp; }<br>};<br><br>struct MessageWarning {<br>&nbsp; void writeMessage() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "warning" &lt;&lt; '\n';<br>&nbsp; }<br>};<br><br>struct MessageFatal: MessageSeverity{};&nbsp;&nbsp;&nbsp; &nbsp;<br><br>template &lt;MessageServer T&gt;&nbsp;&nbsp; // (2)<br>void writeMessage(T&amp; messServer){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;writeElapsedTime();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;messServer.writeMessage();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageInformation messInfo;<br>&nbsp;&nbsp;&nbsp; writeMessage(messInfo);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; MessageWarning messWarn;<br>&nbsp;&nbsp;&nbsp; writeMessage(messWarn);<br><br>&nbsp;&nbsp;&nbsp; MessageFatal messFatal;<br>&nbsp;&nbsp;&nbsp; writeMessage(messFatal);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}<br></div><div class="text">Das Concept <span class="tx_code">MessageServer</span> (1) setzt voraus, dass ein Objekt<span class="tx_code"> t </span>vom Datentyp <span class="tx_code">T</span> den Aufruf <span class="tx_code">t.writeMessage</span> unterstützt. (2) wendet das <span class="tx_code">Concept</span> in dem Funktions-Template <span class="tx_code">writeMessage</span> an.</div><div class="ztitel">Wie geht's weiter?<br></div><div class="text">Bisher habe ich nur über das polymorphe Verhalten von Templates geschrieben, aber nicht über statische Polymorphismie. Das ändert sich in meinem nächsten Beitrag. Ich stelle das sogenannte CRTP-Idiom vor. CRTP steht für Curiously Recurring Template Pattern und bezeichnet eine Technik in C++, bei der eine Klasse <span class="tx_code">Derived</span> von einer Template-Klasse <span class="tx_code">Base</span> abgeleitet wird und <span class="tx_code">Base</span> <span class="tx_code">Derived</span> als Template-Parameter besitzt:<br></div><div class="pre">template &lt;typename T&gt;<br>class Base<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>};<br><br>class Derived : public Base&lt;Derived&gt;<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>};</div>