<div class="vorspann">Hybride Programmierung ist kein offizieller Begriff. Ich habe ihn erfunden, um einen interessanten Aspekt von Templates zu betonen: Den Unterschied zwischen Funktionsargumenten und Templateargumenten.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/1/4/3/0/2/TN_220661220_47d7332e51.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Meinen letzten Artikel "<a title="Link auf https://heise.de/-6237233" alt="%7B%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6237233%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6237233%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Template-Metaprogrammierung%3A%20Wie%20es%20funktioniert%22%7D" href="https://heise.de/-6237233">Template-Metaprogrammierung: Wie es funktioniert</a>" beendete ich mit einem Rätsel. Zur Erinnerung, hier ist das Rätsel:<br></div><div class="ztitel">Das Rätsel</div><div class="text">Die Funktionen <span class="tx_code">power</span> und Power berechnen pow(2, 10). <span class="tx_code">power</span> wird zur Laufzeit ausgeführt und <span class="tx_code">Power</span> zur Compilezeit.</div><div class="pre">// power.cpp<br><br>#include &lt;iostream&gt;<br><br>int power(int m, int n) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; int r = 1;<br>&nbsp;&nbsp;&nbsp; for(int k = 1; k &lt;= n; ++k) r *= m;<br>&nbsp;&nbsp;&nbsp; return r;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>}<br><br>template&lt;int m, int n&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>struct Power {<br>&nbsp;&nbsp;&nbsp; static int const value = m * Power&lt;m, n-1&gt;::value;<br>};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>template&lt;int m&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>struct Power&lt;m, 0&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; static int const value = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>};<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "power(2, 10)= " &lt;&lt; power(2, 10) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Power&lt;2,10&gt;::value= " &lt;&lt; Power&lt;2, 10&gt;::value &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br>}</div><div class="text">Mehr Details zu beiden Funktionen finden sich in meinem vorherigen Artikel "<a title="Link auf https://heise.de/-6237233" alt="%7B%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6237233%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Template-Metaprogrammierung%20-%20Wie%20es%20funktioniert%22%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6237233%22%2C%22alias%22%3A%22%22%7D" href="https://heise.de/-6237233">Template-Metaprogrammierung - Wie es funktioniert</a>.</div><div class="text">So weit, so gut, aber was passiert in folgendem Beispiel?</div><div class="pre">// powerHybrid.cpp<br><br>#include &lt;iostream&gt;<br><br>template&lt;int n&gt;<br>int Power(int m){<br>&nbsp;&nbsp;&nbsp; return m * Power&lt;n-1&gt;(m);<br>}<br><br>template&lt;&gt;<br>int Power&lt;0&gt;(int m){<br>&nbsp;&nbsp;&nbsp; return 1;<br>}<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Power&lt;0&gt;(10): " &lt;&lt; Power&lt;0&gt;(20) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Power&lt;1&gt;(10): " &lt;&lt; Power&lt;1&gt;(10) &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Power&lt;2&gt;(10): " &lt;&lt; Power&lt;2&gt;(10) &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text">Wie erwartet, erledigt <span class="tx_code">Power</span> seine Aufgabe zuverlässig.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/1/4/3/0/2/TN_220661227_0faedf5940.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Hier ist das Rätsel in Kurzform: Ist <span class="tx_code">Power</span> eine Funktion oder eine Metafunktion?</div><div class="ztitel">Hybride Programmierung</div><div class="text">Die Aufrufe<span class="tx_code"> Power&lt;0&gt;(10)</span>, <span class="tx_code">Power&lt;1&gt;(10)</span> und <span class="tx_code">Power&lt;2&gt;(10)</span> verwenden spitze und runde Klammern und potenzieren 10 mit 0, 1 und 2. Das heißt, 0, 1 und 2 sind Compilezeit-Argumente und 10 ist ein Laufzeit-Argument. Anders ausgedrückt heißt dies: <span class="tx_code">Potenz</span> ist gleichzeitig eine Funktion und eine Metafunktion. Ich möchte auf diesen Punkt gerne genauer eingehen.</div><div class="ztitel_kleiner">Power zur Laufzeit</div><div class="text">Zunächst kann ich <span class="tx_code">Power</span> für 2 instanziieren, ihr den Namen <span class="tx_code">Power2of</span> geben und sie in einer for-Schleife verwenden.</div><div class="pre">// powerHybridRuntime.cpp<br><br>#include &lt;iostream&gt;<br><br>template&lt;int n&gt;<br>int Power(int m){<br>&nbsp;&nbsp;&nbsp; return m * Power&lt;n-1&gt;(m);<br>}<br><br>template&lt;&gt;<br>int Power&lt;0&gt;(int m){<br>&nbsp;&nbsp;&nbsp; return 1;<br>}<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; auto Power2of = Power&lt;2&gt;;<br><br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt;= 20; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Power2of(" &lt;&lt; i &lt;&lt; ")= "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; Power2of(i)&nbsp; &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text"><span class="tx_code">Power2of</span> ermöglicht es, die Quadrate von 0 ... 20 zur Laufzeit zu berechnen.<br> </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/1/4/3/0/2/TN_220661231_cfaf2f0706.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br> </div><div class="text">Natürlich kann man Power nicht mit verschiedenen Template-Argumenten in der for-Schleife aufrufen. Die Instanziierung eines Templates erfordert einen konstanten Ausdruck. Um es kurz zu machen: Die folgende Anwendung von Power führt zu einem Compilierfehler, der besagt, dass "<i>the value of 'i' is not usable in a constant expression</i>".</div><div class="pre">for (int i = 0; i &lt;= 20; ++i) {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Power&lt;" &lt;&lt; i &lt;&lt; "&gt;(2)= " &lt;&lt; Power&lt;i&gt;(2) &lt;&lt; '\n';<br><br>}</div><div class="text">Es gibt einen sehr interessanten Unterschied zwischen einer Funktion und einer Metafunktion.</div><div class="ztitel_kleiner">Power zur Compilezeit</div><div class="text">Wer das vorherige Programm <span class="tx_code">powerHybrid.cp</span>p in C++ Insights untersucht, sieht, dass jeder Einsatz von <span class="tx_code">Power</span> mit einem anderen Template-Argument einen neuen Typ erzeugt.</div><div class="text">Das bedeutet, dass der Aufruf von <span class="tx_code">Power&lt;2&gt;(10</span>) die rekursive Template-Instanziierung für <span class="tx_code">Power&lt;1&gt;(10)</span> und <span class="tx_code">Power&lt;0&gt;(10)</span> bewirkt. Hier ist die Ausgabe von C++ Insights.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/1/4/3/0/2/TN_220661237_574972f15f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Um meine Beobachtung zusammenzufassen: Jede Template-Instanziierung erzeugt einen neuen Typ.<br> </div><div class="ztitel_kleiner">Neue Typen erstellen</div><div class="text">Wer ein Template wie <span class="tx_code">Power</span>, <span class="tx_code">std::vector</span> oder <span class="tx_code">std::array</span> verwendet, kann es mit zwei Arten von Argumenten aufrufen: Funktionsargumente und Template-Argumente. Die Funktionsargumente stehen in runden Klammern (<span class="tx_code">( ... )</span>) und die Template-Argumente stehen in spitzen Klammern (<span class="tx_code">&lt;...&gt;</span>). Mit den Template-Argumenten werden neue Typen erstellt. Oder andersherum formuliert. Man kann Templates auf zwei Arten parametrisieren: zur Compilezeit mit spitzen Klammern (<span class="tx_code">&lt;...&gt;</span>) und zur Laufzeit mit runden Klammern (<span class="tx_code">( ... )</span>).</div><div class="pre">auto res1 = Power&lt;2&gt;(10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>auto res2 = Power&lt;2&gt;(11);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>auto rest3 = Power&lt;3&gt;(10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>std::vector&lt;int&gt; myVec1(10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>std::vector&lt;int&gt; myVec2(10, 5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>std::vector&lt;double&gt; myDouble(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>std::array&lt;int, 3&gt; myArray1{ 1, 2, 3};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>std::array&lt;int, 3&gt; myArray2{ 1, 2, 3};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>std::array&lt;double, 3&gt; myArray3{ 1.1, 2.2, 3.3}; // (3)</div><div class="text"><ul><li>(1) erstellt eine neue Power-Instanz, einen <span class="tx_code">std::vector </span>der Länge 10 oder ein<span class="tx_code"> std::array</span> mit drei Elementen</li><li>(2) verwendet die bereits erstellten Typen aus den vorherigen Zeilen (1) wieder</li><li>(3) erstellt einen neuen Typ</li></ul></div><div class="text">Ein paar meiner deutschen Leser haben mich bereits darauf hingewiesen: Meine Metafunktion <span class="tx_code">Power</span> hat eine große Schwachstelle.</div><div class="ztitel_kleiner">Die große Schwachstelle</div><div class="text">Wenn ich Power mit einer negativen oder einer zu großen Zahl instanziiere, kommt es zu undefiniertem Verhalten.</div><div class="text"><ul><li><span class="tx_code">Power&lt;-1&gt;(10)</span> verursacht eine unendliche Template-Instanziierung, weil die Randbedingung <span class="tx_code">Power&lt;0&gt;(10)</span> nicht zuschlägt.</li><li><span class="tx_code">Potenz&lt;200&gt;(10)</span> verursacht einen <span class="tx_code">int</span>-Überlauf.</li></ul></div><div class="text">Das erste Problem kann durch die Verwendung eines <span class="tx_code">static_assert</span> innerhalb der <span class="tx_code">Power</span>-Templates behoben werden: <span class="tx_code">static_assert(n &gt;= 0, "exponent must be &gt;= 0");</span>. Für das zweite Problem gibt es keine einfache Lösung.</div><div class="pre">// powerHybridRuntimeOverflow.cpp<br><br>#include &lt;iostream&gt;<br><br>template&lt;int n&gt;<br>int Power(int m){<br>&nbsp;&nbsp;&nbsp; return m * Power&lt;n-1&gt;(m);<br>}<br><br>template&lt;&gt;<br>int Power&lt;0&gt;(int m){<br>&nbsp;&nbsp;&nbsp; return 1;<br>}<br><br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; auto Power10of = Power&lt;10&gt;;<br><br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt;= 20; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Power10of(" &lt;&lt; i &lt;&lt; ")= "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; Power10of(i)&nbsp; &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text">Der Überlauf beginnt mit <span class="tx_code">Power10of</span>(9). pow(9, 10) ist 3.486.784.40</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/2/1/4/3/0/2/TN_220661246_0300fbfd8a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="ztitel_kleiner">Was ich noch sagen wollte ...<br></div><div class="text">Am Ende dieser drei Artikel "<a title="Link auf https://heise.de/-6233576" alt="%7B%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6233576%22%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Template%20Metaprogrammierung%20-%20Wie%20alles%26nbsp%3B%20begann%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6233576%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://heise.de/-6233576">Template Metaprogrammierung - Wie alles&nbsp; begann</a>",&nbsp; "<a title="Link auf https://heise.de/-6237233" alt="%7B%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Template-Metaprogrammierung%3A%20Wie%20es%20funktioniert%22%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6237233%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6237233%22%2C%22subject%22%3A%22%22%7D" href="https://heise.de/-6237233">Template-Metaprogrammierung: Wie es funktioniert</a>" über Template Metaprogramming möchte ich einen Haftungsausschluss aussprechen. Ich möchte nicht, dass jemand zur Compilezeit mit Templates programmiert. Die meiste Zeit ist <span class="tx_code">constexpr</span> (C++11) oder <span class="tx_code">consteval</span> (C++20) die deutlich bessere Wahl.</div><div class="text">Ich habe die Template-Metaprogrammierung aber aus zwei Gründen erklärt.</div><div class="text"><ul><li>Die Template-Metaprogrammierung hilft dir, Templates und den Prozess der Template-Instanziierung besser zu verstehen.</li></ul><ul><li>Die <a title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" alt="%7B%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22mediasync_id%22%3A%22%22%2C%22text%22%3A%22Type-Traits-Bibliothek%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%7D" href="https://en.cppreference.com/w/cpp/header/type_traits">Type-Traits-Bibliothek</a> wendet die Idee der Template-Metaprogrammierung an und nutzt deren Konventionen.</li></ul></div><div class="ztitel">Wie geht's weiter?</div><div class="text">In meinem nächsten Artikel schreibe ich über die <a title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" alt="%7B%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22alias%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Type-Traits-Bibliothek%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%7D" href="https://en.cppreference.com/w/cpp/header/type_traits">Type-Traits-Bibliothek</a>, die Template-Metaprogrammierung in schönen Gewande verkörpert.<br></div>