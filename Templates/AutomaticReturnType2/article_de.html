<div class="vorspann">Nach der Vorstellung des automatischen Rückgabetyps in C++98, folgt nun die Umsetzung mit&nbsp; den Mitteln von C++11, C++14 und C++20.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/1/8/9/4/1/1/TN_218537134_183ba241fb.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Zur Erinnerung: Hier ist die Aufgabe, die ich lösen möchte.</div>
<div class="pre">template &lt;typename T, typename T2&gt;<br>??? sum(T t, T2 t2) {<br>&nbsp;&nbsp;&nbsp; return t + t2;<br>}</div>
<div class="text">Wer ein Funktions-Template mit mindestens zwei Parametern implementiert, kann im Allgemeinen nicht den Rückgabetyp der Funktion bestimmen. Natürlich sollte <span class="tx_code">sum</span> den Typ zurückgeben, den die arithmetische Operation <span class="tx_code">t + t2</span> ergibt.</div>
<div class="pre">std::cout &lt;&lt; typeid(5.5 + 5.5).name();&nbsp;&nbsp;&nbsp; // double<br>std::cout &lt;&lt; typeid(5.5 + true).name();&nbsp;&nbsp; // double<br>std::cout &lt;&lt; typeid(true + 5.5).name();&nbsp;&nbsp; // double<br>std::cout &lt;&lt; typeid(true + false).name(); // int</div>
<div class="text">Die ganze Geschichte findet sich in meinem vorherigen Artikel "<a title="Link auf Beitrag 3185125" alt="%7B%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Automatischen%20R%C3%BCckgabetyp%20%28C%2B%2B98%29%22%2C%22version%22%3A1%2C%22type%22%3A%22B%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Ded069b394a120105575c0d5a2453d0ee%26rm%3Dopen_article_id%26bid%3D3185125%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A3185125%2C%22mediasync_id%22%3A%22%22%2C%22target%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="/exec/mainmenu.pl?sid=ed069b394a120105575c0d5a2453d0ee&amp;rm=open_article_id&amp;bid=3185125" class="">Automatischen Rückgabetyp (C++98)</a>". Jetzt springe ich aber direkt zu C++11.<br></div>
<div class="ztitel">C++11<br></div>
<div class="text">In C++11 gibt es im Wesentlichen zwei Möglichkeiten, dieses Problem zu lösen: Type-Traits oder <span class="tx_code">auto</span> in Kombination mit <span class="tx_code">decltype</span>.</div>
<div class="ztitel_kleiner">Type-Traits<br></div>
<div class="text">Die Type-Traits-Bibliothek besitzt die Funktion <a title="Link auf https://en.cppreference.com/w/cpp/types/common_type" alt="%7B%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22std%3A%3Acommon_type%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22mediasync_id%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fcommon_type%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fcommon_type%22%7D" href="https://en.cppreference.com/w/cpp/types/common_type" class="">std::common_type</a>. Diese Funktion bestimmt zur Compilezeit den gemeinsamen Typ einer beliebigen Anzahl von Typen. Der gemeinsame Datentyp ist derjenige, in den alle Datentypen implizit konvertiert werden können. Wenn es ihn nicht gibt, spuckt der Compiler eine Fehlermeldung aus.</div>
<div class="pre">// automaticReturnTypeTypeTraits.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;typeinfo&gt;<br>#include &lt;type_traits&gt;<br><br>template &lt;typename T, typename T2&gt;<br>typename std::common_type&lt;T, T2&gt;::type sum(T t, T2 t2) {<br>&nbsp;&nbsp;&nbsp; return t + t2;<br>}<br><br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(5.5, 5.5)).name() &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp; // double<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(5.5, true)).name() &lt;&lt; '\n';&nbsp;&nbsp;&nbsp; // double<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(true, 5.5)).name() &lt;&lt; '\n';&nbsp;&nbsp;&nbsp; // double<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(true, false)).name() &lt;&lt; '\n';&nbsp; // bool<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div>
<div class="text">Der Einfachheit halber zeige ich die String-Darstellung des Datentyps im Quellcode an. Ich habe den MSVC-Compiler verwendet. Der GCC- oder Clang-Compiler würde einzelne Zeichen wie <span class="tx_code">d</span> für <span class="tx_code">double</span> und <span class="tx_code">b</span> für <span class="tx_code">bool</span> zurückgeben. </div>
<div class="text">Es gibt einen feinen Unterschied zwischen<span class="tx_code"> std::common_type</span> und allen anderen Varianten, die ich im letzten Beitrag und in diesem Beitrag vorgestellt habe<span class="tx_code">: std::common_type </span>gibt den gemeinsamen Datentyp zurück, meine Traits-Umsetzung des letzten Artikels hingegen und die auf <span class="tx_code">auto</span> basierenden Variante in diesem Artikel, geben den Typ zurück, den der Ausdruck <span class="tx_code">t + t2</span> ergibt.<br></div>
<div class="ztitel_kleiner"><span class="tx_code">auto</span> in Kombination mit <span class="tx_code">decltype</span></div>
<div class="text"><span class="tx_code">auto</span> zum Bestimmen des Rückgabetyps einer Funktion in C++11 zu verwenden, ist viel zu umständlich.<br></div>
<div class="text">Erstens muss man den sogenannten Trailing Return Type verwenden und zweitens den Rückgabetyp in einem<span class="tx_code"> decltype</span>-Ausdruck angeben.</div>
<div class="pre">// automaticReturnTypeTypeAutoDecltype.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;typeinfo&gt;<br>#include &lt;type_traits&gt;<br><br>template &lt;typename T, typename T2&gt;<br>auto sum(T t, T2 t2) -&gt; decltype(t + t2) {<br>&nbsp;&nbsp;&nbsp; return t + t2;<br>}<br><br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(5.5, 5.5)).name() &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp; // double<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(5.5, true)).name() &lt;&lt; '\n';&nbsp;&nbsp;&nbsp; // double<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(true, 5.5)).name() &lt;&lt; '\n';&nbsp;&nbsp;&nbsp; // double<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(true, false)).name() &lt;&lt; '\n';&nbsp; // int<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div>
<div class="text">Der Ausdruck <span class="tx_code">auto sum(T t, T2 t2) -&gt; decltype(t + t2)</span> lässt sich folgendermaßen lesen: <span class="tx_code">auto</span> drückt aus, dass der Rückgabetyp zu diesem Zeitpunkt noch nicht bekannt ist und er später angegeben wird. Diese Angabe erfolgt in dem Ausdruck <span class="tx_code">decltype: decltype(t + t2)</span>. Der Rückgabetyp der Funktions-Template <span class="tx_code">sum</span> ist der Typ, zu dem der arithmetische Ausdruck konvertiert. Was mir an dieser C++11-Syntax nicht gefällt, ist dass ich zweimal denselben Ausdruck<span class="tx_code"> t + t2</span> verwenden muss. Das ist fehleranfällig und überflüssig. Die Syntax für den&nbsp; Rrailing Return Type ist im Allgemeinen optional, aber für die automatische Ableitung des Rückgabetyps in C++11 und Lambdas erforderlich.</div>
<div class="text">Schauen wir uns an, ob C++14 die Bestimmung des automatischen Rückgabetyps vereinfacht.</div>
<div class="ztitel">C++14</div>
<div class="text">Mit C++14 haben wir eine bequeme Syntax für die automatische Bestimmung des Rückgabetyps ohne Redundanz.</div>
<div class="pre">// automaticReturnTypeTypeAuto.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;typeinfo&gt;<br>#include &lt;type_traits&gt;<br><br>template &lt;typename T, typename T2&gt;<br>auto sum(T t, T2 t2) {<br>&nbsp;&nbsp;&nbsp; return t + t2;<br>}<br><br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(5.5, 5.5)).name() &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp; // double<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(5.5, true)).name() &lt;&lt; '\n';&nbsp;&nbsp;&nbsp; // double<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(true, 5.5)).name() &lt;&lt; '\n';&nbsp;&nbsp;&nbsp; // double<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(true, false)).name() &lt;&lt; '\n';&nbsp; // int<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div>
<div class="text">In C++14 lässt sich einfach <span class="tx_code">auto</span> als Rückgabetyp verwenden. </div>
<div class="text">Machen wir den letzten Sprung zu C++20.</div>
<div class="ztitel">C++20</div>
<div class="text">In C++20 lässt sich statt eines Unconstrained Placeholders einen Constrained Placeholder, auch bekannt als Concept, verwenden. Die Definition und Verwendung des Concepts <span class="tx_code">Arithmetic</span> drückt explizit meine Absicht aus. In dem Funktions-Template <span class="tx_code">sum</span> sind nur arithmetische Typen erlaubt.</div>
<div class="pre">// automaticReturnTypeTypeAuto.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;typeinfo&gt;<br>#include &lt;type_traits&gt;<br><br>template&lt;typename T&gt;<br>concept Arithmetic = std::is_arithmetic&lt;T&gt;::value;<br><br>Arithmetic auto sum(Arithmetic auto t, Arithmetic auto t2) {<br>&nbsp;&nbsp;&nbsp; return t + t2;<br>}<br><br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(5.5, 5.5)).name() &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp; // double<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(5.5, true)).name() &lt;&lt; '\n';&nbsp;&nbsp;&nbsp; // double<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(true, 5.5)).name() &lt;&lt; '\n';&nbsp;&nbsp;&nbsp; // double<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(sum(true, false)).name() &lt;&lt; '\n';&nbsp; // int<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div>
<div class="text">Ich definiere das Concept <span class="tx_code">Arithmetic</span>, indem ich direkt die Type-Traits-Funktion <span class="tx_code">std::is_arithmetic</span> einsetze. Die Funktion <span class="tx_code">std::is_arithmetic</span> ist ein sogenanntes Compiletime Predicat. Ein Compiletime Predicat ist eine Funktion, die zur Compilezeit einen booleschen Wert zurückgibt.</div>
<div class="text">Zu <a title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/concepts" alt="%7B%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fconcepts%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fconcepts%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22mediasync_id%22%3A%22%22%2C%22text%22%3A%22Concepts%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" href="https://www.grimm-jaud.de/index.php/blog/tag/concepts" class="">Concepts</a> habe ich bereits mehrere Artikel geschrieben, in denen sich die Details nachlesen lassen.<br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Template-Metaprogrammierung oder die Programmierung zur Compilezeit mithilfe von Templates ist eine sehr leistungsfähige C++-Technik mit einem schlechten Ruf. Die Funktionen der Type-Traits-Bibliothek wie <span class="tx_code">std::common_type</span> oder<span class="tx_code"> std::is_arithmetic</span> sind Beispiele für die Template-Metaprogrammierung in C++. In meinem nächsten Beitrag gehe ich näher auf die Template-Metaprogrammierung ein.</div>
<div class="ztitel">Online-Seminar: Clean Code: Best Practices für modernes C++<br></div>
<div class="text">Ich freue mich darauf, mein nächstes Online-Seminar vom <b>14.12 - 16.12.2021</b> durchzuführen. Jeder Teilnehmer erhält eines meiner Bücher zur freien Auswahl und einen Gutschein für meinen Online Kurs <a title="Link auf https://www.educative.io/courses/cpp-fundamentals-for-professionals" alt="%7B%22alias%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Fundamentals%20for%20Professionals%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.educative.io%2Fcourses%2Fcpp-fundamentals-for-professionals%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.educative.io%2Fcourses%2Fcpp-fundamentals-for-professionals%22%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://www.educative.io/courses/cpp-fundamentals-for-professionals" class="">C++ Fundamentals for Professionals</a>.<br></div>
<div class="text">Mehr Informationen zu dem Online-Seminar gibt es hier: Clean Code: <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/34-clean-code-best-practices-fuer-modernes-c" alt="%7B%22alias%22%3A%22%22%2C%22text%22%3A%22Best%20Practices%20f%C3%BCr%20modernes%20C%2B%2B%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F34-clean-code-best-practices-fuer-modernes-c%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F34-clean-code-best-practices-fuer-modernes-c%22%2C%22anchor%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/34-clean-code-best-practices-fuer-modernes-c" class="">Best Practices für modernes C++</a><br></div>