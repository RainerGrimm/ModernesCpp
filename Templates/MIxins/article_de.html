<div class="vorspann">Das Curiously Recurring Template Pattern lässt sich nicht nur für statische Polymorphie nutzen, sondern auch für Mixins.<br></div><div class="text">In meinem letzten Artikel "<a title="Link auf https://heise.de/-6526677" alt="%7B%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Mehr%20Details%20zur%20statischen%20und%20dynamischen%20Polymorphi%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-6526677%22%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-6526677%22%2C%22target%22%3A%22_blank%22%7D" href="https://heise.de/-6526677">Mehr Details zur statischen und dynamischen Polymorphi</a>e" habe ich das Curiously Recurring Template Pattern (CRTP) verwendet, um statische Polymorphie zu implementieren. Ein weiterer typischer Anwendungsfall für CRTP sind Mixins.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/5/8/4/9/2/TN_230099584_7f727f2e48.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Mixins sind eine beliebte Methode beim Entwurf von Klassen, um diese mit neuer Funktionalität zu erweitern. Es ist in Python eine häufig verwendete Technik, das Verhalten einer Klasse durch Mehrfachvererbung zu anzupassen. Im Gegensatz zu C++ ist es in Python erlaubt, mehr als eine Definition einer Methode in einer Klassenhierarchie zu besitzen. Python verwendet einfach die Methode, die in der <a title="Link auf https://docs.python.org/3/glossary.html#term-method-resolution-order" alt="%7B%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Method%20Resolution%20Order%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fdocs.python.org%2F3%2Fglossary.html%23term-method-resolution-order%22%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fdocs.python.org%2F3%2Fglossary.html%23term-method-resolution-order%22%2C%22target%22%3A%22_blank%22%7D" href="https://docs.python.org/3/glossary.html#term-method-resolution-order">Method Resolution Order</a> (MRO) an erster Stelle steht.</div><div class="text">Mixins lassen sich in C++ mit CRTP implementieren. Ein bekanntes Beispiel ist die Klasse <span class="tx_code">std::enable_shared_from_this.</span></div><div class="text">Das folgende Beispiel zeigt <span class="tx_code">std::enable_shared_from_this</span> und damit CRTP in der Anwendung.</div><div class="pre">// enableShared.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;memory&gt;<br><br>class ShareMe: public std::enable_shared_from_this&lt;ShareMe&gt; {&nbsp; // (1)<br>public:<br>&nbsp; std::shared_ptr&lt;ShareMe&gt; getShared(){<br>&nbsp;&nbsp;&nbsp; return shared_from_this();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; }<br>};<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>&nbsp; std::shared_ptr&lt;ShareMe&gt; shareMe(new ShareMe);<br>&nbsp; std::shared_ptr&lt;ShareMe&gt; shareMe1= shareMe-&gt;getShared();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; auto shareMe2(shareMe1);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "shareMe.use_count(): "&nbsp; &lt;&lt; shareMe.use_count() &lt;&lt; '\n';<br>&nbsp; }<br>&nbsp; std::cout &lt;&lt; "shareMe.use_count(): "&nbsp; &lt;&lt; shareMe.use_count() &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; shareMe1.reset();<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "shareMe.use_count(): "&nbsp; &lt;&lt; shareMe.use_count() &lt;&lt; '\n';<br><br>&nbsp; std::cout &lt;&lt; '\n';<br><br>}</div><div class="text">Mit der Klasse<span class="tx_code"> std::enable_shared_from_this</span> lassen sich Objekte erstellen, die eine <span class="tx_code">std::shared_ptr </span>auf sich selbst zurückgeben. Dazu muss die Klasse <span class="tx_code">MySharedClass </span>public von <span class="tx_code">std::enable_shared_from_this </span>abgeleitet werden (1). Jetzt besitzt die Klasse <span class="tx_code">MySharedClass</span> eine Member-Funktion <span class="tx_code">shared_from_this</span> (2), mit der sich <span class="tx_code">std::shared_ptr</span> zu ihren Objekten erstellen lassen. Der Aufruf <span class="tx_code">shareMe-&gt;getShared() </span>(3) erzeugt einen neuen Smart Pointer. Die Memberfunktion <span class="tx_code">getShared</span> verwendet intern die Funktion <span class="tx_code">shared_from_this </span>(2). Der folgende Screenshot zeigt die Erstellung des Shared Pointer.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/5/8/4/9/2/TN_230099591_179c67c29c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Mehr über Smart Pointer findet sich in meinem früheren Artikel <a title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/smart-pointer" alt="%7B%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Smart%20Pointer%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22mediasync_id%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fsmart-pointer%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fsmart-pointer%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/tag/smart-pointer">Smart Pointer</a>.</div><div class="text">Um die Arbeitsweise von Mixin-Klassen in C++ zu zeigen, stelle ich einen typischen Anwendungsfall vor.</div><div class="ztitel">Erweitern einer Klasse mit allen Vergleichsoperatoren</div><div class="text">Als Beispiel dient die Implementierung aller sechs Vergleichsoperatoren für einen Datentyp.&nbsp; (Mit C++20 kann der Compiler sie natürlich automatisch generieren:&nbsp;<a title="Link auf https://www.heise.de/developer/artikel/C-20-Der-Drei-Weg-Vergleichsoperator-4782690.html" alt="%7B%22target%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22text%22%3A%22%20C%2B%2B20%3A%20Der%20Drei-Wege-Vergleichsoperator%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-20-Der-Drei-Weg-Vergleichsoperator-4782690.html%22%2C%22ir_link%22%3A1%2C%22mediasync_id%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-20-Der-Drei-Weg-Vergleichsoperator-4782690.html%22%7D" href="https://www.heise.de/developer/artikel/C-20-Der-Drei-Weg-Vergleichsoperator-4782690.html"> C++20: Der Drei-Wege-Vergleichsoperator</a>). Bislang existiert für unser Beispiel nur der Kleiner-Operator (&lt;). Alle anderen fünf Vergleichsoperatoren (<span class="tx_code">&lt;=, &gt;, &gt;=</span> <span class="tx_code">==</span> und <span class="tx_code">!=</span>) lassen sich aber mithilfe des Kleiner-Operators umsetzen. Dank dieser Idee und CRTP, sind viel weniger Tastaturanschläge notwendig.</div><div class="pre">// mixins.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>template &lt;typename Derived&gt;<br>struct Relational {<br>&nbsp;&nbsp;&nbsp; friend bool operator &gt; (Derived const&amp; op1, Derived const&amp; op2){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return op2 &lt; op1;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; friend bool operator == (Derived const&amp; op1, Derived const&amp; op2){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return !(op1 &lt; op2) &amp;&amp; !(op2 &lt; op1);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; friend bool operator != (Derived const&amp; op1, Derived const&amp; op2){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (op1 &lt; op2) || (op2 &lt; op1);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; friend bool operator &lt;= (Derived const&amp; op1, Derived const&amp; op2){ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (op1 &lt; op2) || (op1 == op2);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; friend bool operator &gt;= (Derived const&amp; op1, Derived const&amp; op2){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (op1 &gt; op2) || (op1 == op2);<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>class Apple: public Relational&lt;Apple&gt;{<br>public:<br>&nbsp;&nbsp;&nbsp; explicit Apple(int s): size{s}{};<br>&nbsp;&nbsp;&nbsp; friend bool operator &lt; (Apple const&amp; a1, Apple const&amp; a2){&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a1.size &lt; a2.size;<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp;&nbsp;&nbsp; int size;<br>};<br><br>class Man: public Relational&lt;Man&gt;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>public:<br>&nbsp;&nbsp;&nbsp; explicit Man(const std::string&amp; n): name{n}{}<br>&nbsp;&nbsp;&nbsp; friend bool operator &lt; (Man const&amp; m1, Man const&amp; m2){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m1.name &lt; m2.name;<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp;&nbsp;&nbsp; std::string name;<br>};<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; Apple apple1{5};<br>&nbsp; Apple apple2{10}; <br>&nbsp; std::cout &lt;&lt; "apple1 &lt; apple2: " &lt;&lt; (apple1 &lt; apple2) &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "apple1 &gt; apple2: " &lt;&lt; (apple1 &gt; apple2) &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "apple1 == apple2: " &lt;&lt; (apple1 == apple2) &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "apple1 != apple2: " &lt;&lt; (apple1 != apple2) &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "apple1 &lt;= apple2: " &lt;&lt; (apple1 &lt;= apple2) &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "apple1 &gt;= apple2: " &lt;&lt; (apple1 &gt;= apple2) &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; Man man1{"grimm"};<br>&nbsp; Man man2{"jaud"};<br>&nbsp; std::cout &lt;&lt; "man1 &lt; man2: " &lt;&lt; (man1 &lt; man2) &lt;&lt; '\n'; <br>&nbsp; std::cout &lt;&lt; "man1 &gt; man2: " &lt;&lt; (man1 &gt; man2) &lt;&lt; '\n'; <br>&nbsp; std::cout &lt;&lt; "man1 == man2: " &lt;&lt; (man1 == man2) &lt;&lt; '\n'; <br>&nbsp; std::cout &lt;&lt; "man1 != man2: " &lt;&lt; (man1 != man2) &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "man1 &lt;= man2: " &lt;&lt; (man1 &lt;= man2) &lt;&lt; '\n';<br>&nbsp; std::cout &lt;&lt; "man1 &gt;= man2: " &lt;&lt; (man1 &gt;= man2) &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp;&nbsp; &nbsp;<br>}</div><div class="text">Ich habe für den <span class="tx_code">Apple</span> und den <span class="tx_code">Man</span> den Kleiner-Operator implementiert (Zeilen 1 und 2).&nbsp; Der Einfachheit halber verwende ich in meiner Argumentation nur die Klasse <span class="tx_code">Man</span>.&nbsp; <span class="tx_code">Man</span> ist eine public Ableitung der Klasse <span class="tx_code">Relational&lt;Man&gt; </span>(Zeile 3), die CRTP verwendet. Die Klasse <span class="tx_code">Relational</span> unterstützt die fünf fehlenden Vergleichsoperatoren (<span class="tx_code">&lt;=, &lt;,&gt;=, ==</span> und<span class="tx_code"> !=</span>).&nbsp; Die fünf Vergleichsoperatoren werden auf den Kleiner-Operator von <span class="tx_code">Man</span> abgebildet (Zeile 2). </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/5/8/4/9/2/TN_230099597_d1bb13d742.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Ehrlich gesagt, gefällt mir der Name Mixins für dieses Idiom sehr gut. Die Klasse <span class="tx_code">Relational</span> mischt die restlichen Vergleichsoperatoren in die Klasse <span class="tx_code">Man</span>.</div><div class="text">Die Besonderheit von CRTP ist, dass eine Klasse <span class="tx_code">Derived</span> von einer Klassenvorlage <span class="tx_code">Base</span> abgeleitet wird und Base <span class="tx_code">Derived</span> als Templateargument besitzt:</div><div class="pre">class Derived : public Base&lt;Derived&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>};<br><br>class Derivedwrong : public Base&lt;Derived&gt; // (2)<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>};</div><div class="text">Wie kann man sicherstellen, dass man nicht versehentlich wie in Zeile 2 die falsche Klasse <span class="tx_code">DervivedWrong</span> von <span class="tx_code">Base&lt;Derived&gt; </span>ableitet?</div><div class="ztitel">Geprüftes CRTP</div><div class="text">Der Trick ist ganz einfach: Der Konstruktor von Base sollte privat sein.</div><div class="pre">// crtpCheck.cpp<br><br>#include &lt;iostream&gt;<br><br>template &lt;typename Derived&gt;<br>struct Base{<br>&nbsp; void interface(){<br>&nbsp;&nbsp;&nbsp; static_cast&lt;Derived*&gt;(this)-&gt;implementation();<br>&nbsp; }<br>private:<br>&nbsp;&nbsp;&nbsp; Base() = default;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; friend Derived;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>};<br><br>struct Derived1: Base&lt;Derived1&gt;{<br>&nbsp; void implementation(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Implementation Derived1" &lt;&lt; '\n';<br>&nbsp; }<br>};<br><br>struct Derived2: Base&lt;Derived1&gt;{&nbsp;&nbsp; // (3)<br>&nbsp; void implementation(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Implementation Derived1" &lt;&lt; '\n';<br>&nbsp; }<br>};<br><br>template &lt;typename T&gt;<br>void execute(T&amp; base){<br>&nbsp;&nbsp;&nbsp; base.interface();<br>}<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>&nbsp; Derived1 d1;<br>&nbsp; execute(d1);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; Derived2 d2;<br>&nbsp; execute(d2);<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; '\n';<br>&nbsp; <br>}</div><div class="text"><span class="tx_code">Base</span> hat einen privaten Default-Konstruktor (1). Nur die Klasse <span class="tx_code">Base</span> selbst oder sein Freund <span class="tx_code">Derived</span> (2) kann ihn aufrufen. Folglich schlägt der Aufruf <span class="tx_code">Derived2 d2</span> (3) fehl, weil <span class="tx_code">Derived2</span> von <span class="tx_code">Base&lt;Derived1&gt;</span> abgeleitet ist und damit kein Freund von Base ist. Hier ist die Fehlermeldung des GCC:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//3/3/5/8/4/9/2/TN_230099603_6194fd9bdd.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel">Wie geht's weiter?</div><div class="text">Das Curiously Recurring Template Pattern (CRTP) ist zwar sehr mächtig, aber nicht leicht zu verstehen. Das Gleiche gilt für Expression Templates. Damit lassen sich überflüssige temporäre Objekte vermeiden. <br></div>