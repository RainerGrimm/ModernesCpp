<p>If you declare a variable as <span style="font-family: courier new,courier;">constexpr</span> the compiler will evaluate them at compile time. This holds not only true for built-in types but also for instantiations of user-defined types. There are a few serious restrictions for objects in order to evaluate them at compile time.</p>
<p>&nbsp;</p>
<hr id="system-readmore" />
<p>To make the life for you and me easier I will use for built-in types like<span style="font-family: courier new,courier;"> bool, char, int</span>, and <span style="font-family: courier new,courier;">double</span> the name variable. I will call the remaining data types as user-defined data types. These are for example <span style="font-family: courier new,courier;">std::string,</span> types from the C++ library and user-defined data types. User-defined types holds typically built-in types.</p>
<h2>Variables</h2>
<p>By using the keyword <span style="font-family: courier new,courier;">constexpr</span> the variable becomes a constant expression.</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;">constexpr <span style="color: #2b91af;">double</span> myDouble= 5.2;
</pre>
</div>
<p>&nbsp;</p>
<p>Therefore, I can use the variable in contexts that requires a constant expression. For example, if I want to define the size of an array. This has to be done at compile time.</p>
<p>For the declaration of <span style="font-family: courier new,courier;">constexpr</span> variable you have to keep a few rules in mind.</p>
<p>The variable</p>
<ul>
<li>is implicitly const.</li>
<li>has to be initialized.</li>
<li>requires a constant expression for initialization.</li>
</ul>
<p>The rule makes sense. If I evaluate a variable at compile time, the variable can only depend on values that can be evaluated at compile time.</p>
<p>The objects are created by the invocation of the constructor. The constructor has a few special rules.</p>
<h2>User-defined types</h2>
<p>The class <span style="font-family: courier new,courier;">MyDistance</span> from the post<span style="font-family: courier new,courier;"></span> <a href="index.php/constant-expressions-with-constexpr">Constant expressions with<span style="font-family: courier new,courier;"> constexpr </span></a>fulfils all requirements to be initialized at compile time. But what are the requirements?</p>
<p>A <span style="font-family: courier new,courier;">constexpr</span> constructor&nbsp;</p>
<ol>
<li>can only be invoked with constant expressions.</li>
<li>can not use exception handling.</li>
<li>has to be declared as <span style="font-family: courier new,courier;">default</span> or <span style="font-family: courier new,courier;">delete</span> or the function body must be empty (C++11).</li>
</ol>
<p>The <span style="font-family: courier new,courier;">constexpr</span> user-defined type</p>
<ol>
<li>can not have virtual base classes.</li>
<li>requires that each base object and each non-static member has to be initialized in the initialization list of the constructor or directly in the class body. Consequently, it holds that each used constructor (e.g of a base class) has to be constexpr constructor and that the applied initializers have to be constant expressions.</li>
</ol>
<p>Sorry, but the details are even harder: <a href="http://en.cppreference.com/w/cpp/language/constexpr">cppreference.com</a>. To make the theory obvious I define the class <span style="font-family: courier new,courier;">MyInt. MyInt</span> shows the just mentioned points<span style="font-family: courier new,courier;"></span>. The class has in addition <span style="font-family: courier new,courier;">constexpr</span> methods. There are special rules for <span style="font-family: courier new,courier;">constexpr</span> methods and functions. This rules will follow in the next post, so we can concentrate in this post on the essentials about variables and user-defined types.</p>
<p>&nbsp;</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<table>
<tbody>
<tr>
<td>
<pre style="margin: 0; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65</pre>
</td>
<td>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000;">// userdefinedTypes.cpp</span>

<span style="color: #0000ff;">#include &lt;iostream&gt;</span>
<span style="color: #0000ff;">#include &lt;ostream&gt;</span>

<span style="color: #0000ff;">class</span> <span style="color: #2b91af;">MyInt</span>{
public:
  constexpr MyInt()= <span style="color: #0000ff;">default</span>;
  constexpr MyInt(<span style="color: #2b91af;">int</span> fir, <span style="color: #2b91af;">int</span> sec): myVal1(fir), myVal2(sec){}
  MyInt(<span style="color: #2b91af;">int</span> i){
	myVal1= i-2;
	myVal2= i+3;
  }
  
  constexpr MyInt(<span style="color: #0000ff;">const</span> MyInt&amp; oth)= <span style="color: #0000ff;">default</span>;
  constexpr MyInt(MyInt&amp;&amp; oth)= <span style="color: #0000ff;">delete</span>;
  
  constexpr <span style="color: #2b91af;">int</span> getSum(){ <span style="color: #0000ff;">return</span> myVal1+myVal2; }
  
  <span style="color: #0000ff;">friend</span> std::ostream&amp; <span style="color: #0000ff;">operator</span>&lt;&lt; (std::ostream &amp;out, <span style="color: #0000ff;">const</span> MyInt&amp; myInt){
    out &lt;&lt; <span style="color: #a31515;">"("</span> &lt;&lt; myInt.myVal1 &lt;&lt; <span style="color: #a31515;">","</span> &lt;&lt; myInt.myVal2 &lt;&lt; <span style="color: #a31515;">")"</span>;  
    <span style="color: #0000ff;">return</span> out;
  }

private:
  <span style="color: #2b91af;">int</span> myVal1= 1998;
  <span style="color: #2b91af;">int</span> myVal2= 2003;

};

<span style="color: #2b91af;">int</span> main(){
  
  std::cout &lt;&lt; std::endl;
  
  constexpr MyInt myIntConst1;
  MyInt myInt2;
  
  constexpr <span style="color: #2b91af;">int</span> sec= 2014;
  constexpr MyInt myIntConst3(2011,sec);
  std::cout &lt;&lt; <span style="color: #a31515;">"myIntConst3.getSum(): "</span> &lt;&lt; myIntConst3.getSum() &lt;&lt; std::endl;
  
  std::cout &lt;&lt; std::endl;
  
  <span style="color: #2b91af;">int</span> a= 1998;
  <span style="color: #2b91af;">int</span> b= 2003;
  MyInt myInt4(a,b);
  std::cout &lt;&lt; <span style="color: #a31515;">"myInt4.getSum(): "</span> &lt;&lt; myInt4.getSum() &lt;&lt; std::endl;
  std::cout &lt;&lt; myInt4 &lt;&lt; std::endl;
  
  std::cout &lt;&lt; std::endl;
  
  <span style="color: #008000;">// constexpr MyInt myIntConst5(2000);  ERROR</span>
  MyInt myInt6(2000);
  std::cout &lt;&lt; <span style="color: #a31515;">"myInt6.getSum(): "</span> &lt;&lt; myInt4.getSum() &lt;&lt; std::endl;
  std::cout &lt;&lt; myInt6 &lt;&lt; std::endl;
  
  <span style="color: #008000;">// constexpr MyInt myInt7(myInt4); ERROR</span>
  constexpr MyInt myInt8(myIntConst3);
  
  std::cout &lt;&lt; std::endl;
  
  <span style="color: #2b91af;">int</span> arr[myIntConst3.getSum()];
  static_assert( myIntConst3.getSum() == 4025, <span style="color: #a31515;">"2011 + 2014 should be 4025"</span> );
  
}
</pre>
</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<p>The class <span style="font-family: courier new,courier;">MyInt</span> has three constructors. A <span style="font-family: courier new,courier;">constexpr</span> default constructor (line 8) and a constructor taking two (line 9) and taking one argument (line 10). The constructor with two arguments is a <span style="font-family: courier new,courier;">constexpr</span> constructor. Therefore, its body is empty. This holds not true for the non-<span style="font-family: courier new,courier;">constexpr</span> constructor with one argument. The definition goes on with a defaulted copy-constructor (line 15) and a deleted move-constructor (line 16).&nbsp; Additionally, the class has two methods, but only the method <span style="font-family: courier new,courier;">getSum</span> is a const expression. I can only define the variables <span style="font-family: courier new,courier;">myVal1</span> and <span style="font-family: courier new,courier;">myVal2</span> (line 26 and 27) in two ways if I want to use them in <span style="font-family: courier new,courier;">constexpr</span> objects. At first, I can initialize them in the initialization list of the constructor (line 9); at second, I can initialize them in the class body (line 26 and 27). The initialization in the initialization list of the constructor has higher priority. It's not allowed to define both variables in the body of the constructor (line 11 and 12).&nbsp;</p>
<p>To put the theory to practice, here is the output of the program.</p>
<p>&nbsp;</p>
<p>&nbsp;<img src="images/blog/EmbeddedProgrammierung/constexprVariablenUndObjekte/userdefinedTypes.png" alt="userdefinedTypes" /></p>
<p>The program shows a few special points:</p>
<ul>
<li>You can use a <span style="font-family: courier new,courier;">constexpr </span>constructor at run time. Of course, the instance is no constant expression<span style="font-family: courier new,courier;"></span> (line 36 and line 46).</li>
<li>If you declare a non-constant expression as <span style="font-family: courier new,courier;">constexpr,</span> you will get a compiler error (line 52 and 57).</li>
<li><span style="font-family: courier new,courier;">constexpr</span> constructors can coexit with non-<span style="font-family: courier new,courier;">constexpr</span> constructors. The same holds true for the methods of a class.<span style="font-family: courier new,courier;"></span></li>
</ul>
<p>The key observation is: <strong>A <span style="font-family: courier new,courier;">constexpr</span> object can only use <span style="font-family: courier new,courier;">constexpr</span> methods.</strong></p>
<p>But stop. What's the story about the two last lines 62 and 63 in the <span style="font-family: courier new,courier;">main</span> function?</p>
<h3>The proof</h3>
<p>Quite straight forward. They are the twofold proof that the call <span style="font-family: courier new,courier;">myIntConst3.getSum()</span> is performed at compile time.</p>
<p>At first, C++ requires&nbsp;that the size of an array has to be a constant expression. At second,<span style="font-family: courier new,courier;"> static_assert</span> evaluate its expression at compile time. If not, <span style="font-family: courier new,courier;">static_assert</span> will not compile.</p>
<p>If I replace the line 63</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;">static_assert( myIntConst3.getSum() == 4025, <span style="color: #a31515;">"2011 + 2014 should be 4025"</span> );
</pre>
</div>
<p>with the line</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;">static_assert( myIntConst4.getSum() == 4001, <span style="color: #a31515;">"1998 + 2003 should be 4001"</span> );
</pre>
</div>
<p>, I will get a compiler error.</p>
<p>&nbsp;<img src="images/blog/EmbeddedProgrammierung/constexprVariablenUndObjekte/userdefinedTypesError.png" alt="userdefinedTypesError" width="800" height="229" /></p>
<h2>What's next?</h2>
<p>I think, you know it already. In the <a href="index.php/constexpr-functions">next post</a><span id="transmark"></span> I will write about contexpr functions. They have with C++11 a lot of restrictions that will almost disappear with C++14. constexpr functions in C++14 feels almost like normal functions. Of course, my points about functions will also hold for methods of classes.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>{tooltip} <img src="images/books/title_page_small.png" alt="title page small" width="166" height="212" />{end-texte}<img src="images/books/title_page_small.png" alt="title page small" style="margin: 3px;" /> Go to <a href="https://leanpub.com/cpplibrary"> </a><a href="https://leanpub.com/cpplibrary">Leanpub/cpplibrary</a> <a href="https://leanpub.com/cpplibrary"> </a><strong>"What every professional C++ programmer should know about the C++ standard library".</strong> <a href="https://leanpub.com/cpplibrary"></a>{end-tooltip} &nbsp; <strong><span class="h3">Get your e-book. Support my blog.</span></strong></p>
<p>&nbsp;</p>
