<div class="moz-text-html" lang="x-unicode">
    <p>Nachdem ich einige Artikel rund um das&nbsp;<a href="index.php/blog/tag/speicher">Speichermanagement</a> in C++ geschrieben habe, bin ich sehr froh, Jonathan Müller für einen Gastartikel zu seiner Implementierung der <a href="https://github.com/foonathan/memory">memory</a> Bibliothek in diesem Blog gewinnen zu können. Er wird die Konzepte rund um sein Design erklären. Jonathan ist als Experte zum Speichermangement&nbsp;in der C++-Community weltweit bekannt, sodass er in der <a href="http://cppcast.com/2016/06/jonathan-muller/">59 Episode </a>Gast des cppcast war und seine Bibiothek den Zuhörern vorstellen konnte.</p>
    <hr id="system-readmore" />
    <h2>Die Motivation</h2>
    <p>Zuerst einmal stellt sich mir die Frage, warum Jonathan eine Bibliothek zum Speichermanagement in C++ geschrieben hat? Diese Frage beantwortet er direkt auf seinem github Projekt <a href="https://github.com/foonathan/memory">memory:</a></p>
    <p>"<em>The C++ STL allocator model has various flaws. For example, they are fixed to a certain type, because they are almost necessarily required to be templates. So you can't easily share a single allocator for multiple types. In addition, you can only get a copy from the containers and not the original allocator object. At least with C++11 they are allowed to be stateful and so can be made object not instance based. But still, the model has many flaws. Over the course of the years many solutions have been proposed. for example <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html">EASTL</a>. This library is another. But instead of trying to change the STL, it works with the current implementation</em>."</p>
    <p>Das ist aber nur ein Teil der Antwort. Noch vielversprechender finde ich seine bewusst provokanten These zur Performance seiner Bibliothek, die er in vier <a href="https://foonathan.github.io/blog/2016/03/18/boosting-pools-1.html">sehr lesenswerten Artikeln&nbsp;</a>begründet:&nbsp;<strong>How I have beaten Boost.Pool.</strong> Insbesondere seine Erläuterungen zu den verschiedenen Optimierungsstrategien der Speicherallokation liefern sehr viel Hintergrundwissen und besitzen einen deutlich allgemeineren Fokus.<strong> <br /> </strong></p>
    <p>Nun aber endlich zu Jonathan's Artikel.</p>
    <h2>Memory Pool Allokator</h2>
    <p>Ein Memory Pool Allokator ist ein universal einsetzbarer und schneller Pool Allokator -&gt; und schneller Allokator. Er fordert nur große Speicherblöcke an und unterteilt sie in gleich große Stücke. Alle freien Stücke werden in einer sogenannten <strong>free list</strong>&nbsp; <strong class="moz-txt-star"><span class="moz-txt-tag"></span><span class="moz-txt-tag"></span></strong>gespeichert. Allokation entfernt einfach das erste Stück aus der&nbsp;<strong class="moz-txt-star"><span class="moz-txt-tag"></span>free list<span class="moz-txt-tag"></span></strong> und gibt es zurück,&nbsp; Freigabe fügt es wieder ein.&nbsp; Das ist recht schnell, kann jedoch nur Stücke einer festen Größe verwenden, ansonsten hat man wieder Fragmentierungsprobleme und mitunter langsame Suchen nach dem am besten passenden Stück.</p>
    <p><br /> Ich werde nun zeigen wie man die Pool Implementierung meiner <a href="https://github.com/foonathan/memory">memory Bibliothek</a>&nbsp; für eigene Allokationen nutzt.</p>
    <p style="padding-left: 30px;">memory ist eine Bibliothek, die verschiedene Allokatoren implementiert und die benötigte Infrastruktur um sie problemlos nutzen zu können zur Verfügung stellt. Sie ist aktuell noch in Version 0.x und somit noch in der Entwicklung.</p>
    <h3>Der<span style="font-family: courier new,courier;"> memory pool</span></h3>
    <p>Hat man meine Bibliothek <a href="https://github.com/foonathan/memory">installiert</a> kann man einen Memory Pool ganz einfach nutzen.</p>
    <div style="background: #ffffff none repeat scroll 0% 0%; overflow: auto; width: auto; border-width: 0.1em 0.1em 0.1em 0.8em;">
    <pre style="margin: 0px; line-height: 125%;"><span style="color: #0000ff;">#include &lt;foonathan/memory/memory_pool.hpp&gt;</span>
    <span style="color: #0000ff;">#include &lt;foonathan/memory/namespace_alias.hpp&gt; </span><span style="color: #008000;">// (1)</span>
    
    <span style="color: #2b91af;">int</span> main()
    {
        memory::memory_pool&lt;&gt; pool(16, 4096); <span style="color: #008000;">// (2)</span>
        <span style="color: #2b91af;">void</span>* node = pool.allocate_node(); <span style="color: #008000;">// (3)</span>
        <span style="color: #008000;">// ...</span>
        pool.deallocate_node(node); <span style="color: #008000;">// (4)</span>
    } 
    </pre>
    </div>
    <p><br /> <br /> Nachdem man die benötigten Header-Dateien in (1) inkludiert hat (<span style="font-family: courier new,courier;">namespace_alias.hpp</span> stellt automatisch ein <a href="https://foonathan.github.io/blog/2016/01/26/namespace-alias.html">Alias</a> für den sonst recht langen Namespace-Namen <span style="font-family: courier new,courier;">foonathan::memory</span> zur Verfügung), kann man in (2) direkt den Memory Pool erstellen. Der Konstruktor hat zwei Parameter: der erste ist die Größe jedes Blocks in der <strong class="moz-txt-star"><span class="moz-txt-tag"></span>free list<span class="moz-txt-tag"></span></strong>, die sogenannte <strong class="moz-txt-star"><span class="moz-txt-tag"></span>node size<span class="moz-txt-tag"></span></strong>. Der zweite Parameter ist die Größe des großen Speicherblocks, der unterteilt wird, hier sind das 4KiB. <br /> <br /> Von dem Pool kann man nun kleine Speicherblöcke, sogenannte&nbsp;<strong class="moz-txt-star"><span class="moz-txt-tag"></span>nodes<span class="moz-txt-tag"></span></strong> anfordern (3) und wieder freigeben (4). Jeder <strong class="moz-txt-star"><span class="moz-txt-tag"></span>node<span class="moz-txt-tag"></span></strong> ist dabei so groß wie im Konstruktor angegeben - hier also 16 Bytes. <br /> Selbstverständlich wird mit der Freigabe des großen Speicherblocks im Destruktor des Pools automatisch auch alle <strong class="moz-txt-star"><span class="moz-txt-tag"></span>nodes<span class="moz-txt-tag"></span></strong> freigegeben - auch wenn kein Aufruf von<span style="font-family: courier new,courier;"> deallocate_node()</span> erfolgt ist. <br /> <br /> Nun ist es jedoch recht mühsam den Pool so manuell zu verwenden. Da hilft jedoch das Konzept des&nbsp;<span style="font-family: courier new,courier;">RawAllocator</span>, die grundlegende Abstraktion der Bibliothek.</p>
    <h3>Der <span style="font-family: courier new,courier;">RawAllocator</span></h3>
    <p><br /> In einem vorherigen Teil wurde das <span style="font-family: courier new,courier;">Allocator</span> Konzept vorgestellt, mit dem man die Speicheranforderung der STL Container anpassen kann. Nun ist das <span style="font-family: courier new,courier;">Allocator</span> Konzept <a href="https://foonathan.github.io/blog/2015/10/05/allocatorawarecontainer-propagation-pitfalls.html">nicht gerade einfach </a> <a href="https://foonathan.github.io/blog/2015/10/05/allocatorawarecontainer-propagation-pitfalls.html" class="moz-txt-link-freetext"></a>und außerdem koppelt er die Erstellung der Objekte mit der Anforderung für den Speicher. Die meiste Zeit braucht man das nicht, man will einfach nur anpassen, wie der Speicher verwaltet wird. Für diese Fälle ist der <a href="https://foonathan.github.io/doc/memory/md_doc_concepts.html#concept_rawallocator">RawAllocator</a>&nbsp;gedacht.</p>
    <p><br /> Ein <span style="font-family: courier new,courier;">RawAllocator</span> hat folgendes Interface:</p>
    <div style="background: #ffffff none repeat scroll 0% 0%; overflow: auto; width: auto; border-width: 0.1em 0.1em 0.1em 0.8em;">
    <pre style="margin: 0px; line-height: 125%;"><span style="color: #0000ff;">struct</span> raw_allocator
    {
        <span style="color: #0000ff;">using</span> is_stateful = std::integral_constant&lt;<span style="color: #2b91af;">bool</span>, Value&gt;; <span style="color: #008000;">// optional, default ist std::is_empty</span>
    
        <span style="color: #2b91af;">void</span>* allocate_node(std::<span style="color: #2b91af;">size_t</span> size, std::<span style="color: #2b91af;">size_t</span> alignment); <span style="color: #008000;">// verlangt, alloziert Speicher</span>
        <span style="color: #2b91af;">void</span> deallocate_node(<span style="color: #2b91af;">void</span> *node, std::<span style="color: #2b91af;">size_t</span> size, std::<span style="color: #2b91af;">size_t</span> alignment) noexcept; <span style="color: #008000;">// verlangt, gibt Speicher frei</span>
    
        <span style="color: #2b91af;">void</span>* allocate_array(std::<span style="color: #2b91af;">size_t</span> count, std::<span style="color: #2b91af;">size_t</span> size, std::<span style="color: #2b91af;">size_t</span> alignment); <span style="color: #008000;">// optional, default ruft allocate_node() auf</span>
        <span style="color: #2b91af;">void</span> deallocate_array(<span style="color: #2b91af;">void</span> *ptr, std::<span style="color: #2b91af;">size_t</span> count, std::<span style="color: #2b91af;">size_t</span> size, std::<span style="color: #2b91af;">size_t</span> alignment) noexcept; <span style="color: #008000;">// optional, default ruft deallocate_node() auf</span>
    
        std::<span style="color: #2b91af;">size_t</span> max_node_size() <span style="color: #0000ff;">const</span>; <span style="color: #008000;">// optional, default gibt maximalen Wert zurück</span>
        std::<span style="color: #2b91af;">size_t</span> max_array_size() <span style="color: #0000ff;">const</span>; <span style="color: #008000;">// optional, default gibt max_node_size() zurück</span>
        std::<span style="color: #2b91af;">size_t</span> max_alignment() <span style="color: #0000ff;">const</span>; <span style="color: #008000;">// optional, default gibt maximales Alginment zurück, d.h. alignof(std::max_align_t)</span>
    }
    </pre>
    </div>
    <p style="padding-left: 30px;">Dieses Interface ähnelt sehr dem der neuen <a href="http://en.cppreference.com/w/cpp/memory/memory_resource)">std::pmr::memory_resource</a>, nur, dass es nicht über Vererbung implementiert wird. Der&nbsp;<span style="font-family: courier new,courier;">RawAllocator</span> ist somit Bestandteil des Typs bei default und kann nur optional&nbsp;<strong class="moz-txt-star"><span class="moz-txt-tag"></span>type erased<span class="moz-txt-tag"></span></strong> werden - über die Verwendung der&nbsp;<span style="font-family: courier new,courier;">any_allocator_reference</span> Klasse.</p>
    <p>Das meiste des Interfaces ist optional und muss nur in besonderen Fällen selber implementiert werden.&nbsp; Der <span style="font-family: courier new,courier;">memory_pool</span> ist nun ebenfalls ein&nbsp;<span style="font-family: courier new,courier;">RawAllocator,</span> obwohl er das Interface nicht implementiert. Das ist möglich, da jeglicher Zugriff über die&nbsp;<span style="font-family: courier new,courier;">memory::allocator_traits</span> passiert, die der&nbsp;<span style="font-family: comic sans ms,sans-serif;">memory_pool</span> spezialisiert hat. <br /> <br /> Um nun <span style="font-family: courier new,courier;">RawAllocator</span> in STL Container zu nutzen gibt es den Adapter&nbsp;<span style="font-family: courier new,courier;">std_allocator,</span> der ein&nbsp;<span style="font-family: courier new,courier;">RawAllocator</span> nimmt und ihm die Schnittstelle eines <span style="font-family: courier new,courier;">Allocator</span> gibt. Da&nbsp;<span style="font-family: courier new,courier;">Allocator</span> kopierbar sein müssen,&nbsp;<span style="font-family: courier new,courier;">RawAllocator</span> jedoch nicht, nimmt er den&nbsp;<span style="font-family: courier new,courier;">RawAllocator</span> nur per Referenz. <br /> <br /> Da Memory Pools Probleme mit Array Anforderung haben, was allerdings z.B.&nbsp;<span style="font-family: courier new,courier;">std::vector</span> macht, sind sie ideal für die <strong>node based containers</strong>, hier ein Beispiel:</p>
    <div style="background: #ffffff none repeat scroll 0% 0%; overflow: auto; width: auto; border-width: 0.1em 0.1em 0.1em 0.8em;">
    <pre style="margin: 0px; line-height: 125%;"><span style="color: #0000ff;">#include &lt;set&gt;</span>
    
    <span style="color: #0000ff;">#include &lt;foonathan/memory/container.hpp&gt;</span>
    <span style="color: #0000ff;">#include &lt;foonathan/memory/memory_pool.hpp&gt;</span>
    <span style="color: #0000ff;">#include &lt;foonathan/memory/namespace_alias.hpp&gt;</span>
    
    <span style="color: #2b91af;">int</span> main()
    {
        memory::memory_pool&lt;&gt; pool(memory::set_node_size&lt;<span style="color: #2b91af;">int</span>&gt;::value, 4096); <span style="color: #008000;">// (1)</span>
        memory::set&lt;<span style="color: #2b91af;">int</span>, decltype(pool)&gt; set(pool); <span style="color: #008000;">// (2)</span>
        set.insert(3);
        <span style="color: #008000;">// ...</span>
    } 
    </pre>
    </div>
    <p>Wir erstellen wie gehabt unseren Pool in (1). Die übergebene <strong class="moz-txt-star">node size</strong> ist genau der Wert, der für ein <span style="font-family: Courier New;">std::set&lt;int&gt;</span> benötigt wird.&nbsp; Diesen verwenden wir nun für ein <span style="font-family: Courier New;">set</span> in (2).&nbsp; Der Typ des Container ist jedoch <span style="font-family: Courier New;">memory::set</span>. Das ist nicht etwa eine Neu-Implementierung von <span style="font-family: Courier New;">std::set</span>, sondern einfach ein <strong class="moz-txt-star">template alias</strong>, in diesem Fall für <span style="font-family: Courier New;">std::set&lt;int, std::less&lt;int&gt;, memory::std_allocator&lt;int, decltype(pool)&gt;&gt;</span> - also ein <span style="font-family: Courier New;">std::set&lt;int&gt;</span>, was den Pool durch den <span style="font-family: Courier New;">std_allocator</span> verwendet. Der aufgerufene Konstruktor ist auch der reguläre Allokator Konstruktor von <span style="font-family: Courier New;">std::set</span>. Wir nutzen aus, dass der <span style="font-family: Courier New;">memory::std_allocator</span> implizit von dem <span style="font-family: Courier New;">RawAllocator</span> erstellt werden kann.</p>
    <p>Nun können wir das <span style="font-family: Courier New;">set</span> ganz normal verwenden, alle Allokation geht dabei über unseren Pool.</p>
    <h3>Anpassung der Pool internen Allokationen</h3>
    <p><br /> Wie anfangs angesprochen, fordert der Pool einen großen Speicherblock an und unterteilt ihn in kleinere Stücke. Standardmäßig nutzt er dazu<span style="font-family: Courier New;"> memory::heap_allocator</span>, das ist ein <span style="font-family: Courier New;">RawAllocator</span>, der an OS spezifische Funktionen weiterleitet, z.B. <span style="font-family: Courier New;">HeapAlloc()</span> unter Windows. <br /> Jedoch kann man diesen internen Allokator über ein Template Argument anpassen. <br /> <br /> Eine Kombination von Allokatoren ist besonders nützlich. Sagen wir, wir wollen einen <span style="font-family: Courier New;">std::vector</span> haben, der nicht auf dem Heap, sondern auf dem Stack liegt. <br /> Einfach: Wir nehmen <span style="font-family: Courier New;">std::array</span> oder ein C-Array.</p>
    <p>Wie sieht es aber aus, wenn wir ein <span style="font-family: Courier New;">std::set</span> auf dem Stack haben wollen?</p>
    <pre style="margin: 0px; line-height: 125%;"><span style="color: #0000ff;">#include &lt;set&gt;</span>
    
    <span style="color: #0000ff;">#include &lt;foonathan/memory/container.hpp&gt;</span>
    <span style="color: #0000ff;">#include &lt;foonathan/memory/memory_pool.hpp&gt;</span>
    <span style="color: #0000ff;">#include &lt;foonathan/memory/namespace_alias.hpp&gt;</span>
    <span style="color: #0000ff;">#include &lt;foonathan/memory/static_allocator.hpp&gt;</span>
    
    <span style="color: #2b91af;">int</span> main()
    {
        memory::static_allocator_storage&lt;4096u&gt; storage; <span style="color: #008000;">// (1)</span>
    
        <span style="color: #0000ff;">using</span> static_pool = memory::memory_pool&lt;memory::node_pool, memory::static_allocator&gt;; <span style="color: #008000;">// (2)</span>
        static_pool pool(memory::set_node_size&lt;<span style="color: #2b91af;">int</span>&gt;::value, 4096, storage); <span style="color: #008000;">// (3)</span>
    
        memory::set&lt;<span style="color: #2b91af;">int</span>, decltype(pool)&gt; set(pool);
        set.insert(3);
        <span style="color: #008000;">// ...</span>
    } </pre>
    <p><br /> Wir kombinieren unseren <span style="font-family: Courier New;">memory_pool</span> mit dem <span style="font-family: Courier New;">static_allocator</span> für die interne Speicheranforderung. Wie&nbsp;<span style="font-family: Courier New;">heap_allocator</span> kann man auch den <span style="font-family: Courier New;">RawAllocator static_allocator</span> selber verwenden, nützlicher ist er allerdings im Zusammenhang mit <span style="font-family: Courier New;">memory_pool</span>. <br /> Die Allokatoren von <strong class="moz-txt-star">memory</strong> können sehr gut miteinander kombiniert werden um verschiedene Strategien zu bewerkstelligen. <br /> <br /> Zunächst erstellen wir in (1) unseren Speicher, den der <span style="font-family: Courier New;">static_allocator</span> für die Speicheranforderung nutzt. Ein Alias in (2) definiert unseren neuen Pool Typen. <span style="font-family: Courier New;">memory::memory_pool</span> hat zwei Template Parameter. Der erste ist der Typ des Pools und man kann ihn so für verschiedene Anforderungen einstellen. Der Standardwert ist <span style="font-family: Courier New;">memory::node_pool</span> und das sollte man meistens auch nehmen. Der zweite Parameter ist der Typ des internen Allokators.&nbsp; Hier nehmen wir unseren <span style="font-family: Courier New;">memory::static_allocator</span>.&nbsp; In (3) konstruieren wir dann den Pool, diesmal müssen wir ihm allerdings auch den <span style="font-family: Courier New;">storage</span> übergeben, den der <span style="font-family: Courier New;">memory::static_allocator</span> verlangt.</p>
    <p><br /> Dann können wir nach wie vor unser <span style="font-family: Courier New;">set</span> erstellen und haben ein <span style="font-family: Courier New;">set</span> dessen Speicher komplett auf dem Stack liegt.</p>
    <p style="padding-left: 30px;"><br /> Der interne Allokator ist eigentlich ein <span style="font-family: Courier New;">BlockAllocator</span>, kein <span style="font-family: Courier New;">RawAllocator</span>,&nbsp; da man damit auch kontrollieren kann wie groß die nächsten Blöcke werden,&nbsp; wenn der erste Block keinen Speicher mehr hat. Template-Magie sorgt aber dafür, dass man auch einfach <span style="font-family: Courier New;">RawAllocator</span> übergeben kann,&nbsp; die dann automatisch zu einem <span style="font-family: Courier New;">BlockAllocator</span> werden.</p>
    <h3>Mehrere Pools</h3>
    <p><br /> Der <span style="font-family: Courier New;">memory_pool</span> kann nur Speicher für eine bestimmte Größe verwalten. <br /> Braucht man mehrere Größen muss man entweder die <strong class="moz-txt-star">node size</strong> auf die maximale Größe setzen und bei den kleineren Größen Platz verschwenden oder man nimmt mehrere Pools und wählt den passendsten aus. <br /> <br /> Diese zweite Alternative ist automatisiert in der <span style="font-family: Courier New;">memory::memory_pool_collection</span>.&nbsp; Diese Klasse verwaltet mehrere Pools und wählt den richtigen Pool aus. Es ist wieder ein Template mit drei Parametern. Der erste ist der Typ des Pools, er sollte meistens <span style="font-family: Courier New;">memory::node_pool</span> sein. Der zweite ist die Verteilungsstrategie. Sie kann entweder <span style="font-family: Courier New;">memory::identity_buckets</span> - ein Pool für jede Größe - oder <span style="font-family: Courier New;">memory::log2_buckets</span> - ein Pool für jede Zweierpotenz sein. Der dritte ist wie beim regulären Pool, der Allokator, der für den internen Speicher genutzt wird. <br /> Zu beachten ist, dass sich alle Pools den noch ungenutzten Speicher teilen und erst bei Bedarf nimmt sich jeder Pool einen gleichmäßigen Anteil. <br /> <br /> Die Verwendung ist sehr ähnlich wie beim regulären <span style="font-family: Courier New;">memory_pool</span>, weshalb ich mir ein Beispiel schenke. <br /> Zu beachten ist, dass die <strong class="moz-txt-star">node size</strong> im Konstruktor nun die <strong class="moz-txt-star">maximale</strong> Größe hat und die <span style="font-family: Courier New;">allocate_node()</span> Funktionen eine Größe verlangen. <br /> Dank der <span style="font-family: Courier New;">RawAllocator</span> Abstraktion ist die Verwendung im Zusammenhang mit STL Containern etc. identisch.</p>
    <h3>Fazit</h3>
    <p><br /> Es gibt viele Bibliotheken, die Pools implementieren. <strong class="moz-txt-star">memory</strong> ist jedoch die einzige, die ein Rundum-Paket an Allokatoren bietet. Ich habe längst nicht alles an Funktionalität gezeigt. Es gibt noch viele weitere Allokatoren und Adapter, z.B. <span style="font-family: Courier New;">Deleter</span> Klassen für&nbsp;<span style="font-family: Courier New;">std::unique_ptr</span>, und die ganze <span style="font-family: Courier New;">allocator_storage</span> Funktionalität, die beispielsweise <span style="font-family: Courier New;">allocator_reference</span> implementiert, habe ich überhaupt nicht angesprochen. <br /> Die Bibliothek ist so entworfen, dass man einfach nur den Allokator, den man braucht dort hineinstecken kann, wo man ihn braucht, bietet allerdings auch die Möglichkeit ganz nah ran zu gehen und jedes Detail einzustellen. <br /> <br /> Wer mehr über das Design von <strong class="moz-txt-star">memory</strong> wissen will, dem empfehle ich meinen <a href="http://foonathan.net/meetingcpp2016">Meeting C++ Talk</a> im November. <br /> Ansonsten folgt mir doch auf <a href="https://twitter.com/foonathan">Twitter</a> oder schaut auch mal auf <a href="https://foonathan.github.io">meinem Blog</a> vorbei.</p>
    <h2>Wie geht's weiter?</h2>
    <p>Mit diese Artikel enden meine Artikel zur embedded Programmierung im allgemeinen und zur Speichermanagement im besonderen. Weiter geht es im <a href="index.php/blog/objektorientierte-generische-funktionale-programmierung">nächsten Artikel </a>mit der funktionalen Programmierung in C++.</p>
    <p class="moz-signature"><a href="index.php/blog" class="moz-txt-link-freetext"></a> <br /> <br /><a href="https://github.com/RainerGrimm/ModernesCppSource"></a></p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>{tooltip} <img src="images/books/title_page_small.png" alt="title page small" width="166" height="212" />{end-texte}<img src="images/books/title_page_small.png" alt="title page small" style="margin: 3px;" /> Go to <a href="https://leanpub.com/cpplibrary"> </a><a href="https://leanpub.com/cpplibrary">Leanpub/cpplibrary</a> <a href="https://leanpub.com/cpplibrary"> </a><strong>"What every professional C++ programmer should know about the C++ standard library".</strong> <a href="https://leanpub.com/cpplibrary"></a>{end-tooltip} &nbsp; <strong><span class="h3">Hole dir dein E-Book. Unterstütze meinen Blog.</span></strong></p>
    </div>