<p>With C++14 came reader-writer locks. The idea is straightforward and promising. Arbitrary reading threads can access the critical region at the same time, but only one thread is allowed to write.</p>
<hr id="system-readmore" />
<h2>Minimized bottleneck</h2>
<p>Reader-writer locks do not solve the fundamental problem - threads competing for access to a critical region. But reader-writer locks help a lot - to minimize the bottleneck. Let's have an example.</p>
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<table>
<tbody>
<tr>
<td>
<pre style="margin: 0; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61</pre>
</td>
<td>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000;">// readerWriterLock.cpp</span>

<span style="color: #0000ff;">#include &lt;iostream&gt;</span>
<span style="color: #0000ff;">#include &lt;map&gt;</span>
<span style="color: #0000ff;">#include &lt;shared_mutex&gt;</span>
<span style="color: #0000ff;">#include &lt;string&gt;</span>
<span style="color: #0000ff;">#include &lt;thread&gt;</span>

std::map&lt;std::string,<span style="color: #2b91af;">int</span>&gt; teleBook{{<span style="color: #a31515;">"Dijkstra"</span>,1972},{<span style="color: #a31515;">"Scott"</span>,1976},{<span style="color: #a31515;">"Ritchie"</span>,1983}};

std::shared_timed_mutex teleBookMutex;

<span style="color: #2b91af;">void</span> addToTeleBook(<span style="color: #0000ff;">const</span> std::string&amp; na, <span style="color: #2b91af;">int</span> tele){
  std::lock_guard&lt;std::shared_timed_mutex&gt; writerLock(teleBookMutex);
  std::cout &lt;&lt; <span style="color: #a31515;">"\nSTARTING UPDATE "</span> &lt;&lt; na;
  std::this_thread::sleep_for(std::chrono::milliseconds(500));
  teleBook[na]= tele;
  std::cout &lt;&lt; <span style="color: #a31515;">" ... ENDING UPDATE "</span> &lt;&lt; na &lt;&lt; std::endl;
}

<span style="color: #2b91af;">void</span> printNumber(<span style="color: #0000ff;">const</span> std::string&amp; na){
  std::shared_lock&lt;std::shared_timed_mutex&gt; readerLock(teleBookMutex);
  std::cout &lt;&lt; na &lt;&lt; <span style="color: #a31515;">": "</span> &lt;&lt; teleBook[na];
}

<span style="color: #2b91af;">int</span> main(){

  std::cout &lt;&lt; std::endl;

  std::<span style="color: #0000ff;">thread</span> reader1([]{ printNumber(<span style="color: #a31515;">"Scott"</span>); });
  std::<span style="color: #0000ff;">thread</span> reader2([]{ printNumber(<span style="color: #a31515;">"Ritchie"</span>); });
  std::<span style="color: #0000ff;">thread</span> w1([]{ addToTeleBook(<span style="color: #a31515;">"Scott"</span>,1968); });
  std::<span style="color: #0000ff;">thread</span> reader3([]{ printNumber(<span style="color: #a31515;">"Dijkstra"</span>); });
  std::<span style="color: #0000ff;">thread</span> reader4([]{ printNumber(<span style="color: #a31515;">"Scott"</span>); });
  std::<span style="color: #0000ff;">thread</span> w2([]{ addToTeleBook(<span style="color: #a31515;">"Bjarne"</span>,1965); });
  std::<span style="color: #0000ff;">thread</span> reader5([]{ printNumber(<span style="color: #a31515;">"Scott"</span>); });
  std::<span style="color: #0000ff;">thread</span> reader6([]{ printNumber(<span style="color: #a31515;">"Ritchie"</span>); });
  std::<span style="color: #0000ff;">thread</span> reader7([]{ printNumber(<span style="color: #a31515;">"Scott"</span>); });
  std::<span style="color: #0000ff;">thread</span> reader8([]{ printNumber(<span style="color: #a31515;">"Bjarne"</span>); });

  reader1.join();
  reader2.join();
  reader3.join();
  reader4.join();
  reader5.join();
  reader6.join();
  reader7.join();
  reader8.join();
  w1.join();
  w2.join();

  std::cout &lt;&lt; std::endl;

  std::cout &lt;&lt; <span style="color: #a31515;">"\nThe new telephone book"</span> &lt;&lt; std::endl;
  <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">auto</span> teleIt: teleBook){
    std::cout &lt;&lt; teleIt.first &lt;&lt; <span style="color: #a31515;">": "</span> &lt;&lt; teleIt.second &lt;&lt; std::endl;
  }

  std::cout &lt;&lt; std::endl;

}
</pre>
</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<p>The <span style="font-family: courier new,courier;">telebook</span> in line 9 is the shared variable, which has to be protected.<span style="font-family: courier new,courier;"></span> Eight threads want to read the telephone book, two threads want to modify (lines 30 - 39) it. To access the telephone book at the same time,&nbsp;the reading threads use the <span style="font-family: courier new,courier;">std::shared_lock&lt;std::shared_timed_mutex&gt;&gt;</span> in line 22. This is in opposite to the writing threads, which need exclusive access to the critical section. The exclusivity is given by the <span style="font-family: courier new,courier;">std::lock_guard&lt;std::shared_timed_mutex&gt;&gt;</span> in line 14. At the end, the program displays (lines 54 - 57)&nbsp;the updated telephone book.</p>
<p><img src="images/blog/Threads/ReaderWriterLocks/readerWriterLocks.png" alt="readerWriterLocks" /></p>
<p>The screenshot &nbsp;shows that the output of the reading threads overlaps, while the writing thread are executed one after the other. It means that the reading operations are performed at the same time.</p>
<p>That was easy. Too easy.</p>
<h3>Undefined behaviour</h3>
<p>The program has undefined behaviour. What? Before you continue, stop for a few seconds and think. By the way, the concurrent access of <span style="font-family: courier new,courier;">std::cout</span> is not the issue.</p>
<p>The characteristic of a race condition is, that at least two threads access the shared variable at the same time, at least one of them is writer. Exactly what is happening in the program. A characteristic <span id="transmark"></span>of the ordered associative container is that the reading of the container can modify it. It happens if the element is not available in the container - the case "Bjarne". If "Bjarne" is not found in the telephone book, a pair ("Bjarne",0) will be created from the read operation. For the details, have a look at <a href="http://en.cppreference.com/w/cpp/container/map">cppreference.com</a>.</p>
<h2>What's next?</h2>
<p>In the next post I continue with the thread safe initialisation of data in mulithreading programs.</p>
<p style="color: #000000;">&nbsp;</p>
<p>&nbsp;</p>
<p>Do you want to get the source code? <a href="index.php/source-code-repository">Source code repository</a></p>
<p>Would you like to have all articles for the weekend?&nbsp; <a href="index.php/source-code-repository"></a></p>
<p>{loadmodule mod_acymailing,Neue Artikel zum Wochenende}</p>