<p><span style="font-family: courier new,courier;">std:.async</span> feels like an asynchronous function call. Under the hood<span style="font-family: courier new,courier;"> std::async</span> is a <a href="index.php/tasks">task.</a> One, which is extremely easy to use.</p>
<hr id="system-readmore" />
<h2>std::async<span id="transmark"></span></h2>
<p><span style="font-family: courier new,courier;">std::async</span> gets as work package a callable. This is in this example&nbsp;a function, a function object or a lambda function.&nbsp;</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
	<table>
		<tbody>
			<tr>
				<td>
					<pre style="margin: 0; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre>
				</td>
				<td>
					<pre style="margin: 0; line-height: 125%;"><span style="color: #008000;">// async.cpp</span>

<span style="color: #0000ff;">#include &lt;future&gt;</span>
<span style="color: #0000ff;">#include &lt;iostream&gt;</span>
<span style="color: #0000ff;">#include &lt;string&gt;</span>

std::string helloFunction(<span style="color: #0000ff;">const</span> std::string&amp; s){
  <span style="color: #0000ff;">return</span> <span style="color: #a31515;">"Hello C++11 from "</span> + s + <span style="color: #a31515;">"."</span>;
}

<span style="color: #0000ff;">class</span> <span style="color: #2b91af;">HelloFunctionObject</span>{
  public:
    std::string <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">const</span> std::string&amp; s) <span style="color: #0000ff;">const</span> {
      <span style="color: #0000ff;">return</span> <span style="color: #a31515;">"Hello C++11 from "</span> + s + <span style="color: #a31515;">"."</span>;
    }
};

<span style="color: #2b91af;">int</span> main(){

  std::cout &lt;&lt; std::endl;

  <span style="color: #008000;">// future with function</span>
  <span style="color: #0000ff;">auto</span> futureFunction= std::async(helloFunction,<span style="color: #a31515;">"function"</span>);

  <span style="color: #008000;">// future with function object</span>
  HelloFunctionObject helloFunctionObject;
  <span style="color: #0000ff;">auto</span> futureFunctionObject= std::async(helloFunctionObject,<span style="color: #a31515;">"function object"</span>);

  <span style="color: #008000;">// future with lambda function</span>
  <span style="color: #0000ff;">auto</span> futureLambda= std::async([](<span style="color: #0000ff;">const</span> std::string&amp; s ){<span style="color: #0000ff;">return</span> <span style="color: #a31515;">"Hello C++11 from "</span> + s + <span style="color: #a31515;">"."</span>;},<span style="color: #a31515;">"lambda function"</span>);

  std::cout &lt;&lt; futureFunction.get() &lt;&lt; <span style="color: #a31515;">"\n"</span> 
	    &lt;&lt; futureFunctionObject.get() &lt;&lt; <span style="color: #a31515;">"\n"</span> 
	    &lt;&lt; futureLambda.get() &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</pre>
				</td>
			</tr>
		</tbody>
	</table>
</div>
<p>&nbsp;</p>
<p>The program execution is not so exciting.</p>
<p>&nbsp;<img src="images/blog/Threads/AsynchroneFunktionsaufrufe/async.png" alt="async" /></p>
<p>The future gets in line 23 a function, in line 27 a function object and in line 30 a lambda function. At the end, each future request its value (line 32).</p>
<p>Once more, a little bit more formal. The <span style="font-family: courier new,courier;">std::async</span> calls in line 23, 27 and 30 create a <a href="index.php/tasks">data channel </a>between the two endpoints future and promise. The promise immediately starts to execute its work package. But that is only the default behaviour.&nbsp;By the get call, the future requests the result of It's work packages</p>
<h2>Eager or lazy evaluation</h2>
<p>Eager&nbsp;or lazy evaluation are two orthogonal strategies, to calculate the result of an expression. In case of <a href="https://en.wikipedia.org/wiki/Eager_evaluation">eager evaluation</a>,&nbsp;the expression will immediately be evaluated, in case of <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a>, the expression will only be evaluated, if needed. Often lazy evaluation is called call-by-need. With lazy evaluation you save time and compute power, because there is no evaluation on suspicion. An expression can be a mathematical calculation, a function or a <span style="font-family: courier new,courier;">std::async</span> call.&nbsp;</p>
<p>By default, std::async executed immediately its work package. The C++ runtime decides, if the calculation happens in the same or a new thread. With the flag <span style="font-family: courier new,courier;">std::launch::async</span> <span style="font-family: courier new,courier;">std::async</span> will run it's work package in a new thread. In opposite to that,&nbsp;the flag std::launch::deferred expresses, that std::async runs in the same thread. The execution is in this case lazy. That implies, that the eager evaluations starts immediately, but the lazy evaluation with the policy <span style="font-family: courier new,courier;">std::launch::deferred</span> starts, when the future asks for the value with its get call.&nbsp;</p>
<p>The program shows that different behaviour.<br /><span style="font-family: courier new,courier;"><span style="font-family: courier new,courier;"><span style="font-family: arial,helvetica,sans-serif;"></span></span><span style="font-family: arial,helvetica,sans-serif;"> </span> </span>
</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
	<table>
		<tbody>
			<tr>
				<td>
					<pre style="margin: 0; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre>
				</td>
				<td>
					<pre style="margin: 0; line-height: 125%;"><span style="color: #008000;">// asyncLazy.cpp</span>

<span style="color: #0000ff;">#include &lt;chrono&gt;</span>
<span style="color: #0000ff;">#include &lt;future&gt;</span>
<span style="color: #0000ff;">#include &lt;iostream&gt;</span>

<span style="color: #2b91af;">int</span> main(){

  std::cout &lt;&lt; std::endl;

  <span style="color: #0000ff;">auto</span> begin= std::chrono::system_clock::now();

  <span style="color: #0000ff;">auto</span> asyncLazy=std::async(std::launch::deferred,[]{ <span style="color: #0000ff;">return</span>  std::chrono::system_clock::now();});

  <span style="color: #0000ff;">auto</span> asyncEager=std::async( std::launch::async,[]{ <span style="color: #0000ff;">return</span>  std::chrono::system_clock::now();});

  std::this_thread::sleep_for(std::chrono::seconds(1));

  <span style="color: #0000ff;">auto</span> lazyStart= asyncLazy.get() - begin;
  <span style="color: #0000ff;">auto</span> eagerStart= asyncEager.get() - begin;

  <span style="color: #0000ff;">auto</span> lazyDuration= std::chrono::duration&lt;<span style="color: #2b91af;">double</span>&gt;(lazyStart).count();
  <span style="color: #0000ff;">auto</span> eagerDuration=  std::chrono::duration&lt;<span style="color: #2b91af;">double</span>&gt;(eagerStart).count();

  std::cout &lt;&lt; <span style="color: #a31515;">"asyncLazy evaluated after : "</span> &lt;&lt; lazyDuration &lt;&lt; <span style="color: #a31515;">" seconds."</span> &lt;&lt; std::endl;
  std::cout &lt;&lt; <span style="color: #a31515;">"asyncEager evaluated after: "</span> &lt;&lt; eagerDuration &lt;&lt; <span style="color: #a31515;">" seconds."</span> &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</pre>
				</td>
			</tr>
		</tbody>
	</table>
</div>
<p>&nbsp;</p>
<p>Both <span style="font-family: courier new,courier;">std::async</span> calls (line 13 and 15) returns the currentl time point. But the first call is lazy, the second greedy. The short sleep of one second in line 17 makes that obvious. By the call <span style="font-family: courier new,courier;">asyncLazy.get()</span> in line 19, the result will be available after a short nap.&nbsp; The is not true for<span style="font-family: courier new,courier;"> asyncEager. asyncEager.get()</span> gets the result from the immediately executed work package.</p>
<p><img src="images/blog/Threads/AsynchroneFunktionsaufrufe/asyncLazy.png" alt="asyncLazy" /></p>
<h2>A bigger compute job</h2>
<p><span style="font-family: courier new,courier;">std::async</span> is quite convenient, to put a bigger compute job on more shoulders. So, the calculation of the scalar product is done in the program with four asynchronous function calls.</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
	<table>
		<tbody>
			<tr>
				<td>
					<pre style="margin: 0; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53</pre>
				</td>
				<td>
					<pre style="margin: 0; line-height: 125%;"><span style="color: #008000;">// dotProductAsync.cpp</span>

<span style="color: #0000ff;">#include &lt;chrono&gt;</span>
<span style="color: #0000ff;">#include &lt;iostream&gt;</span>
<span style="color: #0000ff;">#include &lt;future&gt;</span>
<span style="color: #0000ff;">#include &lt;random&gt;</span>
<span style="color: #0000ff;">#include &lt;vector&gt;</span>
<span style="color: #0000ff;">#include &lt;numeric&gt;</span>

<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #2b91af;">int</span> NUM= 100000000;

<span style="color: #2b91af;">long</span> <span style="color: #2b91af;">long</span> getDotProduct(std::vector&lt;<span style="color: #2b91af;">int</span>&gt;&amp; v, std::vector&lt;<span style="color: #2b91af;">int</span>&gt;&amp; w){

  <span style="color: #0000ff;">auto</span> future1= std::async([&amp;]{<span style="color: #0000ff;">return</span> std::inner_product(&amp;v[0],&amp;v[v.size()/4],&amp;w[0],0LL);});
  <span style="color: #0000ff;">auto</span> future2= std::async([&amp;]{<span style="color: #0000ff;">return</span> std::inner_product(&amp;v[v.size()/4],&amp;v[v.size()/2],&amp;w[v.size()/4],0LL);});
  <span style="color: #0000ff;">auto</span> future3= std::async([&amp;]{<span style="color: #0000ff;">return</span> std::inner_product(&amp;v[v.size()/2],&amp;v[v.size()*3/4],&amp;w[v.size()/2],0LL);});
  <span style="color: #0000ff;">auto</span> future4= std::async([&amp;]{<span style="color: #0000ff;">return</span> std::inner_product(&amp;v[v.size()*3/4],&amp;v[v.size()],&amp;w[v.size()*3/4],0LL);});

  <span style="color: #0000ff;">return</span> future1.get() + future2.get() + future3.get() + future4.get();
}


<span style="color: #2b91af;">int</span> main(){

  std::cout &lt;&lt; std::endl;

  <span style="color: #008000;">// get NUM random numbers from 0 .. 100</span>
  std::random_device seed;

  <span style="color: #008000;">// generator</span>
  std::mt19937 engine(seed());

  <span style="color: #008000;">// distribution</span>
  std::uniform_int_distribution&lt;<span style="color: #2b91af;">int</span>&gt; dist(0,100);

  <span style="color: #008000;">// fill the vectors</span>
  std::vector&lt;<span style="color: #2b91af;">int</span>&gt; v, w;
  v.reserve(NUM);
  w.reserve(NUM);
  <span style="color: #0000ff;">for</span> (<span style="color: #2b91af;">int</span> i=0; i&lt; NUM; ++i){
    v.push_back(dist(engine));
    w.push_back(dist(engine));
  }

  <span style="color: #008000;">// measure the execution time</span>
  std::chrono::system_clock::time_point start = std::chrono::system_clock::now();
  std::cout &lt;&lt; <span style="color: #a31515;">"getDotProduct(v,w): "</span> &lt;&lt; getDotProduct(v,w) &lt;&lt; std::endl;
  std::chrono::duration&lt;<span style="color: #2b91af;">double</span>&gt; dur  = std::chrono::system_clock::now() - start;
  std::cout &lt;&lt; <span style="color: #a31515;">"Parallel Execution: "</span>&lt;&lt; dur.count() &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</pre>
				</td>
			</tr>
		</tbody>
	</table>
</div>
<p>&nbsp;</p>
<p>The program uses the functionality of the random and time library. Both libraries are part of C++11. The two vectors v and w are created and filled with random number in the lines 27 - 43.&nbsp; Each of the vector gets (line 40 - 43) hundred million elements. <span style="font-family: courier new,courier;">dist(engine)</span> in line 41 and 42 generated the random numbers, which are uniform distributed on the range from 0 to 100. The current calculation of the scalar product takes place in the function<span style="font-family: courier new,courier;"> getDotProduct</span> (line 12 - 20). <span style="font-family: courier new,courier;">std::async</span> uses internally the standard template library algorithm <span style="font-family: courier new,courier;"><a href="http://en.cppreference.com/w/cpp/algorithm/inner_product">std::inner_product</a>. </span>The return statement sums up the results of the futures.</p>
<p>It take my PC about 0.4 seconds to calculate the result .</p>
<p><img src="images/blog/Threads/AsynchroneFunktionsaufrufe/dotProductAsync.png" alt="dotProductAsync" /></p>
<p>But now the question is. How fast is the program, if I executed it on one core? A small modification of the function <span style="font-family: courier new,courier;">getDotProduct</span> and we know the truth.</p>
<div style="background: #ffffff none repeat scroll 0% 0%; overflow: auto; width: auto; border-width: 0.1em 0.1em 0.1em 0.8em;">
	<pre style="margin: 0px; line-height: 125%;"><span style="color: #2b91af;"><br />long</span> <span style="color: #2b91af;">long</span> getDotProduct(std::vector&lt;<span style="color: #2b91af;">int</span>&gt;&amp; v,std::vector&lt;<span style="color: #2b91af;">int</span>&gt;&amp; w){
  <span style="color: #0000ff;">return</span> std::inner_product(v.begin(),v.end(),w.begin(),0LL);
}
</pre>
</div>
<p>&nbsp;</p>
<p>The execution of the program is four times slower.</p>
<p>&nbsp;</p>
<p><img src="images/blog/Threads/AsynchroneFunktionsaufrufe/dotProduct.png" alt="dotProduct" /></p>
<h3>Optimization</h3>
<p>But, if I compile the program with maximal optimization level O3 with my GCC, the performance difference is nearly gone. The parallel execution is about 10 percent faster.</p>
<p>&nbsp;</p>
<p><img src="images/blog/Threads/AsynchroneFunktionsaufrufe/dotProductComparisonOptimization.png" alt="dotProductComparisonOptimization" /></p>
<h2>What's next?</h2>
<p>In the next post I show you, how to parallelize&nbsp;big compute job by using <span style="font-family: courier new,courier;">std::packaged_task.</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Do you want to get the source code? <a href="index.php/source-code-repository">Source code repository</a></p>
<p>Would you like to have all posts for the weekend?&nbsp;
	<a href="index.php/source-code-repository"></a>
</p>
<p>{loadmodule mod_acymailing,Neue Artikel zum Wochenende}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>